{"version":3,"sources":["skylark-jsmodeler.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-jsmodeler.js","sourcesContent":["define('skylark-jsmodeler/core/jsm',[],function(){\n\tvar JSM = function ()\n\t{\n\t\tthis.mainVersion = 0;\n\t\tthis.subVersion = 45;\n\t};\n\n\t/**\n\t* Function: RandomNumber\n\t* Description: Generates a random number between two numbers.\n\t* Parameters:\n\t*\tfrom {number} lowest random result\n\t*\tto {number} highest random result\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.RandomNumber = function (from, to)\n\t{\n\t\treturn Math.random () * (to - from) + from;\n\t};\n\n\t/**\n\t* Function: RandomInt\n\t* Description: Generates a random integer between two integers.\n\t* Parameters:\n\t*\tfrom {integer} lowest random result\n\t*\tto {integer} highest random result\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.RandomInt = function (from, to)\n\t{\n\t\treturn Math.floor ((Math.random () * (to - from + 1)) + from);\n\t};\n\n\t/**\n\t* Function: RandomBoolean\n\t* Description: Generates a random boolean value.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.RandomBoolean = function ()\n\t{\n\t\treturn JSM.RandomInt (0, 1) === 1;\n\t};\n\n\t/**\n\t* Function: SeededRandomInt\n\t* Description: Generates a random integer between two integers. A seed number can be specified.\n\t* Parameters:\n\t*\tfrom {integer} lowest random result\n\t*\tto {integer} highest random result\n\t*\tseed {integer} seed value\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SeededRandomInt = function (from, to, seed)\n\t{\n\t    var random = ((seed * 9301 + 49297) % 233280) / 233280;\n\t\treturn Math.floor ((random * (to - from + 1)) + from);\n\t};\n\n\t/**\n\t* Function: ValueOrDefault\n\t* Description: Returns the given value, or a default if it is undefined.\n\t* Parameters:\n\t*\tval {anything} new value\n\t*\tdef {anything} default value\n\t* Returns:\n\t*\t{anything} the result\n\t*/\n\tJSM.ValueOrDefault = function (val, def)\n\t{\n\t\tif (val === undefined || val === null) {\n\t\t\treturn def;\n\t\t}\n\t\treturn val;\n\t};\n\n\t/**\n\t* Function: PrevIndex\n\t* Description: Returns the circular previous index for an array with the given length.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t*\tlength {integer} the number of indices\n\t*/\n\tJSM.PrevIndex = function (index, length)\n\t{\n\t\treturn index > 0 ? index - 1 : length - 1;\n\t};\n\n\t/**\n\t* Function: NextIndex\n\t* Description: Returns the circular next index for an array with the given length.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t*\tlength {integer} the number of indices\n\t*/\n\tJSM.NextIndex = function (index, length)\n\t{\n\t\treturn index < length - 1 ? index + 1 : 0;\n\t};\n\n\t/**\n\t* Function: CopyObjectProperties\n\t* Description: Copies one object properties to another object.\n\t* Parameters:\n\t*\tsource {anything} source object\n\t*\ttarget {anything} target object\n\t*\toverwrite {boolean} overwrite existing properties\n\t*/\n\tJSM.CopyObjectProperties = function (source, target, overwrite)\n\t{\n\t\tif (source === undefined || source === null ||\n\t\t\ttarget === undefined || target === null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar property;\n\t\tfor (property in source) {\n\t\t\tif (source.hasOwnProperty (property)) {\n\t\t\t\tif (overwrite || target[property] === undefined || target[property] === null) {\n\t\t\t\t\ttarget[property] = source[property];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GetObjectProperty\n\t* Description: Returns the given property of the object. If it doesn't exist, returns the given default value.\n\t* Parameters:\n\t*\tobject {anything} the object\n\t*\tpropertyName {string} the name of the property\n\t*\tdefaultValue {anything} the default value\n\t*/\n\tJSM.GetObjectProperty = function (object, propertyName, defaultValue)\n\t{\n\t\tif (object === undefined || object === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tvar propertyValue = object[propertyName];\n\t\tif (propertyValue === undefined || propertyValue === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\t\n\t\treturn propertyValue;\n\t};\n\n\t/**\n\t* Function: Message\n\t* Description: Writes a message to the console.\n\t* Parameters:\n\t*\tmessage {string} the message\n\t*/\n\tJSM.Message = function (message)\n\t{\n\t\tconsole.log ('JSModeler: ' + message);\n\t};\n\n\treturn JSM;\n});\n\n\n\ndefine('skylark-jsmodeler/core/timer',[\"./jsm\"],function(JSM){\n\t/**\n\t* Class: Timer\n\t* Description: Utility class for time measure.\n\t*/\n\tJSM.Timer = function ()\t{\n\t\tthis.start = 0;\n\t\tthis.stop = 0;\n\t};\n\n\t/**\n\t* Function: Timer.Start\n\t* Description: Starts the timer.\n\t*/\n\tJSM.Timer.prototype.Start = function ()\t{\n\t\tvar date = new Date ();\n\t\tthis.start = date.getTime ();\n\t};\n\n\t/**\n\t* Function: Timer.Stop\n\t* Description: Stops the timer.\n\t*/\n\tJSM.Timer.prototype.Stop = function ()\t{\n\t\tvar date = new Date ();\n\t\tthis.end = date.getTime ();\n\t};\n\n\t/**\n\t* Function: Timer.Result\n\t* Description: Returns the time between start and stop.\n\t* Returns:\n\t*\t{number} The result.\n\t*/\n\tJSM.Timer.prototype.Result = function (){\n\t\treturn (this.end - this.start);\n\t};\n\n\t/**\n\t* Class: FPSCounter\n\t* Description:\n\t*\tUtility class for FPS count. It calculates the frames and returns FPS count for the last interval\n\t*\twith the given length. The Get function should called in every frame.\n\t*/\n\tJSM.FPSCounter = function (){\n\t\tthis.start = null;\n\t\tthis.frames = null;\n\t\tthis.current = null;\n\t};\n\n\t/**\n\t* Function: FPSCounter.Get\n\t* Description: Returns the FPS count for the last interval with the given length.\n\t* Parameters:\n\t*\tinterval {integer} the interval length in milliseconds\n\t* Returns:\n\t*\t{integer} The result.\n\t*/\n\tJSM.FPSCounter.prototype.Get = function (interval)\t{\n\t\tvar date = new Date ();\n\t\tvar end = date.getTime ();\n\t\tif (this.start === null) {\n\t\t\tthis.start = end;\n\t\t\tthis.frames = 0;\n\t\t\tthis.current = 0;\n\t\t}\n\n\t\tif (interval === null || interval === undefined) {\n\t\t\tinterval = 1000;\n\t\t}\n\t\t\n\t\tthis.frames = this.frames + 1;\n\t\tvar elapsed = end - this.start;\n\t\tif (elapsed >= interval) {\n\t\t\tthis.current = 1000 * (this.frames / elapsed);\n\t\t\tthis.start = end;\n\t\t\tthis.frames = 0;\n\t\t}\n\n\t\treturn parseInt (this.current, 10);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/algorithm',[\"./jsm\"],function(JSM){\n\n\t/**\n\t* Function: SwapArrayValues\n\t* Description: Swaps to array values.\n\t* Parameters:\n\t*\tarray {anything[]} the array\n\t*\tfrom {integer} from index\n\t*\tto {integer} to index\n\t*/\n\tJSM.SwapArrayValues = function (array, from, to){\n\t\tvar temp = array[from];\n\t\tarray[from] = array[to];\n\t\tarray[to] = temp;\n\t};\n\n\t/**\n\t* Function: BubbleSort\n\t* Description: Sorts an array with bubble sort.\n\t* Parameters:\n\t*\tarray {anything[]} the array to sort\n\t*\tonCompare {function} the compare function\n\t*\tonSwap {function} the swap function\n\t*/\n\tJSM.BubbleSort = function (array, onCompare, onSwap){\n\t\tif (array.length < 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar compareFunction = onCompare;\n\t\tif (compareFunction === undefined || compareFunction === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar swapFunction = onSwap;\n\t\tif (swapFunction === undefined || swapFunction === null) {\n\t\t\tswapFunction = function (i, j) {\n\t\t\t\tJSM.SwapArrayValues (array, i, j);\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < array.length - 1; i++) {\n\t\t\tfor (j = 0; j < array.length - i - 1; j++) {\n\t\t\t\tif (!compareFunction (array[j], array[j + 1])) {\n\t\t\t\t\tswapFunction (j, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: ShiftArray\n\t* Description: Shifts an array.\n\t* Parameters:\n\t*\tarray {anything[]} the array to shift\n\t*\tcount {integer} shift count\n\t*/\n\tJSM.ShiftArray = function (array, count){\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tarray.push (array.shift ());\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/async',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: AsyncRunTask\n\t* Description:\n\t*\tCalls a function multiple times asynchronously. If the environment\n\t*\tis not specified, it will run synchronously.\n\t* Parameters:\n\t*\ttaskFunction {function} the function to run\n\t*\tcallbacks {object} callbacks for start, process, and finish\n\t*\trunCount {integer} the count of runs\n\t*\ttimeout {integer} the timeout between runs\n\t*\tuserData {anything} task specific data\n\t*/\n\tJSM.AsyncRunTask = function (taskFunction, callbacks, runCount, timeout, userData)\n\t{\n\t\tfunction OnStart (runCount, userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onStart !== undefined && callbacks.onStart !== null) {\n\t\t\t\tcallbacks.onStart (runCount, userData);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnProgress (currentCount, userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onProgress !== undefined && callbacks.onProgress !== null) {\n\t\t\t\tcallbacks.onProgress (currentCount, userData);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnFinished (userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onFinish !== undefined && callbacks.onFinish !== null) {\n\t\t\t\tcallbacks.onFinish (userData);\n\t\t\t}\n\t\t}\n\n\t\tfunction RunTask (currentCount, userData, callbacks)\n\t\t{\n\t\t\tvar needContinue = taskFunction ();\n\t\t\tOnProgress (currentCount, userData, callbacks);\n\t\t\tif (needContinue && currentCount < runCount - 1) {\n\t\t\t\tsetTimeout (function () {\n\t\t\t\t\tRunTask (currentCount + 1, userData, callbacks);\n\t\t\t\t}, timeout);\n\t\t\t} else {\n\t\t\t\tsetTimeout (function () {\n\t\t\t\t\tOnFinished (userData, callbacks);\n\t\t\t\t}, timeout);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tvar i, needContinue;\n\t\t\tfor (i = 0; i < runCount; i++) {\n\t\t\t\tneedContinue = taskFunction ();\n\t\t\t\tif (!needContinue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tOnStart (runCount, userData, callbacks);\n\t\tRunTask (0, userData, callbacks);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/check',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: IsWebGLEnabled\n\t* Description: Returns if WebGL is enabled in the browser.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsWebGLEnabled = function (){\n\t\tif (!window.WebGLRenderingContext) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tvar canvas = document.createElement ('canvas');\n\t\t\tif (!canvas.getContext ('experimental-webgl') && !canvas.getContext ('webgl')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (exception) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: IsFileApiEnabled\n\t* Description: Returns if file api is enabled in the browser.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsFileApiEnabled = function ()\t{\n\t\tif (!window.File || !window.FileReader || !window.FileList || !window.Blob || !window.URL) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/jsonloader',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: LoadJsonFile\n\t* Description: Loads a json file, and calls a callback with the parsed json.\n\t* Parameters:\n\t*\tfileName {string} the name of the json\n\t*\tonReady {function} the callback\n\t*/\n\tJSM.LoadJsonFile = function (fileName, onReady)\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.overrideMimeType ('application/json');\n\t\trequest.open ('GET', fileName, true);\n\t\trequest.onreadystatechange = function () {\n\t\t\tif (request.readyState == 4) {\n\t\t\t\tvar jsonData = JSON.parse (request.responseText);\n\t\t\t\tonReady (jsonData);\n\t\t\t}\n\t\t};\n\t\trequest.send (null);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/definitions',[\"../core/jsm\"],function(JSM){\n\tJSM.Eps = 0.00000001;\n\tJSM.Inf = 9999999999;\n\tJSM.RadDeg = 57.29577951308232;\n\tJSM.DegRad = 0.017453292519943;\n\n\t/**\n\t* Function: IsZero\n\t* Description: Determines if the given value is near zero. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsZero = function (a)\n\t{\n\t\treturn Math.abs (a) < JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsPositive\n\t* Description: Determines if the given value is positive. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsPositive = function (a)\n\t{\n\t\treturn a > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsNegative\n\t* Description: Determines if the given value is negative. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsNegative = function (a)\n\t{\n\t\treturn a < -JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsLower\n\t* Description: Determines if a value is lower than an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsLower = function (a, b)\n\t{\n\t\treturn b - a > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsGreater\n\t* Description: Determines if a value is greater than an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsGreater = function (a, b)\n\t{\n\t\treturn a - b > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsEqual\n\t* Description: Determines if two values are equal. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsEqual = function (a, b)\n\t{\n\t\treturn Math.abs (b - a) < JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsEqualWithEps\n\t* Description: Determines if two values are equal. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t*\teps {number} epsilon value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsEqualWithEps = function (a, b, eps)\n\t{\n\t\treturn Math.abs (b - a) < eps;\n\t};\n\n\t/**\n\t* Function: IsLowerOrEqual\n\t* Description: Determines if a value is lower or equal to an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsLowerOrEqual = function (a, b)\n\t{\n\t\treturn JSM.IsLower (a, b) || JSM.IsEqual (a, b);\n\t};\n\n\t/**\n\t* Function: IsGreaterOrEqual\n\t* Description: Determines if a value is greater or equal to an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsGreaterOrEqual = function (a, b)\n\t{\n\t\treturn JSM.IsGreater (a, b) || JSM.IsEqual (a, b);\n\t};\n\n\t/**\n\t* Function: Minimum\n\t* Description: Returns the minimum of two values. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Minimum = function (a, b)\n\t{\n\t\treturn JSM.IsLower (a, b) ? a : b;\n\t};\n\n\t/**\n\t* Function: Maximum\n\t* Description: Returns the maximum of two values. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Maximum = function (a, b)\n\t{\n\t\treturn JSM.IsGreater (a, b) ? a : b;\n\t};\n\n\t/**\n\t* Function: ArcSin\n\t* Description: Calculates the arcus sinus value.\n\t* Parameters:\n\t*\tvalue {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ArcSin = function (value)\n\t{\n\t\tif (JSM.IsGreaterOrEqual (value, 1.0)) {\n\t\t\treturn Math.PI / 2.0;\n\t\t} else if (JSM.IsLowerOrEqual (value, -1.0)) {\n\t\t\treturn - Math.PI / 2.0;\n\t\t}\n\t\t\n\t\treturn Math.asin (value);\n\t};\n\n\t/**\n\t* Function: ArcCos\n\t* Description: Calculates the arcus cosinus value.\n\t* Parameters:\n\t*\tvalue {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ArcCos = function (value)\n\t{\n\t\tif (JSM.IsGreaterOrEqual (value, 1.0)) {\n\t\t\treturn 0.0;\n\t\t} else if (JSM.IsLowerOrEqual (value, -1.0)) {\n\t\t\treturn Math.PI;\n\t\t}\n\t\t\n\t\treturn Math.acos (value);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coord2d',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Coord2D\n\t* Description: Represents a 2D coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*/\n\tJSM.Coord2D = function (x, y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t};\n\n\t/**\n\t* Function: Coord2D.Set\n\t* Description: Sets the coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*/\n\tJSM.Coord2D.prototype.Set = function (x, y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t};\n\n\t/**\n\t* Function: Coord2D.IsEqual\n\t* Description: Returns if the coordinate is equal with the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord2D.prototype.IsEqual = function (coord)\n\t{\n\t\treturn JSM.IsEqual (this.x, coord.x) && JSM.IsEqual (this.y, coord.y);\n\t};\n\n\t/**\n\t* Function: Coord2D.IsEqualWithEps\n\t* Description: Returns if the coordinate is equal with the given one. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*\teps {number} the epsilon\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord2D.prototype.IsEqualWithEps = function (coord, eps)\n\t{\n\t\treturn JSM.IsEqualWithEps (this.x, coord.x, eps) && JSM.IsEqualWithEps (this.y, coord.y, eps);\n\t};\n\n\t/**\n\t* Function: Coord2D.DistanceTo\n\t* Description: Calculates the coordinate distance to the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.DistanceTo = function (coord)\n\t{\n\t\treturn Math.sqrt ((coord.x - this.x) * (coord.x - this.x) + (coord.y - this.y) * (coord.y - this.y));\n\t};\n\n\t/**\n\t* Function: Coord2D.AngleTo\n\t* Description: Calculates the coordinate vector angle to the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.AngleTo = function (coord)\n\t{\n\t\tvar aDirection = this.Clone ().Normalize ();\n\t\tvar bDirection = coord.Clone ().Normalize ();\n\t\tif (aDirection.IsEqual (bDirection)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvar product = JSM.VectorDot2D (aDirection, bDirection);\n\t\treturn JSM.ArcCos (product);\n\t};\n\n\t/**\n\t* Function: Coord2D.Length\n\t* Description: Calculates the length of the coordinate vector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.Length = function ()\n\t{\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y);\n\t};\n\n\t/**\n\t* Function: Coord2D.MultiplyScalar\n\t* Description: Multiplies the vector with a scalar.\n\t* Parameters:\n\t*\tscalar {number} the scalar\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.MultiplyScalar = function (scalar)\n\t{\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Normalize\n\t* Description: Normalizes the coordinate vector.\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Normalize = function ()\n\t{\n\t\tvar length = this.Length ();\n\t\tif (JSM.IsPositive (length)) {\n\t\t\tthis.MultiplyScalar (1.0 / length);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.SetLength\n\t* Description: Sets the length of the coordinate vector.\n\t* Parameters:\n\t*\tlength {number} the length\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.SetLength = function (length)\n\t{\n\t\tvar thisLength = this.Length ();\n\t\tif (JSM.IsPositive (thisLength)) {\n\t\t\tthis.MultiplyScalar (length / thisLength);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Offset\n\t* Description: Offsets the coordinate.\n\t* Parameters:\n\t*\tdirection {Vector2D} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Offset = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tthis.x += normal.x * distance;\n\t\tthis.y += normal.y * distance;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Rotate\n\t* Description: Rotates the coordinate.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord2D} the origo of the rotation\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Rotate = function (angle, origo)\n\t{\n\t\tvar x = this.x - origo.x;\n\t\tvar y = this.y - origo.y;\n\t\tvar co = Math.cos (angle);\n\t\tvar si = Math.sin (angle);\n\t\tthis.x = x * co - y * si + origo.x;\n\t\tthis.y = x * si + y * co + origo.y;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.ToString\n\t* Description: Converts the coordinate values to string.\n\t* Returns:\n\t*\t{string} the string representation of the coordinate\n\t*/\n\tJSM.Coord2D.prototype.ToString = function ()\n\t{\n\t\treturn ('(' + this.x + ', ' + this.y + ')');\n\t};\n\n\t/**\n\t* Function: Coord2D.Clone\n\t* Description: Clones the coordinate.\n\t* Returns:\n\t*\t{Coord2D} a cloned instance\n\t*/\n\tJSM.Coord2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Coord2D (this.x, this.y);\n\t};\n\n\t/**\n\t* Class: Vector2D\n\t* Description: Same as Coord2D.\n\t*/\n\tJSM.Vector2D = JSM.Coord2D;\n\n\t/**\n\t* Function: CoordFromArray2D\n\t* Description: Returns a coordinate from an array of components.\n\t* Parameters:\n\t*\tarray {number[2]} the array of components\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordFromArray2D = function (array)\n\t{\n\t\treturn new JSM.Coord2D (array[0], array[1]);\n\t};\n\n\t/**\n\t* Function: CoordToArray2D\n\t* Description: Returns array of components from a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\tarray {number[2]} the result\n\t*/\n\tJSM.CoordToArray2D = function (coord)\n\t{\n\t\treturn [coord.x, coord.y];\n\t};\n\n\t/**\n\t* Function: CoordAdd2D\n\t* Description: Adds two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordAdd2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D (a.x + b.x, a.y + b.y);\n\t};\n\n\t/**\n\t* Function: CoordSub2D\n\t* Description: Subs two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordSub2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D (a.x - b.x, a.y - b.y);\n\t};\n\n\t/**\n\t* Function: VectorDot2D\n\t* Description: Calculates the dot product of two vectors.\n\t* Parameters:\n\t*\ta {Vector2D} the first vector\n\t*\tb {Vector2D} the second vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.VectorDot2D = function (a, b)\n\t{\n\t\treturn a.x * b.x + a.y * b.y;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coord',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Coord\n\t* Description: Represents a 3D coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*\tz {number} the third component\n\t*/\n\tJSM.Coord = function (x, y, z)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t};\n\n\t/**\n\t* Function: Coord.Set\n\t* Description: Sets the coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*\tz {number} the third component\n\t*/\n\tJSM.Coord.prototype.Set = function (x, y, z)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t};\n\n\t/**\n\t* Function: Coord.IsEqual\n\t* Description: Returns if the coordinate is equal with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsEqual = function (coord)\n\t{\n\t\treturn JSM.IsEqual (this.x, coord.x) && JSM.IsEqual (this.y, coord.y) && JSM.IsEqual (this.z, coord.z);\n\t};\n\n\t/**\n\t* Function: Coord.IsEqualWithEps\n\t* Description: Returns if the coordinate is equal with the given one. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\teps {number} the epsilon\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsEqualWithEps = function (coord, eps)\n\t{\n\t\treturn JSM.IsEqualWithEps (this.x, coord.x, eps) && JSM.IsEqualWithEps (this.y, coord.y, eps) && JSM.IsEqualWithEps (this.z, coord.z, eps);\n\t};\n\n\t/**\n\t* Function: Coord.DistanceTo\n\t* Description: Calculates the coordinate distance to the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.DistanceTo = function (coord)\n\t{\n\t\treturn Math.sqrt ((coord.x - this.x) * (coord.x - this.x) + (coord.y - this.y) * (coord.y - this.y) + (coord.z - this.z) * (coord.z - this.z));\n\t};\n\n\t/**\n\t* Function: Coord.AngleTo\n\t* Description: Calculates the coordinate vector angle to the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.AngleTo = function (coord)\n\t{\n\t\tvar aDirection = this.Clone ().Normalize ();\n\t\tvar bDirection = coord.Clone ().Normalize ();\n\t\tif (aDirection.IsEqual (bDirection)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvar product = JSM.VectorDot (aDirection, bDirection);\n\t\treturn JSM.ArcCos (product);\n\t};\n\n\t/**\n\t* Function: Coord.IsCollinearWith\n\t* Description: Returns if the coordinate vector is collinear with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsCollinearWith = function (coord)\n\t{\n\t\tvar angle = this.AngleTo (coord);\n\t\treturn JSM.IsEqual (angle, 0.0) || JSM.IsEqual (angle, Math.PI);\n\t};\n\n\t/**\n\t* Function: Coord.IsPerpendicularWith\n\t* Description: Returns if the coordinate vector is perpendicular with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsPerpendicularWith = function (coord)\n\t{\n\t\tvar angle = this.AngleTo (coord);\n\t\treturn JSM.IsEqual (angle, Math.PI / 2.0);\n\t};\n\n\t/**\n\t* Function: Coord.Length\n\t* Description: Calculates the length of the coordinate vector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.Length = function ()\n\t{\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y + this.z * this.z);\n\t};\n\n\t/**\n\t* Function: Coord.Add\n\t* Description: Adds the given coordinate to coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Coord.prototype.Add = function (coord)\n\t{\n\t\tthis.x += coord.x;\n\t\tthis.y += coord.y;\n\t\tthis.z += coord.z;\n\t};\n\n\t/**\n\t* Function: Coord.Sub\n\t* Description: Subs the given coordinate from coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Coord.prototype.Sub = function (coord)\n\t{\n\t\tthis.x -= coord.x;\n\t\tthis.y -= coord.y;\n\t\tthis.z -= coord.z;\n\t};\n\n\t/**\n\t* Function: Coord.MultiplyScalar\n\t* Description: Multiplies the vector with a scalar.\n\t* Parameters:\n\t*\tscalar {number} the scalar\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.MultiplyScalar = function (scalar)\n\t{\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Normalize\n\t* Description: Normalizes the coordinate vector.\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.Normalize = function ()\n\t{\n\t\tvar length = this.Length ();\n\t\tif (JSM.IsPositive (length)) {\n\t\t\tthis.MultiplyScalar (1.0 / length);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.SetLength\n\t* Description: Sets the length of the coordinate vector.\n\t* Parameters:\n\t*\tlength {number} the length\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.SetLength = function (length)\n\t{\n\t\tvar thisLength = this.Length ();\n\t\tif (JSM.IsPositive (thisLength)) {\n\t\t\tthis.MultiplyScalar (length / thisLength);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Offset\n\t* Description: Offsets the coordinate.\n\t* Parameters:\n\t*\tdirection {Vector} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.Offset = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tthis.x += normal.x * distance;\n\t\tthis.y += normal.y * distance;\n\t\tthis.z += normal.z * distance;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Rotate\n\t* Description: Rotates the coordinate.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\n\tJSM.Coord.prototype.Rotate = function (axis, angle, origo)\n\t{\n\t\tvar normal = axis.Clone ().Normalize ();\n\n\t\tvar u = normal.x;\n\t\tvar v = normal.y;\n\t\tvar w = normal.z;\n\n\t\tvar x = this.x - origo.x;\n\t\tvar y = this.y - origo.y;\n\t\tvar z = this.z - origo.z;\n\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\t\tthis.x = - u * (- u * x - v * y - w * z) * (1.0 - co) + x * co + (- w * y + v * z) * si;\n\t\tthis.y = - v * (- u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;\n\t\tthis.z = - w * (- u * x - v * y - w * z) * (1.0 - co) + z * co + (- v * x + u * y) * si;\n\t\t\n\t\tthis.x += origo.x;\n\t\tthis.y += origo.y;\n\t\tthis.z += origo.z;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.ToCoord2D\n\t* Description: Converts the coordinate to a 2D coordinate.\n\t* Parameters:\n\t*\tnormal {Vector} the normal vector for conversion\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.Coord.prototype.ToCoord2D = function (normal)\n\t{\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar zNormal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar axis = JSM.VectorCross (normal, zNormal);\n\t\tvar angle = normal.AngleTo (zNormal);\n\t\tvar rotated = this.Clone ().Rotate (axis, angle, origo);\n\t\treturn new JSM.Coord2D (rotated.x, rotated.y);\n\t};\n\n\t/**\n\t* Function: Coord.ToString\n\t* Description: Converts the coordinate values to string.\n\t* Returns:\n\t*\t{string} the string representation of the coordinate\n\t*/\n\tJSM.Coord.prototype.ToString = function ()\n\t{\n\t\treturn ('(' + this.x + ', ' + this.y + ', ' + this.z + ')');\n\t};\n\n\t/**\n\t* Function: Coord.Clone\n\t* Description: Clones the coordinate.\n\t* Returns:\n\t*\t{Coord} a cloned instance\n\t*/\n\tJSM.Coord.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Coord (this.x, this.y, this.z);\n\t};\n\n\t/**\n\t* Class: Vector\n\t* Description: Same as Coord.\n\t*/\n\tJSM.Vector = JSM.Coord;\n\n\t/**\n\t* Function: CoordFromArray\n\t* Description: Returns a coordinate from an array of components.\n\t* Parameters:\n\t*\tarray {number[3]} the array of components\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordFromArray = function (array)\n\t{\n\t\treturn new JSM.Coord (array[0], array[1], array[2]);\n\t};\n\n\t/**\n\t* Function: CoordToArray\n\t* Description: Returns array of components from a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\tarray {number[3]} the result\n\t*/\n\tJSM.CoordToArray = function (coord)\n\t{\n\t\treturn [coord.x, coord.y, coord.z];\n\t};\n\n\t/**\n\t* Function: CoordAdd\n\t* Description: Adds two coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordAdd = function (a, b)\n\t{\n\t\treturn new JSM.Coord (a.x + b.x, a.y + b.y, a.z + b.z);\n\t};\n\n\t/**\n\t* Function: CoordSub\n\t* Description: Subs two coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordSub = function (a, b)\n\t{\n\t\treturn new JSM.Coord (a.x - b.x, a.y - b.y, a.z - b.z);\n\t};\n\n\t/**\n\t* Function: VectorDot\n\t* Description: Calculates the dot product of two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.VectorDot = function (a, b)\n\t{\n\t\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n\t};\n\n\t/**\n\t* Function: VectorCross\n\t* Description: Calculates the cross product of two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.VectorCross = function (a, b)\n\t{\n\t\tvar result = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tresult.x = a.y * b.z - a.z * b.y;\n\t\tresult.y = a.z * b.x - a.x * b.z;\n\t\tresult.z = a.x * b.y - a.y * b.x;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/determinant',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixDeterminant2x2\n\t* Description: Calculates the determinant of a 2x2 matrix.\n\t* Parameters:\n\t*\tm00..m11 {4 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant2x2 = function (m00, m01,\n\t\t\t\t\t\t\t\t\t\tm10, m11)\n\t{\n\t\treturn m00 * m11 - m01 * m10;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant3x3\n\t* Description: Calculates the determinant of a 3x3 matrix.\n\t* Parameters:\n\t*\tm00..m22 {9 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant3x3 = function (m00, m01, m02,\n\t\t\t\t\t\t\t\t\t\tm10, m11, m12,\n\t\t\t\t\t\t\t\t\t\tm20, m21, m22)\n\t{\n\t\tvar subDet1 = JSM.MatrixDeterminant2x2 (m11, m12, m21, m22);\n\t\tvar subDet2 = JSM.MatrixDeterminant2x2 (m10, m12, m20, m22);\n\t\tvar subDet3 = JSM.MatrixDeterminant2x2 (m10, m11, m20, m21);\n\t\treturn m00 * subDet1 - m01 * subDet2 + m02 * subDet3;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant4x4\n\t* Description: Calculates the determinant of a 4x4 matrix.\n\t* Parameters:\n\t*\tm00..m33 {16 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant4x4 = function (m00, m01, m02, m03,\n\t\t\t\t\t\t\t\t\t\tm10, m11, m12, m13,\n\t\t\t\t\t\t\t\t\t\tm20, m21, m22, m23,\n\t\t\t\t\t\t\t\t\t\tm30, m31, m32, m33)\n\t{\n\t\tvar subDet1 = JSM.MatrixDeterminant3x3 (m11, m12, m13, m21, m22, m23, m31, m32, m33);\n\t\tvar subDet2 = JSM.MatrixDeterminant3x3 (m10, m12, m13, m20, m22, m23, m30, m32, m33);\n\t\tvar subDet3 = JSM.MatrixDeterminant3x3 (m10, m11, m13, m20, m21, m23, m30, m31, m33);\n\t\tvar subDet4 = JSM.MatrixDeterminant3x3 (m10, m11, m12, m20, m21, m22, m30, m31, m32);\n\t\treturn subDet1 * m00 - subDet2 * m01 + subDet3 * m02 - subDet4 * m03;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coordutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Orientation\n\t* Description: Orientation of coordinates.\n\t* Values:\n\t*\t{Invalid} invalid orientation or collinear\n\t*\t{CounterClockwise} counter clockwise orientation\n\t*\t{Clockwise} clockwise orientation\n\t*/\n\tJSM.Orientation = {\n\t\tInvalid : 0,\n\t\tCounterClockwise : 1,\n\t\tClockwise : 2\n\t};\n\n\t/**\n\t* Function: MidCoord2D\n\t* Description: Calculates the coordinate in the middle of two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} first coordinate\n\t*\tb {Coord2D} second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.MidCoord2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D ((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n\t};\n\n\t/**\n\t* Function: CoordOrientation2D\n\t* Description: Calculates the turn type of three coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t*\tc {Coord2D} the third coordinate\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.CoordOrientation2D = function (a, b, c)\n\t{\n\t\tvar m00 = a.x;\n\t\tvar m01 = a.y;\n\t\tvar m10 = b.x;\n\t\tvar m11 = b.y;\n\t\tvar m20 = c.x;\n\t\tvar m21 = c.y;\n\t    \n\t\tvar determinant = m00 * m11 + m01 * m20 + m10 * m21 - m11 * m20 - m01 * m10 - m00 * m21;\n\t\tif (JSM.IsPositive (determinant)) {\n\t\t\treturn JSM.Orientation.CounterClockwise;\n\t\t} else if (JSM.IsNegative (determinant)) {\n\t\t\treturn JSM.Orientation.Clockwise;\n\t\t}\n\t\t\n\t\treturn JSM.Orientation.Invalid;\t\n\t};\n\n\t/**\n\t* Function: CoordSignedDistance2D\n\t* Description: Calculates the distance of two coordinates along a direction vector.\n\t* Parameters:\n\t*\ta {Coord2D} first coordinate\n\t*\tb {Coord2D} second coordinate\n\t*\tdirection {Vector2D} direction vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordSignedDistance2D = function (a, b, direction)\n\t{\n\t\tvar abDirection = JSM.CoordSub2D (b, a);\n\t\tvar distance = a.DistanceTo (b);\n\t\t\n\t\tvar angle = abDirection.AngleTo (direction);\n\t\tif (JSM.IsPositive (angle)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: PolarToCartesian\n\t* Description: Converts a polar coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\ttheta {number} the angle component\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.PolarToCartesian = function (radius, theta)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\t\tresult.x = radius * Math.cos (theta);\n\t\tresult.y = radius * Math.sin (theta);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetArcLengthFromAngle\n\t* Description: Calculates arc length from radius and angle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\ttheta {number} the angle of rotation\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetArcLengthFromAngle = function (radius, theta)\n\t{\n\t\treturn theta * radius;\n\t};\n\n\t/**\n\t* Function: GetAngleFromArcLength\n\t* Description: Calculates angle from arc length.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tarcLength {number} the arc length\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetAngleFromArcLength = function (radius, arcLength)\n\t{\n\t\tif (JSM.IsEqual (radius, 0.0)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\t\n\t\treturn arcLength / radius;\n\t};\n\n\t/**\n\t* Function: MidCoord\n\t* Description: Calculates the coordinate in the middle of two coordinates.\n\t* Parameters:\n\t*\ta {Coord} first coordinate\n\t*\tb {Coord} second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.MidCoord = function (a, b)\n\t{\n\t\treturn new JSM.Coord ((a.x + b.x) / 2.0, (a.y + b.y) / 2.0, (a.z + b.z) / 2.0);\n\t};\n\n\t/**\n\t* Function: CoordSignedDistance\n\t* Description: Calculates the distance of two coordinates along a direction vector.\n\t* Parameters:\n\t*\ta {Coord} first coordinate\n\t*\tb {Coord} second coordinate\n\t*\tdirection {Vector} direction vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordSignedDistance = function (a, b, direction)\n\t{\n\t\tvar abDirection = JSM.CoordSub (b, a);\n\t\tvar distance = a.DistanceTo (b);\n\t\t\n\t\tvar angle = abDirection.AngleTo (direction);\n\t\tif (JSM.IsPositive (angle)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: GetVectorsFullAngle\n\t* Description: Calculates the full angle (0 to pi) of two vectors with the given normal vector.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tnormal {Vector} the normal vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetVectorsFullAngle = function (a, b, normal)\n\t{\n\t\tvar angle = a.AngleTo (b);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tif (JSM.CoordOrientation (a, origo, b, normal) == JSM.Orientation.Clockwise) {\n\t\t\tangle = 2.0 * Math.PI - angle;\n\t\t}\n\t\t\n\t\treturn angle;\n\t};\n\n\t/**\n\t* Function: CoordOrientation\n\t* Description: Calculates the turn type of three coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t*\tc {Coord} the third coordinate\n\t*\tnormal {Vector} normal vector for calculation\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.CoordOrientation = function (a, b, c, normal)\n\t{\n\t\tvar a2 = a.ToCoord2D (normal);\n\t\tvar b2 = b.ToCoord2D (normal);\n\t\tvar c2 = c.ToCoord2D (normal);\n\t\tvar orientation = JSM.CoordOrientation2D (a2, b2, c2);\n\n\t\tvar zNormal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar angle = normal.AngleTo (zNormal);\n\t\tif (JSM.IsEqual (angle, Math.PI)) {\n\t\t\tif (orientation == JSM.Orientation.CounterClockwise) {\n\t\t\t\torientation = JSM.Orientation.Clockwise;\n\t\t\t} else if (orientation == JSM.Orientation.Clockwise) {\n\t\t\t\torientation = JSM.Orientation.CounterClockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: SphericalToCartesian\n\t* Description: Converts a spherical coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\ttheta {number} the angle component\n\t*\tphi {number} the phi component\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SphericalToCartesian = function (radius, theta, phi)\n\t{\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = radius * Math.sin (theta) * Math.cos (phi);\n\t\tresult.y = radius * Math.sin (theta) * Math.sin (phi);\n\t\tresult.z = radius * Math.cos (theta);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CylindricalToCartesian\n\t* Description: Converts a cylindrical coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\theight {number} the height component\n\t*\ttheta {number} the theta component\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CylindricalToCartesian = function (radius, height, theta)\n\t{\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = radius * Math.cos (theta);\n\t\tresult.y = radius * Math.sin (theta);\n\t\tresult.z = height;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetArcLength\n\t* Description: Calculates arc length between two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tradius {number} the radius component\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetArcLength = function (a, b, radius)\n\t{\n\t\tvar angle = a.AngleTo (b);\n\t\treturn angle * radius;\n\t};\n\n\t/**\n\t* Function: GetFullArcLength\n\t* Description: Calculates arc length between two vectors with the given normal vector.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tradius {number} the radius component\n\t*\tnormal {Vector} the normal vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetFullArcLength = function (a, b, radius, normal)\n\t{\n\t\tvar angle = JSM.GetVectorsFullAngle (a, b, normal);\n\t\treturn angle * radius;\n\t};\n\n\t/**\n\t* Function: CalculateCentroid\n\t* Description: Calculates center points of the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the array of coordinates\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculateCentroid = function (coords)\n\t{\n\t\tvar count = coords.length;\n\t\tvar centroid = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tif (count >= 1) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcentroid = JSM.CoordAdd (centroid, coords[i]);\n\t\t\t}\n\t\t\tcentroid.MultiplyScalar (1.0 / count);\n\t\t}\n\n\t\treturn centroid;\n\t};\n\n\t/**\n\t* Function: CalculateTriangleNormal\n\t* Description: Calculates normal vector for the given triangle vertices.\n\t* Parameters:\n\t*\tv0 {Coord} the first vertex of the triangle\n\t*\tv1 {Coord} the second vertex of the triangle\n\t*\tv2 {Coord} the third vertex of the triangle\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateTriangleNormal = function (v0, v1, v2)\n\t{\n\t\tvar v = JSM.CoordSub (v1, v0);\n\t\tvar w = JSM.CoordSub (v2, v0);\n\t\t\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tnormal.x = (v.y * w.z - v.z * w.y);\n\t\tnormal.y = (v.z * w.x - v.x * w.z);\n\t\tnormal.z = (v.x * w.y - v.y * w.x);\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateNormal\n\t* Description: Calculates normal vector for the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the array of coordinates\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateNormal = function (coords)\n\t{\n\t\tvar count = coords.length;\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex;\n\t\t\tvar current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i % count;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = coords[currentIndex];\n\t\t\t\tnext = coords[nextIndex];\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: BarycentricInterpolation\n\t* Description: Calculates barycentric interpolation for the given values.\n\t* Parameters:\n\t*\tvertex0, vertex1, vertex2 {Coord} the vertices of interpolation\n\t*\tvalue0, value1, value2 {Coord} the values to interpolate\n\t*\tposition {Coord} the position of interpolation\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.BarycentricInterpolation = function (vertex0, vertex1, vertex2, value0, value1, value2, position)\n\t{\n\t\tfunction GetTriangleArea (a, b, c)\n\t\t{\n\t\t\tvar s = (a + b + c) / 2.0;\n\t\t\tvar areaSquare = s * (s - a) * (s - b) * (s - c);\n\t\t\tif (areaSquare < 0.0) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn Math.sqrt (areaSquare);\n\t\t}\n\t\t\n\t\tvar edge0 = vertex0.DistanceTo (vertex1);\n\t\tvar edge1 = vertex1.DistanceTo (vertex2);\n\t\tvar edge2 = vertex2.DistanceTo (vertex0);\n\t\t\n\t\tvar distance0 = vertex0.DistanceTo (position);\n\t\tvar distance1 = vertex1.DistanceTo (position);\n\t\tvar distance2 = vertex2.DistanceTo (position);\n\t\t\n\t\tvar area = GetTriangleArea (edge0, edge1, edge2);\n\t\tif (JSM.IsZero (area)) {\n\t\t\treturn value0;\n\t\t}\n\t\t\n\t\tvar area0 = GetTriangleArea (edge0, distance0, distance1);\n\t\tvar area1 = GetTriangleArea (edge1, distance1, distance2);\n\t\tvar area2 = GetTriangleArea (edge2, distance0, distance2);\n\t\t\n\t\tvar interpolated0 = value0.Clone ().MultiplyScalar (area1);\n\t\tvar interpolated1 = value1.Clone ().MultiplyScalar (area2);\n\t\tvar interpolated2 = value2.Clone ().MultiplyScalar (area0);\n\t\tvar interpolated = JSM.CoordAdd (JSM.CoordAdd (interpolated0, interpolated1), interpolated2);\n\t\tinterpolated.MultiplyScalar (1.0 / area);\n\t\treturn interpolated;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/matrix',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixIdentity\n\t* Description: Generates an identity matrix.\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixIdentity = function ()\n\t{\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixClone\n\t* Description: Clones a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixClone = function (matrix)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = matrix[0];\n\t\tresult[1] = matrix[1];\n\t\tresult[2] = matrix[2];\n\t\tresult[3] = matrix[3];\n\t\tresult[4] = matrix[4];\n\t\tresult[5] = matrix[5];\n\t\tresult[6] = matrix[6];\n\t\tresult[7] = matrix[7];\n\t\tresult[8] = matrix[8];\n\t\tresult[9] = matrix[9];\n\t\tresult[10] = matrix[10];\n\t\tresult[11] = matrix[11];\n\t\tresult[12] = matrix[12];\n\t\tresult[13] = matrix[13];\n\t\tresult[14] = matrix[14];\n\t\tresult[15] = matrix[15];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixTranspose\n\t* Description: Transposes a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixTranspose = function (matrix)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = matrix[0];\n\t\tresult[1] = matrix[4];\n\t\tresult[2] = matrix[8];\n\t\tresult[3] = matrix[12];\n\t\tresult[4] = matrix[1];\n\t\tresult[5] = matrix[5];\n\t\tresult[6] = matrix[9];\n\t\tresult[7] = matrix[13];\n\t\tresult[8] = matrix[2];\n\t\tresult[9] = matrix[6];\n\t\tresult[10] = matrix[10];\n\t\tresult[11] = matrix[14];\n\t\tresult[12] = matrix[3];\n\t\tresult[13] = matrix[7];\n\t\tresult[14] = matrix[11];\n\t\tresult[15] = matrix[15];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixVectorMultiply\n\t* Description: Multiplies a matrix with a vector.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tvector {number[4]} the vector\n\t* Returns:\n\t*\t{number[4]} the result vector\n\t*/\n\tJSM.MatrixVectorMultiply = function (matrix, vector)\n\t{\n\t\tvar a00 = vector[0];\n\t\tvar a01 = vector[1];\n\t\tvar a02 = vector[2];\n\t\tvar a03 = vector[3];\n\t\tvar b00 = matrix[0];\n\t\tvar b01 = matrix[1];\n\t\tvar b02 = matrix[2];\n\t\tvar b03 = matrix[3];\n\t\tvar b10 = matrix[4];\n\t\tvar b11 = matrix[5];\n\t\tvar b12 = matrix[6];\n\t\tvar b13 = matrix[7];\n\t\tvar b20 = matrix[8];\n\t\tvar b21 = matrix[9];\n\t\tvar b22 = matrix[10];\n\t\tvar b23 = matrix[11];\n\t\tvar b30 = matrix[12];\n\t\tvar b31 = matrix[13];\n\t\tvar b32 = matrix[14];\n\t\tvar b33 = matrix[15];\n\n\t\tvar result = [];\n\t\tresult[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n\t\tresult[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n\t\tresult[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n\t\tresult[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixMultiply\n\t* Description: Multiplies a two matrices.\n\t* Parameters:\n\t*\tmatrix1 {number[16]} first matrix\n\t*\tmatrix2 {number[16]} second matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixMultiply = function (matrix1, matrix2)\n\t{\n\t\tvar a00 = matrix1[0];\n\t\tvar a01 = matrix1[1];\n\t\tvar a02 = matrix1[2];\n\t\tvar a03 = matrix1[3];\n\t\tvar a10 = matrix1[4];\n\t\tvar a11 = matrix1[5];\n\t\tvar a12 = matrix1[6];\n\t\tvar a13 = matrix1[7];\n\t\tvar a20 = matrix1[8];\n\t\tvar a21 = matrix1[9];\n\t\tvar a22 = matrix1[10];\n\t\tvar a23 = matrix1[11];\n\t\tvar a30 = matrix1[12];\n\t\tvar a31 = matrix1[13];\n\t\tvar a32 = matrix1[14];\n\t\tvar a33 = matrix1[15];\n\t\t\n\t\tvar b00 = matrix2[0];\n\t\tvar b01 = matrix2[1];\n\t\tvar b02 = matrix2[2];\n\t\tvar b03 = matrix2[3];\n\t\tvar b10 = matrix2[4];\n\t\tvar b11 = matrix2[5];\n\t\tvar b12 = matrix2[6];\n\t\tvar b13 = matrix2[7];\n\t\tvar b20 = matrix2[8];\n\t\tvar b21 = matrix2[9];\n\t\tvar b22 = matrix2[10];\n\t\tvar b23 = matrix2[11];\n\t\tvar b30 = matrix2[12];\n\t\tvar b31 = matrix2[13];\n\t\tvar b32 = matrix2[14];\n\t\tvar b33 = matrix2[15];\n\t\t\t\n\t\tvar result = [];\n\t\tresult[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n\t\tresult[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n\t\tresult[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n\t\tresult[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n\t\tresult[4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n\t\tresult[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n\t\tresult[6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n\t\tresult[7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n\t\tresult[8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n\t\tresult[9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n\t\tresult[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n\t\tresult[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n\t\tresult[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n\t\tresult[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n\t\tresult[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n\t\tresult[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant\n\t* Description: Calculates the determinant of a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number} the determinant\n\t*/\n\tJSM.MatrixDeterminant = function (matrix)\n\t{\n\t\tvar a00 = matrix[0];\n\t\tvar a01 = matrix[1];\n\t\tvar a02 = matrix[2];\n\t\tvar a03 = matrix[3];\n\t\tvar a10 = matrix[4];\n\t\tvar a11 = matrix[5];\n\t\tvar a12 = matrix[6];\n\t\tvar a13 = matrix[7];\n\t\tvar a20 = matrix[8];\n\t\tvar a21 = matrix[9];\n\t\tvar a22 = matrix[10];\n\t\tvar a23 = matrix[11];\n\t\tvar a30 = matrix[12];\n\t\tvar a31 = matrix[13];\n\t\tvar a32 = matrix[14];\n\t\tvar a33 = matrix[15];\n\n\t\tvar b00 = a00 * a11 - a01 * a10;\n\t\tvar b01 = a00 * a12 - a02 * a10;\n\t\tvar b02 = a00 * a13 - a03 * a10;\n\t\tvar b03 = a01 * a12 - a02 * a11;\n\t\tvar b04 = a01 * a13 - a03 * a11;\n\t\tvar b05 = a02 * a13 - a03 * a12;\n\t\tvar b06 = a20 * a31 - a21 * a30;\n\t\tvar b07 = a20 * a32 - a22 * a30;\n\t\tvar b08 = a20 * a33 - a23 * a30;\n\t\tvar b09 = a21 * a32 - a22 * a31;\n\t\tvar b10 = a21 * a33 - a23 * a31;\n\t\tvar b11 = a22 * a33 - a23 * a32;\n\t\t\n\t\tvar determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\treturn determinant;\n\t};\n\n\t/**\n\t* Function: MatrixInvert\n\t* Description: Inverts a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixInvert = function (matrix)\n\t{\n\t\tvar a00 = matrix[0];\n\t\tvar a01 = matrix[1];\n\t\tvar a02 = matrix[2];\n\t\tvar a03 = matrix[3];\n\t\tvar a10 = matrix[4];\n\t\tvar a11 = matrix[5];\n\t\tvar a12 = matrix[6];\n\t\tvar a13 = matrix[7];\n\t\tvar a20 = matrix[8];\n\t\tvar a21 = matrix[9];\n\t\tvar a22 = matrix[10];\n\t\tvar a23 = matrix[11];\n\t\tvar a30 = matrix[12];\n\t\tvar a31 = matrix[13];\n\t\tvar a32 = matrix[14];\n\t\tvar a33 = matrix[15];\n\n\t\tvar b00 = a00 * a11 - a01 * a10;\n\t\tvar b01 = a00 * a12 - a02 * a10;\n\t\tvar b02 = a00 * a13 - a03 * a10;\n\t\tvar b03 = a01 * a12 - a02 * a11;\n\t\tvar b04 = a01 * a13 - a03 * a11;\n\t\tvar b05 = a02 * a13 - a03 * a12;\n\t\tvar b06 = a20 * a31 - a21 * a30;\n\t\tvar b07 = a20 * a32 - a22 * a30;\n\t\tvar b08 = a20 * a33 - a23 * a30;\n\t\tvar b09 = a21 * a32 - a22 * a31;\n\t\tvar b10 = a21 * a33 - a23 * a31;\n\t\tvar b11 = a22 * a33 - a23 * a32;\n\t\t\n\t\tvar determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = [];\n\t\t\n\t\tresult[0] = (a11 * b11 - a12 * b10 + a13 * b09) / determinant;\n\t\tresult[1] = (a02 * b10 - a01 * b11 - a03 * b09) / determinant;\n\t\tresult[2] = (a31 * b05 - a32 * b04 + a33 * b03) / determinant;\n\t\tresult[3] = (a22 * b04 - a21 * b05 - a23 * b03) / determinant;\n\t\tresult[4] = (a12 * b08 - a10 * b11 - a13 * b07) / determinant;\n\t\tresult[5] = (a00 * b11 - a02 * b08 + a03 * b07) / determinant;\n\t\tresult[6] = (a32 * b02 - a30 * b05 - a33 * b01) / determinant;\n\t\tresult[7] = (a20 * b05 - a22 * b02 + a23 * b01) / determinant;\n\t\tresult[8] = (a10 * b10 - a11 * b08 + a13 * b06) / determinant;\n\t\tresult[9] = (a01 * b08 - a00 * b10 - a03 * b06) / determinant;\n\t\tresult[10] = (a30 * b04 - a31 * b02 + a33 * b00) / determinant;\n\t\tresult[11] = (a21 * b02 - a20 * b04 - a23 * b00) / determinant;\n\t\tresult[12] = (a11 * b07 - a10 * b09 - a12 * b06) / determinant;\n\t\tresult[13] = (a00 * b09 - a01 * b07 + a02 * b06) / determinant;\n\t\tresult[14] = (a31 * b01 - a30 * b03 - a32 * b00) / determinant;\n\t\tresult[15] = (a20 * b03 - a21 * b01 + a22 * b00) / determinant;\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixTranslation\n\t* Description: Creates a translation matrix.\n\t* Parameters:\n\t*\tx {number} x offset of the transformation\n\t*\ty {number} y offset of the transformation\n\t*\tz {number} z offset of the transformation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixTranslation = function (x, y, z)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = x;\n\t\tresult[13] = y;\n\t\tresult[14] = z;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotation\n\t* Description: Creates a rotation matrix around the given axis.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotation = function (axis, angle, origo)\n\t{\n\t\tvar normal = axis.Clone ().Normalize ();\n\n\t\tvar u = normal.x;\n\t\tvar v = normal.y;\n\t\tvar w = normal.z;\n\n\t\tvar u2 = u * u;\n\t\tvar v2 = v * v;\n\t\tvar w2 = w * w;\n\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\t\t\n\t\tvar result = [];\n\t\tif (origo === undefined || origo === null) {\n\t\t\tresult[0] = u2 + (v2 + w2) * co;\n\t\t\tresult[1] = u * v * (1.0 - co) + w * si;\n\t\t\tresult[2] = u * w * (1.0 - co) - v * si;\n\t\t\tresult[3] = 0.0;\n\t\t\tresult[4] = u * v * (1.0 - co) - w * si;\n\t\t\tresult[5] = v2 + (u2 + w2) * co;\n\t\t\tresult[6] = v * w * (1.0 - co) + u * si;\n\t\t\tresult[7] = 0.0;\n\t\t\tresult[8] = u * w * (1.0 - co) + v * si;\n\t\t\tresult[9] = v * w * (1.0 - co) - u * si;\n\t\t\tresult[10] = w2 + (u2 + v2) * co;\n\t\t\tresult[11] = 0.0;\n\t\t\tresult[12] = 0.0;\n\t\t\tresult[13] = 0.0;\n\t\t\tresult[14] = 0.0;\n\t\t\tresult[15] = 1.0;\n\t\t} else {\n\t\t\tvar a = origo.x;\n\t\t\tvar b = origo.y;\n\t\t\tvar c = origo.z;\n\t\t\n\t\t\tresult[0] = u2 + (v2 + w2) * co;\n\t\t\tresult[1] = u * v * (1.0 - co) + w * si;\n\t\t\tresult[2] = u * w * (1.0 - co) - v * si;\n\t\t\tresult[3] = 0.0;\n\t\t\tresult[4] = u * v * (1.0 - co) - w * si;\n\t\t\tresult[5] = v2 + (u2 + w2) * co;\n\t\t\tresult[6] = v * w * (1.0 - co) + u * si;\n\t\t\tresult[7] = 0.0;\n\t\t\tresult[8] = u * w * (1.0 - co) + v * si;\n\t\t\tresult[9] = v * w * (1.0 - co) - u * si;\n\t\t\tresult[10] = w2 + (u2 + v2) * co;\n\t\t\tresult[11] = 0.0;\n\t\t\tresult[12] = (a * (v2 + w2) - u * (b * v + c * w)) * (1.0 - co) + (b * w - c * v) * si;\n\t\t\tresult[13] = (b * (u2 + w2) - v * (a * u + c * w)) * (1.0 - co) + (c * u - a * w) * si;\n\t\t\tresult[14] = (c * (u2 + v2) - w * (a * u + b * v)) * (1.0 - co) + (a * v - b * u) * si;\n\t\t\tresult[15] = 1.0;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationQuaternion\n\t* Description: Creates a rotation matrix from a given quaternion.\n\t* Parameters:\n\t*\tquaternion {number[4]} the quaternion\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationQuaternion = function (quaternion)\n\t{\n\t\tvar x = quaternion[0];\n\t\tvar y = quaternion[1];\n\t\tvar z = quaternion[2];\n\t\tvar w = quaternion[3];\n\n\t\tvar x2 = x + x;\n\t\tvar y2 = y + y;\n\t\tvar z2 = z + z;\n\n\t\tvar xx = x * x2;\n\t\tvar xy = x * y2;\n\t\tvar xz = x * z2;\n\t\tvar yy = y * y2;\n\t\tvar yz = y * z2;\n\t\tvar zz = z * z2;\n\t\tvar wx = w * x2;\n\t\tvar wy = w * y2;\n\t\tvar wz = w * z2;\n\n\t\tvar result = [];\n\t\tresult[0] = 1.0 - (yy + zz);\n\t\tresult[1] = xy + wz;\n\t\tresult[2] = xz - wy;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = xy - wz;\n\t\tresult[5] = 1.0 - (xx + zz);\n\t\tresult[6] = yz + wx;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = xz + wy;\n\t\tresult[9] = yz - wx;\n\t\tresult[10] = 1.0 - (xx + yy);\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationX\n\t* Description: Creates a rotation matrix around the x axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationX = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = co;\n\t\tresult[6] = si;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = -si;\n\t\tresult[10] = co;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationY\n\t* Description: Creates a rotation matrix around the y axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationY = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = co;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = -si;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = si;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = co;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationZ\n\t* Description: Creates a rotation matrix around the z axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationZ = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = co;\n\t\tresult[1] = si;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = -si;\n\t\tresult[5] = co;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ApplyTransformation\n\t* Description: Applies a matrix transformation to a coordinate.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.ApplyTransformation = function (matrix, coord)\n\t{\n\t\tvar vector = [];\n\t\tvector[0] = coord.x;\n\t\tvector[1] = coord.y;\n\t\tvector[2] = coord.z;\n\t\tvector[3] = 1.0;\n\t\t\n\t\tvar resultVector = JSM.MatrixVectorMultiply (matrix, vector);\n\t\tvar result = new JSM.Coord (resultVector[0], resultVector[1], resultVector[2]);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ApplyRotation\n\t* Description: Applies the rotation part of a matrix transformation to a coordinate.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.ApplyRotation = function (matrix, coord)\n\t{\n\t\tvar vector = [];\n\t\tvector[0] = coord.x;\n\t\tvector[1] = coord.y;\n\t\tvector[2] = coord.z;\n\t\tvector[3] = 0.0;\n\t\t\n\t\tvar resultVector = JSM.MatrixVectorMultiply (matrix, vector);\n\t\tvar result = new JSM.Coord (resultVector[0], resultVector[1], resultVector[2]);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coordsystem',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: CoordSystem\n\t* Description: Represents coordinate system.\n\t* Parameters:\n\t*\torigo {Coord} origo\n\t*\te1 {Vector} first direction vector\n\t*\te2 {Vector} second direction vector\n\t*\te3 {Vector} third direction vector\n\t*/\n\tJSM.CoordSystem = function (origo, e1, e2, e3)\n\t{\n\t\tthis.origo = origo;\n\t\tthis.e1 = e1;\n\t\tthis.e2 = e2;\n\t\tthis.e3 = e3;\n\t};\n\n\t/**\n\t* Function: CoordSystem.Set\n\t* Description: Sets the coordinate system.\n\t* Parameters:\n\t*\torigo {Coord} origo\n\t*\te1 {Vector} first direction vector\n\t*\te2 {Vector} second direction vector\n\t*\te3 {Vector} third direction vector\n\t*/\n\tJSM.CoordSystem.prototype.Set = function (origo, e1, e2, e3)\n\t{\n\t\tthis.origo = origo;\n\t\tthis.e1 = e1;\n\t\tthis.e2 = e2;\n\t\tthis.e3 = e3;\n\t};\n\n\t/**\n\t* Function: CoordSystem.CoordSystemToDirectionVectors\n\t* Description: Converts coordinate system vectors to origo relative direction vectors.\n\t* Returns:\n\t*\t{CoordSystem} this pointer\n\t*/\n\tJSM.CoordSystem.prototype.ToDirectionVectors = function ()\n\t{\n\t\tthis.e1 = JSM.CoordSub (this.e1, this.origo);\n\t\tthis.e2 = JSM.CoordSub (this.e2, this.origo);\n\t\tthis.e3 = JSM.CoordSub (this.e3, this.origo);\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: CoordSystem.CoordSystemToAbsoluteCoords\n\t* Description: Converts the coordinate system vectors to absolute coordinates.\n\t* Returns:\n\t*\t{CoordSystem} this pointer\n\t*/\n\tJSM.CoordSystem.prototype.ToAbsoluteCoords = function ()\n\t{\n\t\tthis.e1 = JSM.CoordAdd (this.e1, this.origo);\n\t\tthis.e2 = JSM.CoordAdd (this.e2, this.origo);\n\t\tthis.e3 = JSM.CoordAdd (this.e3, this.origo);\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: CoordSystem.Clone\n\t* Description: Clones the coordinate system.\n\t* Returns:\n\t*\t{CoordSystem} a cloned instance\n\t*/\n\tJSM.CoordSystem.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.CoordSystem (this.origo.Clone (), this.e1.Clone (), this.e2.Clone (), this.e3.Clone ());\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/sector',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordSectorPosition2D\n\t* Description: Position of a coordinate and a sector.\n\t* Values:\n\t*\t{CoordInsideOfSector} coordinate lies inside of sector\n\t*\t{CoordOnSectorEndCoord} coordinate lies at the end of the sector\n\t*\t{CoordOutsideOfSector} coordinate lies outside of the sector\n\t*/\n\tJSM.CoordSectorPosition2D = {\n\t\tCoordInsideOfSector : 0,\n\t\tCoordOnSectorEndCoord : 1,\n\t\tCoordOutsideOfSector : 2\n\t};\n\n\t/**\n\t* Enum: SectorSectorPosition2D\n\t* Description: Position of two sectors.\n\t* Values:\n\t*\t{SectorsDontIntersect} sectors do not intersect\n\t*\t{SectorsIntersectCoincident} sectors intersect coincident\n\t*\t{SectorsIntersectEndPoint} sectors intersect at end point\n\t*\t{SectorsIntersectOnePoint} sectors intersect one point\n\t*/\n\tJSM.SectorSectorPosition2D = {\n\t\tSectorsDontIntersect : 0,\n\t\tSectorsIntersectCoincident : 1,\n\t\tSectorsIntersectEndPoint : 2,\n\t\tSectorsIntersectOnePoint : 3\n\t};\n\n\t/**\n\t* Enum: CoordSectorPosition\n\t* Description: Position of a coordinate and a sector.\n\t* Values:\n\t*\t{CoordInsideOfSector} coordinate lies inside of sector\n\t*\t{CoordOnSectorEndCoord} coordinate lies at the end of the sector\n\t*\t{CoordOutsideOfSector} coordinate lies outside of the sector\n\t*/\n\tJSM.CoordSectorPosition = {\n\t\tCoordInsideOfSector : 0,\n\t\tCoordOnSectorEndCoord : 1,\n\t\tCoordOutsideOfSector : 2\n\t};\n\n\t/**\n\t* Class: Sector2D\n\t* Description: Represents a 2D sector.\n\t* Parameters:\n\t*\tbeg {Coord2D} the beginning coordinate\n\t*\tend {Coord2D} the ending coordinate\n\t*/\n\tJSM.Sector2D = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector2D.Set\n\t* Description: Sets the sector.\n\t* Parameters:\n\t*\tbeg {Coord2D} the beginning coordinate\n\t*\tend {Coord2D} the ending coordinate\n\t*/\n\tJSM.Sector2D.prototype.Set = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.GetLength\n\t* Description: Returns the length of the sector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sector2D.prototype.GetLength = function ()\n\t{\n\t\treturn this.beg.DistanceTo (this.end);\n\t};\n\n\t/**\n\t* Function: Sector2D.CoordPosition\n\t* Description: Calculates the position of the sector and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Sector2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar x1 = this.beg.x;\n\t\tvar y1 = this.beg.y;\n\t\tvar x2 = this.end.x;\n\t\tvar y2 = this.end.y;\n\n\t\tvar length = this.GetLength ();\n\t\tif (JSM.IsZero (length)) {\n\t\t\tif (coord.IsEqual (this.beg)) {\n\t\t\t\treturn JSM.CoordSectorPosition2D.CoordOnSectorEndCoord;\n\t\t\t}\n\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar u = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / (length * length);\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar ux = x1 + u * (x2 - x1);\n\t\tvar uy = y1 + u * (y2 - y1);\n\t\tif (!JSM.IsEqual (ux, x) || !JSM.IsEqual (uy, y)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tif (JSM.IsEqual (u, 0.0) || JSM.IsEqual (u, 1.0)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOnSectorEndCoord;\n\t\t}\n\n\t\treturn JSM.CoordSectorPosition2D.CoordInsideOfSector;\n\t};\n\n\t/**\n\t* Function: Sector2D.SectorPosition\n\t* Description: Calculates the position of the sector and the given sector.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tintersection {Coord2D} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{SectorSectorPosition2D} the result\n\t*/\n\tJSM.Sector2D.prototype.SectorPosition = function (sector, intersection)\n\t{\n\t\tfunction IsOnSegment (beg, end, coord)\n\t\t{\n\t\t\tif (!coord.IsEqual (beg) && !coord.IsEqual (end) &&\n\t\t\t\tJSM.IsLowerOrEqual (coord.x, Math.max (beg.x, end.x)) &&\n\t\t\t\tJSM.IsLowerOrEqual (coord.y, Math.max (beg.y, end.y)) &&\n\t\t\t\tJSM.IsGreaterOrEqual (coord.x, Math.min (beg.x, end.x)) &&\n\t\t\t\tJSM.IsGreaterOrEqual (coord.y, Math.min (beg.y, end.y)))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvar calcIntersection = (intersection !== undefined && intersection !== null);\n\t\t\n\t\tvar aBeg = this.beg;\n\t\tvar aEnd = this.end;\n\t\tvar bBeg = sector.beg;\n\t\tvar bEnd = sector.end;\n\t\t\n\t\tvar equalBeg = aBeg.IsEqual (bBeg) || aBeg.IsEqual (bEnd);\n\t\tvar equalEnd = aEnd.IsEqual (bBeg) || aEnd.IsEqual (bEnd);\n\t\tif (equalBeg && equalEnd) {\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectCoincident;\n\t\t}\n\n\t\tvar x1 = aBeg.x;\n\t\tvar y1 = aBeg.y;\n\t\tvar x2 = aEnd.x;\n\t\tvar y2 = aEnd.y;\n\t\tvar x3 = bBeg.x;\n\t\tvar y3 = bBeg.y;\n\t\tvar x4 = bEnd.x;\n\t\tvar y4 = bEnd.y;\n\n\t\tvar numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t\tvar numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t\tvar denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\tif (JSM.IsZero (denominator)) {\n\t\t\tif (JSM.IsZero (numeratorA) && JSM.IsZero (numeratorB)) {\n\t\t\t\tif (IsOnSegment (aBeg, aEnd, bBeg) ||\n\t\t\t\t\tIsOnSegment (aBeg, aEnd, bEnd) ||\n\t\t\t\t\tIsOnSegment (bBeg, bEnd, aBeg) ||\n\t\t\t\t\tIsOnSegment (bBeg, bEnd, aEnd))\n\t\t\t\t{\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectCoincident;\n\t\t\t\t} else if (equalBeg) {\n\t\t\t\t\tif (calcIntersection) {\n\t\t\t\t\t\tintersection.x = aBeg.x;\n\t\t\t\t\t\tintersection.y = aBeg.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t\t\t} else if (equalEnd) {\n\t\t\t\t\tif (calcIntersection) {\n\t\t\t\t\t\tintersection.x = aEnd.x;\n\t\t\t\t\t\tintersection.y = aEnd.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsDontIntersect;\n\t\t}\n\t\t\n\t\tvar distA = numeratorA / denominator;\n\t\tvar distB = numeratorB / denominator;\n\t\tif (JSM.IsLower (distA, 0.0) || JSM.IsGreater (distA, 1.0) ||\n\t\t\tJSM.IsLower (distB, 0.0) || JSM.IsGreater (distB, 1.0))\n\t\t{\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsDontIntersect;\n\t\t}\n\n\t\tif (equalBeg) {\n\t\t\tif (calcIntersection) {\n\t\t\t\tintersection.x = aBeg.x;\n\t\t\t\tintersection.y = aBeg.y;\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t} else if (equalEnd) {\n\t\t\tif (calcIntersection) {\n\t\t\t\tintersection.x = aEnd.x;\n\t\t\t\tintersection.y = aEnd.y;\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t}\n\t\t\n\t\tif (calcIntersection) {\n\t\t\tintersection.x = x1 + distA * (x2 - x1);\n\t\t\tintersection.y = y1 + distA * (y2 - y1);\n\t\t}\n\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectOnePoint;\n\t};\n\n\t/**\n\t* Function: Sector2D.ProjectCoord\n\t* Description: Calculates the projected coordinate of the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{Coord2D} the projected coordinate\n\t*/\n\tJSM.Sector2D.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\n\t\tvar beg = this.beg;\n\t\tvar end = this.end;\n\t\tvar x1 = beg.x;\n\t\tvar y1 = beg.y;\n\t\tvar x2 = end.x;\n\t\tvar y2 = end.y;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn beg.Clone ();\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1)) / denom;\n\t\tif (JSM.IsLower (u, 0.0)) {\n\t\t\treturn beg.Clone ();\n\t\t} else if (JSM.IsGreater (u, 1.0)) {\n\t\t\treturn end.Clone ();\n\t\t}\n\t\t\n\t\tvar dir = JSM.CoordSub2D (end, beg).MultiplyScalar (u);\n\t\tvar result = JSM.CoordAdd2D (beg, dir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Sector2D.Clone\n\t* Description: Clones the sector.\n\t* Returns:\n\t*\t{Sector2D} a cloned instance\n\t*/\n\tJSM.Sector2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sector2D (this.beg.Clone (), this.end.Clone ());\n\t};\n\n\t/**\n\t* Class: Sector\n\t* Description: Represents a 3D sector.\n\t* Parameters:\n\t*\tbeg {Coord} the beginning coordinate\n\t*\tend {Coord} the ending coordinate\n\t*/\n\tJSM.Sector = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.Set\n\t* Description: Sets the sector.\n\t* Parameters:\n\t*\tbeg {Coord} the beginning coordinate\n\t*\tend {Coord} the ending coordinate\n\t*/\n\tJSM.Sector.prototype.Set = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.GetLength\n\t* Description: Returns the length of the sector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sector.prototype.GetLength = function ()\n\t{\n\t\treturn this.beg.DistanceTo (this.end);\n\t};\n\n\t/**\n\t* Function: Sector.CoordPosition\n\t* Description: Calculates the position of the sector and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{CoordSectorPosition} the result\n\t*/\n\tJSM.Sector.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.beg;\n\t\tvar b = JSM.CoordSub (this.end, this.beg);\n\t\t\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\tif (a.IsEqual (coord)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOnSectorEndCoord;\n\t\t\t}\n\t\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\tvar c = JSM.CoordAdd (a, bu);\n\t\tvar distance = coord.DistanceTo (c);\n\t\tif (JSM.IsZero (distance)) {\n\t\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t\t\t} else if (JSM.IsEqual (u, 0.0) || JSM.IsEqual (u, 1.0)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOnSectorEndCoord;\n\t\t\t}\n\t\t\treturn JSM.CoordSectorPosition.CoordInsideOfSector;\n\t\t}\n\n\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t};\n\n\t/**\n\t* Function: Sector.Clone\n\t* Description: Clones the sector.\n\t* Returns:\n\t*\t{Sector} a cloned instance\n\t*/\n\tJSM.Sector.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sector (this.beg.Clone (), this.end.Clone ());\n\t};\n\n\t/**\n\t* Function: GetSectorSegmentation2D\n\t* Description: Returns the segmented coordinates of a sector.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tsegmentation {integer} the segmentation\n\t* Returns:\n\t*\t{Coord2D[*]} the result coordinates\n\t*/\n\tJSM.GetSectorSegmentation2D = function (sector, segmentation)\n\t{\n\t\tvar direction = JSM.CoordSub2D (sector.end, sector.beg);\n\t\tvar length = sector.beg.DistanceTo (sector.end);\n\t\tvar step = length / segmentation;\n\t\tvar distance = 0.0;\n\n\t\tvar result = [];\n\t\tvar i, offseted;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\toffseted = sector.beg.Clone ().Offset (direction, distance);\n\t\t\tresult.push (offseted);\n\t\t\tdistance += step;\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetSectorSegmentation\n\t* Description: Returns the segmented coordinates of a sector.\n\t* Parameters:\n\t*\tsector {Sector} the sector\n\t*\tsegmentation {integer} the segmentation\n\t* Returns:\n\t*\t{Coord[*]} the result coordinates\n\t*/\n\tJSM.GetSectorSegmentation = function (sector, segmentation)\n\t{\n\t\tvar direction = JSM.CoordSub (sector.end, sector.beg);\n\t\tvar length = sector.beg.DistanceTo (sector.end);\n\t\tvar step = length / segmentation;\n\t\tvar distance = 0.0;\n\n\t\tvar result = [];\n\t\tvar i, offseted;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\toffseted = sector.beg.Clone ().Offset (direction, distance);\n\t\t\tresult.push (offseted);\n\t\t\tdistance += step;\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/line',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordLinePosition2D\n\t* Description: Position of a coordinate and a line.\n\t* Values:\n\t*\t{CoordOnLine} coordinate lies on the line\n\t*\t{CoordAtLineLeft} coordinate lies on the left side of the line\n\t*\t{CoordAtLineRight} coordinate lies on the left side right the line\n\t*/\n\tJSM.CoordLinePosition2D = {\n\t\tCoordOnLine : 0,\n\t\tCoordAtLineLeft : 1,\n\t\tCoordAtLineRight : 2\n\t};\n\n\t/**\n\t* Enum: LineLinePosition2D\n\t* Description: Position of two lines.\n\t* Values:\n\t*\t{LinesDontIntersect} lines do not intersect\n\t*\t{LinesIntersectsCoincident} lines intersect coincident\n\t*\t{LinesIntersectsOnePoint} lines intersect one point\n\t*/\n\tJSM.LineLinePosition2D = {\n\t\tLinesDontIntersect : 0,\n\t\tLinesIntersectsOnePoint : 1,\n\t\tLinesIntersectsCoincident : 2\n\t};\n\n\t/**\n\t* Enum: CoordLinePosition\n\t* Description: Position of a coordinate and a line.\n\t* Values:\n\t*\t{CoordOnLine} coordinate lies on the line\n\t*\t{CoordOutsideOfLine} coordinate lies outside of the line\n\t*/\n\tJSM.CoordLinePosition = {\n\t\tCoordOnLine : 0,\n\t\tCoordOutsideOfLine : 1\n\t};\n\n\t/**\n\t* Enum: LineLinePosition\n\t* Description: Position of two lines.\n\t* Values:\n\t*\t{LinesDontIntersect} lines do not intersect\n\t*\t{LinesIntersectsCoincident} lines intersect coincident\n\t*\t{LinesIntersectsOnePoint} lines intersect one point\n\t*/\n\tJSM.LineLinePosition = {\n\t\tLinesDontIntersect : 0,\n\t\tLinesIntersectsOnePoint : 1,\n\t\tLinesIntersectsCoincident : 2\n\t};\n\n\t/**\n\t* Class: Line2D\n\t* Description: Represents a 2D infinite line.\n\t* Parameters:\n\t*\tstart {Coord2D} the start point of the line\n\t*\tdirection {Vector2D} the direction of the line\n\t*/\n\tJSM.Line2D = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line2D.Set\n\t* Description: Sets the line.\n\t* Parameters:\n\t*\tstart {Coord2D} the start point of the line\n\t*\tdirection {Vector2D} the direction of the line\n\t*/\n\tJSM.Line2D.prototype.Set = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line2D.CoordPosition\n\t* Description: Calculates the position of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordLinePosition2D} the result\n\t*/\n\tJSM.Line2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar position = this.CoordSignedDistance (coord);\n\t\tif (JSM.IsPositive (position)) {\n\t\t\treturn JSM.CoordLinePosition2D.CoordAtLineLeft;\n\t\t} else if (JSM.IsNegative (position)) {\n\t\t\treturn JSM.CoordLinePosition2D.CoordAtLineRight;\n\t\t}\n\n\t\treturn JSM.CoordLinePosition2D.CoordOnLine;\n\t};\n\n\t/**\n\t* Function: Line2D.CoordSignedDistance\n\t* Description: Calculates the signed distance of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Line2D.prototype.CoordSignedDistance = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\t\treturn b.x * (y - a.y) - b.y * (x - a.x);\n\t};\n\n\t/**\n\t* Function: Line2D.LinePosition\n\t* Description: Calculates the position of the line and the given line.\n\t* Parameters:\n\t*\tline {Line2D} the line\n\t*\tintersection {Coord2D} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{LineLinePosition2D} the result\n\t*/\n\tJSM.Line2D.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar x1 = this.start.x;\n\t\tvar y1 = this.start.y;\n\t\tvar x2 = this.start.x + this.direction.x;\n\t\tvar y2 = this.start.y + this.direction.y;\n\t\tvar x3 = line.start.x;\n\t\tvar y3 = line.start.y;\n\t\tvar x4 = line.start.x + line.direction.x;\n\t\tvar y4 = line.start.y + line.direction.y;\n\t\t\n\t\tvar numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t\tvar numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t\tvar denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\tif (JSM.IsZero (denominator)) {\n\t\t\tif (JSM.IsZero (numeratorA) && JSM.IsZero (numeratorB)) {\n\t\t\t\treturn JSM.LineLinePosition2D.LinesIntersectsCoincident;\n\t\t\t}\n\t\t\treturn JSM.LineLinePosition2D.LinesDontIntersect;\n\t\t}\n\n\t\tvar distance = numeratorA / denominator;\n\t\tif (intersection !== null) {\n\t\t\tintersection.x = x1 + distance * (x2 - x1);\n\t\t\tintersection.y = y1 + distance * (y2 - y1);\n\t\t}\n\t\treturn JSM.LineLinePosition2D.LinesIntersectsOnePoint;\n\t};\n\n\t/**\n\t* Function: Line2D.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{Line2D} a cloned instance\n\t*/\n\tJSM.Line2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Line2D (this.start.Clone (), this.direction.Clone ());\n\t};\n\n\t/**\n\t* Class: Line\n\t* Description: Represents a 3D infinite line.\n\t* Parameters:\n\t*\tstart {Coord} the start point of the line\n\t*\tdirection {Vector} the direction of the line\n\t*/\n\tJSM.Line = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line.Set\n\t* Description: Sets the line.\n\t* Parameters:\n\t*\tstart {Coord} the start point of the line\n\t*\tdirection {Vector} the direction of the line\n\t*/\n\tJSM.Line.prototype.Set = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line.CoordPosition\n\t* Description: Calculates the position of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tprojected {Coord} (out) the projected coordinate\n\t* Returns:\n\t*\t{CoordLinePosition} the result\n\t*/\n\tJSM.Line.prototype.CoordPosition = function (coord, projected)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\tif (projected !== undefined) {\n\t\t\t\tprojected.Set (a.x, a.y, a.z);\n\t\t\t}\n\n\t\t\tif (a.IsEqual (coord)) {\n\t\t\t\treturn JSM.CoordLinePosition.CoordOnLine;\n\t\t\t}\n\n\t\t\treturn JSM.CoordLinePosition.CoordOutsideOfLine;\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\tvar c = JSM.CoordAdd (a, bu);\n\t\tif (projected !== undefined) {\n\t\t\tprojected.Set (c.x, c.y, c.z);\n\t\t}\n\n\t\tvar distance = coord.DistanceTo (c);\n\t\tif (JSM.IsZero (distance)) {\n\t\t\treturn JSM.CoordLinePosition.CoordOnLine;\n\t\t}\n\n\t\treturn JSM.CoordLinePosition.CoordOutsideOfLine;\n\t};\n\n\t/**\n\t* Function: Line.ProjectCoord\n\t* Description: Calculates the projected coordinate of the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Line.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn a.Clone ();\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\treturn JSM.CoordAdd (a, bu);\n\t};\n\n\t/**\n\t* Function: Line.ClosestPoint\n\t* Description: Calculates the closest points between the line and a given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tthisClosestPoint {Coord} (out) the closest point on the current line\n\t*\tlineClosestPoint {Coord} (out) the closest point on the given line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.Line.prototype.ClosestPoint = function (line, thisClosestPoint, lineClosestPoint)\n\t{\n\t\tfunction Dmnop (v, m, n, o, p)\n\t\t{\n\t\t\tvar result = (v[m].x - v[n].x) * (v[o].x - v[p].x) + (v[m].y - v[n].y) * (v[o].y - v[p].y) + (v[m].z - v[n].z) * (v[o].z - v[p].z);\n\t\t\treturn result;\n\t\t}\n\n\t\tvar aDir = this.direction.Clone ().Normalize ();\n\t\tvar aStart = this.start;\n\t\tvar aEnd = JSM.CoordAdd (aStart, aDir);\n\n\t\tvar bDir = line.direction.Clone ().Normalize ();\n\t\tvar bStart = line.start;\n\t\tvar bEnd = JSM.CoordAdd (bStart, bDir);\n\t\t\n\t\tvar v = [aStart, aEnd, bStart, bEnd];\n\t\tvar d1010 = Dmnop (v, 1, 0, 1, 0);\n\t\tvar d0210 = Dmnop (v, 0, 2, 1, 0);\n\t\tvar d0232 = Dmnop (v, 0, 2, 3, 2);\n\t\tvar d3210 = Dmnop (v, 3, 2, 1, 0);\n\t\tvar d3232 = Dmnop (v, 3, 2, 3, 2);\n\t\tvar denom = (d1010 * d3232 - d3210 * d3210);\n\t\tif (JSM.IsEqual (denom, 0.0)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar nom = (d0232 * d3210 - d0210 * d3232);\n\t\tvar mua = nom / denom;\n\t\tvar mub = (d0232 + mua * d3210) / d3232;\n\n\t\tif (thisClosestPoint !== undefined) {\n\t\t\taDir.MultiplyScalar (mua);\n\t\t\tvar aClosest = JSM.CoordAdd (aStart, aDir);\n\t\t\tthisClosestPoint.Set (aClosest.x, aClosest.y, aClosest.z);\n\t\t}\n\t\t\n\t\tif (lineClosestPoint !== undefined) {\n\t\t\tbDir.MultiplyScalar (mub);\n\t\t\tvar bClosest = JSM.CoordAdd (bStart, bDir);\n\t\t\tlineClosestPoint.Set (bClosest.x, bClosest.y, bClosest.z);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Line.LinePosition\n\t* Description: Calculates the position of the line and the given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tintersection {Coord} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{LineLinePosition} the result\n\t*/\n\tJSM.Line.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar thisClosestPoint = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar lineClosestPoint = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tif (!this.ClosestPoint (line, thisClosestPoint, lineClosestPoint)) {\n\t\t\treturn JSM.LineLinePosition.LinesIntersectsCoincident;\n\t\t}\n\t\t\n\t\tif (thisClosestPoint.IsEqual (lineClosestPoint)) {\n\t\t\tif (intersection !== undefined) {\n\t\t\t\tintersection.Set (thisClosestPoint.x, thisClosestPoint.y, thisClosestPoint.z);\n\t\t\t}\n\t\t\treturn JSM.LineLinePosition.LinesIntersectsOnePoint;\n\t\t}\n\t\t\n\t\treturn JSM.LineLinePosition.LinesDontIntersect;\n\t};\n\n\t/**\n\t* Function: Line.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{Line} a cloned instance\n\t*/\n\tJSM.Line.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Line (this.start.Clone (), this.direction.Clone ());\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/box',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Box2D\n\t* Description: Represents a 2D box.\n\t* Parameters:\n\t*\tmin {Coord2D} the minimum position of the box\n\t*\tmin {Coord2D} the maximum position of the box\n\t*/\n\tJSM.Box2D = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box2D.Set\n\t* Description: Sets the box.\n\t* Parameters:\n\t*\tmin {Coord2D} the minimum position of the box\n\t*\tmin {Coord2D} the maximum position of the box\n\t*/\n\tJSM.Box2D.prototype.Set = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box2D.GetCenter\n\t* Description: Returns the center point of the box.\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.Box2D.prototype.GetCenter = function ()\n\t{\n\t\treturn JSM.MidCoord2D (this.min, this.max);\n\t};\n\n\t/**\n\t* Function: Box2D.Clone\n\t* Description: Clones the box.\n\t* Returns:\n\t*\t{Box2D} a cloned instance\n\t*/\n\tJSM.Box2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Box2D (this.min.Clone (), this.max.Clone ());\n\t};\n\n\t/**\n\t* Class: Box\n\t* Description: Represents a 3D box.\n\t* Parameters:\n\t*\tmin {Coord} the minimum position of the box\n\t*\tmin {Coord} the maximum position of the box\n\t*/\n\tJSM.Box = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box.Set\n\t* Description: Sets the box.\n\t* Parameters:\n\t*\tmin {Coord} the minimum position of the box\n\t*\tmin {Coord} the maximum position of the box\n\t*/\n\tJSM.Box.prototype.Set = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box.GetCenter\n\t* Description: Returns the center point of the box.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Box.prototype.GetCenter = function ()\n\t{\n\t\treturn JSM.MidCoord (this.min, this.max);\n\t};\n\n\t/**\n\t* Function: Box.GetSize\n\t* Description: Returns the size of the box.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Box.prototype.GetSize = function ()\n\t{\n\t\treturn JSM.CoordSub (this.max, this.min);\n\t};\n\n\t/**\n\t* Function: Box.IsCoordInside\n\t* Description: Determines if the given coordinate is inside the box.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Box.prototype.IsCoordInside = function (coord)\n\t{\n\t\tif (JSM.IsLower (coord.x, this.min.x) || JSM.IsLower (coord.y, this.min.y) || JSM.IsLower (coord.z, this.min.z)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (JSM.IsGreater (coord.x, this.max.x) || JSM.IsGreater (coord.y, this.max.y) || JSM.IsGreater (coord.z, this.max.z)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Box.Clone\n\t* Description: Clones the box.\n\t* Returns:\n\t*\t{Box} a cloned instance\n\t*/\n\tJSM.Box.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Box (this.min.Clone (), this.max.Clone ());\n\t};\n\n\t/**\n\t* Function: BoxUnion\n\t* Description: Calculates the union of two 3D boxes.\n\t* Parameters:\n\t*\taBox {Box} the first box\n\t*\tbBox {Box} the second box\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.BoxUnion = function (aBox, bBox)\n\t{\n\t\tvar min = new JSM.Coord (JSM.Minimum (aBox.min.x, bBox.min.x), JSM.Minimum (aBox.min.y, bBox.min.y), JSM.Minimum (aBox.min.z, bBox.min.z));\n\t\tvar max = new JSM.Coord (JSM.Maximum (aBox.max.x, bBox.max.x), JSM.Maximum (aBox.max.y, bBox.max.y), JSM.Maximum (aBox.max.z, bBox.max.z));\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/sphere',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Sphere\n\t* Description: Represents a sphere.\n\t* Parameters:\n\t*\tcenter {Coord} the center of the sphere\n\t*\tradius {number} the radius of the sphere\n\t*/\n\tJSM.Sphere = function (center, radius)\n\t{\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t};\n\n\t/**\n\t* Function: Sphere.Set\n\t* Description: Sets the sphere.\n\t* Parameters:\n\t*\tcenter {Coord} the center of the sphere\n\t*\tradius {number} the radius of the sphere\n\t*/\n\tJSM.Sphere.prototype.Set = function (center, radius)\n\t{\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t};\n\n\t/**\n\t* Function: Sphere.GetCenter\n\t* Description: Returns the center of the sphere.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Sphere.prototype.GetCenter = function ()\n\t{\n\t\treturn this.center;\n\t};\n\n\t/**\n\t* Function: Sphere.GetRadius\n\t* Description: Returns the radius of the sphere.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sphere.prototype.GetRadius = function ()\n\t{\n\t\treturn this.radius;\n\t};\n\n\t/**\n\t* Function: Sphere.Clone\n\t* Description: Clones the sphere.\n\t* Returns:\n\t*\t{Sphere} a cloned instance\n\t*/\n\tJSM.Sphere.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sphere (this.center.Clone (), this.radius);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/transformation',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Transformation\n\t* Description: Represents a transformation matrix.\n\t*/\n\tJSM.Transformation = function ()\n\t{\n\t\tthis.matrix = JSM.MatrixIdentity ();\n\t};\n\n\t/**\n\t* Function: Transformation.GetMatrix\n\t* Description: Returns the matrix of the transformation.\n\t* Returns:\n\t*\t{number[16]} the matrix\n\t*/\n\tJSM.Transformation.prototype.GetMatrix = function ()\n\t{\n\t\treturn this.matrix;\n\t};\n\n\t/**\n\t* Function: Transformation.SetMatrix\n\t* Description: Sets matrix of the transformation.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*/\n\tJSM.Transformation.prototype.SetMatrix = function (matrix)\n\t{\n\t\tthis.matrix = matrix;\n\t};\n\n\t/**\n\t* Function: Transformation.Append\n\t* Description: Adds a transformation to the matrix.\n\t* Parameters:\n\t*\tsource {Transformation} the another transformation\n\t*/\n\tJSM.Transformation.prototype.Append = function (source)\n\t{\n\t\tthis.matrix = JSM.MatrixMultiply (this.matrix, source.matrix);\n\t};\n\n\t/**\n\t* Function: Transformation.Apply\n\t* Description: Apply transformation to a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Transformation.prototype.Apply = function (coord)\n\t{\n\t\treturn JSM.ApplyTransformation (this.matrix, coord);\n\t};\n\n\t/**\n\t* Function: Transformation.Clone\n\t* Description: Clones the transformation.\n\t* Returns:\n\t*\t{Transformation} a cloned instance\n\t*/\n\tJSM.Transformation.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Transformation ();\n\t\tresult.matrix = JSM.MatrixClone (this.matrix);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IdentityTransformation\n\t* Description: Generates an identity transformation.\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.IdentityTransformation = function ()\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixIdentity ();\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: TranslationTransformation\n\t* Description: Generates a translation transformation.\n\t* Parameters:\n\t*\ttranslation {Vector} the translation vector\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.TranslationTransformation = function (translation)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixTranslation (translation.x, translation.y, translation.z);\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: OffsetTransformation\n\t* Description: Generates an offset transformation.\n\t* Parameters:\n\t*\tdirection {Vector} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.OffsetTransformation = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tvar translation = normal.Clone ().MultiplyScalar (distance);\n\t\treturn JSM.TranslationTransformation (translation);\n\t};\n\n\t/**\n\t* Function: RotationTransformation\n\t* Description: Generates a rotation transformation.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationTransformation = function (axis, angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixRotation (axis, angle, origo);\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationXTransformation\n\t* Description: Generates a rotation transformation around the x axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationXTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationX (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationXTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationYTransformation\n\t* Description: Generates a rotation transformation around the y axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationYTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationY (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationYTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationZTransformation\n\t* Description: Generates a rotation transformation around the z axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationZTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationZ (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationZTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationXYZTransformation\n\t* Description: Generates a rotation transformation around all axis in x, y, z order.\n\t* Parameters:\n\t*\txAngle {number} the x angle of the rotation\n\t*\tyAngle {number} the y angle of the rotation\n\t*\tzAngle {number} the z angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationXYZTransformation = function (xAngle, yAngle, zAngle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.Append (JSM.RotationXTransformation (xAngle, origo));\n\t\ttransformation.Append (JSM.RotationYTransformation (yAngle, origo));\n\t\ttransformation.Append (JSM.RotationZTransformation (zAngle, origo));\n\t\treturn transformation;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/plane',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordPlanePosition\n\t* Description: Position of a coordinate and a plane.\n\t* Values:\n\t*\t{CoordOnPlane} coordinate lies on the plane\n\t*\t{CoordInFrontOfPlane} coordinate lies in front of of the plane\n\t*\t{CoordAtBackOfPlane} coordinate lies at the back of the plane\n\t*/\n\tJSM.CoordPlanePosition = {\n\t\tCoordOnPlane : 0,\n\t\tCoordInFrontOfPlane : 1,\n\t\tCoordAtBackOfPlane : 2\n\t};\n\n\t/**\n\t* Enum: LinePlanePosition\n\t* Description: Position of a line and a plane.\n\t* Values:\n\t*\t{LineParallelToPlane} line is parallel to the plane\n\t*\t{LineIntersectsPlane} line intersects the plane\n\t*/\n\tJSM.LinePlanePosition = {\n\t\tLineParallelToPlane : 0,\n\t\tLineIntersectsPlane : 1\n\t};\n\n\t/**\n\t* Class: Plane\n\t* Description: Represents a plane.\n\t* Parameters:\n\t*\ta {number} the a component of plane equation\n\t*\tb {number} the b component of plane equation\n\t*\tc {number} the c component of plane equation\n\t*\td {number} the d component of plane equation\n\t*/\n\tJSM.Plane = function (a, b, c, d)\n\t{\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t};\n\n\t/**\n\t* Function: Plane.Set\n\t* Description: Sets the plane.\n\t* Parameters:\n\t*\ta {number} the a component of plane equation\n\t*\tb {number} the b component of plane equation\n\t*\tc {number} the c component of plane equation\n\t*\td {number} the d component of plane equation\n\t*/\n\tJSM.Plane.prototype.Set = function (a, b, c, d)\n\t{\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t};\n\n\t/**\n\t* Function: Plane.GetNormal\n\t* Description: Calculates the normal vector of the plane.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Plane.prototype.GetNormal = function ()\n\t{\n\t\treturn new JSM.Vector (this.a, this.b, this.c);\n\t};\n\n\t/**\n\t* Function: Plane.CoordSignedDistance\n\t* Description: Calculates the signed distance of a coordinate and the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Plane.prototype.CoordSignedDistance = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar distance = (a * x + b * y + c * z + d) / Math.sqrt (a * a + b * b + c * c);\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: Plane.CoordDistance\n\t* Description: Calculates the distance of a coordinate and the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Plane.prototype.CoordDistance = function (coord)\n\t{\n\t\tvar signed = this.CoordSignedDistance (coord);\n\t\treturn Math.abs (signed);\n\t};\n\n\t/**\n\t* Function: Plane.ProjectCoord\n\t* Description: Projects a coordinate to the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the projected coordinate\n\t*/\n\tJSM.Plane.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar distance = this.CoordDistance (coord);\n\t\tvar side = a * x + b * y + c * z + d;\n\t\tif (JSM.IsGreater (side, 0.0)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\tvar normal = this.GetNormal ().Normalize ();\n\t\tvar result = coord.Clone ().Offset (normal, distance);\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Plane.CoordPosition\n\t* Description: Calculates the position of the plane and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{CoordPlanePosition} thre result\n\t*/\n\tJSM.Plane.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar s = a * x + b * y + c * z + d;\n\t\tif (JSM.IsPositive (s)) {\n\t\t\treturn JSM.CoordPlanePosition.CoordInFrontOfPlane;\n\t\t} else if (JSM.IsNegative (s)) {\n\t\t\treturn JSM.CoordPlanePosition.CoordAtBackOfPlane;\n\t\t}\n\t\t\n\t\treturn JSM.CoordPlanePosition.CoordOnPlane;\n\t};\n\n\t/**\n\t* Function: Plane.LinePosition\n\t* Description: Calculates the position of the plane and the given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tintersection {Coord} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{CoordLinePosition} the result\n\t*/\n\tJSM.Plane.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar\tdirection = line.direction.Clone ().Normalize ();\n\n\t\tvar x1 = line.start.x;\n\t\tvar y1 = line.start.y;\n\t\tvar z1 = line.start.z;\n\n\t\tvar x2 = line.start.x + direction.x;\n\t\tvar y2 = line.start.y + direction.y;\n\t\tvar z2 = line.start.z + direction.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn JSM.LinePlanePosition.LineParallelToPlane;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tif (intersection !== undefined) {\n\t\t\tdirection.MultiplyScalar (u);\n\t\t\tvar i = JSM.CoordAdd (line.start, direction);\n\t\t\tintersection.Set (i.x, i.y, i.z);\n\t\t}\n\n\t\treturn JSM.LinePlanePosition.LineIntersectsPlane;\n\t};\n\n\t/**\n\t* Function: Plane.LineIntersection\n\t* Description:\n\t*\tCalculates the intersection point of a line and a plane.\n\t*\tThe line should not be parallel to the plane.\n\t* Parameters:\n\t*\tline {Line} the line\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Plane.prototype.LineIntersection = function (line)\n\t{\n\t\tvar\tdirection = line.direction.Clone ().Normalize ();\n\n\t\tvar x1 = line.start.x;\n\t\tvar y1 = line.start.y;\n\t\tvar z1 = line.start.z;\n\n\t\tvar x2 = line.start.x + direction.x;\n\t\tvar y2 = line.start.y + direction.y;\n\t\tvar z2 = line.start.z + direction.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tdirection.MultiplyScalar (u);\n\t\treturn JSM.CoordAdd (line.start, direction);\n\t};\n\n\t/**\n\t* Function: Plane.Clone\n\t* Description: Clones the plane.\n\t* Returns:\n\t*\t{Plane} a cloned instance\n\t*/\n\tJSM.Plane.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Plane (this.a, this.b, this.c, this.d);\n\t};\n\n\t/**\n\t* Function: GetPlaneFromCoordAndDirection\n\t* Description: Generates a plane from a coordinate and a direction.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t* Returns:\n\t*\t{Plane} the result\n\t*/\n\tJSM.GetPlaneFromCoordAndDirection = function (coord, direction)\n\t{\n\t\tvar plane = new JSM.Plane ();\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tvar pa = normal.x;\n\t\tvar pb = normal.y;\n\t\tvar pc = normal.z;\n\t\tvar pd = -(pa * coord.x + pb * coord.y + pc * coord.z);\n\t\tplane.Set (pa, pb, pc, pd);\n\t\treturn plane;\n\t};\n\n\t/**\n\t* Function: GetPlaneFromThreeCoords\n\t* Description: Generates a plane from three coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t*\tc {Coord} the third coordinate\n\t* Returns:\n\t*\t{Plane} the result\n\t*/\n\tJSM.GetPlaneFromThreeCoords = function (a, b, c)\n\t{\n\t\tvar plane = new JSM.Plane ();\n\t\tvar pa = (b.y - a.y) * (c.z - a.z) - (c.y - a.y) * (b.z - a.z);\n\t\tvar pb = (b.z - a.z) * (c.x - a.x) - (c.z - a.z) * (b.x - a.x);\n\t\tvar pc = (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);\n\t\tvar pd = -(pa * a.x + pb * a.y + pc * a.z);\n\t\tplane.Set (pa, pb, pc, pd);\n\t\treturn plane;\n\t};\n\n\t/**\n\t* Function: CoordPlaneSignedDirectionalDistance\n\t* Description: Calculates the signed distance of a coordinate and a plane along a direction vector.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordPlaneSignedDirectionalDistance = function (coord, direction, plane)\n\t{\n\t\tvar\tnormal = direction.Clone ().Normalize ();\n\n\t\tvar x1 = coord.x;\n\t\tvar y1 = coord.y;\n\t\tvar z1 = coord.z;\n\n\t\tvar x2 = coord.x + normal.x;\n\t\tvar y2 = coord.y + normal.y;\n\t\tvar z2 = coord.z + normal.z;\n\n\t\tvar a = plane.a;\n\t\tvar b = plane.b;\n\t\tvar c = plane.c;\n\t\tvar d = plane.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tnormal.MultiplyScalar (u);\n\t\tvar intersection = JSM.CoordAdd (coord, normal);\n\t\tvar distance = coord.DistanceTo (intersection);\n\t\tvar s = a * x1 + b * y1 + c * z1 + d;\n\t\tif (JSM.IsNegative (s)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: CoordPlaneDirectionalDistance\n\t* Description: Calculates the distance of a coordinate and a plane along a direction vector.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordPlaneDirectionalDistance = function (coord, direction, plane)\n\t{\n\t\treturn Math.abs (JSM.CoordPlaneSignedDirectionalDistance (coord, direction, plane));\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/projection',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixView\n\t* Description: Creates a view matrix.\n\t* Parameters:\n\t*\teye {Coord} eye position\n\t*\tcenter {Coord} center position\n\t*\tup {Vector} up vector\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixView = function (eye, center, up)\n\t{\n\t\tif (eye.IsEqual (center)) {\n\t\t\treturn JSM.MatrixIdentity ();\n\t\t}\n\t\t\n\t\tvar result = [];\n\n\t\tvar d = JSM.CoordSub (eye, center).Normalize ();\n\t\tvar v = JSM.VectorCross (up, d).Normalize ();\n\t\tvar u = JSM.VectorCross (d, v).Normalize ();\n\n\t\tresult[0] = v.x;\n\t\tresult[1] = u.x;\n\t\tresult[2] = d.x;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = v.y;\n\t\tresult[5] = u.y;\n\t\tresult[6] = d.y;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = v.z;\n\t\tresult[9] = u.z;\n\t\tresult[10] = d.z;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = -JSM.VectorDot (v, eye);\n\t\tresult[13] = -JSM.VectorDot (u, eye);\n\t\tresult[14] = -JSM.VectorDot (d, eye);\n\t\tresult[15] = 1.0;\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixPerspective\n\t* Description: Creates a perspective matrix.\n\t* Parameters:\n\t*\tfieldOfView {number} field of view\n\t*\taspectRatio {number} aspect ratio\n\t*\tnearPlane {number} near clipping plane\n\t*\tfarPlane {number} far clipping plane\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixPerspective = function (fieldOfView, aspectRatio, nearPlane, farPlane)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar f = 1.0 / Math.tan (fieldOfView / 2.0);\n\t\tvar nf = 1.0 / (nearPlane - farPlane);\n\t\t\n\t\tresult[0] = f / aspectRatio;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = f;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = (farPlane + nearPlane) * nf;\n\t\tresult[11] = -1.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = (2.0 * farPlane * nearPlane) * nf;\n\t\tresult[15] = 0.0;\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Project\n\t* Description: Projects a 3D coordinate to 2D.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\teye {Coord} the eye of the camera\n\t*\tcenter {Coord} the center of the camera\n\t*\tup {Vector} the up vector of the camera\n\t*\tfieldOfView {number} camera field of view\n\t*\taspectRatio {number} aspect ratio of the desired image\n\t*\tnearPlane {number} near cutting plane distance\n\t*\tfarPlane {number} far cutting plane distance\n\t*\tviewPort {number[4]} view port coordinates in pixels\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Project = function (coord, eye, center, up, fieldOfView, aspectRatio, nearPlane, farPlane, viewPort)\n\t{\n\t\tvar input = [\n\t\t\tcoord.x,\n\t\t\tcoord.y,\n\t\t\tcoord.z,\n\t\t\t1.0\n\t\t];\n\n\t\tvar viewMatrix = JSM.MatrixView (eye, center, up);\n\t\tvar perspectiveMatrix = JSM.MatrixPerspective (fieldOfView, aspectRatio, nearPlane, farPlane);\n\t\tvar projectionMatrix = JSM.MatrixMultiply (viewMatrix, perspectiveMatrix);\n\t\tvar output = JSM.MatrixVectorMultiply (projectionMatrix, input);\n\t\tvar denom = output[3];\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = (output[0] / denom * 0.5 + 0.5) * viewPort[2] + viewPort[0];\n\t\tresult.y = (output[1] / denom * 0.5 + 0.5) * viewPort[3] + viewPort[1];\n\t\tresult.z = (output[2] / denom * 0.5 + 0.5);\n\t\treturn result;\t\n\t};\n\n\t/**\n\t* Function: Unproject\n\t* Description: Projects a 2D coordinate to 3D.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate (the z component can be zero)\n\t*\teye {Coord} the eye of the camera\n\t*\tcenter {Coord} the center of the camera\n\t*\tup {Vector} the up vector of the camera\n\t*\tfieldOfView {number} camera field of view\n\t*\taspectRatio {number} aspect ratio of the desired image\n\t*\tnearPlane {number} near cutting plane distance\n\t*\tfarPlane {number} far cutting plane distance\n\t*\tviewPort {number[4]} view port coordinates in pixels\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Unproject = function (coord, eye, center, up, fieldOfView, aspectRatio, nearPlane, farPlane, viewPort)\n\t{\n\t\tvar input = [\n\t\t\t(coord.x - viewPort[0]) / viewPort[2] * 2.0 - 1.0,\n\t\t\t(coord.y - viewPort[1]) / viewPort[3] * 2.0 - 1.0,\n\t\t\t2.0 * coord.z - 1,\n\t\t\t1.0\n\t\t];\n\t\t\n\t\tvar viewMatrix = JSM.MatrixView (eye, center, up);\n\t\tvar perspectiveMatrix = JSM.MatrixPerspective (fieldOfView, aspectRatio, nearPlane, farPlane);\n\t\tvar projectionMatrix = JSM.MatrixMultiply (viewMatrix, perspectiveMatrix);\n\t\tvar inverseMatrix = JSM.MatrixInvert (projectionMatrix);\n\t\tvar output = JSM.MatrixVectorMultiply (inverseMatrix, input);\n\t\tvar denom = output[3];\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = (output[0] / output[3]);\n\t\tresult.y = (output[1] / output[3]);\n\t\tresult.z = (output[2] / output[3]);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/convexhull',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ConvexHull2D\n\t* Description: Calculates the 2D convex hull from the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord2D[*]} the coordinate array\n\t* Returns:\n\t*\t{Coord2D[*]} coordinate array of the convex hull\n\t*/\n\tJSM.ConvexHull2D = function (coords)\n\t{\n\t\tfunction FindLeftMostCoord (coords)\n\t\t{\n\t\t\tvar count = coords.length;\n\t\t\tvar minValue = JSM.Inf;\n\t\t\tvar minIndex = -1;\n\t\t\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = coords[i].x;\n\t\t\t\tif (JSM.IsLower (current, minValue)) {\n\t\t\t\t\tminValue = current;\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn minIndex;\n\t\t}\n\t\t\n\t\tfunction FindNextCoord (coords, current)\n\t\t{\n\t\t\tvar count = coords.length;\n\t\t\tvar next = 0;\n\t\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 1; i < count; i++) {\n\t\t\t\tif (current == next) {\n\t\t\t\t\tnext = i;\n\t\t\t\t} else {\n\t\t\t\t\tif (JSM.CoordOrientation2D (coords[current], coords[next], coords[i]) == JSM.Orientation.Clockwise) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn next;\n\t\t}\n\n\t\tvar result = [];\n\t\tvar count = coords.length;\n\t\tif (count < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar first = FindLeftMostCoord (coords);\n\t\tvar current = first;\n\t\tvar next;\n\t\t\n\t\tdo {\n\t\t\tresult.push (current);\n\t\t\tnext = FindNextCoord (coords, current);\n\t\t\tcurrent = next;\n\t\t} while (next != first);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvexHull3D\n\t* Description:\n\t*\tCalculates the 3D convex hull from the given coordinates. The result defines\n\t*\tconvex hull triangles as an array of arrays with three coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the coordinate array\n\t* Returns:\n\t*\t{Coord[3][*]} the result\n\t*/\n\tJSM.ConvexHull3D = function (coords)\n\t{\n\t\tfunction Vertex ()\n\t\t{\n\t\t\tthis.position = null;\n\t\t}\n\t\t\n\t\tfunction Edge ()\n\t\t{\n\t\t\tthis.vert1 = null;\n\t\t\tthis.vert2 = null;\n\t\t\tthis.tri1 = null;\n\t\t\tthis.tri2 = null;\n\t\t}\n\n\t\tfunction Triangle ()\n\t\t{\n\t\t\tthis.vertices = null;\n\t\t\tthis.edges = null;\n\t\t\tthis.valid = null;\n\t\t}\n\n\t\tfunction Body ()\n\t\t{\n\t\t\tthis.vertices = [];\n\t\t\tthis.edges = [];\n\t\t\tthis.triangles = [];\n\t\t}\n\n\t\tfunction AddVertex (body, coord)\n\t\t{\n\t\t\tvar vertex = new Vertex ();\n\t\t\tvertex.position = coord;\n\t\t\tbody.vertices.push (vertex);\n\t\t\treturn body.vertices.length - 1;\n\t\t}\n\n\t\tfunction AddEdge (body, triangleIndex, a, b)\n\t\t{\n\t\t\tvar edgeIndex = -1;\n\t\t\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < body.edges.length; i++) {\n\t\t\t\tcurrent = body.edges[i];\n\t\t\t\tif (current.vert1 == a && current.vert2 == b || current.vert1 == b && current.vert2 == a) {\n\t\t\t\t\tedgeIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (edgeIndex == -1) {\n\t\t\t\tvar newEdge = new Edge ();\n\t\t\t\tnewEdge.vert1 = a;\n\t\t\t\tnewEdge.vert2 = b;\n\t\t\t\tnewEdge.tri1 = -1;\n\t\t\t\tnewEdge.tri2 = -1;\n\t\t\t\tbody.edges.push (newEdge);\n\t\t\t\tedgeIndex = body.edges.length - 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar edge = body.edges[edgeIndex];\n\t\t\tif (edge.tri1 != triangleIndex && edge.tri2 != triangleIndex) {\n\t\t\t\tif (edge.tri1 == -1) {\n\t\t\t\t\tedge.tri1 = triangleIndex;\n\t\t\t\t} else if (edge.tri2 == -1) {\n\t\t\t\t\tedge.tri2 = triangleIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn edgeIndex;\n\t\t}\n\n\t\tfunction AddTriangle (body, a, b, c)\n\t\t{\n\t\t\tvar triangleIndex = body.triangles.length;\n\t\t\tvar edge1 = AddEdge (body, triangleIndex, a, b);\n\t\t\tvar edge2 = AddEdge (body, triangleIndex, b, c);\n\t\t\tvar edge3 = AddEdge (body, triangleIndex, c, a);\n\t\t\t\n\t\t\tvar triangle = new Triangle ();\n\t\t\ttriangle.vertices = [a, b, c];\n\t\t\ttriangle.edges = [edge1, edge2, edge3];\n\t\t\ttriangle.valid = true;\n\t\t\tbody.triangles.push (triangle);\n\t\t\treturn body.triangles.length - 1;\n\t\t}\n\n\t\tfunction RemoveTriangleFromEdge (body, triangleIndex, edgeIndex)\n\t\t{\n\t\t\tvar edge = body.edges[edgeIndex];\n\t\t\tif (edge.tri1 == triangleIndex) {\n\t\t\t\tedge.tri1 = -1;\n\t\t\t} else if (edge.tri2 == triangleIndex) {\n\t\t\t\tedge.tri2 = -1;\n\t\t\t}\n\t\t}\n\n\t\tfunction RemoveTriangle (body, triangleIndex)\n\t\t{\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tif (!triangle.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[0]);\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[1]);\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[2]);\n\t\t\ttriangle.valid = false;\n\t\t}\n\n\t\tfunction GetTetrahedronVolume (body, a, b, c, d)\n\t\t{\n\t\t\tvar aCoord = body.vertices[a].position;\n\t\t\tvar bCoord = body.vertices[b].position;\n\t\t\tvar cCoord = body.vertices[c].position;\n\t\t\tvar dCoord = body.vertices[d].position;\n\t\t\t\n\t\t\tvar adSub = JSM.CoordSub (aCoord, dCoord);\n\t\t\tvar bdSub = JSM.CoordSub (bCoord, dCoord);\n\t\t\tvar cdSub = JSM.CoordSub (cCoord, dCoord);\n\t\t\t\n\t\t\treturn (JSM.VectorDot (adSub, JSM.VectorCross (bdSub, cdSub))) / 6.0;\n\t\t}\n\t\t\n\t\tfunction CheckTetrahedronOrientation (body, a, b, c, d)\n\t\t{\n\t\t\tif (JSM.IsLower (GetTetrahedronVolume (body, a, b, c, d), 0.0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddInitialTetrahedron (body)\n\t\t{\n\t\t\tvar triangleIndex = -1;\n\t\t\tif (CheckTetrahedronOrientation (body, 0, 1, 2, 3)) {\n\t\t\t\ttriangleIndex = AddTriangle (body, 0, 1, 2);\n\t\t\t} else {\n\t\t\t\ttriangleIndex = AddTriangle (body, 0, 2, 1);\n\t\t\t}\n\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tAddTriangle (body, triangle.vertices[0], triangle.vertices[2], 3);\n\t\t\tAddTriangle (body, triangle.vertices[2], triangle.vertices[1], 3);\n\t\t\tAddTriangle (body, triangle.vertices[1], triangle.vertices[0], 3);\n\t\t}\n\n\t\tfunction AddCoordToHull (body, index)\n\t\t{\n\t\t\tvar visibleTriangles = [];\n\t\t\t\n\t\t\tvar i, triangle;\n\t\t\tfor (i = 0; i < body.triangles.length; i++) {\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tvisibleTriangles.push (false);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (CheckTetrahedronOrientation (body, triangle.vertices[0], triangle.vertices[2], triangle.vertices[1], index)) {\n\t\t\t\t\tvisibleTriangles.push (true);\n\t\t\t\t} else {\n\t\t\t\t\tvisibleTriangles.push (false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar edge1, edge2, edge3, edge1Vis, edge2Vis, edge3Vis;\n\t\t\tvar newTriangles = [];\n\t\t\tfor (i = 0; i < visibleTriangles.length; i++) {\n\t\t\t\tif (!visibleTriangles[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tedge1 = body.edges[triangle.edges[0]];\n\t\t\t\tedge2 = body.edges[triangle.edges[1]];\n\t\t\t\tedge3 = body.edges[triangle.edges[2]];\n\n\t\t\t\tedge1Vis = (edge1.tri1 == -1 || edge1.tri2 == -1 || visibleTriangles[edge1.tri1] != visibleTriangles[edge1.tri2]);\n\t\t\t\tedge2Vis = (edge2.tri1 == -1 || edge2.tri2 == -1 || visibleTriangles[edge2.tri1] != visibleTriangles[edge2.tri2]);\n\t\t\t\tedge3Vis = (edge3.tri1 == -1 || edge3.tri2 == -1 || visibleTriangles[edge3.tri1] != visibleTriangles[edge3.tri2]);\n\t\t\t\t\n\t\t\t\tif (edge1Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[0], triangle.vertices[1], index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (edge2Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[1], triangle.vertices[2], index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (edge3Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[2], triangle.vertices[0], index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < visibleTriangles.length; i++) {\n\t\t\t\tif (!visibleTriangles[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRemoveTriangle (body, i);\n\t\t\t}\n\t\t\t\n\t\t\tvar newTriangle;\n\t\t\tfor (i = 0; i < newTriangles.length; i++) {\n\t\t\t\tnewTriangle = newTriangles[i];\n\t\t\t\tAddTriangle (body, newTriangle[0], newTriangle[1], newTriangle[2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\tvar count = coords.length;\n\t\tif (count < 4) {\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = new Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tAddVertex (body, coords[i]);\n\t\t}\n\t\t\n\t\tAddInitialTetrahedron (body);\n\t\tfor (i = 4; i < count; i++) {\n\t\t\tAddCoordToHull (body, i);\n\t\t}\n\t\t\n\t\tvar triangle;\n\t\tfor (i = 0; i < body.triangles.length; i++) {\n\t\t\ttriangle = body.triangles[i];\n\t\t\tif (triangle.valid) {\n\t\t\t\tresult.push (triangle.vertices);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/polygon2d',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Complexity\n\t* Description: Complexity of a polygon.\n\t* Values:\n\t*\t{Invalid} invalid polygon\n\t*\t{Convex} convex polygon\n\t*\t{Concave} concave polygon\n\t*\t{Complex} complex polygon (contains holes)\n\t*/\n\tJSM.Complexity = {\n\t\tInvalid : 0,\n\t\tConvex : 1,\n\t\tConcave : 2,\n\t\tComplex : 3\n\t};\n\n\t/**\n\t* Enum: CoordPolygonPosition2D\n\t* Description: Position of a coordinate and a polygon.\n\t* Values:\n\t*\t{OnVertex} coordinate lies on a vertex of the polygon\n\t*\t{OnEdge} coordinate lies on an edge of the polygon\n\t*\t{Inside} coordinate lies inside the polygon\n\t*\t{Outside} coordinate lies outside of the polygon\n\t*/\n\tJSM.CoordPolygonPosition2D = {\n\t\tOnVertex : 0,\n\t\tOnEdge : 1,\n\t\tInside : 2,\n\t\tOutside : 3\n\t};\n\n\t/**\n\t* Enum: SectorPolygonPosition2D\n\t* Description: Position of a sector and a polygon.\n\t* Values:\n\t*\t{IntersectionOnePoint} sector intersects polygon\n\t*\t{IntersectionCoincident} sector lies on an edge of the polygon\n\t*\t{IntersectionOnVertex} sector intersects polygon on a vertex\n\t*\t{NoIntersection} sector does not intersect polygon\n\t*/\n\tJSM.SectorPolygonPosition2D = {\n\t\tIntersectionOnePoint : 0,\n\t\tIntersectionCoincident : 1,\n\t\tIntersectionOnVertex : 2,\n\t\tNoIntersection : 3\n\t};\n\n\t/**\n\t* Class: Polygon2D\n\t* Description: Represents a 2D polygon.\n\t*/\n\tJSM.Polygon2D = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord2D (x, y));\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.Polygon2D.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon2D.RemoveVertex\n\t* Description: Removes a vertex from the polygon.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.RemoveVertex = function (index)\n\t{\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Polygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon2D.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon2D.EnumerateVertices\n\t* Description:\n\t*\tEnumerates the vertices of the polygon, and calls\n\t*\ta function for each vertex.\n\t* Parameters:\n\t*\tfrom {integer} the start vertex index\n\t*\tto {integer} the end vertex index\n\t*\tcallback {function} the callback function\n\t*/\n\tJSM.Polygon2D.prototype.EnumerateVertices = function (from, to, callback)\n\t{\n\t\tvar count = this.vertices.length;\n\t\tvar index = from;\n\t\tcallback (index);\n\t\twhile (index != to) {\n\t\t\tindex = (index + 1) % count;\n\t\t\tcallback (index);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.ShiftVertices\n\t* Description: Shifts polygon vertices.\n\t* Parameters:\n\t*\tcount {integer} the number of shifts\n\t*/\n\tJSM.Polygon2D.prototype.ShiftVertices = function (count)\n\t{\n\t\tJSM.ShiftArray (this.vertices, count);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub2D (prev, curr);\n\t\tvar nextDir = JSM.CoordSub2D (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tif (this.cache.signedArea !== null) {\n\t\t\treturn this.cache.signedArea;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tvar result = 0.0;\n\t\tif (count >= 3) {\n\t\t\tvar i, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = this.vertices[i];\n\t\t\t\tnext = this.vertices[(i + 1) % count];\n\t\t\t\tresult += current.x * next.y - next.x * current.y;\n\t\t\t}\n\t\t\tresult *= 0.5;\n\t\t}\n\t\t\n\t\tthis.cache.signedArea = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.cache.orientation !== null) {\n\t\t\treturn this.cache.orientation;\n\t\t}\n\n\t\tvar result = JSM.Orientation.Invalid;\n\t\tif (this.vertices.length >= 3) {\n\t\t\tvar signedArea = this.GetSignedArea ();\n\t\t\tif (JSM.IsPositive (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.CounterClockwise;\n\t\t\t} else if (JSM.IsNegative (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.Clockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.orientation = result;\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Polygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.cache.complexity !== null) {\n\t\t\treturn this.cache.complexity;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tif (count < 3) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\t\n\t\tvar result = JSM.Complexity.Invalid;\n\t\tvar polygonOrientain = this.GetOrientation ();\n\t\tif (polygonOrientain != JSM.Orientation.Invalid) {\n\t\t\tresult = JSM.Complexity.Convex;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (this.IsConcaveVertex (i)) {\n\t\t\t\t\tresult = JSM.Complexity.Concave;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.complexity = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexOrientation\n\t* Description: Calculates the orientation of the given vertex of the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexOrientation = function (index)\n\t{\n\t\tif (this.cache.vertexOrientations[index] !== undefined) {\n\t\t\treturn this.cache.vertexOrientations[index];\n\t\t}\n\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\t\n\t\tvar result = JSM.CoordOrientation2D (prev, curr, next);\n\t\tthis.cache.vertexOrientations[index] = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConvexVertex\n\t* Description: Returns if the given vertex is convex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConvexVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation == orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConcaveVertex\n\t* Description: Returns if the given vertex is concave.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConcaveVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation != orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.CoordPosition\n\t* Description: Calculates the position of a coordinate and the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordPolygonPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tfunction IntersectionCount (coord, beg, end)\n\t\t{\n\t\t\tfunction GetIntersection (coord, beg, end)\n\t\t\t{\n\t\t\t\tvar result = new JSM.Coord2D (beg.x, coord.y);\n\t\t\t\tif (!JSM.IsEqual (beg.y, coord.y)) {\n\t\t\t\t\tvar yMoveRatio = Math.abs ((beg.y - coord.y) / (end.y - beg.y));\n\t\t\t\t\tresult.x = beg.x + (end.x - beg.x) * yMoveRatio;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tvar begYDist = beg.y - coord.y;\n\t\t\tvar endYDist = end.y - coord.y;\n\t\t\t\n\t\t\tvar begBelow = JSM.IsNegative (begYDist);\n\t\t\tvar begAbove = JSM.IsPositive (begYDist);\n\t\t\tvar endBelow = JSM.IsNegative (endYDist);\n\t\t\tvar endAbove = JSM.IsPositive (endYDist);\n\t\t\tif ((begBelow && endBelow) || (begAbove && endAbove)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar begOnLine = !begBelow && !begAbove;\n\t\t\tvar endOnLine = !endBelow && !endAbove;\n\t\t\tif (begOnLine && endOnLine) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar intersection = GetIntersection (coord, beg, end);\n\t\t\tif (JSM.IsLower (intersection.x, coord.x)) {\n\t\t\t\treturn 0;\n\t\t\t} else if (JSM.IsGreater (intersection.x, coord.x)) {\n\t\t\t\tif (begOnLine || endOnLine) {\n\t\t\t\t\tvar upwardEdge = JSM.IsGreater (end.y, beg.y);\n\t\t\t\t\tif (begOnLine && upwardEdge || endOnLine && !upwardEdge) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tvar vertexCount = this.vertices.length;\n\t\tvar intersections = 0;\n\t\tvar i, edgeFrom, edgeTo, sector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeFrom = this.vertices[i];\n\t\t\tedgeTo = this.vertices[(i + 1) % vertexCount];\n\t\t\tsector = new JSM.Sector2D (edgeFrom, edgeTo);\n\t\t\tposition = sector.CoordPosition (coord);\n\t\t\tif (position == JSM.CoordSectorPosition2D.CoordInsideOfSector) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnEdge;\n\t\t\t} else if (position == JSM.CoordSectorPosition2D.CoordOnSectorEndCoord) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnVertex;\n\t\t\t}\n\t\t\tintersections += IntersectionCount (coord, edgeFrom, edgeTo);\n\t\t}\n\t\t\n\t\tif (intersections % 2 !== 0) {\n\t\t\treturn JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\treturn JSM.CoordPolygonPosition2D.Outside;\n\t};\n\n\t/**\n\t* Function: Polygon2D.SectorPosition\n\t* Description:\n\t*\tCalculates the position of a sector and the polygon. The given begin and end\n\t*\tvertex indices are omitted form intersection checking.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tbegIndex {integer} begin vertex index\n\t*\tendIndex {integer} end vertex index\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.SectorPosition = function (sector, begIndex, endIndex)\n\t{\n\t\tvar result = JSM.SectorPolygonPosition2D.NoIntersection;\n\t\tvar vertexCount = this.vertices.length;\n\t\tif (vertexCount < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar i, edgeBegIndex, edgeEndIndex, edgeBeg, edgeEnd;\n\t\tvar currentSector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeBegIndex = i;\n\t\t\tedgeEndIndex = (i + 1) % vertexCount;\n\t\t\tedgeBeg = this.vertices[edgeBegIndex];\n\t\t\tedgeEnd = this.vertices[edgeEndIndex];\n\t\t\tif (edgeBegIndex == begIndex || edgeEndIndex == begIndex || edgeBegIndex == endIndex || edgeEndIndex == endIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentSector = new JSM.Sector2D (edgeBeg, edgeEnd);\n\t\t\tposition = sector.SectorPosition (currentSector);\n\t\t\tif (position == JSM.SectorSectorPosition2D.SectorsIntersectOnePoint) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionOnePoint;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectCoincident) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionCoincident;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectEndPoint) {\n\t\t\t\tresult = JSM.SectorPolygonPosition2D.IntersectionOnVertex;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsDiagonal\n\t* Description: Returns if the sector between two vertices is diagonal.\n\t* Parameters:\n\t*\tfrom {integer} begin vertex index\n\t*\tto {integer} end vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsDiagonal = function (from, to)\n\t{\n\t\tfunction DiagonalIntersectsAnyEdges (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar sector = new JSM.Sector2D (fromVertex, toVertex);\n\t\t\tvar position = polygon.SectorPosition (sector, from, to);\n\t\t\tif (position != JSM.SectorPolygonPosition2D.NoIntersection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction DiagonalInsideOfPolygon (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar midCoord = new JSM.Coord2D (\n\t\t\t\t(fromVertex.x + toVertex.x) / 2.0,\n\t\t\t\t(fromVertex.y + toVertex.y) / 2.0\n\t\t\t);\n\t\t\tvar position = polygon.CoordPosition (midCoord);\n\t\t\treturn position == JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\t\n\t\tif (from == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.GetPrevVertex (from) == to || this.GetNextVertex (from) == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar fromVertex = this.vertices[from];\n\t\tvar toVertex = this.vertices[to];\n\t\tif (fromVertex.IsEqual (toVertex)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (DiagonalIntersectsAnyEdges (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!DiagonalInsideOfPolygon (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Polygon2D.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.Polygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon2D.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.Polygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t};\n\n\t/**\n\t * Function: Polygon2D.GetBoundingBox\n\t * Description: Calculates the bounding box of the polygon.\n\t * Returns:\n\t *\t{Box2D} the result\n\t */\n\tJSM.Polygon2D.prototype.GetBoundingBox = function ()\n\t{\n\t\tif (this.cache.boundingBox !== null) {\n\t\t\treturn this.cache.boundingBox;\n\t\t}\n\n\t\tvar result = new JSM.Box2D (\n\t\t\tnew JSM.Coord2D (JSM.Inf, JSM.Inf),\n\t\t\tnew JSM.Coord2D (-JSM.Inf, -JSM.Inf)\n\t\t);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tresult.min.x = JSM.Minimum (result.min.x, coord.x);\n\t\t\tresult.min.y = JSM.Minimum (result.min.y, coord.y);\n\t\t\tresult.max.x = JSM.Maximum (result.max.x, coord.x);\n\t\t\tresult.max.y = JSM.Maximum (result.max.y, coord.y);\n\t\t}\n\n\t\tthis.cache.boundingBox = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon2D.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tsignedArea : null,\n\t\t\torientation : null,\n\t\t\tvertexOrientations : {},\n\t\t\tcomplexity : null,\n\t\t\tboundingBox : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon2D} a cloned instance\n\t*/\n\tJSM.Polygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon2D\n\t* Description: Represents a 2D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon2D = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.lastContour.AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertex = function (contourIndex, x, y)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.ContourPolygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tthis.contours[i].ReverseVertices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon2D} the new contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon2D ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon2D} the contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContour = function (index)\n\t{\n\t\treturn this.contours[index];\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tvar area = 0.0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tarea += this.contours[i].GetSignedArea ();\n\t\t}\n\t\treturn area;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar orientation = this.contours[0].GetOrientation ();\n\t\tif (this.contours.length == 1) {\n\t\t\treturn orientation;\n\t\t}\n\t\tif (orientation == JSM.Orientation.Invalid) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar i, contourOrientation;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourOrientation = this.contours[i].GetOrientation ();\n\t\t\tif (contourOrientation == JSM.Orientation.Invalid) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t\tif (orientation == contourOrientation) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\tif (this.contours.length == 1) {\n\t\t\treturn this.contours[0].GetComplexity ();\n\t\t}\n\t\tvar i, contourComplexity;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourComplexity = this.contours[i].GetComplexity ();\n\t\t\tif (contourComplexity == JSM.Complexity.Invalid) {\n\t\t\t\treturn JSM.Complexity.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn JSM.Complexity.Complex;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} a cloned instance\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/polygon',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Polygon\n\t* Description: Represents a 3D polygon.\n\t*/\n\tJSM.Polygon = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.Polygon.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord (x, y, z));\n\t};\n\n\t/**\n\t* Function: Polygon.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord} the vertex\n\t*/\n\tJSM.Polygon.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub (prev, curr);\n\t\tvar nextDir = JSM.CoordSub (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon.GetNormal\n\t* Description: Calculates the normal vector of the polygon.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Polygon.prototype.GetNormal = function ()\n\t{\n\t\tif (this.cache.normal !== null) {\n\t\t\treturn this.cache.normal;\n\t\t}\n\t\tvar result = JSM.CalculateNormal (this.vertices);\n\t\tthis.cache.normal = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon.ToPolygon2D\n\t* Description: Converts the polygon to a 2D polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.Polygon.prototype.ToPolygon2D = function ()\n\t{\n\t\tvar normal = this.GetNormal ();\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i].ToCoord2D (normal);\n\t\t\tresult.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.Polygon.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord[*]} the array of vertices\n\t*/\n\tJSM.Polygon.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tnormal : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon} a cloned instance\n\t*/\n\tJSM.Polygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon\n\t* Description: Represents a 3D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.lastContour.AddVertex (x, y, z);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.ContourPolygon.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.AddContourVertex = function (contourIndex, x, y, z)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y, z);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.ContourPolygon.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon} the new contour\n\t*/\n\tJSM.ContourPolygon.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon} the result\n\t*/\n\tJSM.ContourPolygon.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord} the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon} the contour\n\t*/\n\tJSM.ContourPolygon.prototype.GetContour = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex];\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ToContourPolygon2D\n\t* Description: Converts the polygon to a 2D polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} the result\n\t*/\n\tJSM.ContourPolygon.prototype.ToContourPolygon2D = function ()\n\t{\n\t\tvar normal = this.contours[0].GetNormal ();\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tresult.AddContour ();\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tresult.AddVertexCoord (vertex.ToCoord2D (normal));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.ContourPolygon.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon} a cloned instance\n\t*/\n\tJSM.ContourPolygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\n\t};\n\n\t/**\n\t* Function: OffsetPolygonContour\n\t* Description: Offsets all vertices of a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\twidth {number} the width of the offset\n\t* Returns:\n\t*\t{Polygon} the result\n\t*/\n\tJSM.OffsetPolygonContour = function (polygon, width)\n\t{\n\t\tvar count = polygon.VertexCount ();\n\t\tvar normal = polygon.GetNormal ();\n\n\t\tvar prev, curr, next;\n\t\tvar prevVertex, currVertex, nextVertex;\n\t\tvar prevDir, nextDir;\n\t\tvar distance, offsetedCoord;\n\t\t\n\t\tvar result = new JSM.Polygon ();\n\t\t\n\t\tvar i, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = polygon.GetPrevVertex (i);\n\t\t\tcurr = i;\n\t\t\tnext = polygon.GetNextVertex (i);\n\t\t\t\n\t\t\tprevVertex = polygon.GetVertex (prev);\n\t\t\tcurrVertex = polygon.GetVertex (curr);\n\t\t\tnextVertex = polygon.GetVertex (next);\n\n\t\t\tprevDir = JSM.CoordSub (prevVertex, currVertex);\n\t\t\tnextDir = JSM.CoordSub (nextVertex, currVertex);\n\t\t\tangle = prevDir.AngleTo (nextDir) / 2.0;\n\t\t\tif (JSM.CoordOrientation (prevVertex, currVertex, nextVertex, normal) == JSM.Orientation.Clockwise) {\n\t\t\t\tangle = Math.PI - angle;\n\t\t\t}\n\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\toffsetedCoord = currVertex.Clone ();\n\t\t\toffsetedCoord.Offset (nextDir, distance);\n\t\t\toffsetedCoord.Rotate (normal, angle, currVertex);\n\t\t\tresult.AddVertex (offsetedCoord.x, offsetedCoord.y, offsetedCoord.z);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/cutpolygon',[\"../core/jsm\"],function(JSM){\n\tJSM.CutVertexType = {\n\t\tLeft : 1,\n\t\tRight : 2,\n\t\tCut : 3\n\t};\n\n\tJSM.PolygonCutter = function (geometryInterface)\n\t{\n\t\tthis.geometryInterface = geometryInterface;\n\t\tthis.Reset ();\n\t};\n\n\tJSM.PolygonCutter.prototype.Cut = function (polygon, aSidePolygons, bSidePolygons, cutPolygons)\n\t{\n\t\tthis.Reset ();\n\t\t\n\t\tvar allVertexType = this.CalculateOriginalPolygonData (polygon);\n\t\tif (allVertexType !== null) {\n\t\t\tvar cloned = polygon.Clone ();\n\t\t\tif (allVertexType == JSM.CutVertexType.Left) {\n\t\t\t\taSidePolygons.push (cloned);\n\t\t\t} else if (allVertexType == JSM.CutVertexType.Right) {\n\t\t\t\tbSidePolygons.push (cloned);\n\t\t\t} else {\n\t\t\t\tcutPolygons.push (cloned);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCutPolygonData ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateEntryVertices ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCuttedPolygons (aSidePolygons, bSidePolygons)) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.Reset = function ()\n\t{\n\t\tthis.originalPolygon = null;\n\t\tthis.originalPolygonVertexTypes = null;\n\t\tthis.cutPolygon = null;\n\t\tthis.cutPolygonVertexTypes = null;\n\t\tthis.cutPolygonVertexDistances = null;\n\t\tthis.cutVertexIndices = null;\n\t\tthis.entryVertices = null;\n\t\tthis.entryVertexTypes = null;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateOriginalPolygonData = function (polygon)\n\t{\n\t\tthis.originalPolygon = polygon;\n\t\tthis.originalPolygonVertexTypes = [];\n\t\tvar aSideFound = false;\n\t\tvar bSideFound = false;\n\t\t\n\t\tvar i, vertex, type;\n\t\tfor (i = 0; i < this.originalPolygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\ttype = this.geometryInterface.getVertexSide (vertex);\n\t\t\tif (type == JSM.CutVertexType.Left) {\n\t\t\t\taSideFound = true;\n\t\t\t} else if (type == JSM.CutVertexType.Right) {\n\t\t\t\tbSideFound = true;\n\t\t\t}\n\t\t\tthis.originalPolygonVertexTypes.push (type);\n\t\t}\n\t\t\n\t\tif (aSideFound && bSideFound) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (aSideFound) {\n\t\t\treturn JSM.CutVertexType.Left;\n\t\t} else if (bSideFound) {\n\t\t\treturn JSM.CutVertexType.Right;\n\t\t}\n\t\t\n\t\treturn JSM.CutVertexType.Cut;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCutPolygonData = function ()\n\t{\n\t\tfunction IsIntersectionVertex (cutPolygonVertexTypes, originalType)\n\t\t{\n\t\t\tif (cutPolygonVertexTypes.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar prevType = cutPolygonVertexTypes[cutPolygonVertexTypes.length - 1];\n\t\t\tif (prevType == JSM.CutVertexType.Cut || originalType == JSM.CutVertexType.Cut) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn prevType != originalType;\n\t\t}\n\t\t\n\t\tfunction AddCutVertexToPolygon (polygonCutter, vertex, type)\n\t\t{\n\t\t\tpolygonCutter.cutPolygon.AddVertexCoord (vertex);\n\t\t\tpolygonCutter.cutPolygonVertexTypes.push (type);\n\t\t\tif (type == JSM.CutVertexType.Cut) {\n\t\t\t\tpolygonCutter.cutVertexIndices.push (polygonCutter.cutPolygonVertexTypes.length - 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddIntersectionVertex (polygonCutter, originalIndex)\n\t\t{\n\t\t\tvar prevIndex = polygonCutter.originalPolygon.GetPrevVertex (originalIndex);\n\t\t\tvar prevVertex = polygonCutter.originalPolygon.GetVertex (prevIndex);\n\t\t\tvar currVertex = polygonCutter.originalPolygon.GetVertex (originalIndex);\n\t\t\tvar intersection = polygonCutter.geometryInterface.getIntersectionVertex (prevVertex, currVertex);\n\t\t\tif (intersection === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tAddCutVertexToPolygon (polygonCutter, intersection, JSM.CutVertexType.Cut);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddOriginalVertex (polygonCutter, originalIndex, originalType)\n\t\t{\n\t\t\tvar vertex = polygonCutter.originalPolygon.GetVertex (originalIndex).Clone ();\n\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\n\t\t\tvar vertexCount = polygonCutter.originalPolygon.VertexCount ();\n\t\t\tvar prevType = polygonCutter.originalPolygonVertexTypes[JSM.PrevIndex (originalIndex, vertexCount)];\n\t\t\tvar nextType = polygonCutter.originalPolygonVertexTypes[JSM.NextIndex (originalIndex, vertexCount)];\n\t\t\tif (originalType == JSM.CutVertexType.Cut && prevType == nextType) {\n\t\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction SortCutVertices (cutPolygon, cutVertexIndices, cutPolygonVertexDistances)\n\t\t{\n\t\t\tif (cutVertexIndices.length < 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tJSM.BubbleSort (cutVertexIndices,\n\t\t\t\tfunction (a, b) {\n\t\t\t\t\tvar aDist = cutPolygonVertexDistances[a];\n\t\t\t\t\tvar bDist = cutPolygonVertexDistances[b];\n\t\t\t\t\treturn JSM.IsLower (aDist, bDist);\n\t\t\t\t},\n\t\t\t\tfunction (i, j) {\n\t\t\t\t\tJSM.SwapArrayValues (cutVertexIndices, i, j);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\treturn true;\n\t\t}\t\n\n\t\tthis.cutPolygon = this.geometryInterface.createPolygon ();\n\t\tthis.cutPolygonVertexTypes = [];\n\t\tthis.cutVertexIndices = [];\n\t\t\n\t\tvar vertexCount = this.originalPolygon.VertexCount ();\n\t\tvar i, lastVertex, originalIndex, originalType;\n\t\tfor (i = 0; i <= vertexCount; i++) {\n\t\t\tlastVertex = (i === vertexCount);\n\t\t\toriginalIndex = i;\n\t\t\tif (lastVertex) {\n\t\t\t\toriginalIndex = 0;\n\t\t\t}\n\t\t\t\n\t\t\toriginalType = this.originalPolygonVertexTypes[originalIndex];\n\t\t\tif (IsIntersectionVertex (this.cutPolygonVertexTypes, originalType)) {\n\t\t\t\tAddIntersectionVertex (this, originalIndex);\n\t\t\t}\n\t\t\t\n\t\t\tif (!lastVertex) {\n\t\t\t\tAddOriginalVertex (this, originalIndex, originalType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cutPolygonVertexDistances = this.geometryInterface.getVertexDistances (this.cutPolygon);\n\t\tif (!SortCutVertices (this.cutPolygon, this.cutVertexIndices, this.cutPolygonVertexDistances)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateEntryVertices = function ()\n\t{\n\t\tfunction GetEntryVertexType (cutPolygonVertexTypes, cutPolygonVertexDistances, currIndex)\n\t\t{\n\t\t\tvar currSideType = cutPolygonVertexTypes[currIndex];\n\t\t\tif (currSideType != JSM.CutVertexType.Cut) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tvar prevIndex = JSM.PrevIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar nextIndex = JSM.NextIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar prevSideType = cutPolygonVertexTypes[prevIndex];\n\t\t\tvar nextSideType = cutPolygonVertexTypes[nextIndex];\n\n\t\t\tvar currVertexDistance = cutPolygonVertexDistances[currIndex];\n\t\t\tvar prevVertexDistance = cutPolygonVertexDistances[prevIndex];\n\t\t\tvar nextVertexDistance = cutPolygonVertexDistances[nextIndex];\n\t\t\t\n\t\t\tif (prevSideType == JSM.CutVertexType.Right) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Left) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Cut) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\n\t\tthis.entryVertices = [];\n\t\tthis.entryVertexTypes = [];\n\t\tvar i, vertexIndex, vertexType;\n\t\tfor (i = 0; i < this.cutVertexIndices.length; i++) {\n\t\t\tvertexIndex = this.cutVertexIndices[i];\n\t\t\tvertexType = GetEntryVertexType (this.cutPolygonVertexTypes, this.cutPolygonVertexDistances, vertexIndex);\n\t\t\tif (vertexType !== 0) {\n\t\t\t\tthis.entryVertices.push (vertexIndex);\n\t\t\t\tthis.entryVertexTypes.push (vertexType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.entryVertices.length === 0 || this.entryVertices.length % 2 !== 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCuttedPolygons = function (aSidePolygons, bSidePolygons)\n\t{\n\t\tfunction AddOneSideCuttedPolygons (polygonCutter, aSidePolygons, bSidePolygons, reversed)\n\t\t{\n\t\t\tfunction AddEntryPairToArray (entryPairs, entryVertices, fromIndex, toIndex)\n\t\t\t{\n\t\t\t\tentryPairs[entryVertices[fromIndex]] = entryVertices[toIndex];\n\t\t\t\tentryPairs[entryVertices[toIndex]] = entryVertices[fromIndex];\n\t\t\t}\n\n\t\t\tfunction RemoveEntryPairFromArray (entryPairs, index)\n\t\t\t{\n\t\t\t\tentryPairs[entryPairs[index]] = -1;\n\t\t\t\tentryPairs[index] = -1;\n\t\t\t}\n\n\t\t\tfunction CreateEntryPairsArray (cutPolygon, entryVertices, entryVertexTypes)\n\t\t\t{\n\t\t\t\tfunction FindPairIndex (entryPairs, entryVertices, entryVertexTypes, startIndex)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = startIndex + 1; i < entryVertices.length; i++) {\n\t\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entryVertexTypes[startIndex] != entryVertexTypes[i]) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tvar entryPairs = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < cutPolygon.VertexCount (); i++) {\n\t\t\t\t\tentryPairs.push (-1);\n\t\t\t\t}\n\n\t\t\t\tvar pairIndex;\n\t\t\t\tfor (i = 0; i < entryVertices.length; i++) {\n\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpairIndex = FindPairIndex (entryPairs, entryVertices, entryVertexTypes, i);\n\t\t\t\t\tif (pairIndex == -1) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tAddEntryPairToArray (entryPairs, entryVertices, i, pairIndex);\n\t\t\t\t}\n\t\t\t\treturn entryPairs;\n\t\t\t}\n\t\t\t\n\t\t\tfunction GetNextVertex (currVertexIndex, cutPolygon, entryPairs)\n\t\t\t{\n\t\t\t\tif (entryPairs[currVertexIndex] != -1) {\n\t\t\t\t\tvar nextVertex = entryPairs[currVertexIndex];\n\t\t\t\t\tRemoveEntryPairFromArray (entryPairs, currVertexIndex);\n\t\t\t\t\treturn nextVertex;\n\t\t\t\t} else {\n\t\t\t\t\treturn JSM.NextIndex (currVertexIndex, cutPolygon.VertexCount ());\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tfunction AddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons)\n\t\t\t{\n\t\t\t\tfunction AddVertexIfNotDuplicated (polygon, vertex)\n\t\t\t\t{\n\t\t\t\t\tvar vertexCount = polygon.VertexCount ();\n\t\t\t\t\tif (vertexCount > 0 && polygon.GetVertex (vertexCount - 1).IsEqual (vertex)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpolygon.AddVertexCoord (vertex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar startVertexIndex = polygonCutter.entryVertices[currEntryVertex];\n\t\t\t\tif (entryPairs[startVertexIndex] !== -1) {\n\t\t\t\t\tvar currPolygon = polygonCutter.geometryInterface.createPolygon ();\n\t\t\t\t\tcurrPolygon.AddVertexCoord (polygonCutter.cutPolygon.GetVertex (startVertexIndex).Clone ());\n\t\t\t\t\tvar currVertexIndex = GetNextVertex (startVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\tvar polygonSide = null;\n\t\t\t\t\twhile (currVertexIndex != startVertexIndex) {\n\t\t\t\t\t\tif (polygonSide === null) {\n\t\t\t\t\t\t\tif (polygonCutter.cutPolygonVertexTypes[currVertexIndex] !== JSM.CutVertexType.Cut) {\n\t\t\t\t\t\t\t\tpolygonSide = polygonCutter.cutPolygonVertexTypes[currVertexIndex];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAddVertexIfNotDuplicated (currPolygon, polygonCutter.cutPolygon.GetVertex (currVertexIndex).Clone ());\n\t\t\t\t\t\tcurrVertexIndex = GetNextVertex (currVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\t}\n\t\t\t\t\tif (currPolygon.VertexCount () > 2) {\n\t\t\t\t\t\tif (polygonSide == JSM.CutVertexType.Left) {\n\t\t\t\t\t\t\taSidePolygons.push (currPolygon);\n\t\t\t\t\t\t} else if (polygonSide == JSM.CutVertexType.Right) {\n\t\t\t\t\t\t\tbSidePolygons.push (currPolygon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPairs = CreateEntryPairsArray (polygonCutter.cutPolygon, polygonCutter.entryVertices, polygonCutter.entryVertexTypes);\n\t\t\tif (entryPairs === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currEntryVertex = reversed ? polygonCutter.entryVertices.length - 1 : 0;\n\t\t\twhile (currEntryVertex >= 0 && currEntryVertex < polygonCutter.entryVertices.length) {\n\t\t\t\tAddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons);\n\t\t\t\tcurrEntryVertex = reversed ? currEntryVertex - 1 : currEntryVertex + 1;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, false)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, true)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CutPolygon2DWithLine\n\t* Description:\n\t*\tCuts a polygon with a line. The result array contains cutted\n\t*\tpolygons grouped by their position to the line.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tline {Line2D} the line\n\t*\tleftPolygons {Polygon2D[*]} (out) polygons on the left of the line\n\t*\trightPolygons {Polygon2D[*]} (out) polygons on the right of the line\n\t*\tcutPolygons {Polygon2D[*]} (out) polygons on the line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygon2DWithLine = function (polygon, line, leftPolygons, rightPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon2D ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = line.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordLinePosition2D.CoordAtLineLeft) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordLinePosition2D.CoordAtLineRight) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar edgeLine = new JSM.Line2D (currVertex, JSM.CoordSub2D (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lineLinePosition = line.LinePosition (edgeLine, intersection);\n\t\t\t\tif (lineLinePosition != JSM.LineLinePosition2D.LinesIntersectsOnePoint) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar origo = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar refLineStart = line.start.Clone ();\n\t\t\t\tvar refLineDir = line.direction.Clone ().Rotate (-Math.PI / 2.0, origo);\n\t\t\t\tvar refLine = new JSM.Line2D (refLineStart, refLineDir);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refLine.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, leftPolygons, rightPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: CutPolygonWithPlane\n\t* Description:\n\t*\tCuts a polygon with a plane. The result array contains cutted\n\t*\tpolygons grouped by their position to the plane.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tplane {Plane} the plane\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the plane\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the plane\n\t*\tcutPolygons {Polygon[*]} (out) polygons on the plane\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygonWithPlane = function (polygon, plane, frontPolygons, backPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = plane.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar line = new JSM.Line (currVertex, JSM.CoordSub (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tvar linePlanePosition = plane.LinePosition (line, intersection);\n\t\t\t\tif (linePlanePosition != JSM.LinePlanePosition.LineIntersectsPlane) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar polygonNormal = polygon.GetNormal ();\n\t\t\t\tvar planeNormal = new JSM.Vector (plane.a, plane.b, plane.c);\n\t\t\t\tvar refPlaneNormal = JSM.VectorCross (planeNormal, polygonNormal);\n\t\t\t\tvar refPlaneOrigin = polygon.GetVertex (0);\n\t\t\t\tvar refPlane = JSM.GetPlaneFromCoordAndDirection (refPlaneOrigin, refPlaneNormal);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refPlane.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, frontPolygons, backPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: SegmentPolygon2D\n\t* Description: Segments up a polygon along x and y axis.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\txSegments {integer} x segment number\n\t*\tySegments {integer} y segment number\n\t* Returns:\n\t*\t{Polygon[*]} result polygons\n\t*/\n\tJSM.SegmentPolygon2D = function (polygon, xSegments, ySegments)\n\t{\n\t\tfunction CutPolygonsOneDirection (inputPolygons, resultPolygons, segmentCount, segmentSize, startCoordinate, segmentDir, cutDir)\n\t\t{\n\t\t\tfunction CutPolygon (polygon, line, leftPolygons, rightPolygons)\n\t\t\t{\n\t\t\t\tvar left = [];\n\t\t\t\tvar right = [];\n\t\t\t\tvar cut = [];\n\t\t\t\tif (!JSM.CutPolygon2DWithLine (polygon, line, left, right, cut)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < left.length; i++) {\n\t\t\t\t\tleftPolygons.push (left[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < right.length; i++) {\n\t\t\t\t\trightPolygons.push (right[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar polygonsToProcess = inputPolygons;\n\t\t\tvar startCoord = startCoordinate.Clone ();\n\t\t\tvar i, j, line, newPolygonsToProcess;\n\t\t\tfor (i = 1; i < segmentCount; i++) {\n\t\t\t\tstartCoord.Offset (segmentDir, segmentSize);\n\t\t\t\tline = new JSM.Line2D (startCoord, cutDir);\n\t\t\t\tnewPolygonsToProcess = [];\n\t\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\t\tCutPolygon (polygonsToProcess[j], line, resultPolygons, newPolygonsToProcess);\n\t\t\t\t}\n\t\t\t\tpolygonsToProcess = newPolygonsToProcess;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\tresultPolygons.push (polygonsToProcess[j]);\n\t\t\t}\n\t\t}\n\n\t\tvar boundingBox = polygon.GetBoundingBox ();\n\t\tvar xSize = boundingBox.max.x - boundingBox.min.x;\n\t\tvar ySize = boundingBox.max.y - boundingBox.min.y;\n\t\tvar xSegmentSize = xSize / xSegments;\n\t\tvar ySegmentSize = ySize / ySegments;\n\n\t\tvar originalPolygons = [polygon];\n\t\tvar bottomLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.min.y);\n\t\tvar topLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.max.y);\n\n\t\tvar xCuttedPolygons = [];\n\t\tvar yCuttedPolygons = [];\n\t\tCutPolygonsOneDirection (originalPolygons, xCuttedPolygons, xSegments, xSegmentSize, bottomLeft, new JSM.Vector2D (1.0, 0.0), new JSM.Vector2D (0.0, 1.0));\n\t\tCutPolygonsOneDirection (xCuttedPolygons, yCuttedPolygons, ySegments, ySegmentSize, topLeft, new JSM.Vector2D (0.0, -1.0), new JSM.Vector2D (1.0, 0.0));\n\t\treturn yCuttedPolygons;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/triangulation',[\"../core/jsm\"],function(JSM){\n\tJSM.ConvertContourPolygonToPolygon2D = function (inputPolygon, vertexMap)\n\t{\n\t\tfunction AddResultVertex (resultPolygon, vertex, vertexMap, originalContour, originalVertex)\n\t\t{\n\t\t\tresultPolygon.AddVertexCoord (vertex);\n\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\tvertexMap.push ([originalContour, originalVertex]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)\n\t\t{\n\t\t\tfunction GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData)\n\t\t\t{\n\t\t\t\tfunction IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)\n\t\t\t\t{\n\t\t\t\t\tfunction SegmentIntersectsPolygon (polygon, segmentBeg, segmentEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sector = new JSM.Sector2D (segmentBeg, segmentEnd);\n\t\t\t\t\t\tvar position = polygon.SectorPosition (sector, -1, -1);\n\t\t\t\t\t\tif (position == JSM.SectorPolygonPosition2D.IntersectionOnePoint || position == JSM.SectorPolygonPosition2D.IntersectionCoincident) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SegmentIntersectsPolygon (resultPolygon, resultVertex, holeVertex)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i, hole;\n\t\t\t\t\tfor (i = 1; i < inputPolygon.ContourCount (); i++) {\n\t\t\t\t\t\tif (conversionData.addedHoles[i] !== undefined) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thole = inputPolygon.GetContour (i);\n\t\t\t\t\t\tif (SegmentIntersectsPolygon (hole, resultVertex, holeVertex)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction IsExistingEntryPosition (coord, conversionData)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < conversionData.entryPositions.length; i++) {\n\t\t\t\t\t\tif (coord.IsEqual (conversionData.entryPositions[i])) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar resultVertexIndex, holeVertexIndex, resultVertex, holeVertex;\n\t\t\t\tfor (resultVertexIndex = 0; resultVertexIndex < resultPolygon.VertexCount (); resultVertexIndex++) {\n\t\t\t\t\tfor (holeVertexIndex = 0; holeVertexIndex < holePolygon.VertexCount (); holeVertexIndex++) {\n\t\t\t\t\t\tresultVertex = resultPolygon.GetVertex (resultVertexIndex);\n\t\t\t\t\t\tholeVertex = holePolygon.GetVertex (holeVertexIndex);\n\t\t\t\t\t\tif (IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)) {\n\t\t\t\t\t\t\tif (IsExistingEntryPosition (resultVertex, conversionData) || IsExistingEntryPosition (holeVertex, conversionData)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconversionData.entryPositions.push (resultVertex.Clone ());\n\t\t\t\t\t\t\tconversionData.entryPositions.push (holeVertex.Clone ());\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tbeg : resultVertexIndex,\n\t\t\t\t\t\t\t\tend : holeVertexIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tfunction AddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap)\n\t\t\t{\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar mainContourBeg = entryPoint.beg;\n\t\t\t\tvar mainEntryVertex = resultPolygon.GetVertex (mainContourBeg).Clone ();\n\t\t\t\tresultPolygon.ShiftVertices (mainContourBeg + 1);\n\n\t\t\t\tvar mainEntryContourIndex = 0;\n\t\t\t\tvar mainEntryVertexIndex = 0;\n\t\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\t\tmainEntryContourIndex = vertexMap[mainContourBeg][0];\n\t\t\t\t\tmainEntryVertexIndex = vertexMap[mainContourBeg][1];\n\t\t\t\t\tJSM.ShiftArray (vertexMap, mainContourBeg + 1);\n\t\t\t\t}\n\n\t\t\t\tvar contourBeg = entryPoint.end;\n\t\t\t\tvar contourEnd = holePolygon.GetPrevVertex (contourBeg);\n\t\t\t\tholePolygon.EnumerateVertices (contourBeg, contourEnd, function (index) {\n\t\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (index).Clone (), vertexMap, holeIndex, index);\n\t\t\t\t});\n\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (contourBeg).Clone (), vertexMap, holeIndex, contourBeg);\n\t\t\t\tAddResultVertex (resultPolygon, mainEntryVertex, vertexMap, mainEntryContourIndex, mainEntryVertexIndex);\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPoint = GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData);\n\t\t\tif (entryPoint === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tvar contourCount = inputPolygon.ContourCount ();\n\t\tvar mainContour = inputPolygon.GetContour (0);\n\t\tvar resultPolygon = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < mainContour.VertexCount (); i++) {\n\t\t\tvertex = mainContour.GetVertex (i);\n\t\t\tAddResultVertex (resultPolygon, vertex.Clone (), vertexMap, 0, i);\n\t\t}\n\t\tif (contourCount == 1) {\n\t\t\treturn resultPolygon;\n\t\t}\n\t\t\n\t\tvar holeQueue = [];\n\t\tvar holeIndex;\n\t\tfor (holeIndex = 1; holeIndex < contourCount; holeIndex++) {\n\t\t\tholeQueue.push (holeIndex);\n\t\t}\n\t\t\n\t\tvar conversionData = {\n\t\t\taddedHoles : {},\n\t\t\tholeTryouts : {},\n\t\t\tentryPositions : []\n\t\t};\n\t\t\n\t\twhile (holeQueue.length > 0) {\n\t\t\tholeIndex = holeQueue.shift ();\n\t\t\tif (AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)) {\n\t\t\t\tconversionData.addedHoles[holeIndex] = true;\n\t\t\t} else {\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] === undefined) {\n\t\t\t\t\tconversionData.holeTryouts[holeIndex] = 0;\n\t\t\t\t}\n\t\t\t\tconversionData.holeTryouts[holeIndex] += 1;\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] > 10) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tholeQueue.push (holeIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn resultPolygon;\n\t};\n\n\tJSM.TriangulateConvexPolygon = function (polygon)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 1; i < polygon.VertexCount () - 1; i++) {\n\t\t\tresult.push ([0, i, i + 1]);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulateConcavePolygon2D = function (inputPolygon)\n\t{\n\t\tfunction GetInitialVertexMap (count)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tresult[i] = i;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction FindSplitDiagonal (polygon)\n\t\t{\n\t\t\tvar count = polygon.VertexCount ();\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (polygon.IsDiagonal (i, j)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tbeg : i,\n\t\t\t\t\t\t\tend : j\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction SplitPolygon (polygonData, diagonal)\n\t\t{\n\t\t\tfunction AddVertex (polygonData, resultData, index)\n\t\t\t{\n\t\t\t\tresultData.polygon.AddVertexCoord (polygonData.polygon.GetVertex (index));\n\t\t\t\tresultData.map.push (polygonData.map[index]);\n\t\t\t}\n\t\t\t\n\t\t\tvar resultData1 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\t\t\tvar resultData2 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\n\t\t\tvar beg, end;\n\t\t\t\n\t\t\tbeg = diagonal.beg;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.end);\n\t\t\tAddVertex (polygonData, resultData1, diagonal.end);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData1, index);\n\t\t\t});\n\n\t\t\tbeg = diagonal.end;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.beg);\n\t\t\tAddVertex (polygonData, resultData2, diagonal.beg);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData2, index);\n\t\t\t});\n\t\t\t\n\t\t\treturn {\n\t\t\t\tresultData1 : resultData1,\n\t\t\t\tresultData2 : resultData2\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar polygonStack = [];\n\t\tvar count = inputPolygon.VertexCount ();\n\t\tvar inputMap = GetInitialVertexMap (count);\n\t\tpolygonStack.push ({\n\t\t\tpolygon : inputPolygon,\n\t\t\tmap : inputMap\n\t\t});\n\t\t\n\t\tvar result = [];\n\t\tvar polygonData, vertexCount, diagonal, resultData;\n\t\twhile (polygonStack.length > 0) {\n\t\t\tpolygonData = polygonStack.pop ();\n\t\t\tvertexCount = polygonData.polygon.VertexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tresult.push (polygonData.map);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiagonal = FindSplitDiagonal (polygonData.polygon);\n\t\t\tif (diagonal === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresultData = SplitPolygon (polygonData, diagonal);\n\t\t\tpolygonStack.push (resultData.resultData1);\n\t\t\tpolygonStack.push (resultData.resultData2);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulatePolygon2D = function (polygon)\n\t{\n\t\tif (polygon === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar vertexCount = polygon.VertexCount ();\n\t\tif (vertexCount < 3) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (vertexCount == 3) {\n\t\t\treturn [[0, 1, 2]];\n\t\t}\n\t\t\n\t\tvar complexity = polygon.GetComplexity ();\n\t\tif (complexity === JSM.Complexity.Invalid) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (complexity == JSM.Complexity.Convex) {\n\t\t\treturn JSM.TriangulateConvexPolygon (polygon);\n\t\t}\n\t\t\n\t\treturn JSM.TriangulateConcavePolygon2D (polygon);\n\t};\n\n\t/**\n\t* Function: TriangulatePolygon\n\t* Description:\n\t*\tTriangulates a polygon. The result defines triangles as an\n\t*\tarray of arrays with three original vertex indices.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t* Returns:\n\t*\t{integer[3][*]} the result\n\t*/\n\tJSM.TriangulatePolygon = function (polygon)\n\t{\n\t\tvar polygon2D = polygon.ToPolygon2D ();\n\t\treturn JSM.TriangulatePolygon2D (polygon2D);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/octree',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: TraverseOctreeNodes\n\t* Description:\n\t*\tTraverses the nodes of the tree, and calls the given callback when a node found. The return value\n\t*\tof the callback determines if we need to continue traverse along that given node.\n\t* Parameters:\n\t*\toctree {Octree} the octree\n\t*\tnodeFound {function} the callback\n\t*/\n\tJSM.TraverseOctreeNodes = function (octree, nodeFound)\n\t{\n\t\tfunction TraverseNode (node, nodeFound)\n\t\t{\n\t\t\tif (!nodeFound (node)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (node.children === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, child;\n\t\t\tfor (i = 0; i < node.children.length; i++) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tTraverseNode (child, nodeFound);\n\t\t\t}\n\t\t}\n\n\t\tTraverseNode (octree.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: CreateOctreeChildNodes\n\t* Description:\n\t*\tCreate child nodes for an octree node. It calls a callback function\n\t*\twhich should create a new node element for the octree.\n\t* Parameters:\n\t*\toriginalBox {Box} the box of the original node\n\t*\tcreateNodeCallback {function} the callback function\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.CreateOctreeChildNodes = function (originalBox, createNodeCallback)\n\t{\n\t\tfunction CreateNode (originalBox, createNodeCallback, dirX, dirY, dirZ)\n\t\t{\n\t\t\tvar size = originalBox.GetSize ().Clone ();\n\t\t\tsize.MultiplyScalar (0.5);\n\t\t\tvar min = new JSM.Coord (\n\t\t\t\toriginalBox.min.x + dirX * size.x,\n\t\t\t\toriginalBox.min.y + dirY * size.y,\n\t\t\t\toriginalBox.min.z + dirZ * size.z\n\t\t\t);\n\t\t\tvar max = JSM.CoordAdd (min, size);\n\t\t\tvar box = new JSM.Box (min, max);\n\t\t\treturn createNodeCallback (box);\n\t\t}\n\n\t\tvar size = originalBox.GetSize ();\n\t\tif (JSM.IsZero (size.x) && JSM.IsZero (size.y) && JSM.IsZero (size.z)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar result = [\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 0.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 0.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 1.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 1.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 0.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 0.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 1.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 1.0, 1.0),\n\t\t];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: Octree\n\t* Description: Defines an octree. The octree contains each coordinate only once.\n\t* Parameters:\n\t*\tbox {Box} bounding box\n\t*\tmaxCoordNumInNodes {integer} maximum number of coordinates in a node\n\t*/\n\tJSM.Octree = function (box, maxCoordNumInNodes)\n\t{\n\t\tthis.coords = [];\n\t\tthis.root = this.CreateNewNode (null, box);\n\t\tthis.maxCoordNumInNodes = maxCoordNumInNodes;\n\t\tif (this.maxCoordNumInNodes === undefined || this.maxCoordNumInNodes === null || this.maxCoordNumInNodes === 0) {\n\t\t\tthis.maxCoordNumInNodes = 50;\n\t\t}\n\t};\n\n\t/**\n\t* Function: Octree.AddCoord\n\t* Description:\n\t*\tAdds a coordinate to the octree. The return value is the stored index of the coordinate.\n\t*\tIf the coordinate was already in the octree, it returns the existing index.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.AddCoord = function (coord)\n\t{\n\t\treturn this.AddCoordToNode (coord, this.root);\n\t};\n\n\t/**\n\t* Function: Octree.FindCoord\n\t* Description:\n\t*\tFinds a coordinate in the octree, and returns the stored index of it.\n\t*\tThe return value is -1 if the coordinate does not exist.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.FindCoord = function (coord)\n\t{\n\t\tvar node = this.FindNodeForCoord (coord, this.root);\n\t\tif (node === null) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this.FindCoordInNode (coord, node);\n\t};\n\n\t/**\n\t* Function: Octree.FindCoordInNode\n\t* Description: Finds a coordinate in a node.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnode {object} the node\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.FindCoordInNode = function (coord, node)\n\t{\n\t\tvar i, current;\n\t\tfor (i = 0; i < node.coords.length; i++) {\n\t\t\tcurrent = node.coords[i];\n\t\t\tif (coord.IsEqual (this.coords[current])) {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: Octree.AddCoordToNode\n\t* Description: Adds a coordinate to a node.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\troot {object} the root node\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.AddCoordToNode = function (coord, root)\n\t{\n\t\tvar node = this.FindNodeForCoord (coord, root);\n\t\tif (node === null) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tvar found = this.FindCoordInNode (coord, node);\n\t\tif (found != -1) {\t\n\t\t\treturn found;\n\t\t}\n\t\t\n\t\tif (node.coords.length >= this.maxCoordNumInNodes) {\n\t\t\tif (this.SplitNode (node)) {\n\t\t\t\treturn this.AddCoordToNode (coord, node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar index = this.coords.length;\n\t\tthis.coords.push (coord);\n\t\tnode.coords.push (index);\n\t\treturn index;\n\t};\n\n\t/**\n\t* Function: Octree.FindNodeForCoord\n\t* Description: Finds a node for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnode {object} the starting node\n\t* Returns:\n\t*\t{object} the found node\n\t*/\n\tJSM.Octree.prototype.FindNodeForCoord = function (coord, node)\n\t{\n\t\tif (node.children === null) {\n\t\t\treturn node;\n\t\t}\n\t\t\n\t\tvar center = node.box.GetCenter ();\n\t\tvar xGreater = coord.x > center.x;\n\t\tvar yGreater = coord.y > center.y;\n\t\tvar zGreater = coord.z > center.z;\n\t\t\n\t\tif (!xGreater && !yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[0]);\n\t\t} else if (xGreater && !yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[1]);\n\t\t} else if (xGreater && yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[2]);\n\t\t} else if (!xGreater && yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[3]);\n\t\t} else if (!xGreater && !yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[4]);\n\t\t} else if (xGreater && !yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[5]);\n\t\t} else if (xGreater && yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[6]);\n\t\t} else if (!xGreater && yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[7]);\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\n\t/**\n\t* Function: Octree.SplitNode\n\t* Description: Splits a node to subnodes.\n\t* Parameters:\n\t*\tnode {object} the node\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.Octree.prototype.SplitNode = function (node)\n\t{\n\t\tvar myThis = this;\n\t\tvar children = JSM.CreateOctreeChildNodes (node.box, function (nodeBox) {\n\t\t\treturn myThis.CreateNewNode (node, nodeBox);\n\t\t});\n\t\t\n\t\tif (children === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tnode.children = children;\n\t\tvar nodeCoords = node.coords;\n\t\tnode.coords = [];\n\t\t\n\t\tvar i, newNode;\n\t\tfor (i = 0; i < nodeCoords.length; i++) {\n\t\t\tnewNode = this.FindNodeForCoord (this.coords[nodeCoords[i]], node);\n\t\t\tnewNode.coords.push (nodeCoords[i]);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Octree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Parameters:\n\t*\tparent {object} the parent node\n\t*\tbox {Box} the box of the node\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.Octree.prototype.CreateNewNode = function (parent, box)\n\t{\n\t\tvar newNode = {\n\t\t\tparent : parent,\n\t\t\tbox : box,\n\t\t\tcoords : [],\n\t\t\tchildren : null\n\t\t};\n\t\treturn newNode;\t\n\t};\n\n\t/**\n\t* Class: TriangleOctree\n\t* Description:\n\t*\tDefines an octree which stores triangles. Every triangle is placed in\n\t*\tthe smallest possible node which contains all of its vertices.\n\t* Parameters:\n\t*\tbox {Box} bounding box\n\t*/\n\tJSM.TriangleOctree = function (box)\n\t{\n\t\tthis.root = this.CreateNewNode (null, box);\n\t};\n\n\t/**\n\t* Function: TriangleOctree.AddTriangle\n\t* Description: Adds a triangle to the octree.\n\t* Parameters:\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t*\tuserData {anything} user data for the triangle\n\t*/\n\tJSM.TriangleOctree.prototype.AddTriangle = function (v0, v1, v2, userData)\n\t{\n\t\treturn this.AddTriangleToNode (v0, v1, v2, this.root, userData);\n\t};\n\n\t/**\n\t* Function: TriangleOctree.AddTriangleToNode\n\t* Description: Adds a coordinate to a node.\n\t* Parameters:\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t*\troot {object} the root node\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.TriangleOctree.prototype.AddTriangleToNode = function (v0, v1, v2, root, userData)\n\t{\n\t\tfunction IsTriangleInNode (v0, v1, v2, node)\n\t\t{\n\t\t\treturn node.box.IsCoordInside (v0) && node.box.IsCoordInside (v1) && node.box.IsCoordInside (v2);\n\t\t}\n\t\t\n\t\tif (!IsTriangleInNode (v0, v1, v2, root)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (root.children === null) {\n\t\t\tvar myThis = this;\n\t\t\troot.children = JSM.CreateOctreeChildNodes (root.box, function (nodeBox) {\n\t\t\t\treturn myThis.CreateNewNode (root, nodeBox);\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (root.children !== null) {\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < root.children.length; i++) {\n\t\t\t\tnode = root.children[i];\n\t\t\t\tif (this.AddTriangleToNode (v0, v1, v2, node, userData)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\troot.triangles.push ({\n\t\t\tv0 : v0,\n\t\t\tv1 : v1,\n\t\t\tv2 : v2,\n\t\t\tuserData : userData\n\t\t});\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TriangleOctree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Parameters:\n\t*\tparent {object} the parent node\n\t*\tbox {Box} the box of the node\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleOctree.prototype.CreateNewNode = function (parent, box)\n\t{\n\t\tvar newNode = {\n\t\t\tparent : parent,\n\t\t\tbox : box,\n\t\t\ttriangles : [],\n\t\t\tchildren : null\n\t\t};\n\t\treturn newNode;\t\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/bsptree',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: BSPTree\n\t* Description: Defines a BSP tree.\n\t*/\n\tJSM.BSPTree = function ()\n\t{\n\t\tthis.root = null;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygon\n\t* Description: Adds a polygon to the tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygon = function (polygon, userData)\n\t{\n\t\tif (this.root === null) {\n\t\t\tthis.root = this.CreateNewNode ();\n\t\t}\n\t\t\n\t\treturn this.AddPolygonToNode (this.root, polygon, userData);\n\t};\n\n\t/**\n\t* Function: BSPTree.Traverse\n\t* Description: Traverses the tree and calls a function on node found.\n\t* Parameters:\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.Traverse = function (nodeFound)\n\t{\n\t\tthis.TraverseNode (this.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: BSPTree.TraverseNode\n\t* Description: Traverses a node and its children and calls a function on node found.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.TraverseNode = function (node, nodeFound)\n\t{\n\t\tif (node !== null) {\n\t\t\tnodeFound (node);\n\t\t\tthis.TraverseNode (node.inside, nodeFound);\n\t\t\tthis.TraverseNode (node.outside, nodeFound);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Returns the nodes as an array.\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.BSPTree.prototype.GetNodes = function ()\n\t{\n\t\tvar result = [];\n\t\tthis.Traverse (function (node) {\n\t\t\tresult.push (node);\n\t\t});\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Count nodes.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BSPTree.prototype.NodeCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tthis.Traverse (function () {\n\t\t\tcount = count + 1;\n\t\t});\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygonToNode\n\t* Description: Adds a polygon to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygonToNode = function (node, polygon, userData)\n\t{\n\t\tif (polygon.VertexCount () < 3) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar normal;\n\t\tif (node.polygon === null) {\n\t\t\tnormal = polygon.GetNormal ();\n\t\t\tvar plane = JSM.GetPlaneFromCoordAndDirection (polygon.GetVertex (0), normal);\n\t\t\tnode.polygon = polygon;\n\t\t\tif (userData !== undefined) {\n\t\t\t\tnode.userData = userData;\n\t\t\t}\n\t\t\tnode.plane = plane;\n\t\t} else {\n\t\t\tvar backPolygons = [];\n\t\t\tvar frontPolygons = [];\n\t\t\tvar planePolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, frontPolygons, backPolygons, planePolygons);\n\t\t\tif (cutSucceeded) {\n\t\t\t\tif (backPolygons.length > 0) {\n\t\t\t\t\tthis.AddInsidePolygonsToNode (node, backPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (frontPolygons.length > 0) {\n\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, frontPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (planePolygons.length > 0) {\n\t\t\t\t\tnormal = polygon.GetNormal ();\n\t\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\t\tthis.AddInsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddInsidePolygonsToNode\n\t* Description: Adds inside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddInsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.inside === null) {\n\t\t\tnode.inside = this.CreateNewNode ();\n\t\t\tnode.inside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.inside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.AddOutsidePolygonsToNode\n\t* Description: Adds outside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddOutsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.outside === null) {\n\t\t\tnode.outside = this.CreateNewNode ();\n\t\t\tnode.outside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.outside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.BSPTree.prototype.CreateNewNode = function ()\n\t{\n\t\tvar node = {\n\t\t\tpolygon : null,\n\t\t\tuserData : null,\n\t\t\tplane : null,\n\t\t\tparent : null,\n\t\t\tinside : null,\n\t\t\toutside : null\n\t\t};\n\t\treturn node;\n\t};\n\n\t/**\n\t* Function: ClipPolygonWithBSPTree\n\t* Description: Clips a polygon with a created BSP tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the tree\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the tree\n\t*\tplanarFrontPolygons {Polygon[*]} (out) polygons on the tree looks front\n\t*\tplanarBackPolygons {Polygon[*]} (out) polygons on the tree looks back\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ClipPolygonWithBSPTree = function (polygon, bspTree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t{\n\t\tfunction CutPolygonWithNode (polygon, node, isPlanar)\n\t\t{\n\t\t\tif (node === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar cutBackPolygons = [];\n\t\t\tvar cutFrontPolygons = [];\n\t\t\tvar cutPlanarPolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, cutFrontPolygons, cutBackPolygons, cutPlanarPolygons);\n\t\t\tif (!cutSucceeded) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cutBackPolygons.length > 0) {\n\t\t\t\tAddInsidePolygons (node, cutBackPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutFrontPolygons.length > 0) {\n\t\t\t\tAddOutsidePolygons (node, cutFrontPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutPlanarPolygons.length > 0) {\n\t\t\t\tvar normal = polygon.GetNormal ();\n\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\tAddInsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t} else {\n\t\t\t\t\tAddOutsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction CutPolygonsWithNode (polygons, node, isPlanar)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tCutPolygonWithNode (polygons[i], node, isPlanar);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonsToArray (polygons, polygonArray)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tpolygonArray.push (polygons[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddInsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.inside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.inside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarBackPolygons : backPolygons);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddOutsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.outside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.outside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarFrontPolygons : frontPolygons);\n\t\t\t}\n\t\t}\n\n\t\tCutPolygonWithNode (polygon, bspTree.root, false);\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraverseBSPTreeForEyePosition\n\t* Description: Traverses a BSP tree for a given eye position.\n\t* Parameters:\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\teyePosition {Coord} the eye position\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.TraverseBSPTreeForEyePosition = function (bspTree, eyePosition, nodeFound)\n\t{\n\t\tfunction TraverseNode (node)\n\t\t{\n\t\t\tif (node !== null) {\n\t\t\t\tvar coordPlanePosition = node.plane.CoordPosition (eyePosition);\n\t\t\t\tif (coordPlanePosition == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t} else if (coordPlanePosition == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t} else {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTraverseNode (bspTree.root);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/curves',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateCubicBezierCurve\n\t* Description: Generates a bezier curve from the given points.\n\t* Parameters:\n\t*\tp0 {Coord2D} point 1\n\t*\tp1 {Coord2D} point 2\n\t*\tp2 {Coord2D} point 3\n\t*\tp3 {Coord2D} point 4\n\t*\tsegmentation {integer} the segmentation of the result curve\n\t* Returns:\n\t*\t{Coord2D[]} the result\n\t*/\n\tJSM.GenerateCubicBezierCurve = function (p0, p1, p2, p3, segmentation)\n\t{\n\t\tfunction GetCubicBezierPoint (p0, p1, p2, p3, t)\n\t\t{\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\tvar invT = 1.0 - t;\n\t\t\tvar invT2 = invT * invT;\n\t\t\tvar invT3 = invT2 * invT;\n\t\t\tvar x = invT3 * p0.x + 3.0 * invT2 * t * p1.x  + 3.0 * invT * t2 * p2.x + t3 * p3.x;\n\t\t\tvar y = invT3 * p0.y + 3.0 * invT2 * t * p1.y  + 3.0 * invT * t2 * p2.y + t3 * p3.y;\n\t\t\treturn new JSM.Coord2D (x, y);\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\tvar s = 1.0 / segmentation;\n\t\tvar i, coord;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tcoord = GetCubicBezierPoint (p0, p1, p2, p3, i * s);\n\t\t\tresult.push (coord);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BernsteinPolynomial\n\t* Description: Calculates the value of the Bernstein polynomial.\n\t* Parameters:\n\t*\tk {integer} the start index\n\t*\tn {integer} the end index\n\t*\tx {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.BernsteinPolynomial = function (k, n, x)\n\t{\n\t\tfunction BinomialCoefficient (n, k)\n\t\t{\n\t\t\tvar result = 1.0;\n\t\t\tvar min = JSM.Minimum (k, n - k);\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < min; i++) {\n\t\t\t\tresult = result * (n - i);\n\t\t\t\tresult = result / (i + 1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar coefficient = BinomialCoefficient (n, k);\n\t\treturn coefficient * Math.pow (x, k) * Math.pow (1.0 - x, n - k);\n\t};\n\n\t/**\n\t* Function: GenerateBezierCurve\n\t* Description: Generates a bezier curve from the given points.\n\t* Parameters:\n\t*\tpoints {Coord2D[]} the points\n\t*\tsegmentation {integer} the segmentation of the result curve\n\t* Returns:\n\t*\t{Coord2D[]} the result\n\t*/\n\tJSM.GenerateBezierCurve = function (points, segmentation)\n\t{\n\t\tvar result = [];\n\t\tvar n = points.length - 1;\n\t\tvar s = 1.0 / segmentation;\n\t\t\n\t\tvar i, j, t, point, bernstein, coord;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tt = i * s;\n\t\t\tcoord = new JSM.Coord2D (0.0, 0.0);\n\t\t\tfor (j = 0; j <= n; j++) {\n\t\t\t\tpoint = points[j];\n\t\t\t\tbernstein = JSM.BernsteinPolynomial (j, n, t);\n\t\t\t\tcoord.x += point.x * bernstein;\n\t\t\t\tcoord.y += point.y * bernstein;\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/utilities',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GetGaussianCParameter\n\t* Description:\n\t*\tCalculates the gaussian functions c parameter which can be used\n\t*\tfor the gaussian function to reach epsilon at a given value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tepsilon {number} the epsilon value\n\t* Returns:\n\t*\t{number} the c parameter of the function\n\t*/\n\tJSM.GetGaussianCParameter = function (x, a, b, epsilon)\n\t{\n\t\treturn Math.sqrt (-(Math.pow (x - b, 2.0) / (2.0 * Math.log (epsilon / Math.abs (a)))));\n\t};\n\n\t/**\n\t* Function: GetGaussianValue\n\t* Description: Calculates the gaussian functions value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tc {number} the c parameter of the function\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetGaussianValue = function (x, a, b, c)\n\t{\n\t\treturn a * Math.exp (-(Math.pow (x - b, 2.0) / (2.0 * Math.pow (c, 2.0))));\n\t};\n\n\t/**\n\t* Function: GenerateCirclePoints\n\t* Description: Generates coordinates on circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {number} the segmentation of the circle\n\t*\torigo {Coord} the origo of the circle\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.GenerateCirclePoints = function (radius, segmentation, origo)\n\t{\n\t\tvar result = [];\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcoord = JSM.CylindricalToCartesian (radius, 0.0, theta);\n\t\t\tif (origo !== undefined && origo !== null) {\n\t\t\t\tcoord = JSM.CoordAdd (coord, origo);\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetRuledMesh\n\t* Description:\n\t*\tGenerates ruled mesh coordinates and polygons between two coordinate array.\n\t*\tThe two arrays should have the same length. The result is a coordinate array\n\t*\tand a polygon array which contains indices for vertices.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tsegmentation {number} the segmentation of the mesh\n\t*\tvertices {Coord[*]} (out) the vertices of the mesh\n\t*\tpolygons {integer[*][4]} (out) the polygons of the mesh\n\t*/\n\tJSM.GetRuledMesh = function (aCoords, bCoords, segmentation, vertices, polygons)\n\t{\n\t\tif (aCoords.length !== bCoords.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lineSegmentation = aCoords.length - 1;\n\t\tvar meshSegmentation = segmentation;\n\t\tvar directions = [];\n\t\tvar lengths = [];\n\n\t\tvar i, j;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tdirections.push (JSM.CoordSub (bCoords[i], aCoords[i]));\n\t\t\tlengths.push (aCoords[i].DistanceTo (bCoords[i]));\n\t\t}\n\n\t\tvar step, coord;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tstep = lengths[i] / meshSegmentation;\n\t\t\tfor (j = 0; j <= meshSegmentation; j++) {\n\t\t\t\tcoord = aCoords[i].Clone ().Offset (directions[i], step * j);\n\t\t\t\tvertices.push (coord);\n\t\t\t}\n\t\t}\n\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tfor (j = 0; j < meshSegmentation; j++) {\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + meshSegmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + 1;\n\t\t\t\tnext = current + meshSegmentation + 1;\n\t\t\t\tntop = next + 1;\n\n\t\t\t\tpolygon = [current, next, ntop, top];\n\t\t\t\tpolygons.push (polygon);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/ray',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Ray\n\t* Description: Represents a Ray.\n\t* Parameters:\n\t*\torigin {Coord} the starting point of the ray\n\t*\tdirection {Vector} the direction of the ray\n\t*\tlength {number} the length of the ray, null means infinite ray\n\t*/\n\tJSM.Ray = function (origin, direction, length)\n\t{\n\t\tthis.origin = origin;\n\t\tthis.direction = direction.Normalize ();\n\t\tthis.length = length;\n\t};\n\n\t/**\n\t* Function: Ray.Set\n\t* Description: Sets the ray.\n\t* Parameters:\n\t*\torigin {Coord} the starting point of the ray\n\t*\tdirection {Vector} the direction of the ray\n\t*\tlength {number} the length of the ray, null means infinite ray\n\t*/\n\tJSM.Ray.prototype.Set = function (origin, direction, length)\n\t{\n\t\tthis.origin = origin;\n\t\tthis.direction = direction.Normalize ();\n\t\tthis.length = length;\n\t};\n\n\t/**\n\t* Function: Ray.GetOrigin\n\t* Description: Returns the origin of the ray.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Ray.prototype.GetOrigin = function ()\n\t{\n\t\treturn this.origin;\n\t};\n\n\t/**\n\t* Function: Ray.GetDirection\n\t* Description: Returns the direction of the ray.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Ray.prototype.GetDirection = function ()\n\t{\n\t\treturn this.direction;\n\t};\n\n\t/**\n\t* Function: Ray.IsLengthReached\n\t* Description:\n\t*\tReturns if the given length is greater than the length of the ray.\n\t*\tAlways return false in case of infinite ray.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Ray.prototype.IsLengthReached = function (length)\n\t{\n\t\tif (this.length === undefined || this.length === null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn JSM.IsGreater (length, this.length);\n\t};\n\n\t/**\n\t* Function: Ray.Clone\n\t* Description: Clones the ray.\n\t* Returns:\n\t*\t{Ray} a cloned instance\n\t*/\n\tJSM.Ray.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Ray (this.origin.Clone (), this.direction.Clone (), this.length);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/path',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Path2D\n\t* Description: Helper class for building polygons\n\t* Parameters:\n\t*\tsettings {object} path settings\n\t*/\n\tJSM.Path2D = function (settings)\n\t{\n\t\tthis.settings = {\n\t\t\tsegmentation : 10,\n\t\t\toffset : new JSM.Vector2D (0.0, 0.0),\n\t\t\tscale : new JSM.Coord2D (1.0, 1.0)\n\t\t};\n\t\tJSM.CopyObjectProperties (settings, this.settings, true);\n\t\t\n\t\tthis.position = new JSM.Coord2D (0.0, 0.0);\n\t\tthis.positionAdded = false;\n\t\tthis.polygons = [];\n\t\tthis.currentPolygon = null;\n\t};\n\n\t/**\n\t* Function: Path2D.MoveTo\n\t* Description: Moves the current position to the given position.\n\t* Parameters:\n\t*\tx {number} new x position\n\t*\ty {number} new y position\n\t*/\n\tJSM.Path2D.prototype.MoveTo = function (x, y)\n\t{\n\t\tthis.Close ();\n\t\tthis.position.Set (x, y);\n\t\tthis.positionAdded = false;\n\t};\n\n\t/**\n\t* Function: Path2D.LineTo\n\t* Description: Draws a line from current position to the given position.\n\t* Parameters:\n\t*\tx {number} line end x position\n\t*\ty {number} line end y position\n\t*/\n\tJSM.Path2D.prototype.LineTo = function (x, y)\n\t{\n\t\tif (!this.positionAdded) {\n\t\t\tthis.AddPolygonPoint (this.position.x, this.position.y);\n\t\t}\n\t\tthis.AddPolygonPoint (x, y);\n\t};\n\n\t/**\n\t* Function: Path2D.CubicBezierTo\n\t* Description: Draws a cubic bezier curve from the current position to the given position.\n\t* Parameters:\n\t*\tx {number} curve end x position\n\t*\ty {number} curve end y position\n\t*\tcp1x {number} first control point x position\n\t*\tcp1y {number} first control point y position\n\t*\tcp2x {number} second control point x position\n\t*\tcp2y {number} second control point y position\n\t*/\n\tJSM.Path2D.prototype.CubicBezierTo = function (x, y, cp1x, cp1y, cp2x, cp2y)\n\t{\n\t\tvar bezierPoints = JSM.GenerateCubicBezierCurve (\n\t\t\tnew JSM.Coord2D (this.position.x, this.position.y),\n\t\t\tnew JSM.Coord2D (cp1x, cp1y),\n\t\t\tnew JSM.Coord2D (cp2x, cp2y),\n\t\t\tnew JSM.Coord2D (x, y),\n\t\t\tthis.settings.segmentation\n\t\t);\n\t\tvar i;\n\t\tfor (i = 1; i < bezierPoints.length; i++) {\n\t\t\tthis.LineTo (bezierPoints[i].x, bezierPoints[i].y);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Path2D.Close\n\t* Description: Closes the current polygon.\n\t*/\n\tJSM.Path2D.prototype.Close = function ()\n\t{\n\t\tfunction CheckAndCorrectPolygon (polygon)\n\t\t{\n\t\t\tif (polygon.VertexCount () === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (polygon.GetVertex (0).IsEqual (polygon.GetVertex (polygon.VertexCount () - 1))) {\n\t\t\t\tpolygon.RemoveVertex (polygon.VertexCount () - 1);\n\t\t\t}\n\t\t\tif (polygon.VertexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction FindBasePolygon (polygons, polygon)\n\t\t{\n\t\t\tfunction IsBasePolygon (basePolygon, polygon)\n\t\t\t{\n\t\t\t\tbaseOrientation = baseContour.GetOrientation ();\n\t\t\t\tpolygonOrientation = polygon.GetOrientation ();\n\t\t\t\tif (baseOrientation !== polygonOrientation) {\n\t\t\t\t\tvar firstVertex = polygon.GetVertex (0);\n\t\t\t\t\tvar firstVertexPosition = baseContour.CoordPosition (firstVertex);\n\t\t\t\t\tif (firstVertexPosition == JSM.CoordPolygonPosition2D.Inside) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, baseContour, baseOrientation, polygonOrientation;\n\t\t\tfor (i = polygons.length - 1; i >= 0; i--) {\n\t\t\t\tbaseContour = polygons[i].GetContour (0);\n\t\t\t\tif (IsBasePolygon (baseContour, polygon)) {\n\t\t\t\t\treturn polygons[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.currentPolygon !== null) {\n\t\t\tif (CheckAndCorrectPolygon (this.currentPolygon)) {\n\t\t\t\tvar basePolygon = FindBasePolygon (this.polygons, this.currentPolygon);\n\t\t\t\tif (basePolygon === null) {\n\t\t\t\t\tvar contourPolygon = new JSM.ContourPolygon2D ();\n\t\t\t\t\tcontourPolygon.AddContour (this.currentPolygon);\n\t\t\t\t\tthis.polygons.push (contourPolygon);\n\t\t\t\t} else {\n\t\t\t\t\tbasePolygon.AddContour (this.currentPolygon);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.currentPolygon = null;\n\t\t}\n\t};\t\t\t\n\n\t/**\n\t* Function: Path2D.PolygonCount\n\t* Description: Returns the polygon count of the path.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Path2D.prototype.PolygonCount = function ()\n\t{\n\t\treturn this.polygons.length;\n\t};\n\n\t/**\n\t* Function: Path2D.GetPolygon\n\t* Description: Returns the polygons from the path at the given index.\n\t* Parameters:\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{ContourPolygon2D} the result\n\t*/\n\tJSM.Path2D.prototype.GetPolygon = function (index)\n\t{\n\t\treturn this.polygons[index];\n\t};\n\n\t/**\n\t* Function: Path2D.GetPolygons\n\t* Description: Returns the polygons from the path.\n\t* Returns:\n\t*\t{ContourPolygon2D[*]} the result\n\t*/\n\tJSM.Path2D.prototype.GetPolygons = function ()\n\t{\n\t\treturn this.polygons;\n\t};\n\n\t/**\n\t* Function: Path2D.GetCurrentPolygon\n\t* Description: Returns the current polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.Path2D.prototype.GetCurrentPolygon = function ()\n\t{\n\t\tif (this.currentPolygon === null) {\n\t\t\tthis.currentPolygon = new JSM.Polygon2D ();\n\t\t}\n\t\treturn this.currentPolygon;\n\t};\t\t\n\n\t/**\n\t* Function: Path2D.AddPolygonPoint\n\t* Description: Adds a point to the current polygon.\n\t* Parameters:\n\t*\tx {number} the x position of the point\n\t*\ty {number} the y position of the point\n\t*/\n\tJSM.Path2D.prototype.AddPolygonPoint = function (x, y)\n\t{\n\t\tvar polygon = this.GetCurrentPolygon ();\n\t\tvar polygonX = this.settings.offset.x + x * this.settings.scale.x;\n\t\tvar polygonY = this.settings.offset.y + y * this.settings.scale.y;\n\t\tpolygon.AddVertex (polygonX, polygonY);\n\t\tthis.position.Set (x, y);\n\t\tthis.positionAdded = true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/color',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: HexColorToRGBComponents\n\t* Description: Converts hex color strings to RGB components.\n\t* Parameters:\n\t*\thexColor {string} the hex color\n\t* Returns:\n\t*\t{integer[3]} the RGB components\n\t*/\n\tJSM.HexColorToRGBComponents = function (hexColor)\n\t{\n\t\tvar hexString = hexColor.toString (16);\n\t\twhile (hexString.length < 6) {\n\t\t\thexString = '0' + hexString;\n\t\t}\n\t\tvar r = parseInt (hexString.substr (0, 2), 16);\n\t\tvar g = parseInt (hexString.substr (2, 2), 16);\n\t\tvar b = parseInt (hexString.substr (4, 2), 16);\n\t\treturn [r, g, b];\n\t};\n\n\t/**\n\t* Function: HexColorToNormalizedRGBComponents\n\t* Description: Converts hex color strings to normalized (between 0.0 and 1.0) RGB components.\n\t* Parameters:\n\t*\thexColor {string} the hex color\n\t* Returns:\n\t*\t{number[3]} the RGB components\n\t*/\n\tJSM.HexColorToNormalizedRGBComponents = function (hexColor)\n\t{\n\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\treturn [rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0];\n\t};\n\n\t/**\n\t* Function: HexColorToRGBColor\n\t* Description: Converts hex color strings to RGB color.\n\t* Parameters:\n\t*\thexColor {string} the hex color string\n\t* Returns:\n\t*\t{integer} the RGB value\n\t*/\n\tJSM.HexColorToRGBColor = function (hexColor)\n\t{\n\t\tvar hexString = '0x' + hexColor;\n\t\treturn parseInt (hexString, 16);\n\t};\n\n\t/**\n\t* Function: RGBComponentsToHexColor\n\t* Description: Converts RGB components to hex color.\n\t* Parameters:\n\t*\tred {integer} the red component\n\t*\tgreen {integer} the green component\n\t*\tblue {integer} the blue component\n\t* Returns:\n\t*\t{integer} the hex value\n\t*/\n\tJSM.RGBComponentsToHexColor = function (red, green, blue)\n\t{\n\t\tfunction IntegerToHex (intString)\n\t\t{\n\t\t\tvar result = parseInt (intString, 10).toString (16);\n\t\t\twhile (result.length < 2) {\n\t\t\t\tresult = '0' + result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvar r = IntegerToHex (red);\n\t\tvar g = IntegerToHex (green);\n\t\tvar b = IntegerToHex (blue);\n\t\tvar hexString = '0x' + r + g + b;\n\t\treturn parseInt (hexString, 16);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/material',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Material\n\t* Description:\n\t*\tDefines a material. The parameter structure can contain the following values:\n\t*\tambient, diffuse, specular, shininess, opacity, texture, textureWidth, textureHeight.\n\t* Parameters:\n\t*\tparameters {object} parameters of the material\n\t*/\n\tJSM.Material = function (parameters)\n\t{\n\t\tthis.ambient = 0x00cc00;\n\t\tthis.diffuse = 0x00cc00;\n\t\tthis.specular = 0x000000;\n\t\tthis.shininess = 0.0;\n\t\tthis.opacity = 1.0;\n\t\tthis.reflection = 0.0;\n\t\tthis.singleSided = false;\n\t\tthis.pointSize = 0.1;\n\t\tthis.texture = null;\n\t\tthis.textureWidth = 1.0;\n\t\tthis.textureHeight = 1.0;\n\t\tJSM.CopyObjectProperties (parameters, this, true);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/materialset',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: MaterialSet\n\t* Description: Defines a material container.\n\t*/\n\tJSM.MaterialSet = function ()\n\t{\n\t\tthis.materials = [];\n\t\tthis.defaultMaterial = new JSM.Material ();\n\t};\n\n\t/**\n\t* Function: MaterialSet.AddMaterial\n\t* Description: Adds a material to the container.\n\t* Parameters:\n\t*\tmaterial {Material} the material\n\t* Returns:\n\t*\t{integer} the index of the newly added material\n\t*/\n\tJSM.MaterialSet.prototype.AddMaterial = function (material)\n\t{\n\t\tthis.materials.push (material);\n\t\treturn this.materials.length - 1;\n\t};\n\n\t/**\n\t* Function: MaterialSet.GetMaterial\n\t* Description: Returns a material from the container.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.MaterialSet.prototype.GetMaterial = function (index)\n\t{\n\t\tif (index < 0 || index >= this.materials.length) {\n\t\t\treturn this.defaultMaterial;\n\t\t}\n\t\treturn this.materials[index];\n\t};\n\n\t/**\n\t* Function: MaterialSet.GetDefaultMaterial\n\t* Description: Returns the default material from the container. It is always exists.\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.MaterialSet.prototype.GetDefaultMaterial = function ()\n\t{\n\t\treturn this.defaultMaterial;\n\t};\n\n\t/**\n\t* Function: MaterialSet.Count\n\t* Description: Returns the material count of the container.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.MaterialSet.prototype.Count = function ()\n\t{\n\t\treturn this.materials.length;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/body',[\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: BodyVertex\n\t* Description:\n\t*\tRepresents a vertex of a 3D body. The vertex contains\n\t*\tonly its position as a 3D coordinate.\n\t* Parameters:\n\t*\tposition {Coord} the position\n\t*/\n\tJSM.BodyVertex = function (position)\n\t{\n\t\tthis.position = position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.GetPosition\n\t* Description: Returns the position of the vertex.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.BodyVertex.prototype.GetPosition = function ()\n\t{\n\t\treturn this.position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.SetPosition\n\t* Description: Sets the position of the vertex.\n\t* Parameters:\n\t*\tposition {Coord} the position\n\t*/\n\tJSM.BodyVertex.prototype.SetPosition = function (position)\n\t{\n\t\tthis.position = position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.Clone\n\t* Description: Clones the vertex.\n\t* Returns:\n\t*\t{BodyVertex} the cloned instance\n\t*/\n\tJSM.BodyVertex.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.BodyVertex (this.position.Clone ());\n\t};\n\n\t/**\n\t* Class: BodyPoint\n\t* Description:\n\t*\tRepresents a point in a 3D body. The point contains the vertex index stored in its 3D body,\n\t*\tand a material index of a material defined outside of the body.\n\t* Parameters:\n\t*\tindex {integer} the vertex index stored in the body\n\t*/\n\tJSM.BodyPoint = function (index)\n\t{\n\t\tthis.vertex = index;\n\t\tthis.material = -1;\n\t};\n\n\t/**\n\t* Function: BodyPoint.GetVertexIndex\n\t* Description: Returns the body vertex index of the point.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyPoint.prototype.GetVertexIndex = function ()\n\t{\n\t\treturn this.vertex;\n\t};\n\n\t/**\n\t* Function: BodyPoint.SetVertexIndex\n\t* Description: Sets the vertex index of the point.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyPoint.prototype.SetVertexIndex = function (index)\n\t{\n\t\tthis.vertex = index;\n\t};\n\n\t/**\n\t* Function: BodyPoint.HasMaterialIndex\n\t* Description: Returns if the point has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPoint.prototype.HasMaterialIndex = function ()\n\t{\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPoint.GetMaterialIndex\n\t* Description: Returns the point material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPoint.prototype.GetMaterialIndex = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.SetMaterialIndex\n\t* Description: Sets the point material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyPoint.prototype.SetMaterialIndex = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.InheritAttributes\n\t* Description: Inherits attributes (material) from an another point.\n\t* Parameters:\n\t*\tsource {BodyPoint} the source point\n\t*/\n\tJSM.BodyPoint.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.Clone\n\t* Description: Clones the point.\n\t* Returns:\n\t*\t{BodyPoint} the cloned instance\n\t*/\n\tJSM.BodyPoint.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyPoint (this.vertex);\n\t\tresult.material = this.material;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: BodyLine\n\t* Description:\n\t*\tRepresents a line in a 3D body. The line contains begin and end indices of vertices\n\t*\tstored in its 3D body, and a material index of a material defined outside of the body.\n\t* Parameters:\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.BodyLine = function (beg, end)\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t\tthis.material = -1;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetBegVertexIndex\n\t* Description: Returns the body vertex index at the beginning of the line.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyLine.prototype.GetBegVertexIndex = function ()\t{\n\t\treturn this.beg;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetBegVertexIndex\n\t* Description: Sets the begin vertex index of the line.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyLine.prototype.SetBegVertexIndex = function (index)\t{\n\t\tthis.beg = index;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetEndVertexIndex\n\t* Description: Returns the body vertex index at the end of the line.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyLine.prototype.GetEndVertexIndex = function ()\t{\n\t\treturn this.end;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetEndVertexIndex\n\t* Description: Sets the end vertex index of the line.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyLine.prototype.SetEndVertexIndex = function (index)\t{\n\t\tthis.end = index;\n\t};\n\n\t/**\n\t* Function: BodyLine.HasMaterialIndex\n\t* Description: Returns if the line has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyLine.prototype.HasMaterialIndex = function (){\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetMaterialIndex\n\t* Description: Returns the line material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyLine.prototype.GetMaterialIndex = function (){\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetMaterialIndex\n\t* Description: Sets the line material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyLine.prototype.SetMaterialIndex = function (material){\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyLine.InheritAttributes\n\t* Description: Inherits attributes (material) from an another line.\n\t* Parameters:\n\t*\tsource {BodyLine} the source line\n\t*/\n\tJSM.BodyLine.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t};\n\n\t/**\n\t* Function: BodyLine.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{BodyLine} the cloned instance\n\t*/\n\tJSM.BodyLine.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyLine (this.beg, this.end);\n\t\tresult.material = this.material;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: BodyPolygon\n\t* Description:\n\t*\tRepresents a polygon in a 3D body. The polygon contains indices of vertices stored in its body.\n\t*\tIt also contains a material index of a material defined outside of the body, and a curve\n\t*\tgroup index which defines its normal vector calculation in case of smooth surfaces.\n\t* Parameters:\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.BodyPolygon = function (vertices)\n\t{\n\t\tthis.vertices = vertices;\n\t\tthis.material = -1;\n\t\tthis.curved = -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.AddVertexIndex\n\t* Description: Adds a vertex index to the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.AddVertexIndex = function (index)\n\t{\n\t\tthis.vertices.push (index);\n\t};\n\n\t/**\n\t* Function: BodyPolygon.InsertVertexIndex\n\t* Description: Inserts a vertex index to given index in the polygon.\n\t* Parameters:\n\t*\tvertexIndex {integer} the vertex index\n\t*\tpolygonIndex {integer} the index in the polygon\n\t*/\n\tJSM.BodyPolygon.prototype.InsertVertexIndex = function (vertexIndex, polygonIndex)\n\t{\n\t\tthis.vertices.splice (polygonIndex, 0, vertexIndex);\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetVertexIndex\n\t* Description: Returns the body vertex index at the given polygon vertex index.\n\t* Parameters:\n\t*\tindex {integer} the polygon vertex index\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.GetVertexIndex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetVertexIndex\n\t* Description: Sets the body vertex index at the given polygon vertex index.\n\t* Parameters:\n\t*\tindex {integer} the polygon vertex index\n\t*\tvertIndex {integer} the body vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.SetVertexIndex = function (index, vertIndex)\n\t{\n\t\tthis.vertices[index] = vertIndex;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetVertexIndices\n\t* Description: Returns an array of the body vertex indices in the polygon.\n\t* Returns:\n\t*\t{integer[]} the stored vertex indices\n\t*/\n\tJSM.BodyPolygon.prototype.GetVertexIndices = function ()\n\t{\n\t\treturn this.vertices;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetVertexIndices\n\t* Description: Sets the vertex indices in the polygon.\n\t* Parameters:\n\t*\tvertices {integer[]} the new vertex indices\n\t*/\n\tJSM.BodyPolygon.prototype.SetVertexIndices = function (vertices)\n\t{\n\t\tthis.vertices = vertices;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.VertexIndexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.VertexIndexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.HasMaterialIndex\n\t* Description: Returns if the polygon has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPolygon.prototype.HasMaterialIndex = function ()\n\t{\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetMaterialIndex\n\t* Description: Returns the polygons material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.GetMaterialIndex = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetMaterialIndex\n\t* Description: Sets the polygons material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyPolygon.prototype.SetMaterialIndex = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.HasCurveGroup\n\t* Description: Returns if the polygon has a curve group index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPolygon.prototype.HasCurveGroup = function ()\n\t{\n\t\treturn this.curved !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetCurveGroup\n\t* Description: Returns the polygons curve group index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.GetCurveGroup = function ()\n\t{\n\t\treturn this.curved;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetCurveGroup\n\t* Description: Sets the polygons curve group index.\n\t* Parameters:\n\t*\tgroup {integer} the curve group index\n\t*/\n\tJSM.BodyPolygon.prototype.SetCurveGroup = function (group)\n\t{\n\t\tthis.curved = group;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.ReverseVertexIndices\n\t* Description: Reverses the order of vertex indices in the polygon.\n\t*/\n\tJSM.BodyPolygon.prototype.ReverseVertexIndices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t};\n\n\t/**\n\t* Function: BodyPolygon.InheritAttributes\n\t* Description: Inherits attributes (material and curve group index) from an another polygon.\n\t* Parameters:\n\t*\tsource {BodyPolygon} the source polygon\n\t*/\n\tJSM.BodyPolygon.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t\tthis.curved = source.curved;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{BodyPolygon} the cloned instance\n\t*/\n\tJSM.BodyPolygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyPolygon ([]);\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.vertices.push (this.vertices[i]);\n\t\t}\n\t\tresult.material = this.material;\n\t\tresult.curved = this.curved;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Enum: TextureProjectionType\n\t* Description: Texture projection type.\n\t* Values:\n\t*\t{Planar} planar projection\n\t*\t{Cubic} cubic projection\n\t*\t{Cylindrical} cylindrical projection\n\t*/\n\tJSM.TextureProjectionType = {\n\t\tPlanar : 0,\n\t\tCubic : 1,\n\t\tCylindrical : 2\n\t};\n\n\t/**\n\t* Class: BodyTextureProjection\n\t* Description:\n\t*\tRepresents the texture projection of the body. It contains a projection type,\n\t*\tand a coordinate system for projection.\n\t*/\n\tJSM.BodyTextureProjection = function ()\n\t{\n\t\tthis.type = null;\n\t\tthis.coords = null;\n\t\tthis.SetCubic (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.GetType\n\t* Description: Returns the texture projection type.\n\t* Returns:\n\t*\t{TextureProjectionType} the result\n\t*/\n\tJSM.BodyTextureProjection.prototype.GetType = function ()\n\t{\n\t\treturn this.type;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.GetCoords\n\t* Description: Returns the texture projection coordinate system.\n\t* Returns:\n\t*\t{CoordSystem} the result\n\t*/\n\tJSM.BodyTextureProjection.prototype.GetCoords = function ()\n\t{\n\t\treturn this.coords;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetType\n\t* Description: Sets the texture projection type.\n\t* Parameters:\n\t*\ttype {TextureProjectionType} the type\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetType = function (type)\n\t{\n\t\tthis.type = type;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCoords\n\t* Description: Sets the texture projection coordinates.\n\t* Parameters:\n\t*\tcoords {CoordSystem} the coordinates\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCoords = function (coords)\n\t{\n\t\tthis.coords = coords;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetPlanar\n\t* Description: Sets the texture projection to planar with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction of the projection plane\n\t*\tyDirection {Vector} y direction of the projection plane\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetPlanar = function (origo, xDirection, yDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Planar;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection,\n\t\t\tyDirection,\n\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCubic\n\t* Description: Sets the texture projection to cubic with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction (edge of the cube) of the projection\n\t*\tyDirection {Vector} y direction (edge of the cube) of the projection\n\t*\tzDirection {Vector} z direction (edge of the cube) of the projection\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCubic = function (origo, xDirection, yDirection, zDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Cubic;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection,\n\t\t\tyDirection,\n\t\t\tzDirection\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCylindrical\n\t* Description: Sets the texture projection to cylindrical with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\tradius {number} radius of the cylinder\n\t*\txDirection {Vector} x direction (start point along perimeter) of the projection\n\t*\tzDirection {Vector} z direction (normal vector) of the projection\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCylindrical = function (origo, radius, xDirection, zDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Cylindrical;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection.Clone ().SetLength (radius),\n\t\t\tJSM.VectorCross (zDirection, xDirection).SetLength (radius),\n\t\t\tzDirection\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.Transform\n\t* Description: Transforms the texture projection coordinate system.\n\t* Parameters:\n\t*\ttransformation {Transformation} the transformation\n\t*/\n\tJSM.BodyTextureProjection.prototype.Transform = function (transformation)\n\t{\n\t\tthis.coords.ToAbsoluteCoords ();\n\t\tthis.coords.origo = transformation.Apply (this.coords.origo);\n\t\tthis.coords.e1 = transformation.Apply (this.coords.e1);\n\t\tthis.coords.e2 = transformation.Apply (this.coords.e2);\n\t\tthis.coords.e3 = transformation.Apply (this.coords.e3);\n\t\tthis.coords.ToDirectionVectors ();\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.Clone\n\t* Description: Clones the texture projection.\n\t* Returns:\n\t*\t{BodyTextureProjection} the cloned instance\n\t*/\n\tJSM.BodyTextureProjection.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyTextureProjection ();\n\t\tresult.SetType (this.type);\n\t\tresult.SetCoords (this.coords.Clone ());\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: Body\n\t* Description:\n\t*\tRepresents a 3D body. The body contains vertices, polygons,\n\t*\tand a texture coordinate system.\n\t*/\n\tJSM.Body = function ()\n\t{\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Body.AddVertex\n\t* Description: Adds a vertex to the body.\n\t* Parameters:\n\t*\tvertex {BodyVertex} the vertex\n\t* Returns:\n\t*\t{integer} the index of the newly added vertex\n\t*/\n\tJSM.Body.prototype.AddVertex = function (vertex)\n\t{\n\t\tthis.vertices.push (vertex);\n\t\treturn this.vertices.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddPoint\n\t* Description: Adds a point to the body.\n\t* Parameters:\n\t*\tpoint {BodyPoint} the point\n\t* Returns:\n\t*\t{integer} the index of the newly added point\n\t*/\n\tJSM.Body.prototype.AddPoint = function (point)\n\t{\n\t\tthis.points.push (point);\n\t\treturn this.points.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddLine\n\t* Description: Adds a line to the body.\n\t* Parameters:\n\t*\tline {BodyLine} the line\n\t* Returns:\n\t*\t{integer} the index of the newly added line\n\t*/\n\tJSM.Body.prototype.AddLine = function (line)\n\t{\n\t\tthis.lines.push (line);\n\t\treturn this.lines.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddPolygon\n\t* Description: Adds a polygon to the body.\n\t* Parameters:\n\t*\tpolygon {BodyPolygon} the polygon\n\t* Returns:\n\t*\t{integer} the index of the newly added polygon\n\t*/\n\tJSM.Body.prototype.AddPolygon = function (polygon)\n\t{\n\t\tthis.polygons.push (polygon);\n\t\treturn this.polygons.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.GetVertex\n\t* Description: Returns the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{BodyVertex} the result\n\t*/\n\tJSM.Body.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Body.GetVertexPosition\n\t* Description: Returns the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Body.prototype.GetVertexPosition = function (index)\n\t{\n\t\treturn this.vertices[index].position;\n\t};\n\n\t/**\n\t* Function: Body.SetVertexPosition\n\t* Description: Sets the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*\tposition {Coord} the new position\n\t*/\n\tJSM.Body.prototype.SetVertexPosition = function (index, position)\n\t{\n\t\tthis.vertices[index].position = position;\n\t};\n\n\t/**\n\t* Function: Body.GetPoint\n\t* Description: Returns the point at the given index.\n\t* Parameters:\n\t*\tindex {integer} the point index\n\t* Returns:\n\t*\t{BodyPoint} the result\n\t*/\n\tJSM.Body.prototype.GetPoint = function (index)\n\t{\n\t\treturn this.points[index];\n\t};\n\n\t/**\n\t* Function: Body.GetLine\n\t* Description: Returns the line at the given index.\n\t* Parameters:\n\t*\tindex {integer} the line index\n\t* Returns:\n\t*\t{BodyLine} the result\n\t*/\n\tJSM.Body.prototype.GetLine = function (index)\n\t{\n\t\treturn this.lines[index];\n\t};\n\n\t/**\n\t* Function: Body.GetPolygon\n\t* Description: Returns the polygon at the given index.\n\t* Parameters:\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{BodyPolygon} the result\n\t*/\n\tJSM.Body.prototype.GetPolygon = function (index)\n\t{\n\t\treturn this.polygons[index];\n\t};\n\n\t/**\n\t* Function: Body.SetPointsMaterialIndex\n\t* Description: Sets the material index for all points in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetPointsMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tthis.points[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetLinesMaterialIndex\n\t* Description: Sets the material index for all lines in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetLinesMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tthis.lines[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetPolygonsMaterialIndex\n\t* Description: Sets the material index for all polygons in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetPolygonsMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tthis.polygons[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetPolygonsCurveGroup\n\t* Description: Sets the curve group index for all polygons in the body.\n\t* Parameters:\n\t*\tgroup {integer} the curve group index\n\t*/\n\tJSM.Body.prototype.SetPolygonsCurveGroup = function (group)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tthis.polygons[i].SetCurveGroup (group);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.RemoveVertex\n\t* Description: Removes a vertex from the body. It also removes connected polygons.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Body.prototype.RemoveVertex = function (index)\n\t{\n\t\tvar pointsToDelete = [];\n\t\tvar linesToDelete = [];\n\t\tvar polygonsToDelete = [];\n\t\tvar i, j, point, line, polygon, bodyVertIndex;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tpoint = this.points[i];\n\t\t\tif (point.GetVertexIndex () == index) {\n\t\t\t\tpointsToDelete.push (i);\n\t\t\t} else if (point.GetVertexIndex () >= index) {\n\t\t\t\tpoint.SetVertexIndex (point.GetVertexIndex () - 1);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tline = this.lines[i];\n\t\t\tif (line.GetBegVertexIndex () == index || line.GetEndVertexIndex () == index) {\n\t\t\t\tlinesToDelete.push (i);\n\t\t\t} else {\n\t\t\t\tif (line.GetBegVertexIndex () >= index) {\n\t\t\t\t\tline.SetBegVertexIndex (line.GetBegVertexIndex () - 1);\n\t\t\t\t}\n\t\t\t\tif (line.GetEndVertexIndex () >= index) {\n\t\t\t\t\tline.SetEndVertexIndex (line.GetEndVertexIndex () - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tpolygon = this.polygons[i];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tbodyVertIndex = polygon.GetVertexIndex (j);\n\t\t\t\tif (polygon.GetVertexIndex (j) == index) {\n\t\t\t\t\tpolygonsToDelete.push (i);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (bodyVertIndex >= index) {\n\t\t\t\t\tpolygon.SetVertexIndex (j, bodyVertIndex - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < pointsToDelete.length; i++) {\n\t\t\tthis.RemovePoint (pointsToDelete[i] - i);\n\t\t}\n\t\tfor (i = 0; i < linesToDelete.length; i++) {\n\t\t\tthis.RemoveLine (linesToDelete[i] - i);\n\t\t}\n\t\tfor (i = 0; i < polygonsToDelete.length; i++) {\n\t\t\tthis.RemovePolygon (polygonsToDelete[i] - i);\n\t\t}\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemovePoint\n\t* Description: Removes a point from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the point\n\t*/\n\tJSM.Body.prototype.RemovePoint = function (index)\n\t{\n\t\tthis.points.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemoveLine\n\t* Description: Removes a line from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the line\n\t*/\n\tJSM.Body.prototype.RemoveLine = function (index)\n\t{\n\t\tthis.lines.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemovePolygon\n\t* Description: Removes a polygon from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the polygon\n\t*/\n\tJSM.Body.prototype.RemovePolygon = function (index)\n\t{\n\t\tthis.polygons.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.VertexCount\n\t* Description: Returns the vertex count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Body.PointCount\n\t* Description: Returns the point count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.PointCount = function ()\n\t{\n\t\treturn this.points.length;\n\t};\n\n\t/**\n\t* Function: Body.LineCount\n\t* Description: Returns the line count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.LineCount = function ()\n\t{\n\t\treturn this.lines.length;\n\t};\n\n\t/**\n\t* Function: Body.PolygonCount\n\t* Description: Returns the polygon count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.PolygonCount = function ()\n\t{\n\t\treturn this.polygons.length;\n\t};\n\n\t/**\n\t* Function: Body.GetTextureProjection\n\t* Description: Returns the texture projection of the body.\n\t* Returns:\n\t*\t{BodyTextureProjection} the result\n\t*/\n\tJSM.Body.prototype.GetTextureProjection = function ()\n\t{\n\t\treturn this.projection;\n\t};\n\n\t/**\n\t* Function: Body.SetTextureProjection\n\t* Description: Sets the texture projection of the body.\n\t* Parameters:\n\t*\tprojection {BodyTextureProjection} the new texture projection\n\t*/\n\tJSM.Body.prototype.SetTextureProjection = function (projection)\n\t{\n\t\tthis.projection = projection;\n\t};\n\n\t/**\n\t* Function: Body.SetPlanarTextureProjection\n\t* Description: Sets the texture projection to planar with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction of the projection plane\n\t*\tyDirection {Vector} y direction of the projection plane\n\t*/\n\tJSM.Body.prototype.SetPlanarTextureProjection = function (origo, xDirection, yDirection)\n\t{\n\t\tthis.projection.SetPlanar (origo, xDirection, yDirection);\n\t};\n\n\t/**\n\t* Function: Body.SetCubicTextureProjection\n\t* Description: Sets the texture projection to cubic with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction (edge of the cube) of the projection\n\t*\tyDirection {Vector} y direction (edge of the cube) of the projection\n\t*\tzDirection {Vector} z direction (edge of the cube) of the projection\n\t*/\n\tJSM.Body.prototype.SetCubicTextureProjection = function (origo, xDirection, yDirection, zDirection)\n\t{\n\t\tthis.projection.SetCubic (origo, xDirection, yDirection, zDirection);\n\t};\n\n\t/**\n\t* Function: Body.SetCylindricalTextureProjection\n\t* Description: Sets the texture projection to cylindrical with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\tradius {number} radius of the cylinder\n\t*\txDirection {Vector} x direction (start point along perimeter) of the projection\n\t*\tzDirection {Vector} z direction (normal vector) of the projection\n\t*/\n\tJSM.Body.prototype.SetCylindricalTextureProjection = function (origo, radius, xDirection, zDirection)\n\t{\n\t\tthis.projection.SetCylindrical (origo, radius, xDirection, zDirection);\n\t};\n\n\t/**\n\t* Function: Body.Transform\n\t* Description: Transforms the body.\n\t* Parameters:\n\t*\ttransformation {Transformation} the transformation\n\t*/\n\tJSM.Body.prototype.Transform = function (transformation)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tthis.vertices[i].position = transformation.Apply (this.vertices[i].position);\n\t\t}\n\t\tthis.projection.Transform (transformation);\n\t};\n\n\t/**\n\t* Function: Body.GetBoundingBox\n\t* Description: Returns the bounding box of the body.\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.Body.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i].position;\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\t\t\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\t/**\n\t* Function: Body.GetCenter\n\t* Description: Returns the center of the bounding box of the body.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Body.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\t/**\n\t* Function: Body.GetBoundingSphere\n\t* Description: Returns the bounding sphere of the body.\n\t* Returns:\n\t*\t{Sphere} the result\n\t*/\n\tJSM.Body.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\t\t\n\t\tvar i, current;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcurrent = center.DistanceTo (this.vertices[i].position);\n\t\t\tif (JSM.IsGreater (current, radius)) {\n\t\t\t\tradius = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.Sphere (center, radius);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Body.OffsetToOrigo\n\t* Description: Offsets the body to the origo.\n\t*/\n\tJSM.Body.prototype.OffsetToOrigo = function ()\n\t{\n\t\tvar center = this.GetCenter ().Clone ();\n\t\tcenter.MultiplyScalar (-1.0);\n\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tthis.vertices[i].position = JSM.CoordAdd (this.vertices[i].position, center);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.Merge\n\t* Description: Merges an existing body to the body.\n\t* Parameters:\n\t*\tbody {Body} the body to merge\n\t*/\n\tJSM.Body.prototype.Merge = function (body)\n\t{\n\t\tvar oldVertexCount = this.vertices.length;\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tthis.vertices.push (body.GetVertex (i).Clone ());\n\t\t}\n\t\t\n\t\tvar newPoint;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tnewPoint = body.GetPoint (i).Clone ();\n\t\t\tnewPoint.SetVertexIndex (newPoint.GetVertexIndex () + oldVertexCount);\n\t\t\tthis.points.push (newPoint);\n\t\t}\t\n\t\t\n\t\tvar newLine;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tnewLine = body.GetLine (i).Clone ();\n\t\t\tnewLine.SetBegVertexIndex (newLine.GetBegVertexIndex () + oldVertexCount);\n\t\t\tnewLine.SetEndVertexIndex (newLine.GetEndVertexIndex () + oldVertexCount);\n\t\t\tthis.lines.push (newLine);\n\t\t}\n\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnewPolygon = body.GetPolygon (i).Clone ();\n\t\t\tfor (j = 0; j < newPolygon.VertexIndexCount (); j++) {\n\t\t\t\tnewPolygon.vertices[j] += oldVertexCount;\n\t\t\t}\n\t\t\tthis.polygons.push (newPolygon);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.Clear\n\t* Description: Makes the body empty.\n\t*/\n\tJSM.Body.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.points = [];\n\t\tthis.lines = [];\n\t\tthis.polygons = [];\n\t\tthis.projection = new JSM.BodyTextureProjection ();\n\t};\n\n\t/**\n\t* Function: Body.Clone\n\t* Description: Clones the body.\n\t* Returns:\n\t*\t{Body} the cloned instance\n\t*/\n\tJSM.Body.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.AddVertex (this.vertices[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tresult.AddPoint (this.points[i].Clone ());\n\t\t}\n\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tresult.AddLine (this.lines[i].Clone ());\n\t\t}\n\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tresult.AddPolygon (this.polygons[i].Clone ());\n\t\t}\n\n\t\tresult.SetTextureProjection (this.projection.Clone ());\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/model',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Model\n\t* Description: Represents a 3D model. The model contains bodies.\n\t*/\n\tJSM.Model = function ()\n\t{\n\t\tthis.bodies = [];\n\t\tthis.materials = new JSM.MaterialSet ();\n\t};\n\n\t/**\n\t* Function: Model.AddBody\n\t* Description: Adds a body to the model.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer} the index of the newly added body\n\t*/\n\tJSM.Model.prototype.AddBody = function (body)\n\t{\n\t\tthis.bodies.push (body);\n\t\treturn this.bodies.length - 1;\n\t};\n\n\t/**\n\t* Function: Model.AddBodies\n\t* Description: Adds bodies to the model.\n\t* Parameters:\n\t*\tbodies {Body[*]} the body\n\t*/\n\tJSM.Model.prototype.AddBodies = function (bodies)\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < bodies.length; i++) {\n\t\t\tbody = bodies[i];\n\t\t\tthis.AddBody (body);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Model.GetBody\n\t* Description: Returns the stored body with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.Model.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\t/**\n\t* Function: Model.BodyCount\n\t* Description: Returns the body count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.BodyCount = function ()\n\t{\n\t\treturn this.bodies.length;\n\t};\n\n\t/**\n\t* Function: Model.AddMaterial\n\t* Description: Adds a material to the mode.\n\t* Parameters:\n\t*\tmaterial {Material} the material\n\t* Returns:\n\t*\t{integer} the index of the newly added material\n\t*/\n\tJSM.Model.prototype.AddMaterial = function (material)\n\t{\n\t\treturn this.materials.AddMaterial (material);\n\t};\n\n\t/**\n\t* Function: Model.GetMaterial\n\t* Description: Returns a material from the model.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.Model.prototype.GetMaterial = function (index)\n\t{\n\t\treturn this.materials.GetMaterial (index);\n\t};\n\n\t/**\n\t* Function: Model.GetDefaultMaterial\n\t* Description: Returns the default material from the model. It is always exists.\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.Model.prototype.GetDefaultMaterial = function ()\n\t{\n\t\treturn this.materials.GetDefaultMaterial ();\n\t};\n\n\t/**\n\t* Function: Model.GetMaterialSet\n\t* Description: Returns the material set of the model.\n\t* Returns:\n\t*\t{MaterialSet} the result\n\t*/\n\tJSM.Model.prototype.GetMaterialSet = function ()\n\t{\n\t\treturn this.materials;\n\t};\n\n\t/**\n\t* Function: Model.Count\n\t* Description: Returns the material count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.MaterialCount = function ()\n\t{\n\t\treturn this.materials.Count ();\n\t};\n\n\t/**\n\t* Function: Model.VertexCount\n\t* Description: Returns the vertex count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.VertexCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tcount += this.bodies[i].VertexCount ();\n\t\t}\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: Model.PolygonCount\n\t* Description: Returns the polygon count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.PolygonCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tcount += this.bodies[i].PolygonCount ();\n\t\t}\n\t\treturn count;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/adjacencyinfo',[\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: VertInfo\n\t* Description:\n\t*\tContains adjacency information for a body vertex. Contains arrays\n\t*\twith indices of connected edge and polygon info.\n\t*/\n\tJSM.VertInfo = function ()\n\t{\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\n\t};\n\n\t/**\n\t* Class: EdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body edge. Contains indices\n\t*\tof connected vertex and polygon info.\n\t*/\n\tJSM.EdgeInfo = function ()\n\t{\n\t\tthis.vert1 = -1;\n\t\tthis.vert2 = -1;\n\t\tthis.pgon1 = -1;\n\t\tthis.pgon2 = -1;\n\t};\n\n\t/**\n\t* Class: PolyEdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon edge. Contains an index\n\t*\tof an existing edge, and a flag which defines its direction.\n\t*/\n\tJSM.PolyEdgeInfo = function ()\n\t{\n\t\tthis.index = -1;\n\t\tthis.reverse = false;\n\t};\n\n\t/**\n\t* Class: PgonInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon. Contains arrays\n\t*\twith indices of connected vertex and poly edge info.\n\t*/\n\tJSM.PgonInfo = function ()\n\t{\n\t\tthis.verts = [];\n\t\tthis.pedges = [];\n\t};\n\n\t/**\n\t* Class: AdjacencyInfo\n\t* Description:\n\t*\tContains adjacency information for a body. Contains arrays\n\t*\twith vertex, edge and polygon info.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo = function (body)\n\t{\n\t\tthis.verts = null;\n\t\tthis.edges = null;\n\t\tthis.pgons = null;\n\t\tthis.Calculate (body);\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.Reset\n\t* Description: Calculates the adjacency information for a body.\n\t* Returns:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo.prototype.Calculate = function (body)\n\t{\n\t\tfunction AddVertex (adjacencyInfo)\n\t\t{\n\t\t\tvar vert = new JSM.VertInfo ();\n\t\t\tadjacencyInfo.verts.push (vert);\n\t\t}\n\t\t\n\t\tfunction AddPolygon (adjacencyInfo, body, polygonIndex)\n\t\t{\n\t\t\tfunction AddEdge (adjacencyInfo, pgonInfo, fromVertexIndex, toVertexIndex, polygonIndex)\n\t\t\t{\n\t\t\t\tfunction ConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo)\n\t\t\t\t{\n\t\t\t\t\tfunction ConnectPgonAndEdgeToVert (vert, pgonIndex, edgeIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (vert.edges.indexOf (edgeIndex) == -1) {\n\t\t\t\t\t\t\tvert.edges.push (edgeIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vert.pgons.indexOf (pgonIndex) == -1) {\n\t\t\t\t\t\t\tvert.pgons.push (pgonIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpgonInfo.verts.push (fromVertexIndex);\n\t\t\t\t\tpgonInfo.pedges.push (pedge);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[fromVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[toVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar pedge = new JSM.PolyEdgeInfo ();\n\t\t\t\n\t\t\t\tvar i, edge;\n\t\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\t\tif (edge.vert1 === fromVertexIndex && edge.vert2 === toVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t\t} else if (edge.vert1 === toVertexIndex && edge.vert2 === fromVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pedge.index === -1) {\n\t\t\t\t\tvar newEdge = new JSM.EdgeInfo ();\n\t\t\t\t\tnewEdge.vert1 = fromVertexIndex;\n\t\t\t\t\tnewEdge.vert2 = toVertexIndex;\n\t\t\t\t\tnewEdge.pgon1 = polygonIndex;\n\t\t\t\t\tnewEdge.pgon2 = -1;\n\t\t\t\t\tadjacencyInfo.edges.push (newEdge);\n\t\t\t\t\t\n\t\t\t\t\tpedge.index = adjacencyInfo.edges.length - 1;\n\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t} else {\n\t\t\t\t\tvar currEdge = adjacencyInfo.edges[pedge.index];\n\t\t\t\t\tif (currEdge.pgon1 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon1 = polygonIndex;\n\t\t\t\t\t} else if (currEdge.pgon1 !== polygonIndex && currEdge.pgon2 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon2 = polygonIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo);\n\t\t\t}\n\n\t\t\tvar polygon = body.GetPolygon (polygonIndex);\n\t\t\tvar pgon = new JSM.PgonInfo ();\n\t\t\t\n\t\t\tvar i, curr, next;\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = polygon.GetVertexIndex (i);\n\t\t\t\tnext = polygon.GetVertexIndex (i < count - 1 ? i + 1 : 0);\n\t\t\t\tAddEdge (adjacencyInfo, pgon, curr, next, polygonIndex);\n\t\t\t}\n\t\t\tadjacencyInfo.pgons.push (pgon);\n\t\t}\n\n\t\tthis.verts = [];\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\t\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (this);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (this, body, i);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourVertex\n\t* Description: Returns if the vertex has contour edge.\n\t* Parameters:\n\t*\tvert {VertInfo} the vertex info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourVertex = function (vert)\n\t{\n\t\tvar i, edge;\n\t\tfor (i = 0; i < vert.edges.length; i++) {\n\t\t\tedge = vert.edges[i];\n\t\t\tif (this.IsContourEdge (this.edges[edge])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourEdge\n\t* Description: Returns if the edge has only one polygon neighbour.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourEdge = function (edge)\n\t{\n\t\tvar pgonCount = this.GetEdgePolygonCount (edge);\n\t\treturn pgonCount == 1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetEdgePolygonCount\n\t* Description: Returns the neighbour polygon count of the edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetEdgePolygonCount = function (edge)\n\t{\n\t\tvar pgonCount = 0;\n\t\tif (edge.pgon1 != -1) {\n\t\t\tpgonCount += 1;\n\t\t}\n\t\tif (edge.pgon2 != -1) {\n\t\t\tpgonCount += 2;\n\t\t}\n\t\treturn pgonCount;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetAnotherPgonOfEdge\n\t* Description: Returns the polygon index which is next to the given polygon along an edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t*\tcurrentPgon {integer} the polygon index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetAnotherPgonOfEdge = function (edge, pgon)\n\t{\n\t\tif (edge.pgon1 != -1 && edge.pgon1 != pgon) {\n\t\t\treturn edge.pgon1;\n\t\t} else if (edge.pgon2 != -1 && edge.pgon2 != pgon) {\n\t\t\treturn edge.pgon2;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeStartVertex\n\t* Description: Returns the start vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeStartVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeEndVertex\n\t* Description: Returns the end vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeEndVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t}\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexToPolygon\n\t* Description:\n\t*\tCalculates an array which contains array of the connected polygon\n\t*\tindices for all vertex indices in the body. The result is an\n\t*\tarray of array of polygon indices.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexToPolygon = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.push ([]);\n\t\t}\n\t\t\n\t\tvar polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tresult[polygon.GetVertexIndex (j)].push (i);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IsSolidBody\n\t* Description:\n\t*\tReturns if a given body is solid. It means that every\n\t*\tedges of the body has two polygon neighbours.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tif (adjacencyInfo.edges.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar i, edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CheckSolidBody\n\t* Description:\n\t*\tReturns if a given body solid body is correct. It means that every\n\t*\tedges of the body has two polygon neighbours, and there are no edge\n\t*\tin the body which appears twice with the same direction.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar i, j, edge, pedge, found, pgon1, pgon2, pgon1Reverse, pgon2Reverse;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon1 = adjacencyInfo.pgons[edge.pgon1];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon1.pedges.length; j++) {\n\t\t\t\tpedge = pgon1.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon1Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon2 = adjacencyInfo.pgons[edge.pgon2];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon2.pedges.length; j++) {\n\t\t\t\tpedge = pgon2.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon2Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (pgon1Reverse == pgon2Reverse) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraversePgonsAlongEdges\n\t* Description:\n\t*\tTraverses polygons along edges. The given callback function called on every\n\t*\tfound polygon. The return value of the callback means if the traverse should\n\t*\tcontinue along the edges of the current polygon.\n\t* Parameters:\n\t*\tpgonIndex {integer} the polygon index to start from\n\t*\tadjacencyInfo {AdjacencyInfo} the adjacency info\n\t*\tonPgonFound {function} the callback\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.TraversePgonsAlongEdges = function (pgonIndex, adjacencyInfo, onPgonFound)\n\t{\n\t\tfunction AddNeighboursToStack (pgonIndex, adjacencyInfo, pgonStack)\n\t\t{\n\t\t\tvar pgon = adjacencyInfo.pgons[pgonIndex];\n\t\t\tvar i, edge, anotherPgon;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[pgon.pedges[i].index];\n\t\t\t\tanotherPgon = adjacencyInfo.GetAnotherPgonOfEdge (edge, pgonIndex);\n\t\t\t\tif (anotherPgon != -1) {\n\t\t\t\t\tpgonStack.push (anotherPgon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar pgonIsProcessed = {};\n\t\tvar pgonStack = [pgonIndex];\n\t\tvar currentPgonIndex;\n\t\twhile (pgonStack.length > 0) {\n\t\t\tcurrentPgonIndex = pgonStack.pop ();\n\t\t\tif (pgonIsProcessed[currentPgonIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpgonIsProcessed[currentPgonIndex] = true;\n\t\t\tif (onPgonFound (currentPgonIndex)) {\n\t\t\t\tAddNeighboursToStack (currentPgonIndex, adjacencyInfo, pgonStack);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/bodyutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: AddVertexToBody\n\t* Description: Adds a vertex to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.AddVertexToBody = function (body, x, y, z)\n\t{\n\t\treturn body.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t};\n\n\t/**\n\t* Function: AddPointToBody\n\t* Description: Adds a point to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertex {integer} the vertex index stored in the body\n\t*/\n\tJSM.AddPointToBody = function (body, vertex)\n\t{\n\t\treturn body.AddPoint (new JSM.BodyPoint (vertex));\n\t};\n\n\t/**\n\t* Function: AddLineToBody\n\t* Description: Adds a line to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.AddLineToBody = function (body, beg, end)\n\t{\n\t\treturn body.AddLine (new JSM.BodyLine (beg, end));\n\t};\n\n\t/**\n\t* Function: AddPolygonToBody\n\t* Description: Adds a polygon to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.AddPolygonToBody = function (body, vertices)\n\t{\n\t\treturn body.AddPolygon (new JSM.BodyPolygon (vertices));\n\t};\n\n\t/**\n\t* Function: CheckBody\n\t* Description:\n\t*\tChecks if the body is correct. It means that every polygon has at least three\n\t*\tvertices, and every point, line and polygon vertex index is valid.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckBody = function (body)\n\t{\n\t\tvar vertexCount = body.VertexCount ();\n\t\tvar i, j, point, line, polygon;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tpoint = body.GetPoint (i);\n\t\t\tif (point.GetVertexIndex () < 0 || point.GetVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tline = body.GetLine (i);\n\t\t\tif (line.GetBegVertexIndex () < 0 || line.GetBegVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (line.GetEndVertexIndex () < 0 || line.GetEndVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tif (polygon.VertexIndexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tif (polygon.GetVertexIndex (j) < 0 || polygon.GetVertexIndex (j) >= vertexCount) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormal\n\t* Description: Calculates a normal vector for a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormal = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = body.GetVertexPosition (polygon.GetVertexIndex (currentIndex));\n\t\t\t\tnext = body.GetVertexPosition (polygon.GetVertexIndex (nextIndex));\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormals\n\t* Description: Calculates polygon normal vectors for all polygons stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*]} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculateBodyPolygonNormal (body, i));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexNormals\n\t* Description:\n\t*\tCalculates vertex normal vectors for all vertices stored in the body.\n\t*\tThe result is an array of array with vertex normal vectors.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar vertexToPolygon = null;\n\t\t\n\t\tvar i, j, k, polygon, normal;\n\t\tvar average, count, neighbourPolygons, neighbourPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tresult[i] = [];\n\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\tif (vertexToPolygon === null) {\n\t\t\t\t\tvertexToPolygon = JSM.CalculateBodyVertexToPolygon (body);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\taverage = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\t\tcount = 0;\n\t\t\t\t\t\n\t\t\t\t\tneighbourPolygons = vertexToPolygon[polygon.GetVertexIndex (j)];\n\t\t\t\t\tfor (k = 0; k < neighbourPolygons.length; k++) {\n\t\t\t\t\t\tneighbourPolygon = body.GetPolygon (neighbourPolygons[k]);\n\t\t\t\t\t\tif (neighbourPolygon.GetCurveGroup () === polygon.GetCurveGroup ()) {\n\t\t\t\t\t\t\taverage = JSM.CoordAdd (average, polygonNormals[neighbourPolygons[k]]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\taverage.MultiplyScalar (1.0 / count);\n\t\t\t\t\taverage.Normalize ();\n\t\t\t\t\tresult[i].push (average);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnormal = polygonNormals[i];\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tresult[i].push (new JSM.Vector (normal.x, normal.y, normal.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCurveGroups\n\t* Description: Calculates the curve groups for a given polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon|Polygon2D} the polygon\n\t*\tcurveAngle {number} the curve angle\n\t* Returns:\n\t*\t{integer[*]} the curve groups\n\t*/\n\tJSM.CalculatePolygonCurveGroups = function (polygon, curveAngle)\n\t{\n\t\tvar curveGroups = [];\n\t\tvar count = polygon.VertexCount ();\n\n\t\tvar i, prev;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurveGroups.push (0);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = curveGroups[polygon.GetPrevVertex (i)];\n\t\t\tif (polygon.GetVertexAngle (i) > curveAngle) {\n\t\t\t\tcurveGroups[i] = prev;\n\t\t\t} else {\n\t\t\t\tcurveGroups[i] = prev + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar firstGroup = curveGroups[0];\n\t\tvar lastGroup = curveGroups[count - 1];\n\t\tif (firstGroup === 0 && firstGroup != lastGroup) {\n\t\t\tfor (i = 0; curveGroups[i] == firstGroup; i++) {\n\t\t\t\tcurveGroups[i] = lastGroup;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curveGroups;\n\t};\n\n\n\t/**\n\t* Function: CalculatePolygonCentroid\n\t* Description: Calculates the centroid of a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculatePolygonCentroid = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\t\t\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult = JSM.CoordAdd (result, body.GetVertexPosition (polygon.GetVertexIndex (i)));\n\t\t}\n\t\t\n\t\tresult.MultiplyScalar (1.0 / count);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MakeBodyInsideOut\n\t* Description: Reverses all polygons orientation in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.MakeBodyInsideOut = function (body)\n\t{\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tpolygon.ReverseVertexIndices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: SoftMoveBodyVertex\n\t* Description: Moves a vertex and its nearby vertices depending on gaussian function.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the vertex index to move\n\t*\tradius {number} the radius of the movement\n\t*\tdirection {Vector} the direction of the movement\n\t*\tdistance {number} the distance of the movement\n\t*/\n\tJSM.SoftMoveBodyVertex = function (body, index, radius, direction, distance)\n\t{\n\t\tvar referenceCoord = body.GetVertexPosition (index).Clone ();\n\n\t\tvar eps = 0.00001;\n\t\tvar a = distance;\n\t\tvar b = 0.0;\n\t\tvar c = JSM.GetGaussianCParameter (radius, a, b, eps);\n\n\t\tvar i, currentDistance, newDistance;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tcurrentDistance = referenceCoord.DistanceTo (body.GetVertex (i).position);\n\t\t\tif (JSM.IsGreater (currentDistance, radius)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewDistance = JSM.GetGaussianValue (currentDistance, distance, b, c);\n\t\t\tbody.GetVertexPosition (i).Offset (direction, newDistance);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateWireBody\n\t* Description: Generates a body which contains only the lines from the given body.\n\t* Parameters:\n\t*\tbody {Body} the original body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateWireBody = function (body)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.AddVertex (body.GetVertex (i).Clone ());\n\t\t}\n\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tJSM.AddLineToBody (result, edge.vert1, edge.vert2);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangulateWithCentroids\n\t* Description:\n\t*\tTriangulates all polygons of the body by connecting all polygon\n\t*\tvertices with the centroid vertex of the polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulateWithCentroids = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, centroidCoord, centroidIndex, oldPolygon, oldVertexCount, polygon, curr, next;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tcentroidCoord = JSM.CalculatePolygonCentroid (body, i);\n\t\t\tcentroidIndex = body.AddVertex (new JSM.BodyVertex (centroidCoord));\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\toldVertexCount = oldPolygon.VertexIndexCount ();\n\t\t\tfor (j = 0; j < oldVertexCount; j++) {\n\t\t\t\tcurr = oldPolygon.GetVertexIndex (j);\n\t\t\t\tnext = oldPolygon.GetVertexIndex (j < oldVertexCount - 1 ? j + 1 : 0);\n\t\t\t\tpolygon = new JSM.BodyPolygon ([curr, next, centroidIndex]);\n\t\t\t\tpolygon.InheritAttributes (oldPolygon);\n\t\t\t\tbody.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangulatePolygons\n\t* Description: Triangulates all polygons of the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulatePolygons = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, oldPolygon, polygon, coord, triangleIndices, triangle, bodyTriangle;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\tpolygon = new JSM.Polygon ();\n\t\t\tfor (j = 0; j < oldPolygon.VertexIndexCount (); j++) {\n\t\t\t\tcoord = body.GetVertexPosition (oldPolygon.GetVertexIndex (j));\n\t\t\t\tpolygon.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\ttriangleIndices = JSM.TriangulatePolygon (polygon);\n\t\t\tif (triangleIndices !== null) {\n\t\t\t\tfor (j = 0; j < triangleIndices.length; j++) {\n\t\t\t\t\ttriangle = triangleIndices[j];\n\t\t\t\t\tbodyTriangle = new JSM.BodyPolygon ([\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[0]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[1]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[2])\n\t\t\t\t\t]);\n\t\t\t\t\tbodyTriangle.InheritAttributes (oldPolygon);\n\t\t\t\t\tbody.AddPolygon (bodyTriangle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateRandomMaterials\n\t* Description: Generates random materials for a body. A seed number can be specified.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\tseeded {boolean} seeded random generation\n\t*/\n\tJSM.GenerateRandomMaterials = function (body, materials, seeded)\n\t{\n\t\tfunction GetRandomInt (seeded, seed)\n\t\t{\n\t\t\tvar minColor = 0;\n\t\t\tvar maxColor = 16777215;\n\t\t\tvar color = 0;\n\t\t\tif (seeded !== undefined && seeded) {\n\t\t\t\tcolor = JSM.SeededRandomInt (minColor, maxColor, seed + 1);\n\t\t\t} else {\n\t\t\t\tcolor = JSM.RandomInt (minColor, maxColor);\n\t\t\t}\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tvar i, color, material;\n\t\tvar seed = 0;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetLine (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPoint (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPolygon (i).SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AddBodyToBSPTree\n\t* Description: Adds a body to a BSP tree.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tid {anything} the id for added polygons\n\t*/\n\tJSM.AddBodyToBSPTree = function (body, bspTree, id)\n\t{\n\t\tfunction ConvertBodyPolygonToPolygon (body, index, userData)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tuserData.material = polygon.GetMaterialIndex ();\n\t\t\tvar result = new JSM.Polygon ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar i, polygon, userData;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tuserData = {\n\t\t\t\tid : id,\n\t\t\t\toriginalPolygon : i,\n\t\t\t\tmaterial : -1\n\t\t\t};\n\t\t\tpolygon = ConvertBodyPolygonToPolygon (body, i, userData);\n\t\t\tbspTree.AddPolygon (polygon, userData);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/textureutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CalculatePlanarTextureCoord\n\t* Description: Calculates the planar texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculatePlanarTextureCoord = function (coord, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e1 = system.e1.Clone ().Normalize ();\n\t\tvar e2 = system.e2.Clone ().Normalize ();\n\t\tvar e3 = JSM.VectorCross (system.e1, system.e2);\n\n\t\tvar xyPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e3);\n\t\tvar xzPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e2);\n\t\tvar yzPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e1);\n\t\t\n\t\tvar projected = xyPlane.ProjectCoord (coord);\n\t\tresult.x = yzPlane.CoordSignedDistance (projected);\n\t\tresult.y = xzPlane.CoordSignedDistance (projected);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateCubicTextureCoord\n\t* Description: Calculates the cubic texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnormal {Vector} the normal vector for calculation\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculateCubicTextureCoord = function (coord, normal, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e1 = system.e1.Clone ().Normalize ();\n\t\tvar e2 = system.e2.Clone ().Normalize ();\n\t\tvar e3 = system.e3.Clone ().Normalize ();\n\n\t\tvar correctPlane = -1;\n\t\tvar maxProduct = 0.0;\n\t\t\n\t\tvar i, currentDirection, product;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (i === 0) {\n\t\t\t\tcurrentDirection = e1;\n\t\t\t} else if (i === 1) {\n\t\t\t\tcurrentDirection = e2;\n\t\t\t} else if (i === 2) {\n\t\t\t\tcurrentDirection = e3;\n\t\t\t}\n\n\t\t\tproduct = Math.abs (JSM.VectorDot (normal, currentDirection));\n\t\t\tif (JSM.IsGreater (product, maxProduct)) {\n\t\t\t\tcorrectPlane = i;\n\t\t\t\tmaxProduct = product;\n\t\t\t}\n\t\t}\n\n\t\tif (correctPlane === -1) {\n\t\t\treturn result;\n\t\t}\n\n\t\tvar planeSystem = null;\n\t\tif (correctPlane === 0) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te2,\n\t\t\t\te3,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t} else if (correctPlane === 1) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te1,\n\t\t\t\te3,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t} else if (correctPlane === 2) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te1,\n\t\t\t\te2,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t}\n\t\t\n\t\tif (planeSystem === null) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn JSM.CalculatePlanarTextureCoord (coord, planeSystem);\n\t};\n\n\t/**\n\t* Function: CalculateCylindricalTextureCoord\n\t* Description: Calculates the cylindrical texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnormal {Vector} the normal vector for calculation\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculateCylindricalTextureCoord = function (coord, normal, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e3Direction = system.e3.Clone ().Normalize ();\n\t\tif (e3Direction.IsCollinearWith (normal)) {\n\t\t\tresult = JSM.CalculateCubicTextureCoord (coord, normal, system);\n\t\t\treturn [result, 0.0];\n\t\t}\n\n\t\tvar baseLine = new JSM.Line (system.origo, e3Direction);\n\t\tvar projectedCoord = baseLine.ProjectCoord (coord);\n\t\tvar projectedDistance = JSM.CoordSignedDistance (system.origo, projectedCoord, e3Direction);\n\n\t\tvar e1Direction = system.e1.Clone ().Normalize ();\n\t\tvar coordDirection = JSM.CoordSub (coord, projectedCoord);\n\t\tvar angle = JSM.GetVectorsFullAngle (coordDirection, e1Direction, e3Direction);\n\t\tvar radius = system.e1.Length ();\n\n\t\tresult.x = angle * radius;\n\t\tresult.y = projectedDistance;\n\t\treturn [result, angle];\n\t};\n\n\t/**\n\t* Function: CalculatePolygonPlanarTextureCoords\n\t* Description: Calculates the planar texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonPlanarTextureCoords = function (body, index)\n\t{\n\t\tvar result = [];\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\tresult.push (JSM.CalculatePlanarTextureCoord (coord, system));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCubicTextureCoords\n\t* Description: Calculates the cubic texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t*\tnormal {Vector} the normal vector for calculation\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonCubicTextureCoords = function (body, index, normal)\n\t{\n\t\tvar result = [];\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\tresult.push (JSM.CalculateCubicTextureCoord (coord, normal, system));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCylindricalTextureCoords\n\t* Description: Calculates the cylindrical texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t*\tnormal {Vector} the normal vector for calculation\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonCylindricalTextureCoords = function (body, index, normal)\n\t{\n\t\tvar result = [];\n\t\tvar angles = [];\n\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, j, coord, textureValues;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\ttextureValues = JSM.CalculateCylindricalTextureCoord (coord, normal, system);\n\t\t\tresult.push (textureValues[0]);\n\t\t\tangles.push (textureValues[1]);\n\t\t}\n\n\t\tvar e3Direction = system.e3.Clone ().Normalize ();\n\t\tif (e3Direction.IsCollinearWith (normal)) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar needRepair = false;\n\t\tfor (i = 0; i < angles.length; i++) {\n\t\t\tfor (j = i + 1; j < angles.length; j++) {\n\t\t\t\tif (JSM.IsGreater (Math.abs (angles[i] - angles[j]), Math.PI)) {\n\t\t\t\t\tneedRepair = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needRepair) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (needRepair) {\n\t\t\tvar radius = system.e1.Length ();\n\t\t\tfor (i = 0; i < angles.length; i++) {\n\t\t\t\tif (JSM.IsLower (angles[i], Math.PI)) {\n\t\t\t\t\tresult[i].x = radius * (angles[i] + 2.0 * Math.PI);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPlanarTextureCoords\n\t* Description: Calculates the planar texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyPlanarTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculatePolygonPlanarTextureCoords (body, i));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyCubicTextureCoords\n\t* Description: Calculates the cubic texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyCubicTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar i, normal;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnormal = polygonNormals[i];\n\t\t\tresult.push (JSM.CalculatePolygonCubicTextureCoords (body, i, normal));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyCylindricalTextureCoords\n\t* Description: Calculates the cylindrical texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyCylindricalTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar i, normal;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnormal = polygonNormals[i];\n\t\t\tresult.push (JSM.CalculatePolygonCylindricalTextureCoords (body, i, normal));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyTextureCoords\n\t* Description:\n\t*\tCalculates the texture coordinates for a body. The result\n\t*\tis an array of arrays of texture coordinates.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar projection = body.GetTextureProjection ().GetType ();\n\t\tif (projection === JSM.TextureProjectionType.Planar) {\n\t\t\tresult = JSM.CalculateBodyPlanarTextureCoords (body);\n\t\t} else if (projection === JSM.TextureProjectionType.Cubic) {\n\t\t\tresult = JSM.CalculateBodyCubicTextureCoords (body);\n\t\t} else if (projection === JSM.TextureProjectionType.Cylindrical) {\n\t\t\tresult = JSM.CalculateBodyCylindricalTextureCoords (body);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/cututils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CutBodyByPlane\n\t* Description: Cuts a body by a plane.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CutBodyByPlane = function (body, plane)\n\t{\n\t\tfunction CutBodyPolygonByPlane (polygon, plane, indexTable)\n\t\t{\n\t\t\tfunction AddOriginalVertex (index, vertex, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\trawResult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\trawIndexTable.push (index);\n\t\t\t}\n\n\t\t\tfunction AddIntersectionVertex (from, to, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\tvar direction = JSM.CoordSub (polygon[to], polygon[from]).Normalize ();\n\t\t\t\tvar line = new JSM.Line (polygon[from], direction);\n\t\t\t\tvar intersection = plane.LineIntersection (line);\n\t\t\t\trawResult.push (new JSM.Coord (intersection.x, intersection.y, intersection.z));\n\t\t\t\trawIndexTable.push (-1);\n\t\t\t}\n\n\t\t\tvar hasIndexTable = (indexTable !== undefined && indexTable !== null);\n\t\t\tvar count = polygon.length;\n\t\t\tvar result = [];\n\t\t\tvar front = [];\n\t\t\t\n\t\t\tvar needCut = false;\n\t\t\tvar i, position, vertex;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tvertex = polygon[i];\n\t\t\t\tposition = plane.CoordPosition (vertex);\n\t\t\t\tfront.push (position !== JSM.CoordPlanePosition.CoordAtBackOfPlane);\n\t\t\t\tif (i > 0 && front[i - 1] !== front[i]) {\n\t\t\t\t\tneedCut = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!needCut) {\n\t\t\t\tif (front[0] === false) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\tvertex = polygon[i];\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tindexTable.push (i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tvar rawResult = [];\n\t\t\tvar rawIndexTable = [];\n\n\t\t\tvar from, to;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfrom = i - 1;\n\t\t\t\tto = i;\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tfrom = count - 1;\n\t\t\t\t}\n\n\t\t\t\tvertex = polygon[to];\n\t\t\t\tif (front[to]) {\n\t\t\t\t\tif (!front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t\tAddOriginalVertex (to, vertex, rawResult, rawIndexTable);\n\t\t\t\t} else {\n\t\t\t\t\tif (front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar currentVertex;\n\t\t\tvar currentIndex;\n\t\t\tvar lastVertex;\n\t\t\tvar lastIndex;\n\t\t\tfor (i = 0; i < rawResult.length; i++) {\n\t\t\t\tcurrentVertex = rawResult[i];\n\t\t\t\tlastVertex = result[result.length - 1];\n\t\t\t\tif (i === 0 || !lastVertex.IsEqual (currentVertex)) {\n\t\t\t\t\tresult.push (new JSM.Coord (currentVertex.x, currentVertex.y, currentVertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tindexTable.push (currentIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tlastIndex = rawIndexTable[i - 1];\n\t\t\t\t\t\tif (currentIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = currentIndex;\n\t\t\t\t\t\t} else if (lastIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = lastIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction GetInsertedVertexIndex (result, vertex, originalVertexCount)\n\t\t{\n\t\t\tvar index = -1;\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = originalVertexCount; i < result.VertexCount (); i++) {\n\t\t\t\tif (vertex.IsEqual (result.GetVertexPosition (i))) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (index === -1) {\n\t\t\t\tindex = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t\t\n\t\t\treturn index;\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar cuttedPolygons = [];\n\t\tvar cuttedIndexTables = [];\n\t\t\n\t\tvar remainsVertex = [];\n\t\tvar originalOldToNewIndex = [];\n\t\t\n\t\tvar i, j, polygon, polygon3D, vertexPosition;\n\t\tvar cuttedPolygon, indexTable;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\n\t\t\tpolygon3D = [];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tvertexPosition = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\tpolygon3D.push (new JSM.Coord (vertexPosition.x, vertexPosition.y, vertexPosition.z));\n\t\t\t}\n\t\t\t\n\t\t\tindexTable = [];\n\t\t\tcuttedPolygon = CutBodyPolygonByPlane (polygon3D, plane, indexTable);\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tremainsVertex[polygon.GetVertexIndex (indexTable[j])] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcuttedPolygons.push (cuttedPolygon);\n\t\t\tcuttedIndexTables.push (indexTable);\n\t\t}\n\n\t\tvar vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tif (remainsVertex[i]) {\n\t\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\t\toriginalOldToNewIndex[i] = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t}\n\n\t\tvar originalVertexCount = result.VertexCount ();\n\n\t\tvar newPolygon, newPolygonVertices;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tcuttedPolygon = cuttedPolygons[i];\n\t\t\tindexTable = cuttedIndexTables[i];\n\t\t\tif (indexTable.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewPolygonVertices = [];\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tnewPolygonVertices.push (originalOldToNewIndex[polygon.GetVertexIndex (indexTable[j])]);\n\t\t\t\t} else {\n\t\t\t\t\tvertex = cuttedPolygon[j];\n\t\t\t\t\tnewPolygonVertices.push (GetInsertedVertexIndex (result, vertex, originalVertexCount));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnewPolygon = new JSM.BodyPolygon (newPolygonVertices);\n\t\t\tnewPolygon.InheritAttributes (polygon);\n\t\t\tresult.AddPolygon (newPolygon);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/generator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateRectangle\n\t* Description: Generates a rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRectangle = function (xSize, ySize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, 0.0)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboid\n\t* Description: Generates a cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboid = function (xSize, ySize, zSize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboidSides\n\t* Description:\n\t*\tGenerates the specified sides of a cuboid. The last parameter is\n\t*\ta boolean array which defines sides visibility.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsides {boolean[]} sides visibility\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboidSides = function (xSize, ySize, zSize, sides)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tif (sides[0]) { result.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3])); }\n\t\tif (sides[1]) { result.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2])); }\n\t\tif (sides[2]) { result.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6])); }\n\t\tif (sides[3]) { result.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7])); }\n\t\tif (sides[4]) { result.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1])); }\n\t\tif (sides[5]) { result.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7])); }\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedRectangle\n\t* Description:\tGenerates a segmented rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\txSegmentation {integer} segmentation along x side\n\t*\tySegmentation {integer} segmentation along y side\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedRectangle = function (xSize, ySize, xSegmentation, ySegmentation)\n\t{\n\t\tfunction AddVertices ()\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, 0.0);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons ()\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar xSegment = xSize / xSegmentation;\n\t\tvar ySegment = ySize / ySegmentation;\n\t\t\n\t\tAddVertices ();\n\t\tAddPolygons ();\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedCuboid\n\t* Description:\tGenerates a segmented cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsegmentation {integer} segmentation of the sides\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedCuboid = function (xSize, ySize, zSize, segmentation)\n\t{\n\t\tfunction GetLevelOffset (level)\n\t\t{\n\t\t\tvar offset = 0;\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\toffset = (segmentation + 1) * (segmentation + 1) + (level - 1) * (segmentation * 4);\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction GetLevelSideVertices (level)\n\t\t{\n\t\t\tvar i;\n\t\t\t\n\t\t\tvar vertices = [];\n\t\t\tvar offset = GetLevelOffset (level);\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + (i + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (segmentation + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + i * (segmentation + 1));\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (3 * segmentation) + i - 1);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn vertices;\n\t\t}\n\n\t\tfunction AddVertices (level)\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tvar zCoord = level * zSegment;\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tif (i === 0 || i === segmentation || j === 0 || j === segmentation) {\n\t\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (level)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tvar offset = GetLevelOffset (level);\n\t\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\t\t\tcurrent = offset + i * (segmentation + 1) + j;\n\t\t\t\t\t\tnext = current + 1;\n\t\t\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, top, ntop, next]));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\tvar prevSideVertices = levelSideVertices [level - 1];\n\t\t\t\tvar currSideVertices = levelSideVertices [level];\n\t\t\t\tfor (i = 0; i < segmentation * 4; i++) {\n\t\t\t\t\tcurrent = prevSideVertices[i];\n\t\t\t\t\ttop = currSideVertices[i];\n\t\t\t\t\tif (i < segmentation * 4 - 1) {\n\t\t\t\t\t\tnext = prevSideVertices[i + 1];\n\t\t\t\t\t\tntop = currSideVertices[i + 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = prevSideVertices[0];\n\t\t\t\t\t\tntop = currSideVertices[0];\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar zStart = zSize / 2.0;\n\t\t\n\t\tvar xSegment = xSize / segmentation;\n\t\tvar ySegment = ySize / segmentation;\n\t\tvar zSegment = zSize / segmentation;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddVertices (i);\n\t\t}\n\t\t\n\t\tvar levelSideVertices = [];\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tlevelSideVertices.push (GetLevelSideVertices (i));\n\t\t}\n\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddPolygons (i);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCircle\n\t* Description:\tGenerates a circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {integer} the segmentation of the circle\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCircle = function (radius, segmentation)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar circlePoints = JSM.GenerateCirclePoints (radius, segmentation);\n\t\tvar i;\n\t\tfor (i = 0; i < circlePoints.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (circlePoints[i]));\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\ttopPolygon.AddVertexIndex (i);\n\t\t}\n\t\tresult.AddPolygon (topPolygon);\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSphere\n\t* Description: Generates a sphere.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\tsegmentation {integer} the segmentation of the sphere\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSphere = function (radius, segmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar segments = segmentation;\n\t\tvar circle = segments * 2;\n\n\t\tvar topIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, 0.0, 0.0)));\n\t\tvar step = Math.PI / segments;\n\t\tvar theta = step;\n\t\t\n\t\tvar i, j, phi;\n\t\tfor (i = 1; i < segments; i++) {\n\t\t\tphi = 0;\n\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, theta, phi)));\n\t\t\t\tphi += step;\n\t\t\t}\n\t\t\ttheta += step;\n\t\t}\n\t\tvar bottomIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (-radius, 0.0, 0.0)));\n\n\t\tvar offset, current, next, top, ntop, polygon;\n\t\tfor (i = 1; i <= segments; i++) {\n\t\t\tif (i === 1) {\n\t\t\t\toffset = 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, topIndex]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i < segments) {\n\t\t\t\toffset = (i - 1) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current - circle;\n\t\t\t\t\tntop = top + 1;\n\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t\tntop = offset - circle;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i === segments) {\n\t\t\t\toffset = (i - 2) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, bottomIndex, next]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTriangulatedSphere\n\t* Description: Generates a sphere from triangles.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\titerations {integer} the iteration number\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriangulatedSphere = function (radius, iterations, isCurved)\n\t{\n\t\tfunction GenerateIcosahedron () {\n\t\t\tvar result = new JSM.Body ();\n\n\t\t\tvar a = 1.0;\n\t\t\tvar b = 0.0;\n\t\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 9, 2]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 10, 3]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 9, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 10, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [4, 8, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [6, 11, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [5, 10, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [7, 9, 11]);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tvar result = GenerateIcosahedron ();\n\t\t\n\t\tvar currentRadius = result.GetVertexPosition (0).Length ();\n\t\tvar scale = radius / currentRadius;\n\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t}\n\t\t\n\t\tvar iteration, oldVertexCoord, oldBody, adjacencyInfo;\n\t\tvar currentEdge, edgeVertexIndices;\n\t\tvar currentPgon, polygonVertexIndices;\n\t\tvar edgeCoord, currentPolyEdge;\n\t\tfor (iteration = 0; iteration < iterations; iteration++) {\n\t\t\toldBody = result;\n\t\t\t\n\t\t\tresult = new JSM.Body ();\n\t\t\tadjacencyInfo = new JSM.AdjacencyInfo (oldBody);\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\toldVertexCoord = oldBody.GetVertexPosition (i);\n\t\t\t\tJSM.AddVertexToBody (result, oldVertexCoord.x, oldVertexCoord.y, oldVertexCoord.z);\n\t\t\t}\n\t\t\t\n\t\t\tedgeVertexIndices = [];\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tcurrentEdge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (oldBody.GetVertexPosition (currentEdge.vert1), oldBody.GetVertexPosition (currentEdge.vert2));\n\t\t\t\tedgeVertexIndices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord.SetLength (radius))));\n\t\t\t}\n\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tcurrentPgon = adjacencyInfo.pgons[i];\n\t\t\t\tpolygonVertexIndices = [];\n\t\t\t\tfor (j = 0; j < currentPgon.pedges.length; j++) {\n\t\t\t\t\tcurrentPolyEdge = currentPgon.pedges[j];\n\t\t\t\t\tpolygonVertexIndices.push (adjacencyInfo.GetPolyEdgeStartVertex (currentPolyEdge));\n\t\t\t\t\tpolygonVertexIndices.push (edgeVertexIndices[currentPolyEdge.index]);\n\t\t\t\t}\n\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[0], polygonVertexIndices[1], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[2], polygonVertexIndices[3]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[3], polygonVertexIndices[4], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[3], polygonVertexIndices[5]]);\n\t\t\t}\n\t\t}\n\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < result.PolygonCount (); i++) {\n\t\t\t\tresult.GetPolygon (i).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinder\n\t* Description: Generates a cylinder.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinder = function (radius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePie\n\t* Description: Generates a pie.\n\t* Parameters:\n\t*\tradius {number} the radius of the pie\n\t*\theight {number} the height of the pie\n\t*\tangle {number} the angle of the pie\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePie = function (radius, height, angle, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = angle;\n\t\tvar step = angle / (segments - 1);\n\t\t\n\t\tvar i;\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i <= segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved && i > 0 && i < segments) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i <= segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCone\n\t* Description: Generates a cone.\n\t* Parameters:\n\t*\ttopRadius {number} the top radius of the cone\n\t*\tbottomRadius {number} the bottom radius of the cone\n\t*\theight {number} the height of the cone\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCone = function (topRadius, bottomRadius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar topDegenerated = (JSM.IsZero (topRadius));\n\t\tvar bottomDegenerated = (JSM.IsZero (bottomRadius));\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\n\t\tif (topDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\t}\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (!topDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (topRadius, height / 2.0, theta)));\n\t\t\t}\n\t\t\tif (!bottomDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (bottomRadius, -height / 2.0, theta)));\n\t\t\t}\n\t\t\ttheta -= step;\n\t\t}\n\t\tif (bottomDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tcurrent = i + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 1;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([0, next, current]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\tcurrent = i;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, segments]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else {\n\t\t\t\tcurrent = 2 * i;\n\t\t\t\tnext = current + 2;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tvar topPolygon, bottomPolygon;\n\t\tif (withTopAndBottom) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\tbottomPolygon.AddVertexIndex (i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (segments - i - 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t} else {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t}\n\t\t}\n\n\t\tvar avgRadius = (topRadius + bottomRadius) / 2.0;\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), avgRadius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismGeometry\n\t* Description: Generates a prism defined by bottom and top vertices polygon.\n\t* Parameters:\n\t*\tbottomVertices {Coord[*]} bottom vertices\n\t*\ttopVertices {Coord[*]} top vertices\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismGeometry = function (bottomVertices, topVertices, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = bottomVertices.length;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (bottomVertices[i].Clone ()));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (topVertices[i].Clone ()));\n\t\t}\n\n\t\tvar current, next, bodyPolygon;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * (count - i - 1));\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismFromPolygon\n\t* Description: Generates a prism defined by a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the base polygon\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismFromPolygon = function (polygon, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i, vertex;\n\t\tvar count = polygon.VertexCount ();\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tbottomVertices.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\ttopVertices.push (new JSM.Coord (vertex.x, vertex.y, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = bottomVertices[0].Clone ();\n\t\tvar firtVertex = bottomVertices[1].Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrism\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The base polygon is an array\n\t*\tof coordinates which will be offseted in the given direction.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrism = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.FromArray (basePolygon);\n\t\tvar count = polygon.VertexCount ();\n\n\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tbottomVertices.push (polygon.GetVertex (i).Clone ());\n\t\t\ttopVertices.push (polygon.GetVertex (i).Clone ().Offset (direction, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\t\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = polygon.GetVertex (0).Clone ();\n\t\tvar firtVertex = polygon.GetVertex (1).Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismWithHole\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The polygon can contain null\n\t*\tvalues which defines the end of the current contour. The holes have\n\t*\tto be in reversed orientation than the main contour.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon which can contain null values\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismWithHole = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction AddVertices (contourPolygon, direction, height, result)\n\t\t{\n\t\t\tvar i, j, contour, vertex1, vertex2;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex1 = contour.GetVertex (j).Clone ();\n\t\t\t\t\tvertex2 = contour.GetVertex (j).Clone ().Offset (direction, height);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex1));\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddContours (contourPolygon, contourOffsets, curveAngle, result)\n\t\t{\n\t\t\tvar offset = 0;\n\n\t\t\tvar i, j, contour, vertexCount, current, next, bodyPolygon, curveGroups;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tcurveGroups = null;\n\t\t\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\t\t\tcurveGroups = JSM.CalculatePolygonCurveGroups (contour, curveAngle);\n\t\t\t\t}\t\t\n\t\t\t\tvertexCount = contour.VertexCount ();\n\t\t\t\tcontourOffsets.push (offset);\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tcurrent = 2 * offset + 2 * j;\n\t\t\t\t\tnext = current + 2;\n\t\t\t\t\tif (j == vertexCount - 1) {\n\t\t\t\t\t\tnext = 2 *  offset;\n\t\t\t\t\t}\n\t\t\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\t\tif (curveGroups !== null) {\n\t\t\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t\t\t}\n\t\t\t\toffset += vertexCount;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddTopBottomPolygons (contourPolygon, contourOffsets)\n\t\t{\n\t\t\tvar vertexMap = [];\n\t\t\tvar contourPolygon2D = contourPolygon.ToContourPolygon2D ();\n\t\t\tvar simplePolygon = JSM.ConvertContourPolygonToPolygon2D (contourPolygon2D, vertexMap);\n\t\t\tif (simplePolygon === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar triangles = JSM.TriangulatePolygon2D (simplePolygon);\n\t\t\tif (triangles === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, j, triangle, mapValue;\n\t\t\tvar topTriangle, bottomTriangle;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\ttriangle = triangles[i];\n\t\t\t\ttopTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\tmapValue = vertexMap[triangle[j]];\n\t\t\t\t\ttopTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1] + 1);\n\t\t\t\t\tmapValue = vertexMap[triangle[2 - j]];\n\t\t\t\t\tbottomTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1]);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topTriangle);\n\t\t\t\tresult.AddPolygon (bottomTriangle);\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar contourOffsets = [];\n\t\tvar contourPolygon = new JSM.ContourPolygon ();\n\t\tcontourPolygon.FromArray (basePolygon);\n\t\tAddVertices (contourPolygon, direction, height, result);\n\t\tAddContours (contourPolygon, contourOffsets, curveAngle, result);\n\n\t\tif (withTopAndBottom) {\n\t\t\tAddTopBottomPolygons (contourPolygon, contourOffsets);\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismsFromPath2D\n\t* Description: Generates a prism from the given path.\n\t* Parameters:\n\t*\tpath {Path2D} the path\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body[*]} the result\n\t*/\n\tJSM.GeneratePrismsFromPath2D = function (path, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction GetPrismPolygon (polygon)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i, j, contour, vertex;\n\t\t\tfor (i = 0; i < polygon.ContourCount (); i++) {\n\t\t\t\tcontour = polygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\t\t}\n\t\t\t\tif (i < polygon.ContourCount () - 1) {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar bodies = [];\n\t\tvar polygons = path.GetPolygons ();\n\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygon = polygons[i];\n\t\t\tif (polygon.ContourCount () === 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrism (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t} else if (polygon.ContourCount () > 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrismWithHole (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t}\n\t\t}\n\t\treturn bodies;\n\t};\n\n\t/**\n\t* Function: GeneratePrismShell\n\t* Description: Generates a prism with the given width of sides.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismShell = function (basePolygon, direction, height, width, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolygon.length;\n\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygon[i]));\n\t\t}\n\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.vertices = basePolygon;\n\t\tvar offsetedPolygon = JSM.OffsetPolygonContour (polygon, width);\n\t\tvar innerBasePolygon = offsetedPolygon.vertices;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolygon[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar curr, next, top, ntop;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t\tntop = 2 * count;\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t\tntop = count;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinderShell\n\t* Description: Generates a cylinder with the given width of sides.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\twidth {number} the width of the cylinder sides\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinderShell = function (radius, height, width, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tfunction GenerateCircle (radius, segmentation, bottom)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar step = 2.0 * Math.PI / segmentation;\n\t\t\tvar theta, cartesian;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttheta = i * step;\n\t\t\t\tcartesian = JSM.PolarToCartesian (radius, theta);\n\t\t\t\tresult.push (new JSM.Coord (cartesian.x, cartesian.y, bottom));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar circle = GenerateCircle (radius, segmentation, -height / 2.0);\n\t\tvar result = JSM.GeneratePrismShell (circle, normal, height, width, withTopAndBottom);\n\t\t\n\t\tvar i;\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\tresult.GetPolygon (2 * i).SetCurveGroup (0);\n\t\t\t\tresult.GetPolygon (2 * i + 1).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateLineShell\n\t* Description: Generates a polyline with width and height.\n\t* Parameters:\n\t*\tbasePolyLine {Coord[*]} the base polyline\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the shell\n\t*\twidth {number} the width of the shell\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLineShell = function (basePolyLine, direction, height, width, withStartAndEnd, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolyLine.length;\n\n\t\tvar angles = [];\n\t\t\n\t\tvar i, prev, curr, next;\n\t\tvar prevDir, nextDir, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (i === 0 || i === count - 1) {\n\t\t\t\tangle = Math.PI / 2.0;\n\t\t\t} else {\n\t\t\t\tprev = i - 1;\n\t\t\t\tcurr = i;\n\t\t\t\tnext = i + 1;\n\n\t\t\t\tnextDir = JSM.CoordSub (basePolyLine[next], basePolyLine[curr]);\n\t\t\t\tprevDir = JSM.CoordSub (basePolyLine[prev], basePolyLine[curr]);\n\t\t\t\tangle = nextDir.AngleTo (prevDir) / 2.0;\n\t\t\t\tif (JSM.CoordOrientation (basePolyLine[prev], basePolyLine[curr], basePolyLine[next], direction) == JSM.Orientation.Clockwise) {\n\t\t\t\t\tangle = Math.PI - angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tangles.push (angle);\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0, 0, 1);\n\t\tvar innerBasePolyLine = [];\n\t\tvar distance, innerCoord, offsetDirection;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tif (i === count - 1) {\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr - 1], basePolyLine[curr]);\n\t\t\t} else {\n\t\t\t\tnext = (i + 1) % count;\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr], basePolyLine[next]);\n\t\t\t}\n\n\t\t\tangle = angles[curr];\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\tinnerCoord = basePolyLine[curr].Clone ();\n\t\t\tinnerCoord.Offset (offsetDirection, distance);\n\t\t\tinnerCoord.Rotate (normal, -(Math.PI - angle), basePolyLine[curr]);\n\t\t\tinnerBasePolyLine.push (innerCoord);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolyLine[i]));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolyLine[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar top, ntop;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tcurr = 0;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\n\t\t\tcurr = count - 1;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolyLine[1], basePolyLine[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolyLine[0].x, basePolyLine[0].y, basePolyLine[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTorus\n\t* Description: Generates a torus.\n\t* Parameters:\n\t*\touterRadius {number} the outer radius of the torus\n\t*\tinnerRadius {number} the inner radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tinnerSegmentation {integer} the inner segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTorus = function (outerRadius, innerRadius, outerSegmentation, innerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar theta = 0.0;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = JSM.PolarToCartesian (innerRadius, theta);\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePolyTorus\n\t* Description: Generates a torus with a polygon cross section.\n\t* Parameters:\n\t*\tbasePolygon {Coord2D[*]} the cross section polygon of the torus\n\t*\touterRadius {number} the outer radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePolyTorus = function (basePolygon, outerRadius, outerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar innerSegmentation = basePolygon.length;\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = basePolygon[i];\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (j);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectors\n\t* Description: Generates a ruled surface between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectors = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateGrid\n\t* Description: Generates a planar grid.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\tySize {number} the y size\n\t*\txSegmentation {integer} the segmentation along x axis\n\t*\tySegmentation {integer} the segmentation along y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGrid = function (xSize, ySize, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tvar xSector = new JSM.Sector (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (xSize, 0.0, 0.0));\n\t\tvar ySector = new JSM.Sector (new JSM.Coord (0.0, ySize, 0.0), new JSM.Coord (xSize, ySize, 0.0));\n\t\treturn JSM.GenerateRuledFromSectors (xSector, ySector, xSegmentation, ySegmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateSquareGrid\n\t* Description: Generates a planar square grid.\n\t* Parameters:\n\t*\tsize {number} the size\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSquareGrid = function (size, segmentation, isCurved)\n\t{\n\t\treturn JSM.GenerateGrid (size, size, segmentation, segmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectorsWithHeight\n\t* Description: Generates a ruled surface with height between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\theight {height} the height\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectorsWithHeight = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved, height)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\t\t\n\t\tvar topVertexCount = result.VertexCount ();\n\n\t\tvar newVertex, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tnewVertex = new JSM.Coord (vertex.x, vertex.y, vertex.z);\n\t\t\tnewVertex.z -= height;\n\t\t\tresult.AddVertex (new JSM.BodyVertex (newVertex));\n\t\t}\n\n\t\tvar j, newpolygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tnewpolygonVertexIndices = [];\n\t\t\tfor (j = polygonVertexIndices.length - 1; j >= 0; j--) {\n\t\t\t\tnewpolygonVertexIndices.push (polygonVertexIndices[j] + topVertexCount);\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon (newpolygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tvar current, next, top, ntop;\n\t\t\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + (lineSegmentation * (meshSegmentation + 1)) + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = i * (meshSegmentation + 1) + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = (i + 1) * meshSegmentation + i + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromCoords\n\t* Description:\n\t*\tGenerates a ruled surface between two coordinate arrays.\n\t*\tThe two arrays should have the same length.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromCoords = function (aCoords, bCoords, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tvertices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (vertices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRevolved\n\t* Description:\n\t*\tGenerates a revolved surface by rotating a polyline around a given axis.\n\t*\tIf the angle is 360 degree, it can generate top and bottom polygons.\n\t* Parameters:\n\t*\tpolyLine {Coord[*]} the polyline\n\t*\taxis {Sector} the axis\n\t*\tangle {number} the angle\n\t*\tsegmentation {integer} the segmentation\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveMode {string} 'None', 'CurveSegments', or 'CurveAll'\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRevolved = function (polyLine, axis, angle, segmentation, withTopAndBottom, curveMode)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar circular = JSM.IsEqual (angle, 2.0 * Math.PI);\n\n\t\tvar count = polyLine.length;\n\t\tvar step = angle / segmentation;\n\t\tvar axisDir = JSM.CoordSub (axis.end, axis.beg);\n\t\t\n\t\tvar i, j, rotated;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\tif (circular && j === segmentation) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trotated = polyLine[i].Clone ().Rotate (axisDir, j * step, axis.beg);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar curveModeFlag = 0;\n\t\tif (curveMode == 'CurveSegments') {\n\t\t\tcurveModeFlag = 1;\n\t\t} else if (curveMode == 'CurveAll') {\n\t\t\tcurveModeFlag = 2;\n\t\t}\n\t\t\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\tcurrent = i * (segmentation + 1) + j;\n\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tif (circular) {\n\t\t\t\t\tcurrent = i * segmentation + j;\n\t\t\t\t\ttop = current + segmentation;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tif (j === segmentation - 1) {\n\t\t\t\t\t\tnext = i * segmentation;\n\t\t\t\t\t\tntop = (i + 1) * segmentation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (curveModeFlag == 1) {\n\t\t\t\t\tpolygon.SetCurveGroup (i);\n\t\t\t\t} else if (curveModeFlag == 2) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tif (circular && withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (segmentation * (count - 1) + i);\n\t\t\t\tbottomPolygon.AddVertexIndex (segmentation - i - 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tvar axisNormalDir = axisDir.Clone ().Normalize ();\n\t\tvar axisLine = new JSM.Line (axis.beg, axisNormalDir);\n\t\tvar avgRadius = 0.0;\n\t\tvar projected;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprojected = axisLine.ProjectCoord (polyLine[i]);\n\t\t\tavgRadius = avgRadius + projected.DistanceTo (polyLine[i]);\n\t\t}\n\t\tavgRadius = avgRadius / count;\n\t\t\n\t\tvar origo = new JSM.Coord (axis.beg.x, axis.beg.y, axis.beg.z);\n\t\tvar baseLine = new JSM.Line (origo, axisDir);\n\t\tvar projectedToBaseLine = baseLine.ProjectCoord (polyLine[0]);\n\t\tvar xDirection = JSM.CoordSub (polyLine[0], projectedToBaseLine).Normalize ();\n\t\t\n\t\tresult.SetCylindricalTextureProjection (origo, avgRadius, xDirection, axisNormalDir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTube\n\t* Description:\n\t*\tGenerates a tube from a given array of polygons. All of the\n\t*\tpolygons should have same number of vertices.\n\t* Parameters:\n\t*\tbasePolygons {Coord[*][*]} the array of polygons\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTube = function (basePolygons, withStartAndEnd)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar contourCount = basePolygons.length;\n\t\tvar count = basePolygons[0].length;\n\n\t\tvar i, j;\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tfor (i = 0; i < contourCount; i++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygons[i][j]));\n\t\t\t}\n\t\t}\n\n\t\tvar current, next;\n\t\tfor (j = 0; j < contourCount - 1; j++) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = j + contourCount * i;\n\t\t\t\tnext = current + contourCount;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, next + 1, current + 1]));\n\t\t\t}\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (contourCount * i + contourCount - 1);\n\t\t\t}\n\t\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\t\tbottomPolygon.AddVertexIndex (contourCount * i);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurface\n\t* Description: Generates the surface of a given function.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurface = function (function3D, intervalMin, intervalMax, segmentation, isCurved)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMin.y, 0.0), new JSM.Coord (intervalMax.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMax.y, 0.0), new JSM.Coord (intervalMax.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectors (aSector, bSector, segmentation, segmentation, isCurved);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurfaceSolid\n\t* Description: Generates the surface of a given function with a solid body.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tbottomZ {number} the bottom z coordinate of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurfaceSolid = function (function3D, intervalMin, intervalMax, segmentation, isCurved, bottomZ)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMin.y, 0.0), new JSM.Coord (intervalMin.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMax.y, 0.0), new JSM.Coord (intervalMin.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectorsWithHeight (aSector, bSector, segmentation, segmentation, isCurved, bottomZ);\n\n\t\tvar i, coord;\n\t\tvar topVertexCount = (segmentation + 1) * (segmentation + 1);\n\t\tfor (i = 0; i < topVertexCount; i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/camera',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Camera\n\t* Description: Represents a camera.\n\t* Parameters:\n\t*\teye {Coord} the eye position\n\t*\tcenter {Coord} the center position\n\t*\tup {Vector} the up vector\n\t*\tfieldOfView {number} field of view in degree\n\t*\tnearClippingPlane {number} near clipping plane distance\n\t*\tfarClippingPlane {number} far clipping plane distance\n\t*/\n\tJSM.Camera = function (eye, center, up, fieldOfView, nearClippingPlane, farClippingPlane)\n\t{\n\t\tthis.eye = JSM.ValueOrDefault (eye, new JSM.Coord (1.0, 1.0, 1.0));\n\t\tthis.center = JSM.ValueOrDefault (center, new JSM.Coord (0.0, 0.0, 0.0));\n\t\tthis.up = JSM.ValueOrDefault (up, new JSM.Vector (0.0, 0.0, 1.0));\n\t\tthis.fieldOfView = JSM.ValueOrDefault (fieldOfView, 45.0);\n\t\tthis.nearClippingPlane = JSM.ValueOrDefault (nearClippingPlane, 0.1);\n\t\tthis.farClippingPlane = JSM.ValueOrDefault (farClippingPlane, 1000.0);\n\t};\n\n\t/**\n\t* Function: Camera.Set\n\t* Description: Sets the camera.\n\t* Parameters:\n\t*\teye {Coord} the eye position\n\t*\tcenter {Coord} the center position\n\t*\tup {Vector} the up vector\n\t*\tfieldOfView {number} field of view in degree\n\t*\tnearClippingPlane {number} near clipping plane distance\n\t*\tfarClippingPlane {number} far clipping plane distance\n\t*/\n\tJSM.Camera.prototype.Set = function (eye, center, up, fieldOfView, nearClippingPlane, farClippingPlane)\n\t{\n\t\tthis.eye = eye;\n\t\tthis.center = center;\n\t\tthis.up = up;\n\t\tthis.fieldOfView = JSM.ValueOrDefault (fieldOfView, 45.0);\n\t\tthis.nearClippingPlane = JSM.ValueOrDefault (nearClippingPlane, 0.1);\n\t\tthis.farClippingPlane = JSM.ValueOrDefault (farClippingPlane, 1000.0);\n\t};\n\n\t/**\n\t* Function: Camera.Clone\n\t* Description: Clones the camera.\n\t* Returns:\n\t*\t{Camera} a cloned instance\n\t*/\n\tJSM.Camera.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Camera ();\n\t\tresult.eye = this.eye;\n\t\tresult.center = this.center;\n\t\tresult.up = this.up;\n\t\tresult.fieldOfView = this.fieldOfView;\n\t\tresult.nearClippingPlane = this.nearClippingPlane;\n\t\tresult.farClippingPlane = this.farClippingPlane;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/explode',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ExplodeBody\n\t* Description:\n\t*\tExplodes a body to primitives. The function calls callback functions\n\t*\ton geometry start and end, and when a triangle or a line is created.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\texplodeData {object} the parameters and callback functions of explode\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ExplodeBody = function (body, materials, explodeData)\n\t{\n\t\tfunction SeparateByMaterial (materials, itemsByMaterial, itemsWithNoMaterial, callbacks)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\titemsByMaterial.push ([]);\n\t\t\t}\n\n\t\t\tvar itemCount = callbacks.itemCount ();\n\t\t\tvar material;\n\t\t\tfor (i = 0; i < itemCount; i++) {\n\t\t\t\tmaterial = callbacks.getMaterial (i);\n\t\t\t\tif (material !== -1) {\n\t\t\t\t\titemsByMaterial[material].push (i);\n\t\t\t\t} else {\n\t\t\t\t\titemsWithNoMaterial.push (i);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\tfunction ExplodePoints (body, materials, explodeData)\n\t\t{\n\t\t\tfunction ExplodePointsByMaterial (pointIndices, materialIndex, explodeData)\n\t\t\t{\n\t\t\t\tif (pointIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onPointGeometryStart !== undefined && explodeData.onPointGeometryStart !== null) {\n\t\t\t\t\texplodeData.onPointGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onPoint !== undefined && explodeData.onPoint !== null) {\n\t\t\t\t\tvar i, point, vertex;\n\t\t\t\t\tfor (i = 0; i < pointIndices.length; i++) {\n\t\t\t\t\t\tpoint = body.GetPoint (pointIndices[i]);\n\t\t\t\t\t\tvertex = body.GetVertexPosition (point.GetVertexIndex ());\n\t\t\t\t\t\texplodeData.onPoint (vertex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onPointGeometryEnd !== undefined && explodeData.onPointGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onPointGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.PointCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pointsByMaterial = [];\n\t\t\tvar pointsWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, pointsByMaterial, pointsWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.PointCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar point = body.GetPoint (index);\n\t\t\t\t\treturn point.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar i;\t\t\n\t\t\tfor (i = 0; i < pointsByMaterial.length; i++) {\n\t\t\t\tExplodePointsByMaterial (pointsByMaterial[i], i, explodeData);\n\t\t\t}\n\t\t\tExplodePointsByMaterial (pointsWithNoMaterial, -1, explodeData);\n\t\t}\n\n\t\tfunction ExplodeLines (body, materials, explodeData)\n\t\t{\n\t\t\tfunction ExplodeLinesByMaterial (lineIndices, materialIndex, explodeData)\n\t\t\t{\n\t\t\t\tif (lineIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onLineGeometryStart !== undefined && explodeData.onLineGeometryStart !== null) {\n\t\t\t\t\texplodeData.onLineGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onLine !== undefined && explodeData.onLine !== null) {\n\t\t\t\t\tvar i, line, beg, end;\n\t\t\t\t\tfor (i = 0; i < lineIndices.length; i++) {\n\t\t\t\t\t\tline = body.GetLine (lineIndices[i]);\n\t\t\t\t\t\tbeg = body.GetVertexPosition (line.GetBegVertexIndex ());\n\t\t\t\t\t\tend = body.GetVertexPosition (line.GetEndVertexIndex ());\n\t\t\t\t\t\texplodeData.onLine (beg, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onLineGeometryEnd !== undefined && explodeData.onLineGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onLineGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.LineCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar linesByMaterial = [];\n\t\t\tvar linesWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, linesByMaterial, linesWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.LineCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar line = body.GetLine (index);\n\t\t\t\t\treturn line.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar i;\t\t\n\t\t\tfor (i = 0; i < linesByMaterial.length; i++) {\n\t\t\t\tExplodeLinesByMaterial (linesByMaterial[i], i, explodeData);\n\t\t\t}\n\t\t\tExplodeLinesByMaterial (linesWithNoMaterial, -1, explodeData);\n\t\t}\n\n\t\tfunction ExplodePolygons (body, materials, explodeData)\n\t\t{\n\t\t\tfunction CalculatePolygonsDerivedData (body, materials)\n\t\t\t{\n\t\t\t\tvar vertexNormals = JSM.CalculateBodyVertexNormals (body);\n\n\t\t\t\tvar i, j;\n\t\t\t\tvar hasTextureCoords = false;\n\t\t\t\tif (materials !== undefined && materials !== null) {\n\t\t\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\t\t\tif (materials.GetMaterial (i).texture !== null) {\n\t\t\t\t\t\t\thasTextureCoords = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar textureCoords = null;\n\t\t\t\tvar polygon, material;\n\t\t\t\tif (hasTextureCoords) {\n\t\t\t\t\ttextureCoords = JSM.CalculateBodyTextureCoords (body);\n\t\t\t\t\tfor (i = 0; i < textureCoords.length; i++) {\n\t\t\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\t\t\tif (polygon.HasMaterialIndex ()) {\n\t\t\t\t\t\t\tmaterial = materials.GetMaterial (polygon.GetMaterialIndex ());\n\t\t\t\t\t\t\tfor (j = 0; j < textureCoords[i].length; j++) {\n\t\t\t\t\t\t\t\ttextureCoords[i][j].x /= material.textureWidth;\n\t\t\t\t\t\t\t\ttextureCoords[i][j].y /= -material.textureHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tvertexNormals : vertexNormals,\n\t\t\t\t\ttextureCoords : textureCoords\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tfunction ExplodePolygonsByMaterial (polygonIndices, materialIndex, derivedData, explodeData)\n\t\t\t{\n\t\t\t\tfunction ExplodePolygon (index, derivedData, explodeData)\n\t\t\t\t{\n\t\t\t\t\tfunction CreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (explodeData.onTriangle !== undefined && explodeData.onTriangle !== null) {\n\t\t\t\t\t\t\texplodeData.onTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\t\t\tif (count < 3) {\n\t\t\t\t\t\tJSM.Message ('Invalid polygon found.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar vertex1, vertex2, vertex3;\n\t\t\t\t\tvar normal1, normal2, normal3;\n\t\t\t\t\tvar uv1, uv2, uv3;\n\n\t\t\t\t\tvar convexPolygon = false;\n\t\t\t\t\tif (explodeData.hasConvexPolygons !== undefined && explodeData.hasConvexPolygons !== null) {\n\t\t\t\t\t\tconvexPolygon = explodeData.hasConvexPolygons;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i;\n\t\t\t\t\tif (count == 3 || convexPolygon) {\n\t\t\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\t\t\tvertex1 = body.GetVertexPosition (polygon.GetVertexIndex (0));\n\t\t\t\t\t\t\tvertex2 = body.GetVertexPosition (polygon.GetVertexIndex ((i + 1) % count));\n\t\t\t\t\t\t\tvertex3 = body.GetVertexPosition (polygon.GetVertexIndex ((i + 2) % count));\n\t\t\t\t\t\t\tnormal1 = derivedData.vertexNormals[index][0];\n\t\t\t\t\t\t\tnormal2 = derivedData.vertexNormals[index][(i + 1) % count];\n\t\t\t\t\t\t\tnormal3 = derivedData.vertexNormals[index][(i + 2) % count];\n\t\t\t\t\t\t\tuv1 = null;\n\t\t\t\t\t\t\tuv2 = null;\n\t\t\t\t\t\t\tuv3 = null;\n\t\t\t\t\t\t\tif (derivedData.textureCoords !== null) {\n\t\t\t\t\t\t\t\tuv1 = derivedData.textureCoords[index][0];\n\t\t\t\t\t\t\t\tuv2 = derivedData.textureCoords[index][(i + 1) % count];\n\t\t\t\t\t\t\t\tuv3 = derivedData.textureCoords[index][(i + 2) % count];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar polygon3D = new JSM.Polygon ();\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar vertex;\n\t\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\t\tvertex = body.GetVertexPosition (polygon.vertices[i]);\n\t\t\t\t\t\t\tpolygon3D.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar normal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\t\t\tvar triangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\t\t\tif (triangles !== null) {\n\t\t\t\t\t\t\tvar triangle;\n\t\t\t\t\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\t\t\t\t\ttriangle = triangles[i];\n\t\t\t\t\t\t\t\tvertex1 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[0]));\n\t\t\t\t\t\t\t\tvertex2 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[1]));\n\t\t\t\t\t\t\t\tvertex3 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[2]));\n\t\t\t\t\t\t\t\tnormal1 = derivedData.vertexNormals[index][triangle[0]];\n\t\t\t\t\t\t\t\tnormal2 = derivedData.vertexNormals[index][triangle[1]];\n\t\t\t\t\t\t\t\tnormal3 = derivedData.vertexNormals[index][triangle[2]];\n\t\t\t\t\t\t\t\tuv1 = null;\n\t\t\t\t\t\t\t\tuv2 = null;\n\t\t\t\t\t\t\t\tuv3 = null;\n\t\t\t\t\t\t\t\tif (derivedData.textureCoords !== null) {\n\t\t\t\t\t\t\t\t\tuv1 = derivedData.textureCoords[index][triangle[0]];\n\t\t\t\t\t\t\t\t\tuv2 = derivedData.textureCoords[index][triangle[1]];\n\t\t\t\t\t\t\t\t\tuv3 = derivedData.textureCoords[index][triangle[2]];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tCreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tJSM.Message ('Triangulation failed.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (polygonIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onGeometryStart !== undefined && explodeData.onGeometryStart !== null) {\n\t\t\t\t\texplodeData.onGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < polygonIndices.length; i++) {\n\t\t\t\t\tExplodePolygon (polygonIndices[i], derivedData, explodeData);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onGeometryEnd !== undefined && explodeData.onGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.PolygonCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar polygonsByMaterial = [];\n\t\t\tvar polygonsWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, polygonsByMaterial, polygonsWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.PolygonCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\t\t\treturn polygon.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar derivedData = CalculatePolygonsDerivedData (body, materials);\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygonsByMaterial.length; i++) {\n\t\t\t\tExplodePolygonsByMaterial (polygonsByMaterial[i], i, derivedData, explodeData);\n\t\t\t}\n\t\t\tExplodePolygonsByMaterial (polygonsWithNoMaterial, -1, derivedData, explodeData);\n\t\t}\n\n\t\tif (explodeData === undefined || explodeData === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (materials === undefined || materials === null) {\n\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t}\t\n\t\t\n\t\tExplodePoints (body, materials, explodeData);\n\t\tExplodeLines (body, materials, explodeData);\n\t\tExplodePolygons (body, materials, explodeData);\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/exporter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ExportBodyContentToStl\n\t* Description: Exports a body content to stl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tname {string} name the body\n\t*\thasConvexPolygons {boolean} the body has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyContentToStl = function (body, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddTriangleToContent (normal, vertex1, vertex2, vertex3)\n\t\t{\n\t\t\tAddLineToContent ('\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z);\n\t\t\tAddLineToContent ('\\t\\touter loop');\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex1.x + ' ' + vertex1.y + ' ' + vertex1.z);\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex2.x + ' ' + vertex2.y + ' ' + vertex2.z);\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex3.x + ' ' + vertex3.y + ' ' + vertex3.z);\n\t\t\tAddLineToContent ('\\t\\tendloop');\n\t\t\tAddLineToContent ('\\tendfacet');\n\t\t}\n\t\t\n\t\tfunction AddPolygon (index)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tif (count < 3) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar vertex1, vertex2, vertex3;\n\t\t\tvar normal = null;\n\t\t\tif (count === 3) {\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (0)).position;\n\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex (1)).position;\n\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex (2)).position;\n\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t} else {\n\t\t\t\tvar useTriangulation = true;\n\t\t\t\tif (hasConvexPolygons !== undefined && hasConvexPolygons) {\n\t\t\t\t\tuseTriangulation = false;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar i;\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\tif (useTriangulation) {\n\t\t\t\t\tvar polygon3D = new JSM.Polygon ();\n\t\t\t\t\t\n\t\t\t\t\tvar vertex;\n\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\tvertex = body.GetVertex (polygon.vertices[i]);\n\t\t\t\t\t\tpolygon3D.AddVertex (vertex.position.x, vertex.position.y, vertex.position.z);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar triangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\t\tif (triangles !== null) {\n\t\t\t\t\t\tvar triangle;\n\t\t\t\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\t\t\t\ttriangle = triangles[i];\n\t\t\t\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (triangle[0])).position;\n\t\t\t\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex (triangle[1])).position;\n\t\t\t\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex (triangle[2])).position;\n\t\t\t\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (0)).position;\n\t\t\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex ((i + 1) % count)).position;\n\t\t\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex ((i + 2) % count)).position;\n\t\t\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar stlContent = '';\n\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (i);\n\t\t}\n\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToStl\n\t* Description: Exports a body to stl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tname {string} name the body\n\t*\thasConvexPolygons {boolean} the body has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToStl = function (body, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tvar stlContent = '';\n\t\t\n\t\tAddLineToContent ('solid ' + name);\n\t\tstlContent += JSM.ExportBodyContentToStl (body, name, hasConvexPolygons);\n\t\tAddLineToContent ('endsolid ' + name);\n\t\t\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportModelToStl\n\t* Description: Exports a model to stl.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t*\tname {string} name the model\n\t*\thasConvexPolygons {boolean} the model has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToStl = function (model, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tvar stlContent = '';\n\n\t\tAddLineToContent ('solid ' + name);\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tstlContent += JSM.ExportBodyContentToStl (body, name + (i + 1).toString (), hasConvexPolygons);\n\t\t}\n\t\tAddLineToContent ('endsolid ' + name);\n\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyContentToObj\n\t* Description: Exports a body content to obj.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertexOffset {integer} vertex index offset\n\t*\tnormalOffset {integer} normal index offset\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyContentToObj = function (body, vertexOffset, normalOffset)\n\t{\n\t\tfunction AddToContent (line)\n\t\t{\n\t\t\tobjContent += line;\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tobjContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddVertex (index)\n\t\t{\n\t\t\tvar vertCoord = body.GetVertex (index).position;\n\t\t\tAddLineToContent ('v ' + vertCoord.x + ' ' + vertCoord.y + ' ' + vertCoord.z);\n\t\t}\n\n\t\tfunction AddNormal (index)\n\t\t{\n\t\t\tvar normalVector = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\tAddLineToContent ('vn ' + normalVector.x + ' ' + normalVector.y + ' ' + normalVector.z);\n\t\t}\n\n\t\tfunction AddPolygon (index)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\n\t\t\tAddToContent ('f ');\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tAddToContent ((vertexOffset + polygon.GetVertexIndex (i) + 1) + '//' + (normalOffset + index + 1) + ' ');\n\t\t\t}\n\t\t\t\n\t\t\tAddLineToContent ('');\n\t\t}\n\n\t\tvar objContent = '';\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (i);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddNormal (i);\n\t\t}\n\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (i);\n\t\t}\n\t\t\n\t\treturn objContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToObj\n\t* Description: Exports a body to obj.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToObj = function (body)\n\t{\n\t\treturn JSM.ExportBodyContentToObj (body, 0, 0);\n\t};\n\n\t/**\n\t* Function: ExportModelToObj\n\t* Description: Exports a model to obj.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToObj = function (model)\n\t{\n\t\tvar objContent = '';\n\t\t\n\t\tvar vertexOffset = 0;\n\t\tvar normalOffset = 0;\n\t\t\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tobjContent += JSM.ExportBodyContentToObj (body, vertexOffset, normalOffset);\n\t\t\tvertexOffset += body.VertexCount ();\n\t\t\tnormalOffset += body.PolygonCount ();\n\t\t}\n\n\t\treturn objContent;\n\t};\n\n\t/**\n\t* Function: ExportMaterialsToGdl\n\t* Description: Exports a material container to gdl.\n\t* Parameters:\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportMaterialsToGdl = function (materials)\n\t{\n\t\tfunction HexColorToRGBColorString (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = rgb[0] / 255.0 + ',' + rgb[1] / 255.0 + ',' + rgb[2] / 255.0;\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tgdlContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddMaterial (material, index)\n\t\t{\n\t\t\tvar rgbString = HexColorToRGBColorString (material.diffuse);\n\t\t\tAddLineToContent ('define material \"material' + index + '\" 2, ' + rgbString + ' ! ' + index);\n\t\t}\n\t\t\n\t\tvar gdlContent = '';\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\twriteMaterials = true;\n\t\t}\n\n\t\tvar i;\n\t\tif (writeMaterials) {\n\t\t\tAddMaterial (materials.GetDefaultMaterial (), 1);\n\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\tAddMaterial (materials.GetMaterial (i), i + 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyGeometryToGdl\n\t* Description: Exports a body geometry to gdl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\twriteMaterials {boolean} write materials\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyGeometryToGdl = function (body, writeMaterials)\n\t{\n\t\tfunction AddToContent (line)\n\t\t{\n\t\t\tvar lineLengthLimit = 200;\n\t\t\tif (line.length > lineLengthLimit) {\n\t\t\t\tvar current = 0;\n\t\t\t\tvar i, character;\n\t\t\t\tfor (i = 0; i < line.length; i++) {\n\t\t\t\t\tcharacter = line[i];\n\t\t\t\t\tgdlContent += character;\n\t\t\t\t\tcurrent++;\n\t\t\t\t\tif (current > lineLengthLimit && character == ',') {\n\t\t\t\t\t\tgdlContent += '\\n';\n\t\t\t\t\t\tcurrent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgdlContent += line;\n\t\t\t}\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tAddToContent (line + '\\n');\n\t\t}\n\n\t\tfunction AddVertex (index)\n\t\t{\n\t\t\tvar vertCoord = body.GetVertex (index).position;\n\t\t\tAddLineToContent ('vert ' + vertCoord.x + ', ' + vertCoord.y + ', ' + vertCoord.z + ' ! ' + (index + 1));\n\t\t}\n\n\t\tfunction AddEdge (adjacencyInfo, index)\n\t\t{\n\t\t\tvar edge = adjacencyInfo.edges[index];\n\t\t\tvar status = 0;\n\t\t\tif (edge.pgon1 != -1 && edge.pgon2 != -1) {\n\t\t\t\tif (body.GetPolygon (edge.pgon1).HasCurveGroup () && body.GetPolygon (edge.pgon2).HasCurveGroup ()) {\n\t\t\t\t\tif (body.GetPolygon (edge.pgon1).GetCurveGroup () == body.GetPolygon (edge.pgon2).GetCurveGroup ()) {\n\t\t\t\t\t\tstatus = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tAddLineToContent ('edge ' + (edge.vert1 + 1) + ', ' + (edge.vert2 + 1) + ', -1, -1, ' + status + ' ! ' + (index + 1));\n\t\t}\n\n\t\tfunction AddPolygon (adjacencyInfo, index, lastMaterialIndex)\n\t\t{\n\t\t\tvar materialIndex = -1;\n\t\t\tif (writeMaterials) {\n\t\t\t\tmaterialIndex = body.GetPolygon (index).GetMaterialIndex () + 2;\n\t\t\t\tif (materialIndex != lastMaterialIndex) {\n\t\t\t\t\tAddLineToContent ('set material \"material' + materialIndex + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar pgon = adjacencyInfo.pgons[index];\n\t\t\tvar status = 0;\n\t\t\tif (body.GetPolygon (index).HasCurveGroup ()) {\n\t\t\t\tstatus = 2;\n\t\t\t}\n\t\t\tAddToContent ('pgon ' + pgon.pedges.length + ', 0, ' + status + ', ');\n\t\t\tvar pedgeList = '';\n\t\t\tvar i, pedge;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tpedge = pgon.pedges[i];\n\t\t\t\tif (!pedge.reverse) {\n\t\t\t\t\tpedgeList += (pedge.index + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpedgeList += (-(pedge.index + 1));\n\t\t\t\t}\n\t\t\t\tif (i < pgon.pedges.length - 1) {\n\t\t\t\t\tpedgeList += ', ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tAddToContent (pedgeList);\n\t\t\tAddToContent (' ! ' + (index + 1));\n\t\t\tAddLineToContent ('');\n\t\t\t\n\t\t\treturn materialIndex;\n\t\t}\n\n\t\tvar gdlContent = '';\n\n\t\tAddLineToContent ('base');\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\tAddVertex (i);\n\t\t}\n\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tAddEdge (adjacencyInfo, i);\n\t\t}\n\t\t\n\t\tvar lastMaterialIndex = -1;\n\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\tlastMaterialIndex = AddPolygon (adjacencyInfo, i, lastMaterialIndex);\n\t\t}\n\n\t\tAddLineToContent ('body -1');\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToGdl\n\t* Description: Exports a body to gdl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToGdl = function (body, materials)\n\t{\n\t\tvar gdlContent = '';\n\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\tgdlContent += JSM.ExportMaterialsToGdl (materials);\n\t\t\twriteMaterials = true;\n\t\t}\n\n\t\tgdlContent += JSM.ExportBodyGeometryToGdl (body, writeMaterials);\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportModelToGdl\n\t* Description: Exports a model to gdl.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToGdl = function (model, materials)\n\t{\n\t\tvar gdlContent = '';\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\tgdlContent += JSM.ExportMaterialsToGdl (materials);\n\t\t\twriteMaterials = true;\n\t\t}\n\t\t\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tgdlContent += JSM.ExportBodyGeometryToGdl (body, writeMaterials);\n\t\t}\n\n\t\treturn gdlContent;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/trianglebody',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: TriangleBody\n\t* Description: Represents a 3D body which contains only triangles.\n\t*/\n\tJSM.TriangleBody = function (name)\n\t{\n\t\tthis.name = name;\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.uvs = [];\n\t\tthis.triangles = [];\n\t\tthis.defaultUVIndex = -1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.SetName\n\t* Description: Sets the name of the body.\n\t* Parameters:\n\t*\tname {string} the name\n\t*/\n\tJSM.TriangleBody.prototype.SetName = function (name)\n\t{\n\t\tthis.name = name;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetName\n\t* Description: Returns the name of the body.\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetName = function ()\n\t{\n\t\treturn this.name;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddVertex\n\t* Description: Adds a vertex to the body.\n\t* Parameters:\n\t*\tx, y, z {number} the coordinates of the vertex\n\t* Returns:\n\t*\t{integer} the index of the added vertex\n\t*/\n\tJSM.TriangleBody.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.vertices.push (new JSM.Coord (x, y, z));\n\t\treturn this.vertices.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetVertex\n\t* Description: Returns the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.SetVertex\n\t* Description: Sets the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*\tx, y, z {number} the new coordinates of the vertex\n\t*/\n\tJSM.TriangleBody.prototype.SetVertex = function (index, x, y, z)\n\t{\n\t\tthis.vertices[index] = new JSM.Coord (x, y, z);\n\t};\n\n\t/**\n\t* Function: TriangleBody.VertexCount\n\t* Description: Returns the vertex count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddNormal\n\t* Description: Adds a normal vector to the body.\n\t* Parameters:\n\t*\tx, y, z {number} the coordinates of the normal vector\n\t* Returns:\n\t*\t{integer} the index of the added normal vector\n\t*/\n\tJSM.TriangleBody.prototype.AddNormal = function (x, y, z)\n\t{\n\t\tthis.normals.push (new JSM.Vector (x, y, z));\n\t\treturn this.normals.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetNormal\n\t* Description: Returns the normal vector at the given index.\n\t* Parameters:\n\t*\tindex {integer} the normal vector index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetNormal = function (index)\n\t{\n\t\treturn this.normals[index];\n\t};\n\n\n\t/**\n\t* Function: TriangleBody.GetTriangleNormal\n\t* Description: Returns the normal vector of a triangle at the given position.\n\t* Parameters:\n\t*\ttriangleIndex {integer} the triangle index\n\t*\tnormalPosition {Coord} the position of the normal inside the triangle\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetTriangleNormal = function (triangleIndex, normalPosition)\n\t{\n\t\tvar normal = null;\n\t\tvar triangle = this.triangles[triangleIndex];\n\t\tif (triangle.curve == -1) {\n\t\t\tnormal = this.GetNormal (triangle.n0);\n\t\t} else {\n\t\t\tvar v0 = this.GetVertex (triangle.v0);\n\t\t\tvar v1 = this.GetVertex (triangle.v1);\n\t\t\tvar v2 = this.GetVertex (triangle.v2);\n\t\t\tvar n0 = this.GetNormal (triangle.n0);\n\t\t\tvar n1 = this.GetNormal (triangle.n1);\n\t\t\tvar n2 = this.GetNormal (triangle.n2);\n\t\t\tnormal = JSM.BarycentricInterpolation (v0, v1, v2, n0, n1, n2, normalPosition);\n\t\t}\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: TriangleBody.NormalCount\n\t* Description: Returns the normal vector count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.NormalCount = function ()\n\t{\n\t\treturn this.normals.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddUV\n\t* Description: Adds a texture coordinate to the body.\n\t* Parameters:\n\t*\tx, y {number} the coordinates of the texture coordinate\n\t* Returns:\n\t*\t{integer} the index of the added texture coordinate\n\t*/\n\tJSM.TriangleBody.prototype.AddUV = function (x, y)\n\t{\n\t\tthis.uvs.push (new JSM.Coord2D (x, y));\n\t\treturn this.uvs.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddDefaultUV\n\t* Description:\n\t*\tAdds a default texture coordinate to the body.\n\t*\tThe default texture coordinate is stored only once.\n\t* Returns:\n\t*\t{integer} the index of the default texture coordinate\n\t*/\n\tJSM.TriangleBody.prototype.AddDefaultUV = function ()\n\t{\n\t\tif (this.defaultUVIndex != -1) {\n\t\t\treturn this.defaultUVIndex;\n\t\t}\n\t\t\n\t\tthis.defaultUVIndex = this.AddUV (0.0, 0.0);\n\t\treturn this.defaultUVIndex;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetUV\n\t* Description: Returns the texture coordinate at the given index.\n\t* Parameters:\n\t*\tindex {integer} the texture coordinate index\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetUV = function (index)\n\t{\n\t\treturn this.uvs[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.UVCount\n\t* Description: Returns the texture coordinate count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.UVCount = function ()\n\t{\n\t\treturn this.uvs.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddTriangle\n\t* Description: Adds a triangle to the body.\n\t* Parameters:\n\t*\tv0, v1, v2 {integer} the vertex indices of the triangle\n\t*\tn0, n1, n2 {integer} the normal vector indices of the triangle\n\t*\tu0, u1, u2 {integer} the texture coordinate indices of the triangle\n\t*\tmat {integer} the material index of the triangle\n\t*\tcurve {integer} the curve group index of the triangle\n\t* Returns:\n\t*\t{integer} the index of the added triangle\n\t*/\n\tJSM.TriangleBody.prototype.AddTriangle = function (v0, v1, v2, n0, n1, n2, u0, u1, u2, mat, curve)\n\t{\n\t\tthis.triangles.push ({\n\t\t\tv0 : v0,\n\t\t\tv1 : v1,\n\t\t\tv2 : v2,\n\t\t\tn0 : n0,\n\t\t\tn1 : n1,\n\t\t\tn2 : n2,\n\t\t\tu0 : u0,\n\t\t\tu1 : u1,\n\t\t\tu2 : u2,\n\t\t\tmat : mat,\n\t\t\tcurve : curve\n\t\t});\n\t\treturn this.triangles.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetTriangle\n\t* Description: Returns the triangle at the given index.\n\t* Parameters:\n\t*\tindex {integer} the triangle index\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetTriangle = function (index)\n\t{\n\t\treturn this.triangles[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.TriangleCount\n\t* Description: Returns the triangle count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.TriangleCount = function ()\n\t{\n\t\treturn this.triangles.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetBoundingBox\n\t* Description: Returns the bounding box of the body.\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\t\t\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetCenter\n\t* Description: Returns the center of the bounding box of the body.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetBoundingSphere\n\t* Description: Returns the bounding sphere of the body.\n\t* Returns:\n\t*\t{Sphere} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\t\t\n\t\tvar i, current;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcurrent = center.DistanceTo (this.vertices[i]);\n\t\t\tif (JSM.IsGreater (current, radius)) {\n\t\t\t\tradius = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.Sphere (center, radius);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleBody.Finalize\n\t* Description:\n\t*\tFinalizes the body. This operation calculates normal vectors\n\t*\tand fixes the body if some data is missing from it.\n\t* Parameters:\n\t*\tmodel {TriangleModel} the triangle index\n\t*/\n\tJSM.TriangleBody.prototype.Finalize = function (model)\n\t{\n\t\tfunction FinalizeTriangle (body, triangleIndex, triangleNormals, vertexToTriangles)\n\t\t{\n\t\t\tfunction AddAverageNormal (body, vertexIndex, triangleIndex, triangleNormals, vertexToTriangles)\n\t\t\t{\n\t\t\t\tvar averageNormal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\tvar averageCount = 0;\n\t\t\t\t\n\t\t\t\tvar triangle = body.GetTriangle (triangleIndex);\n\t\t\t\tvar neighbourTriangles = vertexToTriangles[vertexIndex];\n\t\t\t\tvar i, neighbourTriangleIndex, neighbourTriangle;\n\t\t\t\tfor (i = 0; i < neighbourTriangles.length; i++) {\n\t\t\t\t\tneighbourTriangleIndex = neighbourTriangles[i];\n\t\t\t\t\tneighbourTriangle = body.GetTriangle (neighbourTriangleIndex);\n\t\t\t\t\tif (triangle.curve == neighbourTriangle.curve) {\n\t\t\t\t\t\taverageNormal = JSM.CoordAdd (averageNormal, triangleNormals[neighbourTriangleIndex]);\n\t\t\t\t\t\taverageCount = averageCount + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\taverageNormal.MultiplyScalar (1.0 / averageCount);\n\t\t\t\taverageNormal.Normalize ();\n\t\t\t\treturn body.AddNormal (averageNormal.x, averageNormal.y, averageNormal.z);\n\t\t\t}\n\t\t\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tif (triangle.mat === undefined || triangle.mat < 0) {\n\t\t\t\ttriangle.mat = model.GetDefaultMaterialIndex ();\n\t\t\t}\n\t\t\t\n\t\t\tvar normal, normalIndex;\n\t\t\tif (triangle.n0 === undefined || triangle.n1 === undefined || triangle.n2 === undefined) {\n\t\t\t\tif (triangle.curve === undefined || triangle.curve < 0) {\n\t\t\t\t\tnormal = triangleNormals[triangleIndex];\n\t\t\t\t\tnormalIndex = body.AddNormal (normal.x, normal.y, normal.z);\n\t\t\t\t\ttriangle.n0 = normalIndex;\n\t\t\t\t\ttriangle.n1 = normalIndex;\n\t\t\t\t\ttriangle.n2 = normalIndex;\n\t\t\t\t\ttriangle.curve = -1;\n\t\t\t\t} else {\n\t\t\t\t\ttriangle.n0 = AddAverageNormal (body, triangle.v0, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t\ttriangle.n1 = AddAverageNormal (body, triangle.v1, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t\ttriangle.n2 = AddAverageNormal (body, triangle.v2, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (triangle.u0 === undefined || triangle.u1 === undefined || triangle.u2 === undefined) {\n\t\t\t\ttriangle.u0 = body.AddDefaultUV ();\n\t\t\t\ttriangle.u1 = body.AddDefaultUV ();\n\t\t\t\ttriangle.u2 = body.AddDefaultUV ();\n\t\t\t}\n\t\t}\n\n\t\tvar triangleNormals = [];\n\t\tvar vertexToTriangles = {};\n\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertexToTriangles[i] = [];\n\t\t}\n\t\t\n\t\tvar triangle, normal;\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\ttriangle = this.triangles[i];\n\t\t\tnormal = JSM.CalculateTriangleNormal (this.vertices[triangle.v0], this.vertices[triangle.v1], this.vertices[triangle.v2]);\n\t\t\ttriangleNormals.push (normal);\n\t\t\tvertexToTriangles[triangle.v0].push (i);\n\t\t\tvertexToTriangles[triangle.v1].push (i);\n\t\t\tvertexToTriangles[triangle.v2].push (i);\n\t\t}\n\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\tFinalizeTriangle (this, i, triangleNormals, vertexToTriangles);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleBody.Clone\n\t* Description: Clones the body.\n\t* Returns:\n\t*\t{TriangleBody} a cloned instance\n\t*/\n\tJSM.TriangleBody.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.TriangleBody (this.name);\n\t\t\n\t\tvar i, triangle;\n\t\t\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.vertices.push (this.vertices[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.normals.length; i++) {\n\t\t\tresult.normals.push (this.normals[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.uvs.length; i++) {\n\t\t\tresult.uvs.push (this.uvs[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\ttriangle = this.triangles[i];\n\t\t\tresult.triangles.push ({\n\t\t\t\tv0 : triangle.v0,\n\t\t\t\tv1 : triangle.v1,\n\t\t\t\tv2 : triangle.v2,\n\t\t\t\tn0 : triangle.n0,\n\t\t\t\tn1 : triangle.n1,\n\t\t\t\tn2 : triangle.n2,\n\t\t\t\tu0 : triangle.u0,\n\t\t\t\tu1 : triangle.u1,\n\t\t\t\tu2 : triangle.u2,\n\t\t\t\tmat : triangle.mat,\n\t\t\t\tcurve : triangle.curve\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertTriangleBodyToOctree\n\t* Description: Converts a triangle body to triangle octree.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t* Returns:\n\t*\t{TriangleOctree} the result\n\t*/\n\tJSM.ConvertTriangleBodyToOctree = function (body)\n\t{\n\t\tvar result = new JSM.TriangleOctree (body.GetBoundingBox ());\n\t\tvar i, triangle, v0, v1, v2;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tresult.AddTriangle (v0, v1, v2, {\n\t\t\t\ttriangleIndex : i\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/trianglemodel',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: TriangleModel\n\t* Description: Represents a 3D model which contains only triangles.\n\t*/\n\tJSM.TriangleModel = function ()\n\t{\n\t\tthis.materials = [];\n\t\tthis.bodies = [];\n\t\tthis.defaultMaterial = -1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddMaterial\n\t* Description: Adds a material to the model.\n\t* Parameters:\n\t*\tmaterial {material} the parameters of the material\n\t* Returns:\n\t*\t{integer} the index of the added material\n\t*/\n\tJSM.TriangleModel.prototype.AddMaterial = function (material)\n\t{\n\t\tthis.materials.push (material);\n\t\treturn this.materials.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetMaterial\n\t* Description: Returns the material at the given index.\n\t* Parameters:\n\t*\tindex {integer} the material index\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetMaterial = function (index)\n\t{\n\t\treturn this.materials[index];\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddDefaultMaterial\n\t* Description: Adds a default material to the model. The default material is stored only once.\n\t* Returns:\n\t*\t{integer} the index of the default material\n\t*/\n\tJSM.TriangleModel.prototype.AddDefaultMaterial = function ()\n\t{\n\t\tif (this.defaultMaterial == -1) {\n\t\t\tthis.defaultMaterial = this.AddMaterial ({});\n\t\t}\n\t\treturn this.defaultMaterial;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetDefaultMaterialIndex\n\t* Description: Adds a default material, and returns the index of it.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetDefaultMaterialIndex = function ()\n\t{\n\t\treturn this.AddDefaultMaterial ();\n\t};\n\n\t/**\n\t* Function: TriangleModel.MaterialCount\n\t* Description: Returns the material count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.MaterialCount = function ()\n\t{\n\t\treturn this.materials.length;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddBody\n\t* Description: Adds a body to the model.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t* Returns:\n\t*\t{integer} the index of the added body\n\t*/\n\tJSM.TriangleModel.prototype.AddBody = function (body)\n\t{\n\t\tthis.bodies.push (body);\n\t\treturn this.bodies.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddBodyToIndex\n\t* Description: Adds a body to the model to the given index.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{integer} the index of the added body\n\t*/\n\tJSM.TriangleModel.prototype.AddBodyToIndex = function (body, index)\n\t{\n\t\tthis.bodies.splice (index, 0, body);\n\t\treturn index;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetBody\n\t* Description: Returns the body at the given index.\n\t* Parameters:\n\t*\tindex {integer} the body index\n\t* Returns:\n\t*\t{TriangleBody} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\t/**\n\t* Function: TriangleModel.VertexCount\n\t* Description: Returns the vertex count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.VertexCount = function ()\n\t{\n\t\tvar result = 0;\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tresult += body.VertexCount ();\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleModel.TriangleCount\n\t* Description: Returns the triangle count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.TriangleCount = function ()\n\t{\n\t\tvar result = 0;\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tresult += body.TriangleCount ();\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleModel.BodyCount\n\t* Description: Returns the body count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.BodyCount = function ()\n\t{\n\t\treturn this.bodies.length;\n\t};\n\n\t/**\n\t* Function: TriangleModel.FinalizeMaterials\n\t* Description:\n\t*\tFinalizes the materials in the model. This fill every not\n\t*\tspecified material parameter with default values.\n\t*/\n\tJSM.TriangleModel.prototype.FinalizeMaterials = function ()\n\t{\n\t\tvar defaultMaterialData = {\n\t\t\tname : 'Default',\n\t\t\tambient : [0.5, 0.5, 0.5],\n\t\t\tdiffuse : [0.5, 0.5, 0.5],\n\t\t\tspecular : [0.1, 0.1, 0.1],\n\t\t\tshininess : 0.0,\n\t\t\topacity : 1.0,\n\t\t\treflection : 0.0,\n\t\t\ttexture : null,\n\t\t\toffset : null,\n\t\t\tscale : null,\n\t\t\trotation : null\n\t\t};\n\t\t\n\t\tvar i, material;\n\t\tfor (i = 0; i < this.materials.length; i++) {\n\t\t\tmaterial = this.materials[i];\n\t\t\tJSM.CopyObjectProperties (defaultMaterialData, material, false);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleModel.FinalizeBodies\n\t* Description: Finalizes all body in the model.\n\t*/\n\tJSM.TriangleModel.prototype.FinalizeBodies = function ()\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tbody.Finalize (this);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleModel.Finalize\n\t* Description: Finalizes the model. It finalizes materials and bodies.\n\t*/\n\tJSM.TriangleModel.prototype.Finalize = function ()\n\t{\n\t\tthis.FinalizeBodies ();\n\t\tthis.FinalizeMaterials ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/converter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ConvertBodyToTriangleBody\n\t* Description: Converts a body to triangle body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{TriangleBody} the result\n\t*/\n\tJSM.ConvertBodyToTriangleBody = function (body)\n\t{\n\t\tfunction AddTriangle (result, polygon, v0, v1, v2)\n\t\t{\n\t\t\tvar triangleIndex = result.AddTriangle (v0, v1, v2);\n\t\t\tvar triangle = result.GetTriangle (triangleIndex);\n\t\t\tif (polygon.HasMaterialIndex ()) {\n\t\t\t\ttriangle.mat = polygon.GetMaterialIndex ();\n\t\t\t}\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\ttriangle.curve = polygon.GetCurveGroup ();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.TriangleBody ();\n\t\t\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\tresult.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t}\n\t\t\n\t\tvar polygon, vertexCount;\n\t\tvar polygon3D, normal, triangle, triangles;\n\t\tvar v0, v1, v2;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tvertexCount = polygon.VertexIndexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tv0 = polygon.GetVertexIndex (0);\n\t\t\t\tv1 = polygon.GetVertexIndex (1);\n\t\t\t\tv2 = polygon.GetVertexIndex (2);\n\t\t\t\tAddTriangle (result, polygon, v0, v1, v2);\n\t\t\t} else {\n\t\t\t\tpolygon3D = new JSM.Polygon ();\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tvertex = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\t\tpolygon3D.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, i);\n\t\t\t\ttriangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\tif (triangles !== null) {\n\t\t\t\t\tfor (j = 0; j < triangles.length; j++) {\n\t\t\t\t\t\ttriangle = triangles[j];\n\t\t\t\t\t\tv0 = polygon.GetVertexIndex (triangle[0]);\n\t\t\t\t\t\tv1 = polygon.GetVertexIndex (triangle[1]);\n\t\t\t\t\t\tv2 = polygon.GetVertexIndex (triangle[2]);\n\t\t\t\t\t\tAddTriangle (result, polygon, v0, v1, v2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertModelToTriangleModel\n\t* Description: Converts a model to triangle model.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t* Returns:\n\t*\t{TriangleModel} the result\n\t*/\n\tJSM.ConvertModelToTriangleModel = function (model)\n\t{\n\t\tvar result = new JSM.TriangleModel ();\n\t\tvar materials = model.GetMaterialSet ();\n\t\tvar i, material;\n\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\tmaterial = materials.GetMaterial (i);\n\t\t\tresult.AddMaterial ({\n\t\t\t\tname : 'Material' + i,\n\t\t\t\tambient : JSM.HexColorToNormalizedRGBComponents (material.ambient),\n\t\t\t\tdiffuse : JSM.HexColorToNormalizedRGBComponents (material.diffuse),\n\t\t\t\tspecular : JSM.HexColorToNormalizedRGBComponents (material.specular),\n\t\t\t\tshininess : material.shininess,\n\t\t\t\topacity : material.opacity,\n\t\t\t\treflection : material.reflection\n\t\t\t});\n\t\t}\n\t\t\n\t\tvar body, triangleBody;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\ttriangleBody = JSM.ConvertBodyToTriangleBody (body);\n\t\t\tresult.AddBody (triangleBody);\n\t\t}\n\t\tresult.Finalize ();\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertTriangleModelToJsonData\n\t* Description: Converts a triangle model to json data.\n\t* Parameters:\n\t*\tmodel {TriangleModel} the model\n\t* Returns:\n\t*\t{object} the result data\n\t*/\n\tJSM.ConvertTriangleModelToJsonData = function (model)\n\t{\n\t\tfunction ConvertMaterials (model, materials)\n\t\t{\n\t\t\tvar i, material, jsonMaterial;\n\t\t\tfor (i = 0; i < model.MaterialCount (); i++) {\n\t\t\t\tmaterial = model.GetMaterial (i);\n\t\t\t\tjsonMaterial = {\n\t\t\t\t\tname : JSM.ValueOrDefault (material.name, ''),\n\t\t\t\t\tambient : material.ambient,\n\t\t\t\t\tdiffuse : material.diffuse,\n\t\t\t\t\tspecular : material.specular,\n\t\t\t\t\tshininess : material.shininess,\n\t\t\t\t\topacity : material.opacity\n\t\t\t\t};\n\t\t\t\tif (material.texture !== undefined && material.texture !== null) {\n\t\t\t\t\tjsonMaterial.texture = JSM.ValueOrDefault (material.texture, null);\n\t\t\t\t\tjsonMaterial.offset = material.offset;\n\t\t\t\t\tjsonMaterial.scale = material.scale;\n\t\t\t\t\tjsonMaterial.rotation = material.rotation;\n\t\t\t\t}\n\t\t\t\tmaterials.push (jsonMaterial);\n\t\t\t}\n\t\t}\n\n\t\tfunction ConvertBody (model, body, mesh)\n\t\t{\n\t\t\tvar trianglesByMaterial = [];\n\t\t\tvar materialCount = model.MaterialCount ();\n\t\t\t\n\t\t\tvar i, j, coord;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tcoord = body.GetVertex (i);\n\t\t\t\tmesh.vertices.push (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < body.NormalCount (); i++) {\n\t\t\t\tcoord = body.GetNormal (i);\n\t\t\t\tmesh.normals.push (coord.x, coord.y, coord.z);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < body.UVCount (); i++) {\n\t\t\t\tcoord = body.GetUV (i);\n\t\t\t\tmesh.uvs.push (coord.x, coord.y);\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < materialCount; i++) {\n\t\t\t\ttrianglesByMaterial.push ([]);\n\t\t\t}\n\n\t\t\tvar triangle;\n\t\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\t\ttriangle = body.GetTriangle (i);\n\t\t\t\tif (triangle.mat === undefined || triangle.mat < 0 || triangle.mat >= materialCount) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrianglesByMaterial[triangle.mat].push (i);\n\t\t\t}\n\n\t\t\tvar triangleCount = 0;\n\t\t\tvar triangles, jsonTriangles;\n\t\t\tfor (i = 0; i < trianglesByMaterial.length; i++) {\n\t\t\t\ttriangles = trianglesByMaterial[i];\n\t\t\t\tif (triangles.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjsonTriangles =  {\n\t\t\t\t\tmaterial : i,\n\t\t\t\t\tparameters : []\n\t\t\t\t};\n\t\t\t\tfor (j = 0; j < triangles.length; j++) {\n\t\t\t\t\ttriangle = body.GetTriangle (triangles[j]);\n\t\t\t\t\tjsonTriangles.parameters.push (\n\t\t\t\t\t\ttriangle.v0, triangle.v1, triangle.v2,\n\t\t\t\t\t\ttriangle.n0, triangle.n1, triangle.n2,\n\t\t\t\t\t\ttriangle.u0, triangle.u1, triangle.u2\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\ttriangleCount = triangleCount + triangles.length;\n\t\t\t\tmesh.triangles.push (jsonTriangles);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tversion : 1,\n\t\t\tmaterials : [],\n\t\t\tmeshes : []\n\t\t};\n\t\t\n\t\tConvertMaterials (model, result.materials);\n\t\t\n\t\tvar i, body, mesh;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tif (body.TriangleCount () === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmesh = {\n\t\t\t\tname : body.GetName (),\n\t\t\t\tvertices : [],\n\t\t\t\tnormals : [],\n\t\t\t\tuvs : [],\n\t\t\t\ttriangles : []\n\t\t\t};\n\t\t\tConvertBody (model, body, mesh);\n\t\t\tresult.meshes.push (mesh);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MergeJsonDataMeshes\n\t* Description: Merges meshes in json data.\n\t* Parameters:\n\t*\tjsonData {object} the original data\n\t* Returns:\n\t*\t{object} the result data\n\t*/\n\tJSM.MergeJsonDataMeshes = function (jsonData)\n\t{\n\t\tfunction MergeMesh (mesh, currentMesh, materialToTriangles)\n\t\t{\n\t\t\tfunction MergeAttributes (mesh, currentMesh)\n\t\t\t{\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < currentMesh.vertices.length; i++) {\n\t\t\t\t\tmesh.vertices.push (currentMesh.vertices[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < currentMesh.normals.length; i++) {\n\t\t\t\t\tmesh.normals.push (currentMesh.normals[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < currentMesh.uvs.length; i++) {\n\t\t\t\t\tmesh.uvs.push (currentMesh.uvs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction MergeTriangles (mesh, currentTriangles, materialToTriangles, vertexOffset, normalOffset, uvOffset)\n\t\t\t{\n\t\t\t\tvar material = currentTriangles.material;\n\t\t\t\tvar trianglesIndex = materialToTriangles[material];\n\t\t\t\tif (trianglesIndex === undefined) {\n\t\t\t\t\tmesh.triangles.push ({\n\t\t\t\t\t\tmaterial : material,\n\t\t\t\t\t\tparameters : []\n\t\t\t\t\t});\n\t\t\t\t\ttrianglesIndex = mesh.triangles.length - 1;\n\t\t\t\t\tmaterialToTriangles[material] = trianglesIndex;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar triangles = mesh.triangles[trianglesIndex];\n\t\t\t\tvar triangleParameters = triangles.parameters;\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < currentTriangles.parameters.length; i = i + 9) {\n\t\t\t\t\ttriangleParameters.push (\n\t\t\t\t\t\tcurrentTriangles.parameters[i] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 1] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 2] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 3] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 4] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 5] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 6] + uvOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 7] + uvOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 8] + uvOffset\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar vertexOffset = mesh.vertices.length / 3;\n\t\t\tvar normalOffset = mesh.normals.length / 3;\n\t\t\tvar uvOffset = mesh.uvs.length / 2;\n\t\t\tMergeAttributes (mesh, currentMesh);\n\n\t\t\tvar i, currentTriangles;\n\t\t\tfor (i = 0; i < currentMesh.triangles.length; i++) {\n\t\t\t\tcurrentTriangles = currentMesh.triangles[i];\n\t\t\t\tMergeTriangles (mesh, currentTriangles, materialToTriangles, vertexOffset, normalOffset, uvOffset);\n\t\t\t}\n\t\t}\n\n\t\tvar result = {\n\t\t\tversion : jsonData.version,\n\t\t\tmaterials : jsonData.materials,\n\t\t\tmeshes : []\n\t\t};\n\t\t\n\t\tvar mesh = {\n\t\t\tname : 'Merged',\n\t\t\tvertices : [],\n\t\t\tnormals : [],\n\t\t\tuvs : [],\n\t\t\ttriangles : []\n\t\t};\n\t\t\n\t\tvar materialToTriangles = {};\n\t\tvar i, currentMesh;\n\t\tfor (i = 0; i < jsonData.meshes.length; i++) {\n\t\t\tcurrentMesh = jsonData.meshes[i];\n\t\t\tMergeMesh (mesh, currentMesh, materialToTriangles);\n\t\t}\n\t\t\n\t\tresult.meshes.push (mesh);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/rayutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: RayTriangleIntersection\n\t* Description: Calculates intersection between a ray and a triangle.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayTriangleIntersection = function (ray, v0, v1, v2)\n\t{\n\t\tvar rayOrigin = ray.GetOrigin ();\n\t\tvar rayDirection = ray.GetDirection ();\n\n\t\tvar edgeDir1 = JSM.CoordSub (v1, v0);\n\t\tvar edgeDir2 = JSM.CoordSub (v2, v0);\n\t\tvar pVector = JSM.VectorCross (rayDirection, edgeDir2);\n\n\t\tvar determinant = JSM.VectorDot (edgeDir1, pVector);\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar isFrontFacing = JSM.IsPositive (determinant);\n\t\tif (!isFrontFacing) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar invDeterminant = 1.0 / determinant;\n\n\t\tvar tVector = JSM.CoordSub (rayOrigin, v0);\n\t\tvar u = JSM.VectorDot (tVector, pVector) * invDeterminant;\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar qVector = JSM.VectorCross (tVector, edgeDir1);\n\t\tvar v = JSM.VectorDot (rayDirection, qVector) * invDeterminant;\n\t\tif (JSM.IsLower (v, 0.0) || JSM.IsGreater (u + v, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\t \n\t\tvar distance = JSM.VectorDot (edgeDir2, qVector) * invDeterminant;\n\t\tif (!JSM.IsPositive (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar scaledDirection = rayDirection.Clone ().MultiplyScalar (distance);\n\t\tvar intersection = {\n\t\t\tposition : JSM.CoordAdd (rayOrigin, scaledDirection),\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayBoxIntersection\n\t* Description: Calculates intersection between a ray and a box.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmin, max {Coord} the minimum and maximum points of the box\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayBoxIntersection = function (ray, min, max)\n\t{\n\t\tvar rayOriginVec = ray.GetOrigin ();\n\t\tvar rayDirectionVec = ray.GetDirection ();\n\n\t\tvar rayOrigin = JSM.CoordToArray (rayOriginVec);\n\t\tvar rayDirection = JSM.CoordToArray (rayDirectionVec);\n\t\tvar minB = JSM.CoordToArray (min);\n\t\tvar maxB = JSM.CoordToArray (max);\n\t\tvar quadrant = [0, 0, 0];\n\t\tvar candidatePlane = [0.0, 0.0, 0.0];\n\n\t\tvar originInBox = true;\n\t\tvar i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (JSM.IsLower (rayOrigin[i], minB[i])) {\n\t\t\t\tquadrant[i] = -1; // left\n\t\t\t\tcandidatePlane[i] = minB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else if (JSM.IsGreater (rayOrigin[i], maxB[i])) {\n\t\t\t\tquadrant[i] = 1; // right\n\t\t\t\tcandidatePlane[i] = maxB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else {\n\t\t\t\tquadrant[i] = 0; // middle\n\t\t\t}\n\t\t}\n\n\t\tvar intersection = null;\n\t\tif (originInBox) {\n\t\t\tintersection = {\n\t\t\t\tposition : rayOriginVec,\n\t\t\t\tdistance : 0.0\n\t\t\t};\n\t\t\treturn intersection;\n\t\t}\n\n\t\tvar maxT = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (quadrant[i] !== 0 && !JSM.IsZero (rayDirection[i])) {\n\t\t\t\tmaxT[i] = (candidatePlane[i] - rayOrigin[i]) / rayDirection[i];\n\t\t\t} else {\n\t\t\t\tmaxT[i] = -1.0;\n\t\t\t}\n\t\t}\n\n\t\tvar whichPlane = 0;\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (JSM.IsLower (maxT[whichPlane], maxT[i])) {\n\t\t\t\twhichPlane = i;\n\t\t\t}\n\t\t}\n\n\t\tif (JSM.IsNegative (maxT[whichPlane])) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar xCoord = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (whichPlane != i) {\n\t\t\t\txCoord[i] = rayOrigin[i] + maxT[whichPlane] * rayDirection[i];\n\t\t\t\tif (JSM.IsLower (xCoord[i], minB[i]) || JSM.IsGreater (xCoord[i], maxB[i])) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txCoord[i] = candidatePlane[i];\n\t\t\t}\n\t\t}\n\n\t\tvar intersectionCoord = JSM.CoordFromArray (xCoord);\n\t\tvar distance = rayOriginVec.DistanceTo (intersectionCoord);\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tintersection = {\n\t\t\tposition : intersectionCoord,\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayOctreeIntersection\n\t* Description: Calculates the nearest intersection between a ray and an octree.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\toctree {Octree} the octree\n\t*\tintersection {object} the result data (position, distance, userData)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayOctreeIntersection = function (ray, octree, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\n\t\tJSM.TraverseOctreeNodes (octree, function (node) {\n\t\t\tif (!calcMinIntersection && foundIntersection) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!JSM.RayBoxIntersection (ray, node.box.min, node.box.max)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < node.triangles.length; i++) {\n\t\t\t\tvar triangle = node.triangles[i];\n\t\t\t\tvar v0 = triangle.v0;\n\t\t\t\tvar v1 = triangle.v1;\n\t\t\t\tvar v2 = triangle.v2;\n\t\t\t\tvar currentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\tif (currentIntersection !== null) {\n\t\t\t\t\tfoundIntersection = true;\n\t\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\t\tminIntersection.userData = triangle.userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\t\n\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.userData = minIntersection.userData;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleBodyIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle body.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tbody {TriangleBody} the triangle body\n\t*\tintersection {object} the result data (position, distance, triangleIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleBodyIntersection = function (ray, body, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\t\n\t\tvar i, triangle, v0, v1, v2, currentIntersection;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tcurrentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\tif (currentIntersection !== null) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.triangleIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersection = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (JSM.RayTriangleBodyIntersection (ray, body, currentIntersection)) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersectionWithOctree\n\t* Description:\n\t*\tCalculates the nearest intersection between a ray and a triangle model.\n\t*\tCaches the octrees for all bodies in the model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersectionWithOctree = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, hasIntersection, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\thasIntersection = false;\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (body.TriangleCount () > 20) {\n\t\t\t\tif (body.octree === undefined) {\n\t\t\t\t\tbody.octree = JSM.ConvertTriangleBodyToOctree (body);\n\t\t\t\t}\n\t\t\t\thasIntersection = JSM.RayOctreeIntersection (ray, body.octree, currentIntersection);\n\t\t\t} else {\n\t\t\t\thasIntersection = JSM.RayTriangleBodyIntersection (ray, body, currentIntersection);\n\t\t\t}\n\t\t\t\n\t\t\tif (hasIntersection) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tif (currentIntersection.userData !== undefined) {\n\t\t\t\t\t\tminIntersection.triangleIndex = currentIntersection.userData.triangleIndex;\n\t\t\t\t\t}\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/binaryreader',[\"../core/jsm\"],function(JSM){\n\tJSM.BinaryReader = function (arrayBuffer, isLittleEndian)\n\t{\n\t\tthis.arrayBuffer = arrayBuffer;\n\t\tthis.dataView = new DataView (arrayBuffer);\n\t\tthis.isLittleEndian = isLittleEndian;\n\t\tthis.position = 0;\n\t};\n\n\tJSM.BinaryReader.prototype.GetPosition = function ()\n\t{\n\t\treturn this.position;\n\t};\n\n\tJSM.BinaryReader.prototype.GetByteLength = function ()\n\t{\n\t\treturn this.arrayBuffer.byteLength;\n\t};\n\n\tJSM.BinaryReader.prototype.Skip = function (bytes)\n\t{\n\t\tthis.position = this.position + bytes;\n\t};\n\n\tJSM.BinaryReader.prototype.End = function ()\n\t{\n\t\treturn this.position >= this.arrayBuffer.byteLength;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadBoolean = function ()\n\t{\n\t\tvar result = this.dataView.getInt8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result ? true : false;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadCharacter = function ()\n\t{\n\t\tvar result = this.dataView.getInt8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedCharacter = function ()\n\t{\n\t\tvar result = this.dataView.getUint8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadInteger16 = function ()\n\t{\n\t\tvar result = this.dataView.getInt16 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 2;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedInteger16 = function ()\n\t{\n\t\tvar result = this.dataView.getUint16 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 2;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadInteger32 = function ()\n\t{\n\t\tvar result = this.dataView.getInt32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedInteger32 = function ()\n\t{\n\t\tvar result = this.dataView.getUint32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadFloat32 = function ()\n\t{\n\t\tvar result = this.dataView.getFloat32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadDouble64 = function ()\n\t{\n\t\tvar result = this.dataView.getFloat64 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 8;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerutils',[\"../core/jsm\"],function(JSM){\n\tJSM.GetArrayBufferFromURL = function (url, callbacks)\n\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.open ('GET', url, true);\n\t\trequest.responseType = 'arraybuffer';\n\n\t\trequest.onload = function () {\n\t\t\tvar arrayBuffer = request.response;\n\t\t\tif (arrayBuffer && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (arrayBuffer);\n\t\t\t}\n\t\t};\n\t\t\n\t\trequest.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\trequest.send (null);\n\t};\n\n\tJSM.GetArrayBufferFromFile = function (file, callbacks)\n\t{\n\t\tvar reader = new FileReader ();\n\n\t\treader.onloadend = function (event) {\n\t\t\tif (event.target.readyState == FileReader.DONE && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (event.target.result);\n\t\t\t}\n\t\t};\n\t\t\n\t\treader.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\treader.readAsArrayBuffer (file);\n\t};\n\n\tJSM.GetStringBufferFromURL = function (url, callbacks)\n\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.open ('GET', url, true);\n\t\trequest.responseType = 'text';\n\n\t\trequest.onload = function () {\n\t\t\tvar stringBuffer = request.response;\n\t\t\tif (stringBuffer && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (stringBuffer);\n\t\t\t}\n\t\t};\n\t\t\n\t\trequest.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\trequest.send (null);\n\t};\n\n\tJSM.GetStringBufferFromFile = function (file, callbacks)\n\t{\n\t\tvar reader = new FileReader ();\n\n\t\treader.onloadend = function (event) {\n\t\t\tif (event.target.readyState == FileReader.DONE && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (event.target.result);\n\t\t\t}\n\t\t};\n\n\t\treader.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\t\n\t\t\n\t\treader.readAsText (file);\n\t};\n\n\tJSM.LoadMultipleBuffers = function (inputList, onReady)\n\t{\n\t\tfunction LoadMultipleBuffersInternal (inputList, index, result, onReady)\n\t\t{\n\t\t\tif (index >= inputList.length) {\n\t\t\t\tonReady (result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar currentInput = inputList[index];\n\t\t\tvar loaderFunction = null;\n\t\t\tif (currentInput.isFile) {\n\t\t\t\tif (currentInput.isArrayBuffer) {\n\t\t\t\t\tloaderFunction = JSM.GetArrayBufferFromFile;\n\t\t\t\t} else {\n\t\t\t\t\tloaderFunction = JSM.GetStringBufferFromFile;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentInput.isArrayBuffer) {\n\t\t\t\t\tloaderFunction = JSM.GetArrayBufferFromURL;\n\t\t\t\t} else {\n\t\t\t\t\tloaderFunction = JSM.GetStringBufferFromURL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tloaderFunction (currentInput.originalObject, {\n\t\t\t\tonReady : function (resultBuffer) {\n\t\t\t\t\tresult.push (resultBuffer);\n\t\t\t\t\tLoadMultipleBuffersInternal (inputList, index + 1, result, onReady);\n\t\t\t\t},\n\t\t\t\tonError : function () {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t\tLoadMultipleBuffersInternal (inputList, index + 1, result, onReady);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar result = [];\n\t\tLoadMultipleBuffersInternal (inputList, 0, result, function (result) {\n\t\t\tonReady (result);\n\t\t});\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importer3ds',[\"../core/jsm\"],function(JSM){\n\tJSM.Read3dsFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnLog (logText, logLevel)\n\t\t{\n\t\t\tif (callbacks.onLog !== undefined && callbacks.onLog !== null) {\n\t\t\t\tcallbacks.onLog (logText, logLevel);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterial (material)\n\t\t{\n\t\t\tif (callbacks.onMaterial !== undefined && callbacks.onMaterial !== null) {\n\t\t\t\tcallbacks.onMaterial (material);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMesh (objectName)\n\t\t{\n\t\t\tif (callbacks.onMesh !== undefined && callbacks.onMesh !== null) {\n\t\t\t\tcallbacks.onMesh (objectName);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTransformation (matrix)\n\t\t{\n\t\t\tif (callbacks.onTransformation !== undefined && callbacks.onTransformation !== null) {\n\t\t\t\tcallbacks.onTransformation (matrix);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnObjectNode (objectNode)\n\t\t{\n\t\t\tif (callbacks.onObjectNode !== undefined && callbacks.onObjectNode !== null) {\n\t\t\t\tcallbacks.onObjectNode (objectNode);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTextureVertex (x, y)\n\t\t{\n\t\t\tif (callbacks.onTextureVertex !== undefined && callbacks.onTextureVertex !== null) {\n\t\t\t\tcallbacks.onTextureVertex (x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (v0, v1, v2, flags)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, flags);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFaceMaterial (faceIndex, materialName)\n\t\t{\n\t\t\tif (callbacks.onFaceMaterial !== undefined && callbacks.onFaceMaterial !== null) {\n\t\t\t\tcallbacks.onFaceMaterial (faceIndex, materialName);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFaceSmoothingGroup (faceIndex, smoothingGroup)\n\t\t{\n\t\t\tif (callbacks.onFaceSmoothingGroup !== undefined && callbacks.onFaceSmoothingGroup !== null) {\n\t\t\t\tcallbacks.onFaceSmoothingGroup (faceIndex, smoothingGroup);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadChunk (reader, onReady)\n\t\t{\n\t\t\tvar chunkId = reader.ReadUnsignedInteger16 ();\n\t\t\tvar chunkLength = reader.ReadUnsignedInteger32 ();\n\t\t\tonReady (chunkId, chunkLength);\n\t\t}\n\t\t\n\t\tfunction SkipChunk (reader, length)\n\t\t{\n\t\t\treader.Skip (length - 6);\n\t\t}\n\t\t\n\t\tfunction GetChunkEnd (reader, length)\n\t\t{\n\t\t\treturn reader.GetPosition () + length - 6;\n\t\t}\n\t\t\n\t\tfunction ReadName (reader)\n\t\t{\n\t\t\tvar name = '';\n\t\t\tvar letter = 0;\n\t\t\tvar count = 0;\n\t\t\twhile (count < 64) {\n\t\t\t\tletter = reader.ReadCharacter ();\n\t\t\t\tif (letter === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname = name + String.fromCharCode (letter);\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction ReadChunks (reader, endByte, onReady)\n\t\t{\n\t\t\twhile (reader.GetPosition () <= endByte - 6) {\n\t\t\t\tReadChunk (reader, onReady);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadFile (reader, chunks)\n\t\t{\n\t\t\tfunction ReadColorChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tvar color = [0.0, 0.0, 0.0];\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar hasLinColor = false;\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_COLOR) {\n\t\t\t\t\t\tif (!hasLinColor) {\n\t\t\t\t\t\t\tcolor[0] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t\tcolor[1] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t\tcolor[2] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (chunkId == chunks.MAT_LIN_COLOR) {\n\t\t\t\t\t\tcolor[0] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\tcolor[1] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\tcolor[2] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\thasLinColor = true;\n\t\t\t\t\t} else if (chunkId == chunks.MAT_COLOR_F) {\n\t\t\t\t\t\tif (!hasLinColor) {\n\t\t\t\t\t\t\tcolor[0] = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcolor[1] = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcolor[2] = reader.ReadFloat32 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (chunkId == chunks.MAT_LIN_COLOR_F) {\n\t\t\t\t\t\tcolor[0] = reader.ReadFloat32 ();\n\t\t\t\t\t\tcolor[1] = reader.ReadFloat32 ();\n\t\t\t\t\t\tcolor[2] = reader.ReadFloat32 ();\n\t\t\t\t\t\thasLinColor = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn color;\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadPercentageChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tvar percentage = 0.0;\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.PERCENTAGE) {\n\t\t\t\t\t\tpercentage = reader.ReadUnsignedInteger16 () / 100.0;\n\t\t\t\t\t} else if (chunkId == chunks.PERCENTAGE_F) {\n\t\t\t\t\t\tpercentage = reader.ReadFloat32 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn percentage;\n\t\t\t}\n\n\t\t\tfunction ReadTextureMapChunk (reader, id, length, material)\n\t\t\t{\n\t\t\t\tmaterial.texture = null;\n\t\t\t\tmaterial.offset = [0.0, 0.0];\n\t\t\t\tmaterial.scale = [1.0, 1.0];\n\t\t\t\tmaterial.rotation = 0.0;\n\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_TEXMAP_NAME) {\n\t\t\t\t\t\tmaterial.texture = ReadName (reader);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_UOFFSET) {\n\t\t\t\t\t\tmaterial.offset[0] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_VOFFSET) {\n\t\t\t\t\t\tmaterial.offset[1] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_USCALE) {\n\t\t\t\t\t\tmaterial.scale[0] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_VSCALE) {\n\t\t\t\t\t\tmaterial.scale[1] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_ROTATION) {\n\t\t\t\t\t\tmaterial.rotation = reader.ReadFloat32 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadMaterialChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read material chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar material = {};\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_NAME) {\n\t\t\t\t\t\tOnLog ('Read material name chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.name = ReadName (reader);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_AMBIENT) {\n\t\t\t\t\t\tOnLog ('Read material ambient chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.ambient = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_DIFFUSE) {\n\t\t\t\t\t\tOnLog ('Read material diffuse chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.diffuse = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SPECULAR) {\n\t\t\t\t\t\tOnLog ('Read material specular chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.specular = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SHININESS) {\n\t\t\t\t\t\tOnLog ('Read material shininess chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.shininess = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SHININESS_STRENGTH) {\n\t\t\t\t\t\tOnLog ('Read material shininess strength chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.shininessStrength = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TRANSPARENCY) {\n\t\t\t\t\t\tOnLog ('Read material transparency chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.transparency = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP) {\n\t\t\t\t\t\tOnLog ('Read material texture map chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tReadTextureMapChunk (reader, chunkId, chunkLength, material);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tOnMaterial (material);\n\t\t\t}\n\n\t\t\tfunction ReadVerticesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read vertices chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar vertexCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, x, y, z;\n\t\t\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\t\t\tx = reader.ReadFloat32 ();\n\t\t\t\t\ty = reader.ReadFloat32 ();\n\t\t\t\t\tz = reader.ReadFloat32 ();\n\t\t\t\t\tOnVertex (x, y, z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadTextureVerticesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read texture vertices chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar texVertexCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, x, y;\n\t\t\t\tfor (i = 0; i < texVertexCount; i++) {\n\t\t\t\t\tx = reader.ReadFloat32 ();\n\t\t\t\t\ty = reader.ReadFloat32 ();\n\t\t\t\t\tOnTextureVertex (x, y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadFaceMaterialsChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read face materials chunk (' + id.toString (16) + ', ' + length + ')', 5);\n\t\t\t\t\n\t\t\t\tvar materialName = ReadName (reader);\n\t\t\t\tvar faceCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, faceIndex;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tfaceIndex = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tOnFaceMaterial (faceIndex, materialName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadFaceSmoothingGroupsChunk (reader, faceCount, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read face smoothing groups chunk (' + id.toString (16) + ', ' + length + ')', 5);\n\t\t\t\t\n\t\t\t\tvar i, smoothingGroup;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tsmoothingGroup = reader.ReadUnsignedInteger32 ();\n\t\t\t\t\tOnFaceSmoothingGroup (i, smoothingGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadFacesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read faces chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar faceCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, v0, v1, v2, flags;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tv0 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tv1 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tv2 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tflags = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tOnFace (v0, v1, v2, flags);\n\t\t\t\t}\n\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.TRI_MATERIAL) {\n\t\t\t\t\t\tReadFaceMaterialsChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_SMOOTH) {\n\t\t\t\t\t\tReadFaceSmoothingGroupsChunk (reader, faceCount,  chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 5);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadTransformationChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read transformation chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\tvar matrix = [];\n\t\t\t\tvar i, j;\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\tmatrix.push (reader.ReadFloat32 ());\n\t\t\t\t\t}\n\t\t\t\t\tif (i < 3) {\n\t\t\t\t\t\tmatrix.push (0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatrix.push (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tOnTransformation (matrix);\n\t\t\t}\n\n\t\t\tfunction ReadMeshChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read mesh chunk (' + objectName + ', ' +  id.toString (16) + ', ' + length + ')', 3);\n\n\t\t\t\tOnMesh (objectName);\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.TRI_VERTEX) {\n\t\t\t\t\t\tReadVerticesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_TEXVERTEX) {\n\t\t\t\t\t\tReadTextureVerticesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_FACE) {\n\t\t\t\t\t\tReadFacesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_TRANSFORMATION) {\n\t\t\t\t\t\tReadTransformationChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 4);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadLightChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Skip light chunk (' + objectName + ', ' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\tSkipChunk (reader, length);\n\t\t\t}\n\n\t\t\tfunction ReadCameraChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Skip camera chunk (' + objectName + ', ' +  id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\tSkipChunk (reader, length);\n\t\t\t}\n\n\t\t\tfunction ReadObjectChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read object chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar objectName = ReadName (reader);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJ_TRIMESH) {\n\t\t\t\t\t\tReadMeshChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.OBJ_LIGHT) {\n\t\t\t\t\t\tReadLightChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.OBJ_CAMERA) {\n\t\t\t\t\t\tReadCameraChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadEditorChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read editor chunk (' + id.toString (16) + ', ' + length + ')', 1);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.EDIT_MATERIAL) {\n\t\t\t\t\t\tReadMaterialChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.EDIT_OBJECT) {\n\t\t\t\t\t\tReadObjectChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 2);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadObjectNodeChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tfunction ReadTrackVector (reader, type)\n\t\t\t\t{\n\t\t\t\t\tvar result = [];\n\t\t\t\t\treader.Skip (10);\n\t\t\t\t\t\n\t\t\t\t\tvar i, flags, current, tmp;\n\t\t\t\t\tvar keyNum = reader.ReadInteger32 ();\n\t\t\t\t\tfor (i = 0; i < keyNum; i++) {\n\t\t\t\t\t\treader.ReadInteger32 ();\n\t\t\t\t\t\tflags = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t\tif (flags !== 0) {\n\t\t\t\t\t\t\treader.ReadFloat32 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurrent = null;\n\t\t\t\t\t\tif (type == chunks.OBJECT_ROTATION) {\n\t\t\t\t\t\t\ttmp = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcurrent = ReadVector (reader);\n\t\t\t\t\t\t\tcurrent[3] = tmp;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent = ReadVector (reader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push (current);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tOnLog ('Read object node chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar objectNode = {\n\t\t\t\t\tname : '',\n\t\t\t\t\tnodeId : -1,\n\t\t\t\t\tflags : -1,\n\t\t\t\t\tuserId : -1,\n\t\t\t\t\tpivot : [0.0, 0.0, 0.0],\n\t\t\t\t\tpositions : [],\n\t\t\t\t\trotations : [],\n\t\t\t\t\tscales : []\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJECT_HIERARCHY) {\n\t\t\t\t\t\tobjectNode.name = ReadName (reader);\n\t\t\t\t\t\tobjectNode.flags = reader.ReadUnsignedInteger32 ();\n\t\t\t\t\t\tobjectNode.userId = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_PIVOT) {\n\t\t\t\t\t\tobjectNode.pivot = ReadVector (reader);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_POSITION) {\n\t\t\t\t\t\tobjectNode.positions = ReadTrackVector (reader, chunks.OBJECT_POSITION);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_ROTATION) {\n\t\t\t\t\t\tobjectNode.rotations = ReadTrackVector (reader, chunks.OBJECT_ROTATION);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_SCALE) {\n\t\t\t\t\t\tobjectNode.scales = ReadTrackVector (reader, chunks.OBJECT_SCALE);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_ID) {\n\t\t\t\t\t\tobjectNode.nodeId = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tOnObjectNode (objectNode);\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadKeyFrameChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read keyframe chunk (' + id.toString (16) + ', ' + length + ')', 1);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJECT_NODE) {\n\t\t\t\t\t\tReadObjectNodeChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 2);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadMainChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read main chunk (' + id.toString (16) + ', ' + length + ')', 0);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.EDIT3DS) {\n\t\t\t\t\t\tReadEditorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.KF3DS) {\n\t\t\t\t\t\tReadKeyFrameChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 1);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\n\t\t\tvar endByte = reader.GetByteLength ();\n\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\tif (chunkId == chunks.MAIN3DS) {\n\t\t\t\t\tReadMainChunk (reader, chunkId, chunkLength);\n\t\t\t\t} else {\n\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 0);\n\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar chunks = {\n\t\t\tMAIN3DS : 0x4D4D,\n\t\t\tEDIT3DS : 0x3D3D,\n\t\t\tEDIT_MATERIAL : 0xAFFF,\n\t\t\tMAT_NAME : 0xA000,\n\t\t\tMAT_AMBIENT : 0xA010,\n\t\t\tMAT_DIFFUSE : 0xA020,\n\t\t\tMAT_SPECULAR : 0xA030,\n\t\t\tMAT_SHININESS : 0xA040,\n\t\t\tMAT_SHININESS_STRENGTH : 0xA041,\n\t\t\tMAT_TRANSPARENCY : 0xA050,\n\t\t\tMAT_COLOR_F : 0x0010,\n\t\t\tMAT_COLOR : 0x0011,\n\t\t\tMAT_LIN_COLOR : 0x0012,\n\t\t\tMAT_LIN_COLOR_F : 0x0013,\n\t\t\tMAT_TEXMAP : 0xA200,\n\t\t\tMAT_TEXMAP_NAME : 0xA300,\n\t\t\tMAT_TEXMAP_UOFFSET : 0xA358,\n\t\t\tMAT_TEXMAP_VOFFSET : 0xA35A,\n\t\t\tMAT_TEXMAP_USCALE : 0xA354,\n\t\t\tMAT_TEXMAP_VSCALE : 0xA356,\n\t\t\tMAT_TEXMAP_ROTATION : 0xA35C,\n\t\t\tPERCENTAGE : 0x0030,\n\t\t\tPERCENTAGE_F : 0x0031,\n\t\t\tEDIT_OBJECT : 0x4000,\n\t\t\tOBJ_TRIMESH : 0x4100,\n\t\t\tOBJ_LIGHT : 0x4600,\n\t\t\tOBJ_CAMERA : 0x4700,\n\t\t\tTRI_VERTEX : 0x4110,\n\t\t\tTRI_TEXVERTEX : 0x4140,\n\t\t\tTRI_FACE : 0x4120,\n\t\t\tTRI_TRANSFORMATION : 0x4160,\n\t\t\tTRI_MATERIAL : 0x4130,\n\t\t\tTRI_SMOOTH : 0x4150,\n\t\t\tKF3DS : 0xB000,\n\t\t\tOBJECT_NODE : 0xB002,\n\t\t\tOBJECT_HIERARCHY : 0xB010,\n\t\t\tOBJECT_PIVOT : 0xB013,\n\t\t\tOBJECT_POSITION : 0xB020,\n\t\t\tOBJECT_ROTATION : 0xB021,\n\t\t\tOBJECT_SCALE : 0xB022,\n\t\t\tOBJECT_ID : 0xB030\n\t\t};\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\tReadFile (reader, chunks);\n\t};\n\n\tJSM.Convert3dsToJsonData = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction FinalizeMeshes (nodeHierarcy, triangleModel, materialNameToIndex)\n\t\t{\n\t\t\tfunction ApplyTransformation (body, node, nodeHierarcy)\n\t\t\t{\n\t\t\t\tfunction MatrixScale (matrix, scale)\n\t\t\t\t{\n\t\t\t\t\tvar x = scale[0];\n\t\t\t\t\tvar y = scale[1];\n\t\t\t\t\tvar z = scale[2];\n\t\t\t\t\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\t\tmatrix[0 * 4 + i] *= x;\n\t\t\t\t\t\tmatrix[1 * 4 + i] *= y;\n\t\t\t\t\t\tmatrix[2 * 4 + i] *= z;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn matrix;\n\t\t\t\t}\n\n\t\t\t\tfunction MatrixTranslate (matrix, translation)\n\t\t\t\t{\n\t\t\t\t\tvar x = translation[0];\n\t\t\t\t\tvar y = translation[1];\n\t\t\t\t\tvar z = translation[2];\n\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tmatrix[3 * 4 + i] += matrix[0 * 4 + i] * x + matrix[1 * 4 + i] * y + matrix[2 * 4 + i] * z;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn matrix;\n\t\t\t\t}\n\n\t\t\t\tfunction MatrixRotate (matrix, quaternion)\n\t\t\t\t{\n\t\t\t\t\tvar rotation = JSM.MatrixRotationQuaternion (quaternion);\n\t\t\t\t\treturn JSM.MatrixMultiply (rotation, matrix);\n\t\t\t\t}\n\n\t\t\t\tfunction TransformBodyVertices (body, matrix)\n\t\t\t\t{\n\t\t\t\t\tvar i, vertex, transformedVertex;\n\t\t\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\t\t\ttransformedVertex = JSM.ApplyTransformation (matrix, vertex);\n\t\t\t\t\t\tbody.SetVertex (i, transformedVertex.x, transformedVertex.y, transformedVertex.z);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction FlipByXCoordinates (body, matrix, invMatrix)\t\n\t\t\t\t{\n\t\t\t\t\tvar determinant = JSM.MatrixDeterminant (matrix);\n\t\t\t\t\tif (!JSM.IsNegative (determinant)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar flippedMatrix = JSM.MatrixClone (matrix);\n\t\t\t\t\tMatrixScale (flippedMatrix, [-1.0, 1.0, 1.0]);\n\t\t\t\t\t\n\t\t\t\t\tvar finalMatrix = JSM.MatrixMultiply (invMatrix, flippedMatrix);\n\t\t\t\t\tTransformBodyVertices (body, finalMatrix);\n\t\t\t\t}\n\n\t\t\t\tfunction GetNodeTransformation (node, nodeHierarcy)\n\t\t\t\t{\n\t\t\t\t\tfunction GetNodePosition (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.positions.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node.positions[0];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tfunction GetNodeRotation (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tfunction GetQuatFromAxisAndAngle (quat)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar result = [0.0, 0.0, 0.0, 1.0];\n\t\t\t\t\t\t\tvar length = Math.sqrt (quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2]);\n\t\t\t\t\t\t\tif (JSM.IsPositive (length)) {\n\t\t\t\t\t\t\t\tvar omega = quat[3] * -0.5;\n\t\t\t\t\t\t\t\tvar si = Math.sin (omega) / length;\n\t\t\t\t\t\t\t\tresult = [si * quat[0], si * quat[1], si * quat[2], Math.cos (omega)];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (node.rotations.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar quat = node.rotations[0];\n\t\t\t\t\t\treturn GetQuatFromAxisAndAngle (quat);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction GetNodeScale (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.scales.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node.scales[0];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (node.matrix !== undefined) {\n\t\t\t\t\t\treturn node.matrix;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar result = JSM.MatrixIdentity ();\n\t\t\t\t\tresult = MatrixTranslate (result, GetNodePosition (node));\n\t\t\t\t\tresult = MatrixRotate (result, GetNodeRotation (node));\n\t\t\t\t\tresult = MatrixScale (result, GetNodeScale (node));\n\t\t\t\t\t\n\t\t\t\t\tif (node.userId != 65535) {\n\t\t\t\t\t\tvar parentIndex = nodeHierarcy.nodeIdToIndex[node.userId];\n\t\t\t\t\t\tif (parentIndex !== undefined) {\n\t\t\t\t\t\t\tvar parentNode = nodeHierarcy.nodes[parentIndex];\n\t\t\t\t\t\t\tvar parentTransformation = GetNodeTransformation (parentNode, nodeHierarcy);\n\t\t\t\t\t\t\tresult = JSM.MatrixMultiply (result, parentTransformation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode.matrix = result;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tfunction GetNodePivotPoint (node)\n\t\t\t\t{\n\t\t\t\t\tif (node === undefined || node === null) {\n\t\t\t\t\t\treturn [0.0, 0.0, 0.0];\n\t\t\t\t\t}\n\t\t\t\t\treturn node.pivot;\n\t\t\t\t}\n\n\t\t\t\tfunction GetMeshTransformation (mesh)\n\t\t\t\t{\n\t\t\t\t\tif (mesh === undefined || mesh === null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn mesh.transformation;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar currentMeshData = body.meshData;\n\t\t\t\tvar meshTransformation = GetMeshTransformation (currentMeshData);\n\t\t\t\tif (meshTransformation === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar nodeTransformation = null;\n\t\t\t\tif (node !== null) {\n\t\t\t\t\tnodeTransformation = GetNodeTransformation (node, nodeHierarcy);\n\t\t\t\t} else {\n\t\t\t\t\tnodeTransformation = meshTransformation;\n\t\t\t\t}\n\n\t\t\t\tvar matrix = JSM.MatrixClone (nodeTransformation);\n\t\t\t\tvar meshMatrix = JSM.MatrixClone (meshTransformation);\n\t\t\t\tvar invMeshMatrix = JSM.MatrixInvert (meshMatrix);\n\t\t\t\tif (invMeshMatrix === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tFlipByXCoordinates (body, meshMatrix, invMeshMatrix);\n\n\t\t\t\tvar nodePivotPoint = GetNodePivotPoint (node);\n\t\t\t\tMatrixTranslate (matrix, [-nodePivotPoint[0], -nodePivotPoint[1], -nodePivotPoint[2]]);\n\t\t\t\tvar finalMatrix = JSM.MatrixMultiply (invMeshMatrix, matrix);\n\t\t\t\tTransformBodyVertices (body, finalMatrix);\n\t\t\t}\n\n\t\t\tfunction FinalizeMaterials (body, materialNameToIndex)\n\t\t\t{\n\t\t\t\tvar hasTextureCoordinates = (body.UVCount () == body.VertexCount ());\n\t\t\t\tvar currentMeshData = body.meshData;\n\t\t\t\tvar i, triangle, materialName, materialIndex, smoothingGroup;\n\t\t\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\t\t\ttriangle = body.GetTriangle (i);\n\t\t\t\t\tif (hasTextureCoordinates) {\n\t\t\t\t\t\ttriangle.u0 = triangle.v0;\n\t\t\t\t\t\ttriangle.u1 = triangle.v1;\n\t\t\t\t\t\ttriangle.u2 = triangle.v2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmaterialName = currentMeshData.faceToMaterial[i];\n\t\t\t\t\tif (materialName !== undefined) {\n\t\t\t\t\t\tmaterialIndex = materialNameToIndex[materialName];\n\t\t\t\t\t\tif (materialIndex !== undefined) {\n\t\t\t\t\t\t\ttriangle.mat = materialIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsmoothingGroup = currentMeshData.faceToSmoothingGroup[i];\n\t\t\t\t\tif (smoothingGroup !== undefined && smoothingGroup > 0) {\n\t\t\t\t\t\ttriangle.curve = smoothingGroup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction FinalizeMesh (body, node, materialNameToIndex, nodeHierarcy)\n\t\t\t{\n\t\t\t\tApplyTransformation (body, node, nodeHierarcy);\n\t\t\t\tFinalizeMaterials (body, materialNameToIndex);\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfunction DuplicateBody (model, body, bodyIndex, instanceIndex)\n\t\t\t{\n\t\t\t\tvar clonedBody = body.Clone ();\n\t\t\t\tclonedBody.SetName (clonedBody.GetName () + ' (' + instanceIndex + ')');\n\t\t\t\tif (bodyIndex < model.BodyCount ()) {\n\t\t\t\t\tmodel.AddBodyToIndex (clonedBody, bodyIndex);\n\t\t\t\t} else {\n\t\t\t\t\tmodel.AddBody (clonedBody);\n\t\t\t\t}\n\t\t\t\treturn clonedBody;\n\t\t\t}\n\n\t\t\tvar i, j, currentBody, currentMeshData, currentNode;\n\t\t\tvar firstNode, addedBody;\n\t\t\tfor (i = 0; i < triangleModel.BodyCount (); i++) {\n\t\t\t\tcurrentBody = triangleModel.GetBody (i);\n\t\t\t\tcurrentMeshData = currentBody.meshData;\n\t\t\t\tif (currentMeshData.objectNodes.length === 0) {\n\t\t\t\t\tFinalizeMesh (currentBody, null, materialNameToIndex, nodeHierarcy);\n\t\t\t\t} else {\n\t\t\t\t\tfirstNode = nodeHierarcy.nodes[currentMeshData.objectNodes[0]];\n\t\t\t\t\tfor (j = 1; j < currentMeshData.objectNodes.length; j++) {\n\t\t\t\t\t\tcurrentNode = nodeHierarcy.nodes[currentMeshData.objectNodes[j]];\n\t\t\t\t\t\taddedBody = DuplicateBody (triangleModel, currentBody, i + 1, j + 1);\n\t\t\t\t\t\taddedBody.meshData = currentBody.meshData;\n\t\t\t\t\t\tFinalizeMesh (addedBody, currentNode, materialNameToIndex, nodeHierarcy);\n\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tFinalizeMesh (currentBody, firstNode, materialNameToIndex, nodeHierarcy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar currentBody = null;\n\t\t\n\t\tvar materialNameToIndex = {};\n\t\tvar bodyNameToIndex = {};\n\n\t\tvar nodeHierarcy = {\n\t\t\tnodes : [],\n\t\t\tnodeIdToIndex : {}\n\t\t};\n\t\t\n\t\tJSM.Read3dsFile (arrayBuffer, {\n\t\t\tonMaterial : function (material) {\n\t\t\t\tfunction GetOpacity (transparency)\n\t\t\t\t{\n\t\t\t\t\tif (transparency === undefined || transparency === null) {\n\t\t\t\t\t\treturn 1.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1.0 - transparency;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetShininess (shininess, shininessStrength)\n\t\t\t\t{\n\t\t\t\t\tif (shininess === undefined || shininess === null) {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tif (shininessStrength === undefined || shininessStrength === null) {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn shininess * shininessStrength;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (materialNameToIndex[material.name] !== undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar index = triangleModel.AddMaterial ({\n\t\t\t\t\tname : material.name,\n\t\t\t\t\tambient : material.ambient,\n\t\t\t\t\tdiffuse : material.diffuse,\n\t\t\t\t\tspecular : material.specular,\n\t\t\t\t\tshininess : GetShininess (material.shininess, material.shininessStrength),\n\t\t\t\t\topacity : GetOpacity (material.transparency)\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar currentMaterial = triangleModel.GetMaterial (index);\n\t\t\t\tif (material.texture !== undefined && material.texture !== null) {\n\t\t\t\t\tvar textureBuffer = OnFileRequested (material.texture);\n\t\t\t\t\tif (textureBuffer !== null) {\n\t\t\t\t\t\tvar blob = new window.Blob ([textureBuffer]);\n\t\t\t\t\t\tvar blobURL = window.URL.createObjectURL (blob);\n\t\t\t\t\t\tcurrentMaterial.texture = blobURL;\n\t\t\t\t\t\tcurrentMaterial.offset = material.offset;\n\t\t\t\t\t\tcurrentMaterial.scale = material.scale;\n\t\t\t\t\t\tcurrentMaterial.rotation = -material.rotation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaterialNameToIndex[material.name] = index;\n\t\t\t},\n\t\t\tonMesh : function (meshName) {\n\t\t\t\tif (bodyNameToIndex[meshName] !== undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody (meshName));\n\t\t\t\tcurrentBody = triangleModel.GetBody (index);\n\t\t\t\tcurrentBody.meshData ={\n\t\t\t\t\tfaceToMaterial : {},\n\t\t\t\t\tfaceToSmoothingGroup : {},\n\t\t\t\t\tobjectNodes : [],\n\t\t\t\t\ttransformation : null\n\t\t\t\t};\n\t\t\t\tbodyNameToIndex[meshName] = index;\n\t\t\t},\n\t\t\tonTransformation : function (matrix) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.transformation = matrix;\n\t\t\t},\n\t\t\tonObjectNode : function (objectNode) {\n\t\t\t\tvar nodeIndex = nodeHierarcy.nodes.length;\n\t\t\t\tnodeHierarcy.nodes.push (objectNode);\n\t\t\t\tnodeHierarcy.nodeIdToIndex[objectNode.nodeId] = nodeIndex;\n\n\t\t\t\tvar bodyIndex = bodyNameToIndex[objectNode.name];\n\t\t\t\tif (bodyIndex === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar body = triangleModel.GetBody (bodyIndex);\n\t\t\t\tbody.meshData.objectNodes.push (nodeIndex);\n\t\t\t},\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonTextureVertex : function (x, y) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddUV (x, y);\n\t\t\t},\n\t\t\tonFace : function (v0, v1, v2) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t},\n\t\t\tonFaceMaterial : function (faceIndex, materialName) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.faceToMaterial[faceIndex] = materialName;\n\t\t\t},\n\t\t\tonFaceSmoothingGroup : function (faceIndex, smoothingGroup) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.faceToSmoothingGroup[faceIndex] = smoothingGroup;\n\t\t\t},\n\t\t\tonFileRequested : OnFileRequested\n\t\t});\n\t\t\n\t\tFinalizeMeshes (nodeHierarcy, triangleModel, materialNameToIndex);\n\t\ttriangleModel.Finalize ();\n\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerobj',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadObjFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnNewMaterial (name)\n\t\t{\n\t\t\tif (callbacks.onNewMaterial !== undefined && callbacks.onNewMaterial !== null) {\n\t\t\t\tcallbacks.onNewMaterial (name);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialComponent (name, red, green, blue)\n\t\t{\n\t\t\tif (callbacks.onMaterialComponent !== undefined && callbacks.onMaterialComponent !== null) {\n\t\t\t\tcallbacks.onMaterialComponent (name, red, green, blue);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialParameter (name, value)\n\t\t{\n\t\t\tif (callbacks.onMaterialParameter !== undefined && callbacks.onMaterialParameter !== null) {\n\t\t\t\tcallbacks.onMaterialParameter (name, value);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialTexture (textureName)\n\t\t{\n\t\t\tif (callbacks.onMaterialTexture !== undefined && callbacks.onMaterialTexture !== null) {\n\t\t\t\tcallbacks.onMaterialTexture (textureName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnUseMaterial (name)\n\t\t{\n\t\t\tif (callbacks.onUseMaterial !== undefined && callbacks.onUseMaterial !== null) {\n\t\t\t\tcallbacks.onUseMaterial (name);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMesh (meshName)\n\t\t{\n\t\t\tif (callbacks.onMesh !== undefined && callbacks.onMesh !== null) {\n\t\t\t\tcallbacks.onMesh (meshName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnNormal (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onNormal !== undefined && callbacks.onNormal !== null) {\n\t\t\t\tcallbacks.onNormal (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTexCoord (x, y)\n\t\t{\n\t\t\tif (callbacks.onTexCoord !== undefined && callbacks.onTexCoord !== null) {\n\t\t\t\tcallbacks.onTexCoord (x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices, normals, uvs)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices, normals, uvs);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction ProcessLine (line, objectCounter)\n\t\t{\n\t\t\tfunction GetIndex (index, count)\n\t\t\t{\n\t\t\t\tif (index > 0) {\n\t\t\t\t\treturn index - 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn count + index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction GetFileName (line, keyword)\n\t\t\t{\n\t\t\t\tvar fileNameIndex = line.indexOf (keyword) + keyword.length;\n\t\t\t\tvar fileName = line.substr (fileNameIndex, line.length - fileNameIndex);\n\t\t\t\treturn fileName.trim ();\n\t\t\t}\n\t\t\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar i, fileName;\n\t\t\tif (lineParts[0] == 'g') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar meshName = '';\n\t\t\t\tfor (i = 1; i < lineParts.length; i++) {\n\t\t\t\t\tmeshName += lineParts[i];\n\t\t\t\t\tif (i < lineParts.length - 1) {\n\t\t\t\t\t\tmeshName += ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOnMesh (meshName);\n\t\t\t} else if (lineParts[0] == 'v') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.vertexCount += 1;\n\t\t\t\tOnVertex (parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'vn') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.normalCount += 1;\n\t\t\t\tOnNormal (parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'vt') {\n\t\t\t\tif (lineParts.length < 3) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.uvCount += 1;\n\t\t\t\tOnTexCoord (parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t} else if (lineParts[0] == 'f') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar uvs = [];\n\t\t\t\t\n\t\t\t\tvar partSplitted;\n\t\t\t\tfor (i = 1; i < lineParts.length; i++) {\n\t\t\t\t\tpartSplitted = lineParts[i].split ('/');\n\t\t\t\t\tvertices.push (GetIndex (parseInt (partSplitted[0], 10), objectCounter.vertexCount));\n\t\t\t\t\tif (partSplitted.length > 1 && partSplitted[1].length > 0) {\n\t\t\t\t\t\tuvs.push (GetIndex (parseInt (partSplitted[1], 10), objectCounter.uvCount));\n\t\t\t\t\t}\n\t\t\t\t\tif (partSplitted.length > 2 && partSplitted[2].length > 0) {\n\t\t\t\t\t\tnormals.push (GetIndex (parseInt (partSplitted[2], 10), objectCounter.normalCount));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOnFace (vertices, normals, uvs);\n\t\t\t} else if (lineParts[0] == 'usemtl') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnUseMaterial (lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'newmtl') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnNewMaterial (lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'Ka' || lineParts[0] == 'Kd' || lineParts[0] == 'Ks') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnMaterialComponent (lineParts[0], parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'Ns' || lineParts[0] == 'Tr' || lineParts[0] == 'd') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tOnMaterialParameter (lineParts[0], lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'map_Kd') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfileName = GetFileName (line, 'map_Kd');\n\t\t\t\tOnMaterialTexture (fileName);\n\t\t\t} else if (lineParts[0] == 'mtllib') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileName = GetFileName (line, 'mtllib');\n\t\t\t\tvar fileStringBuffer = OnFileRequested (fileName.trim ());\n\t\t\t\tif (fileStringBuffer === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tProcessFile (fileStringBuffer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer, objectCounter)\n\t\t{\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, objectCounter);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar objectCounter = {\n\t\t\tvertexCount : 0,\n\t\t\tnormalCount : 0,\n\t\t\tuvCount : 0\n\t\t};\n\n\t\tProcessFile (stringBuffer, objectCounter);\n\t};\n\n\tJSM.ConvertObjToJsonData = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tvar materialNameToIndex = {};\n\t\tvar currentMaterial = null;\n\t\tvar currentMaterialIndex = null;\n\t\t\n\t\tvar globalVertices = [];\n\t\tvar globalNormals = [];\n\t\tvar globalUVs = [];\n\t\t\n\t\tvar globalToLocalVertices = {};\n\t\tvar globalToLocalNormals = {};\n\t\tvar globalToLocalUVs = {};\n\t\t\n\t\tJSM.ReadObjFile (stringBuffer, {\n\t\t\tonNewMaterial : function (name) {\n\t\t\t\tvar index = triangleModel.AddMaterial ({\n\t\t\t\t\tname : name\n\t\t\t\t});\n\t\t\t\tcurrentMaterial = triangleModel.GetMaterial (index);\n\t\t\t\tmaterialNameToIndex[name] = index;\n\t\t\t},\n\t\t\tonMaterialComponent : function (name, red, green, blue) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (name == 'Ka') {\n\t\t\t\t\tcurrentMaterial.ambient = [red, green, blue];\n\t\t\t\t} else if (name == 'Kd') {\n\t\t\t\t\tcurrentMaterial.diffuse = [red, green, blue];\n\t\t\t\t} else if (name == 'Ks') {\n\t\t\t\t\tcurrentMaterial.specular = [red, green, blue];\n\t\t\t\t}\n\t\t\t},\n\t\t\tonMaterialParameter : function (name, value) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (name == 'Ns') {\n\t\t\t\t\tcurrentMaterial.shininess = 0.0;\n\t\t\t\t\tif (JSM.IsPositive (value)) {\n\t\t\t\t\t\tcurrentMaterial.shininess = (Math.log2 (parseFloat (value)) - 1) / 10.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (name == 'Tr') {\n\t\t\t\t\tcurrentMaterial.opacity = 1.0 - parseFloat (value);\n\t\t\t\t} else if (name == 'd') {\n\t\t\t\t\tcurrentMaterial.opacity = parseFloat (value);\n\t\t\t\t}\t\t\t\n\t\t\t},\n\t\t\tonMaterialTexture : function (textureName) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar textureBuffer = OnFileRequested (textureName);\n\t\t\t\tif (textureBuffer === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar blob = new window.Blob ([textureBuffer]);\n\t\t\t\tvar blobURL = window.URL.createObjectURL (blob);\n\t\t\t\tcurrentMaterial.texture = blobURL;\n\t\t\t},\n\t\t\tonUseMaterial : function (name) {\n\t\t\t\tvar materialIndex = materialNameToIndex[name];\n\t\t\t\tif (materialIndex !== undefined) {\n\t\t\t\t\tcurrentMaterialIndex = materialIndex;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonMesh : function (meshName) {\n\t\t\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody (meshName));\n\t\t\t\tcurrentBody = triangleModel.GetBody (index);\n\t\t\t\tglobalToLocalVertices = {};\n\t\t\t\tglobalToLocalNormals = {};\n\t\t\t\tglobalToLocalUVs = {};\n\t\t\t},\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tglobalVertices.push (new JSM.Coord (x, y, z));\n\t\t\t},\n\t\t\tonNormal : function (x, y, z) {\n\t\t\t\tglobalNormals.push (new JSM.Coord (x, y, z));\n\t\t\t},\n\t\t\tonTexCoord : function (x, y) {\n\t\t\t\tglobalUVs.push (new JSM.Coord2D (x, y));\n\t\t\t},\n\t\t\tonFace : function (vertices, normals, uvs) {\n\t\t\t\tfunction GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, valueAdderFunc)\n\t\t\t\t{\n\t\t\t\t\tif (globalIndex < 0 || globalIndex >= globalValueArray.length) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\tvar result = globalToLocalIndices[globalIndex];\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tvar globalValue = globalValueArray[globalIndex];\n\t\t\t\t\t\tresult = valueAdderFunc (globalValue);\n\t\t\t\t\t\tglobalToLocalIndices[globalIndex] = result;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalVertexIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddVertex (val.x, val.y, val.z);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalNormalIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddNormal (val.x, val.y, val.z);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalUVIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddUV (val.x, val.y);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar i, v0, v1, v2, triangle, triangleIndex;\n\t\t\t\tvar hasNormals = (normals.length == vertices.length);\n\t\t\t\tvar hasUVs = (uvs.length == vertices.length);\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[0]);\n\t\t\t\t\tv1 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[(i + 1) % count]);\n\t\t\t\t\tv2 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[(i + 2) % count]);\n\t\t\t\t\ttriangleIndex = currentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t\ttriangle = currentBody.GetTriangle (triangleIndex);\n\t\t\t\t\tif (hasNormals) {\n\t\t\t\t\t\ttriangle.n0 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[0]);\n\t\t\t\t\t\ttriangle.n1 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[(i + 1) % count]);\n\t\t\t\t\t\ttriangle.n2 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[(i + 2) % count]);\n\t\t\t\t\t}\n\t\t\t\t\tif (hasUVs) {\n\t\t\t\t\t\ttriangle.u0 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[0]);\n\t\t\t\t\t\ttriangle.u1 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[(i + 1) % count]);\n\t\t\t\t\t\ttriangle.u2 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[(i + 2) % count]);\n\t\t\t\t\t}\n\t\t\t\t\tif (currentMaterialIndex !== null) {\n\t\t\t\t\t\ttriangle.mat = currentMaterialIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonFileRequested : OnFileRequested\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerstl',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadBinaryStlFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tvar i, v0, v1, v2, normal;\n\t\tfor (i = 0; i < triangleCount; i++) {\n\t\t\tnormal = ReadVector (reader);\n\t\t\tv0 = ReadVector (reader);\n\t\t\tv1 = ReadVector (reader);\n\t\t\tv2 = ReadVector (reader);\n\t\t\treader.Skip (2);\n\t\t\tOnFace (v0, v1, v2, normal);\n\t\t}\n\t};\n\n\tJSM.ReadAsciiStlFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (lines, lineIndex)\n\t\t{\n\t\t\tfunction GetLine (lines, lineIndex)\n\t\t\t{\n\t\t\t\treturn lines[lineIndex].trim ();\n\t\t\t}\n\t\t\n\t\t\tfunction GetVertices (lines, lineIndex, vertices)\n\t\t\t{\n\t\t\t\tvar currentLineIndex, currentLine, lineParts, vertex;\n\t\t\t\tfor (currentLineIndex = lineIndex; currentLineIndex < lines.length && vertices.length < 3; currentLineIndex++) {\n\t\t\t\t\tcurrentLine = GetLine (lines, currentLineIndex);\n\t\t\t\t\tif (currentLine.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlineParts = currentLine.split (/\\s+/);\n\t\t\t\t\tif (lineParts.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (lineParts[0] == 'vertex') {\n\t\t\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvertex = [parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3])];\n\t\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn currentLineIndex + 1;\n\t\t\t}\n\t\t\n\t\t\tvar line = GetLine (lines, lineIndex);\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\n\t\t\tif (lineParts[0] == 'solid') {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t} else if (lineParts[0] == 'facet' && lineParts[1] == 'normal') {\n\t\t\t\tif (lineParts.length < 5) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar normal = [parseFloat (lineParts[2]), parseFloat (lineParts[3]), parseFloat (lineParts[4])];\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar nextLineIndex = GetVertices (lines, lineIndex + 1, vertices);\n\t\t\t\tif (vertices.length != 3) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnFace (vertices[0], vertices[1], vertices[2], normal);\n\t\t\t\treturn nextLineIndex;\n\t\t\t}\n\n\t\t\treturn lineIndex + 1;\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar lineIndex = 0;\n\t\tvar lines = stringBuffer.split ('\\n');\n\t\twhile (lineIndex < lines.length && lineIndex != -1) {\n\t\t\tlineIndex = ProcessLine (lines, lineIndex);\n\t\t}\n\t};\n\n\tJSM.IsBinaryStlFile = function (arrayBuffer)\n\t{\n\t\tvar byteLength = arrayBuffer.byteLength;\n\t\tif (byteLength < 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tif (byteLength != triangleCount * 50 + 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.ConvertStlToJsonData = function (arrayBuffer, stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\n\t\tif (arrayBuffer !== null) {\n\t\t\tJSM.ReadBinaryStlFile (arrayBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (stringBuffer !== null) {\n\t\t\tJSM.ReadAsciiStlFile (stringBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importeroff',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadOffFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (line, readState)\n\t\t{\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!readState.offHeaderFound) {\n\t\t\t\tif (lineParts.length == 1 && lineParts[0] == 'OFF') {\n\t\t\t\t\treadState.offHeaderFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (!readState.infoFound) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\treadState.vertexCount = parseInt (lineParts[0]);\n\t\t\t\t\treadState.faceCount = parseInt (lineParts[1]);\n\t\t\t\t\treadState.infoFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readVertices < readState.vertexCount) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\tOnVertex (parseFloat (lineParts[0]), parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t\t\treadState.readVertices += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readFaces < readState.faceCount) {\n\t\t\t\tvar vertexCount = parseInt (lineParts[0]);\n\t\t\t\tif (lineParts.length >= vertexCount + 1) {\n\t\t\t\t\tvar vertices = [];\n\t\t\t\t\tvar i, vertex;\n\t\t\t\t\tfor (i = 1; i < vertexCount + 1; i++) {\n\t\t\t\t\t\tvertex = parseInt (lineParts[i]);\n\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t}\n\t\t\t\t\tOnFace (vertices);\n\t\t\t\t\treadState.readFaces += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer)\n\t\t{\n\t\t\tvar readState = {\n\t\t\t\toffHeaderFound : false,\n\t\t\t\tinfoFound : false,\n\t\t\t\tvertexCount : 0,\n\t\t\t\tfaceCount : 0,\n\t\t\t\treadVertices : 0,\n\t\t\t\treadFaces : 0\n\t\t\t};\n\t\t\t\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, readState);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tProcessFile (stringBuffer);\n\t};\n\n\tJSM.ConvertOffToJsonData = function (stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tJSM.ReadOffFile (stringBuffer, {\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonFace : function (vertices) {\n\t\t\t\tvar i, v0, v1, v2;\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = vertices[0];\n\t\t\t\t\tv1 = vertices[i + 1];\n\t\t\t\t\tv2 = vertices[i + 2];\n\t\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importercommon',[\"../core/jsm\"],function(JSM){\n\tJSM.ImportFileList = function ()\n\t{\n\t\tthis.descriptors = null;\n\t\tthis.isFile = null;\n\t};\n\n\tJSM.ImportFileList.prototype.InitFromFiles = function (fileList)\n\t{\n\t\tthis.descriptors = [];\n\t\tvar i, file, descriptor;\n\t\tfor (i = 0; i < fileList.length; i++) {\n\t\t\tfile = fileList[i];\n\t\t\tdescriptor = {\n\t\t\t\toriginalObject : file,\n\t\t\t\toriginalFileName : file.name,\n\t\t\t\tfileName : file.name.toUpperCase (),\n\t\t\t\textension : this.GetFileExtension (file.name).toUpperCase ()\n\t\t\t};\n\t\t\tthis.descriptors.push (descriptor);\n\t\t}\n\t\tthis.isFile = true;\n\t};\n\n\tJSM.ImportFileList.prototype.InitFromURLs = function (urlList)\n\t{\n\t\tthis.descriptors = [];\n\t\tvar i, url, fileName, descriptor;\n\t\tfor (i = 0; i < urlList.length; i++) {\n\t\t\turl = urlList[i];\n\t\t\tfileName = this.GetFileName (url);\n\t\t\tdescriptor = {\n\t\t\t\toriginalObject : url,\n\t\t\t\toriginalFileName : fileName,\n\t\t\t\tfileName : fileName.toUpperCase (),\n\t\t\t\textension : this.GetFileExtension (fileName).toUpperCase ()\n\t\t\t};\n\t\t\tthis.descriptors.push (descriptor);\n\t\t}\n\t\tthis.isFile = false;\n\t};\n\n\tJSM.ImportFileList.prototype.GetInputList = function ()\n\t{\n\t\tfunction IsArrayBuffer (descriptor)\n\t\t{\n\t\t\tif (descriptor.extension == '.OBJ' || descriptor.extension == '.MTL' || descriptor.extension == '.OFF') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tvar result = [];\n\t\tvar i, descriptor, inputListElem;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tinputListElem = {\n\t\t\t\toriginalObject : descriptor.originalObject,\n\t\t\t\tisFile : this.isFile,\n\t\t\t\tisArrayBuffer : IsArrayBuffer (descriptor)\n\t\t\t};\n\t\t\tresult.push (inputListElem);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileName = function (fullFileName)\n\t{\n\t\tvar splitted = fullFileName.split ('/');\n\t\tif (splitted.length == 1) {\n\t\t\tsplitted = fullFileName.split ('\\\\');\n\t\t}\n\t\tif (splitted.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tvar fileName = splitted[splitted.length - 1];\n\t\treturn decodeURI (fileName);\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileDescriptor = function (index)\n\t{\n\t\treturn this.descriptors[index];\n\t};\n\n\tJSM.ImportFileList.prototype.GetMainFileIndex = function ()\n\t{\n\t\tvar i, descriptor;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tif (this.IsSupportedExtension (descriptor.extension)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileIndexByName = function (fileName)\n\t{\n\t\tvar i, descriptor, currentFileName;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tcurrentFileName = this.GetFileName (fileName);\n\t\t\tif (descriptor.fileName == currentFileName.toUpperCase ()) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tJSM.ImportFileList.prototype.IsSupportedExtension = function (extension)\n\t{\n\t\tif (extension == '.3DS' || extension == '.OBJ' || extension == '.STL' || extension == '.OFF') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileExtension = function (fileName)\n\t{\n\t\tvar lastPoint = fileName.lastIndexOf ('.');\n\t\tif (lastPoint == -1) {\n\t\t\treturn '';\n\t\t}\n\t\tvar extension = fileName.substr (lastPoint);\n\t\treturn extension;\n\t};\n\n\tJSM.ConvertImportFileListToJsonData = function (importFileList, callbacks)\n\t{\n\t\tfunction OnError ()\n\t\t{\n\t\t\tif (callbacks.onError !== undefined && callbacks.onError !== null) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t}\n\n\t\tfunction OnReady (fileNames, jsonData)\n\t\t{\n\t\t\tif (callbacks.onReady !== undefined && callbacks.onReady !== null) {\n\t\t\t\tcallbacks.onReady (fileNames, jsonData);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction FileRequested (importFileList, resultBuffers, fileName, fileNames)\n\t\t{\n\t\t\tvar requestedFileIndex = importFileList.GetFileIndexByName (fileName);\n\t\t\tvar currentFileName = importFileList.GetFileName (fileName);\n\t\t\tif (requestedFileIndex == -1) {\n\t\t\t\tfileNames.missing.push (currentFileName);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (fileNames.requested.indexOf (currentFileName) == -1) {\n\t\t\t\tfileNames.requested.push (currentFileName);\n\t\t\t}\n\t\t\treturn resultBuffers[requestedFileIndex];\t\n\t\t}\n\t\t\n\t\tvar mainFileIndex = importFileList.GetMainFileIndex ();\n\t\tif (mainFileIndex === -1) {\n\t\t\tOnError ();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar mainFile = importFileList.GetFileDescriptor (mainFileIndex);\n\t\tvar fileNames = {\n\t\t\tmain : mainFile.originalFileName,\n\t\t\trequested : [],\n\t\t\tmissing : []\n\t\t};\n\n\t\tvar inputList = importFileList.GetInputList ();\n\t\ttry {\n\t\t\tif (mainFile.extension == '.3DS') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.Convert3dsToJsonData (mainFileBuffer, {\n\t\t\t\t\t\t\tonFileRequested : function (fileName) {\n\t\t\t\t\t\t\t\treturn FileRequested (importFileList, resultBuffers, fileName, fileNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.OBJ') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.ConvertObjToJsonData (mainFileBuffer, {\n\t\t\t\t\t\t\tonFileRequested : function (fileName) {\n\t\t\t\t\t\t\t\treturn FileRequested (importFileList, resultBuffers, fileName, fileNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.STL') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (JSM.IsBinaryStlFile (mainFileBuffer)) {\n\t\t\t\t\t\t\tvar jsonData = JSM.ConvertStlToJsonData (mainFileBuffer, null);\n\t\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\tfor (i = 0; i < inputList.length; i++) {\n\t\t\t\t\t\t\t\tinputList[i].isArrayBuffer = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\t\t\t\tOnError ();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar jsonData = JSM.ConvertStlToJsonData (null, mainFileBuffer);\n\t\t\t\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.OFF') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.ConvertOffToJsonData (mainFileBuffer);\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (exception) {\n\t\t\tOnError ();\n\t\t\treturn;\n\t\t}\n\t};\n\n\tJSM.ConvertFileListToJsonData = function (fileList, callbacks)\n\t{\n\t\tvar importFileList = new JSM.ImportFileList ();\n\t\timportFileList.InitFromFiles (fileList);\n\t\tJSM.ConvertImportFileListToJsonData (importFileList, callbacks);\n\t};\n\n\tJSM.ConvertURLListToJsonData = function (urlList, callbacks)\n\t{\n\t\tvar importFileList = new JSM.ImportFileList ();\n\t\timportFileList.InitFromURLs (urlList);\n\t\tJSM.ConvertImportFileListToJsonData (importFileList, callbacks);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/webglutils',[\"../core/jsm\"],function(JSM){\n\tJSM.IsPowerOfTwo = function (x)\n\t{\n\t\treturn (x & (x - 1) === 0);\n\t};\n\n\tJSM.NextPowerOfTwo = function (x)\n\t{\n\t\tif (JSM.IsPowerOfTwo (x)) {\n\t\t\treturn x;\n\t\t}\n\n\t\tvar result = 1;\n\t\twhile (result < x) {\n\t\t\tresult *= 2;\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.ResizeImageToPowerOfTwoSides = function (image)\n\t{\n\t\tif (JSM.IsPowerOfTwo (image.width) && !JSM.IsPowerOfTwo (image.height)) {\n\t\t\treturn image;\n\t\t}\n\t\t\n\t\tvar width = JSM.NextPowerOfTwo (image.width);\n\t\tvar height = JSM.NextPowerOfTwo (image.height);\n\n\t\tvar canvas = document.createElement ('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\t\n\t\tvar context = canvas.getContext ('2d');\n\t\tcontext.drawImage (image, 0, 0, width, height);\n\t\treturn context.getImageData (0, 0, width, height);\n\t};\n\n\tJSM.WebGLInitContext = function (canvas)\n\t{\n\t\tif (canvas === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (canvas.getContext === undefined) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar context = canvas.getContext ('webgl') || canvas.getContext ('experimental-webgl');\n\t\tif (context === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tcontext.viewport (0, 0, canvas.width, canvas.height);\n\t\tcontext.clearColor (1.0, 1.0, 1.0, 1.0);\n\t\treturn context;\n\t};\n\n\tJSM.WebGLInitShaderProgram = function (context, vertexShader, fragmentShader, onError)\n\t{\n\t\tfunction CompileShader (context, script, type, onError)\n\t\t{\n\t\t\tvar shader = context.createShader (type);\n\t\t\tcontext.shaderSource (shader, script);\n\t\t\tcontext.compileShader (shader);\n\t\t\tif (!context.getShaderParameter (shader, context.COMPILE_STATUS)) {\n\t\t\t\tif (onError !== undefined && onError !== null) {\n\t\t\t\t\tonError (context.getShaderInfoLog (shader));\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn shader;\n\t\t}\n\t\t\n\t\tfunction CreateShader (context, fragmentShaderScript, vertexShaderScript, onError)\n\t\t{\n\t\t\tvar fragmentShader = CompileShader (context, fragmentShaderScript, context.FRAGMENT_SHADER, onError);\n\t\t\tvar vertexShader = CompileShader (context, vertexShaderScript, context.VERTEX_SHADER, onError);\n\t\t\tif (fragmentShader === null || vertexShader === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar shaderProgram = context.createProgram ();\n\t\t\tcontext.attachShader (shaderProgram, vertexShader);\n\t\t\tcontext.attachShader (shaderProgram, fragmentShader);\n\t\t\tcontext.linkProgram (shaderProgram);\n\t\t\tif (!context.getProgramParameter (shaderProgram, context.LINK_STATUS)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn shaderProgram;\n\t\t}\n\t\t\n\t\tvar shader = CreateShader (context, fragmentShader, vertexShader, onError);\n\t\tif (shader === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tcontext.useProgram (shader);\n\t\treturn shader;\n\t};\n\n\tJSM.WebGLGetFloatTextureBufferSize = function (array)\n\t{\n\t\treturn JSM.NextPowerOfTwo (Math.ceil (Math.sqrt (array.length / 4.0)));\n\t};\n\n\tJSM.WebGLCreateFloatTextureBuffer = function (context, array, size)\n\t{\n\t\tvar floatArray = null;\n\t\tif (array !== null) {\n\t\t\twhile (array.length < size * size * 4) {\n\t\t\t\tarray.push (0.0);\n\t\t\t}\n\t\t\tfloatArray = new Float32Array (array);\n\t\t}\n\t\tvar textureBuffer = context.createTexture ();\n\t\tcontext.bindTexture (context.TEXTURE_2D, textureBuffer);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\n\t\tcontext.texImage2D (context.TEXTURE_2D, 0, context.RGBA, size, size, 0, context.RGBA, context.FLOAT, floatArray);\n\t\tcontext.bindTexture (context.TEXTURE_2D, null);\n\t\treturn textureBuffer;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderlight',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderAmbientLight = function (color)\n\t{\n\t\tthis.color = JSM.HexColorToNormalizedRGBComponents (color);\n\t};\n\n\tJSM.RenderDirectionalLight = function (diffuse, specular, direction)\n\t{\n\t\tthis.diffuse = JSM.HexColorToNormalizedRGBComponents (diffuse);\n\t\tthis.specular = JSM.HexColorToNormalizedRGBComponents (specular);\n\t\tthis.direction = direction.Clone ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/rendermaterial',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderMaterialFlags = {\n\t\tPoint : 1,\n\t\tLine : 2,\n\t\tTriangle : 4,\n\t\tTextured : 8,\n\t\tTransparent : 16\n\t};\n\n\tJSM.RenderMaterial = function (type, parameters)\n\t{\n\t\tthis.type = type;\n\t\tthis.ambient = [0.0, 0.8, 0.0];\n\t\tthis.diffuse = [0.0, 0.8, 0.0];\n\t\tthis.specular = [0.0, 0.0, 0.0];\n\t\tthis.shininess = 0.0;\n\t\tthis.opacity = 1.0;\n\t\tthis.reflection = 0.0;\n\t\tthis.singleSided = false;\n\t\tthis.pointSize = 0.1;\n\t\tthis.texture = null;\n\t\tJSM.CopyObjectProperties (parameters, this, true);\n\t};\n\n\tJSM.RenderMaterial.prototype.SetType = function (type)\n\t{\n\t\tthis.type = type;\n\t};\n\n\tJSM.RenderMaterial.prototype.SetBuffers = function (textureBuffer, textureImage)\n\t{\n\t\tthis.textureBuffer = textureBuffer;\n\t\tthis.textureImage = textureImage;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/rendermesh',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderMesh = function (material)\n\t{\n\t\tthis.material = material;\n\t\t\n\t\tthis.vertexArray = null;\n\t\tthis.normalArray = null;\n\t\tthis.uvArray = null;\n\t\t\n\t\tthis.vertexBuffer = null;\n\t\tthis.normalBuffer = null;\n\t\tthis.uvBuffer = null;\n\t};\n\n\tJSM.RenderMesh.prototype.SetMaterial = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\tJSM.RenderMesh.prototype.GetMaterial = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\tJSM.RenderMesh.prototype.SetVertexArray = function (vertices)\n\t{\n\t\tthis.vertexArray = new Float32Array (vertices);\n\t};\n\n\tJSM.RenderMesh.prototype.SetNormalArray = function (normals)\n\t{\n\t\tthis.normalArray = new Float32Array (normals);\n\t};\n\n\tJSM.RenderMesh.prototype.SetUVArray = function (uvs)\n\t{\n\t\tthis.uvArray = new Float32Array (uvs);\n\t};\n\n\tJSM.RenderMesh.prototype.HasVertexArray = function ()\n\t{\n\t\treturn this.vertexArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.HasNormalArray = function ()\n\t{\n\t\treturn this.normalArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.HasUVArray = function ()\n\t{\n\t\treturn this.uvArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertexArray = function ()\n\t{\n\t\treturn this.vertexArray;\n\t};\n\n\tJSM.RenderMesh.prototype.GetNormalArray = function ()\n\t{\n\t\treturn this.normalArray;\n\t};\n\n\tJSM.RenderMesh.prototype.GetUVArray = function ()\n\t{\n\t\treturn this.uvArray;\n\t};\n\n\tJSM.RenderMesh.prototype.SetBuffers = function (vertexBuffer, normalBuffer, uvBuffer)\n\t{\n\t\tthis.vertexBuffer = vertexBuffer;\n\t\tthis.normalBuffer = normalBuffer;\n\t\tthis.uvBuffer = uvBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertexBuffer = function ()\n\t{\n\t\treturn this.vertexBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetNormalBuffer = function ()\n\t{\n\t\treturn this.normalBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetUVBuffer = function ()\n\t{\n\t\treturn this.uvBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.VertexCount = function ()\n\t{\n\t\treturn parseInt (this.vertexArray.length / 3, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.NormalCount = function ()\n\t{\n\t\treturn parseInt (this.normalArray.length / 3, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.UVCount = function ()\n\t{\n\t\treturn parseInt (this.uvArray.length / 2, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertex = function (index)\n\t{\n\t\treturn new JSM.Coord (this.vertexArray[3 * index], this.vertexArray[3 * index + 1], this.vertexArray[3 * index + 2]);\n\t};\n\n\tJSM.RenderMesh.prototype.GetTransformedVertex = function (index, transformation)\n\t{\n\t\tvar vertex = this.GetVertex (index);\n\t\treturn transformation.Apply (vertex);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderbody',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderBody = function ()\n\t{\n\t\tthis.transformation = new JSM.Transformation ();\n\t\tthis.meshes = {};\n\t};\n\n\tJSM.RenderBody.prototype.AddMesh = function (mesh)\n\t{\n\t\tif (this.meshes[mesh.material.type] === undefined) {\n\t\t\tthis.meshes[mesh.material.type] = [];\n\t\t}\n\t\tthis.meshes[mesh.material.type].push (mesh);\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateMeshes = function (onMeshFound)\n\t{\n\t\tvar meshType;\n\t\tfor (meshType in this.meshes) {\n\t\t\tif (this.meshes.hasOwnProperty (meshType)) {\n\t\t\t\tthis.EnumerateTypedMeshes (meshType, onMeshFound);\n\t\t\t}\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.HasTypedMeshes = function (meshType)\n\t{\n\t\treturn this.meshes[meshType] !== undefined;\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateTypedMeshes = function (meshType, onMeshFound)\n\t{\n\t\tif (!this.HasTypedMeshes (meshType)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar typedMeshes = this.meshes[meshType];\n\t\tvar\ti, typedMesh;\n\t\tfor\t(i = 0; i < typedMeshes.length; i++) {\n\t\t\ttypedMesh = typedMeshes[i];\n\t\t\tonMeshFound (typedMesh);\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateMeshesWithFlag = function (flag, onMeshFound)\n\t{\n\t\tvar meshType;\n\t\tfor (meshType in this.meshes) {\n\t\t\tif (this.meshes.hasOwnProperty (meshType) && (meshType & flag)) {\n\t\t\t\tthis.EnumerateTypedMeshes (meshType, onMeshFound);\n\t\t\t}\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.GetTransformation = function ()\n\t{\n\t\treturn this.transformation;\n\t};\n\n\tJSM.RenderBody.prototype.GetTransformationMatrix = function ()\n\t{\n\t\treturn this.transformation.matrix;\n\t};\n\n\tJSM.RenderBody.prototype.SetTransformation = function (transformation)\n\t{\n\t\tthis.transformation = transformation;\n\t};\n\n\tJSM.RenderBody.prototype.AppendTransformation = function (transformation)\n\t{\n\t\tthis.transformation.Append (transformation);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/shaderprogram',[\"../core/jsm\"],function(JSM){\n\tJSM.ShaderType = {\n\t\tPoint : 0,\n\t\tLine : 1,\n\t\tTriangle : 2,\n\t\tTexturedTriangle : 3\n\t};\n\n\tJSM.ShaderProgram = function (context)\n\t{\n\t\tthis.context = context;\n\t\tthis.globalParams = null;\n\t\tthis.shaders = null;\n\t\tthis.currentShader = null;\n\t\tthis.currentType = null;\n\t\tthis.cullEnabled = null;\n\t};\n\n\tJSM.ShaderProgram.prototype.Init = function ()\n\t{\n\t\tif (!this.InitGlobalParams ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\t\n\t};\n\n\tJSM.ShaderProgram.prototype.GetMaxLightCount = function ()\n\t{\n\t\treturn this.globalParams.maxLightCount;\n\t};\n\n\tJSM.ShaderProgram.prototype.InitGlobalParams = function ()\n\t{\n\t\tvar noDirectionalLight = new JSM.RenderDirectionalLight (0x000000, 0x000000, new JSM.Vector (0.0, 0.0, 0.0));\n\t\tthis.globalParams = {\n\t\t\tnoDirectionalLight : noDirectionalLight,\n\t\t\tmaxLightCount : 4\n\t\t};\n\t\treturn true;\n\t};\n\n\tJSM.ShaderProgram.prototype.InitShaders = function ()\n\t{\n\t\tfunction GetFragmentShaderScript (shaderType, globalParams)\n\t\t{\n\t\t\tvar script = null;\n\t\t\tif (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define MAX_LIGHTS ' + globalParams.maxLightCount,\n\n\t\t\t\t\t'struct Light',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'};',\n\n\t\t\t\t\t'struct Material',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 ambientColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'};',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump vec3 uAmbientLightColor;',\n\t\t\t\t\t'uniform Light uLights[MAX_LIGHTS];',\n\t\t\t\t\t'uniform Material uMaterial;',\n\t\t\t\t\t\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmediump vec3 ambientComponent = uMaterial.ambientColor * uAmbientLightColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tfor (int i = 0; i < MAX_LIGHTS; i++) {',\n\t\t\t\t\t'\t\tdiffuseComponent += uMaterial.diffuseColor * uLights[i].diffuseColor;',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t'\tgl_FragColor = vec4 (ambientComponent + diffuseComponent, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t} else if (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Triangle ? 'NOTEXTURE' : 'USETEXTURE'),\n\t\t\t\t\t'#define MAX_LIGHTS ' + globalParams.maxLightCount,\n\t\t\t\t\t\n\t\t\t\t\t'struct Light',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'\tmediump vec3 specularColor;',\n\t\t\t\t\t'\tmediump vec3 direction;',\n\t\t\t\t\t'};',\n\n\t\t\t\t\t'struct Material',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 ambientColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'\tmediump vec3 specularColor;',\n\t\t\t\t\t'\tmediump float shininess;',\n\t\t\t\t\t'\tmediump float opacity;',\n\t\t\t\t\t'};',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump vec3 uAmbientLightColor;',\n\t\t\t\t\t'uniform Light uLights[MAX_LIGHTS];',\n\t\t\t\t\t'uniform Material uMaterial;',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\t\t\t\t\t'varying mediump vec3 vNormal;',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'varying mediump vec2 vUV;',\n\t\t\t\t\t'uniform sampler2D uSampler;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmediump vec3 N = normalize (vNormal);',\n\t\t\t\t\t'\tif (!gl_FrontFacing) {',\n\t\t\t\t\t'\t\tN = -N;',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t'\tmediump vec3 ambientComponent = uMaterial.ambientColor * uAmbientLightColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tmediump vec3 specularComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tmediump vec3 E = normalize (-vVertex);',\n\n\t\t\t\t\t'\tfor (int i = 0; i < MAX_LIGHTS; i++) {',\n\t\t\t\t\t'\t\tmediump vec3 L = normalize (-uLights[i].direction);',\n\t\t\t\t\t'\t\tmediump vec3 R = normalize (-reflect (L, N));',\n\t\t\t\t\t'\t\tdiffuseComponent += uMaterial.diffuseColor * uLights[i].diffuseColor * max (dot (N, L), 0.0);',\n\t\t\t\t\t'\t\tspecularComponent += uMaterial.specularColor * uLights[i].specularColor * pow (max (dot (R, E), 0.0), uMaterial.shininess);',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'\tmediump vec3 textureColor = texture2D (uSampler, vec2 (vUV.s, vUV.t)).xyz;',\n\t\t\t\t\t'\tambientComponent = ambientComponent * textureColor;',\n\t\t\t\t\t'\tdiffuseComponent = diffuseComponent * textureColor;',\n\t\t\t\t\t'\tspecularComponent = specularComponent * textureColor;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t\n\t\t\t\t\t'\tambientComponent = clamp (ambientComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tdiffuseComponent = clamp (diffuseComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tspecularComponent = clamp (specularComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tgl_FragColor = vec4 (ambientComponent + diffuseComponent + specularComponent, uMaterial.opacity);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n\t\t\n\t\tfunction GetVertexShaderScript (shaderType)\n\t\t{\n\t\t\tvar script = null;\n\t\t\tif (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Triangle ? 'NOTEXTURE' : 'USETEXTURE'),\n\t\t\t\t\t'attribute mediump vec3 aVertexPosition;',\n\t\t\t\t\t'attribute mediump vec3 aVertexNormal;',\n\n\t\t\t\t\t'uniform mediump mat4 uViewMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uProjectionMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uTransformationMatrix;',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\t\t\t\t\t'varying mediump vec3 vNormal;',\n\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'attribute mediump vec2 aVertexUV;',\n\t\t\t\t\t'varying mediump vec2 vUV;',\n\t\t\t\t\t'#endif',\n\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmat4 modelViewMatrix = uViewMatrix * uTransformationMatrix;',\n\t\t\t\t\t'\tvVertex = vec3 (modelViewMatrix * vec4 (aVertexPosition, 1.0));',\n\t\t\t\t\t'\tvNormal = normalize (vec3 (modelViewMatrix * vec4 (aVertexNormal, 0.0)));',\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'\tvUV = aVertexUV;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t} else if (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Point ? 'POINT' : 'LINE'),\n\t\t\t\t\t'attribute mediump vec3 aVertexPosition;',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump mat4 uViewMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uProjectionMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uTransformationMatrix;',\n\t\t\t\t\t'#ifdef POINT',\n\t\t\t\t\t'uniform mediump float uPointSize;',\n\t\t\t\t\t'#endif',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmat4 modelViewMatrix = uViewMatrix * uTransformationMatrix;',\n\t\t\t\t\t'\tvVertex = vec3 (modelViewMatrix * vec4 (aVertexPosition, 1.0));',\n\t\t\t\t\t'#ifdef POINT',\n\t\t\t\t\t'\tconst mediump float scale = 200.0;',\n\t\t\t\t\t'\tgl_PointSize = uPointSize * (scale / length (vVertex));',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n\n\t\tfunction InitShaderParameters (context, shader, globalParams, shaderType)\n\t\t{\n\t\t\tif (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tshader.vertexPositionAttribute = context.getAttribLocation (shader, 'aVertexPosition');\n\t\t\t\tshader.vertexNormalAttribute = context.getAttribLocation (shader, 'aVertexNormal');\n\n\t\t\t\tshader.ambientLightColorUniform = context.getUniformLocation (shader, 'uAmbientLightColor');\n\t\t\t\tshader.lightUniforms = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < globalParams.maxLightCount; i++) {\n\t\t\t\t\tshader.lightUniforms.push ({\n\t\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uLights[' + i + '].diffuseColor'),\n\t\t\t\t\t\tspecularColor : context.getUniformLocation (shader, 'uLights[' + i + '].specularColor'),\n\t\t\t\t\t\tdirection : context.getUniformLocation (shader, 'uLights[' + i + '].direction')\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tshader.materialUniforms = {\n\t\t\t\t\tambientColor : context.getUniformLocation (shader, 'uMaterial.ambientColor'),\n\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uMaterial.diffuseColor'),\n\t\t\t\t\tspecularColor : context.getUniformLocation (shader, 'uMaterial.specularColor'),\n\t\t\t\t\tshininess : context.getUniformLocation (shader, 'uMaterial.shininess'),\n\t\t\t\t\topacity : context.getUniformLocation (shader, 'uMaterial.opacity')\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tshader.vMatrixUniform = context.getUniformLocation (shader, 'uViewMatrix');\n\t\t\t\tshader.pMatrixUniform = context.getUniformLocation (shader, 'uProjectionMatrix');\n\t\t\t\tshader.tMatrixUniform = context.getUniformLocation (shader, 'uTransformationMatrix');\n\n\t\t\t\tif (shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\t\tshader.vertexUVAttribute = context.getAttribLocation (shader, 'aVertexUV');\n\t\t\t\t\tshader.samplerUniform = context.getUniformLocation (shader, 'uSampler');\n\t\t\t\t}\n\t\t\t} else if (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tshader.vertexPositionAttribute = context.getAttribLocation (shader, 'aVertexPosition');\n\n\t\t\t\tshader.ambientLightColorUniform = context.getUniformLocation (shader, 'uAmbientLightColor');\n\t\t\t\tshader.lightUniforms = [];\n\t\t\t\tfor (i = 0; i < globalParams.maxLightCount; i++) {\n\t\t\t\t\tshader.lightUniforms.push ({\n\t\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uLights[' + i + '].diffuseColor')\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tshader.materialUniforms = {\n\t\t\t\t\tambientColor : context.getUniformLocation (shader, 'uMaterial.ambientColor'),\n\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uMaterial.diffuseColor'),\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tshader.vMatrixUniform = context.getUniformLocation (shader, 'uViewMatrix');\n\t\t\t\tshader.pMatrixUniform = context.getUniformLocation (shader, 'uProjectionMatrix');\n\t\t\t\tshader.tMatrixUniform = context.getUniformLocation (shader, 'uTransformationMatrix');\n\n\t\t\t\tif (shaderType == JSM.ShaderType.Point) {\n\t\t\t\t\tshader.pointSizeUniform = context.getUniformLocation (shader, 'uPointSize');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction InitShader (context, shaders, globalParams, shaderType)\n\t\t{\n\t\t\tvar vertexShaderScript = GetVertexShaderScript (shaderType);\n\t\t\tvar fragmentShaderScript = GetFragmentShaderScript (shaderType, globalParams);\n\t\t\tif (vertexShaderScript === null || fragmentShaderScript === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar shader = JSM.WebGLInitShaderProgram (context, vertexShaderScript, fragmentShaderScript, function (message) {\n\t\t\t\tJSM.Message (message);\n\t\t\t});\n\t\t\tif (shader === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tcontext.useProgram (shader);\n\t\t\tInitShaderParameters (context, shader, globalParams, shaderType);\n\t\t\tshaders[shaderType] = shader;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tthis.shaders = {};\n\t\t\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Point)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Line)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Triangle)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.TexturedTriangle)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context.enable (this.context.DEPTH_TEST);\n\t\tthis.context.depthFunc (this.context.LEQUAL);\n\t\t\n\t\tthis.context.enable (this.context.BLEND);\n\t\tthis.context.blendEquation (this.context.FUNC_ADD);\n\t\tthis.context.blendFunc (this.context.SRC_ALPHA, this.context.ONE_MINUS_SRC_ALPHA);\n\n\t\tthis.context.disable (this.context.CULL_FACE);\n\t\tthis.cullEnabled = false;\n\n\t\treturn true;\n\t};\n\n\tJSM.ShaderProgram.prototype.CompileMaterial = function (material, textureLoaded)\n\t{\n\t\tif (material.texture !== null) {\n\t\t\tvar context = this.context;\n\t\t\tvar textureBuffer = context.createTexture ();\n\t\t\tvar textureImage = new Image ();\n\t\t\ttextureImage.src = material.texture;\n\t\t\ttextureImage.onload = function () {\n\t\t\t\tvar resizedImage = JSM.ResizeImageToPowerOfTwoSides (textureImage);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, textureBuffer);\n\t\t\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.LINEAR);\n\t\t\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);\n\t\t\t\tcontext.texImage2D (context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, resizedImage);\n\t\t\t\tcontext.generateMipmap (context.TEXTURE_2D);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, null);\n\t\t\t\tif (textureLoaded !== undefined && textureLoaded !== null) {\n\t\t\t\t\ttextureLoaded ();\n\t\t\t\t}\n\t\t\t};\n\t\t\tmaterial.SetBuffers (textureBuffer, textureImage);\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.CompileMesh = function (mesh)\n\t{\n\t\tvar context = this.context;\n\t\tvar vertexBuffer = context.createBuffer ();\n\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetVertexArray (), context.STATIC_DRAW);\n\t\tvertexBuffer.itemSize = 3;\n\t\tvertexBuffer.numItems = mesh.VertexCount ();\n\n\t\tvar normalBuffer = null;\n\t\tif (mesh.HasNormalArray ()) {\n\t\t\tnormalBuffer = context.createBuffer ();\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, normalBuffer);\n\t\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetNormalArray (), context.STATIC_DRAW);\n\t\t\tnormalBuffer.itemSize = 3;\n\t\t\tnormalBuffer.numItems = mesh.NormalCount ();\n\t\t}\n\n\t\tvar uvBuffer = null;\n\t\tif (mesh.HasUVArray ()) {\n\t\t\tuvBuffer = context.createBuffer ();\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, uvBuffer);\n\t\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetUVArray (), context.STATIC_DRAW);\n\t\t\tuvBuffer.itemSize = 2;\n\t\t\tuvBuffer.numItems = mesh.UVCount ();\n\t\t}\n\t\t\n\t\tmesh.SetBuffers (vertexBuffer, normalBuffer, uvBuffer);\n\t};\n\n\tJSM.ShaderProgram.prototype.GetShader = function (shaderType)\n\t{\n\t\treturn this.shaders[shaderType];\n\t};\n\n\tJSM.ShaderProgram.prototype.UseShader = function (shaderType)\n\t{\n\t\tthis.currentShader = this.GetShader (shaderType);\n\t\tthis.currentType = shaderType;\n\t\tthis.context.useProgram (this.currentShader);\n\t};\n\n\tJSM.ShaderProgram.prototype.SetParameters = function (ambientLight, directionalLights, viewMatrix, projectionMatrix)\n\t{\n\t\tfunction GetLight (directionalLights, index, noDirectionalLight)\n\t\t{\n\t\t\tif (index < directionalLights.length) {\n\t\t\t\treturn directionalLights[index];\n\t\t\t}\n\n\t\t\treturn noDirectionalLight;\n\t\t}\n\t\t\n\t\tvar context = this.context;\n\t\tvar shader = this.currentShader;\n\t\t\n\t\tvar i, light, lightDirection;\n\t\tif (this.currentType == JSM.ShaderType.Triangle || this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\tcontext.uniform3f (shader.ambientLightColorUniform, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);\n\t\t\tfor (i = 0; i < this.globalParams.maxLightCount; i++) {\n\t\t\t\tlight = GetLight (directionalLights, i, this.globalParams.noDirectionalLight);\n\t\t\t\tlightDirection = JSM.ApplyRotation (viewMatrix, light.direction);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].diffuseColor, light.diffuse[0], light.diffuse[1], light.diffuse[2]);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].specularColor, light.specular[0], light.specular[1], light.specular[2]);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].direction, lightDirection.x, lightDirection.y, lightDirection.z);\n\t\t\t}\n\t\t\tcontext.uniformMatrix4fv (shader.pMatrixUniform, false, projectionMatrix);\n\t\t\tcontext.uniformMatrix4fv (shader.vMatrixUniform, false, viewMatrix);\n\t\t} else if (this.currentType == JSM.ShaderType.Point || this.currentType == JSM.ShaderType.Line) {\n\t\t\tcontext.uniform3f (shader.ambientLightColorUniform, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);\n\t\t\tfor (i = 0; i < this.globalParams.maxLightCount; i++) {\n\t\t\t\tlight = GetLight (directionalLights, i, this.globalParams.noDirectionalLight);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].diffuseColor, light.diffuse[0], light.diffuse[1], light.diffuse[2]);\n\t\t\t}\n\t\t\tcontext.uniformMatrix4fv (shader.pMatrixUniform, false, projectionMatrix);\n\t\t\tcontext.uniformMatrix4fv (shader.vMatrixUniform, false, viewMatrix);\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.SetCullEnabled = function (enable)\n\t{\n\t\tif (enable && !this.cullEnabled) {\n\t\t\tthis.context.enable (this.context.CULL_FACE);\n\t\t\tthis.cullEnabled = true;\n\t\t} else if (!enable && this.cullEnabled) {\n\t\t\tthis.context.disable (this.context.CULL_FACE);\n\t\t\tthis.cullEnabled = false;\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.DrawArrays = function (material, matrix, vertexBuffer, normalBuffer, uvBuffer)\n\t{\n\t\tvar context = this.context;\n\t\tvar shader = this.currentShader;\n\t\tthis.SetCullEnabled (material.singleSided);\n\t\t\n\t\tif (this.currentType == JSM.ShaderType.Triangle || this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\tcontext.uniform3f (shader.materialUniforms.ambientColor, material.ambient[0], material.ambient[1], material.ambient[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.diffuseColor, material.diffuse[0], material.diffuse[1], material.diffuse[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.specularColor, material.specular[0], material.specular[1], material.specular[2]);\n\t\t\tcontext.uniform1f (shader.materialUniforms.shininess, material.shininess);\n\t\t\tcontext.uniform1f (shader.materialUniforms.opacity, material.opacity);\n\n\t\t\tcontext.uniformMatrix4fv (shader.tMatrixUniform, false, matrix);\n\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexPositionAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexPositionAttribute, vertexBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, normalBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexNormalAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexNormalAttribute, normalBuffer.itemSize, context.FLOAT, false, 0, 0);\n\n\t\t\tif (this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tcontext.activeTexture (context.TEXTURE0);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, material.textureBuffer);\n\t\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, uvBuffer);\n\t\t\t\tcontext.enableVertexAttribArray (shader.vertexUVAttribute);\n\t\t\t\tcontext.vertexAttribPointer (shader.vertexUVAttribute, uvBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\tcontext.uniform1i (shader.samplerUniform, 0);\n\t\t\t}\n\t\t\t\n\t\t\tcontext.drawArrays (context.TRIANGLES, 0, vertexBuffer.numItems);\n\t\t} else if (this.currentType == JSM.ShaderType.Point || this.currentType == JSM.ShaderType.Line) {\n\t\t\tcontext.uniform3f (shader.materialUniforms.ambientColor, material.ambient[0], material.ambient[1], material.ambient[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.diffuseColor, material.diffuse[0], material.diffuse[1], material.diffuse[2]);\n\t\t\t\n\t\t\tcontext.uniformMatrix4fv (shader.tMatrixUniform, false, matrix);\n\t\t\t\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexPositionAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexPositionAttribute, vertexBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\n\t\t\tif (this.currentType == JSM.ShaderType.Point) {\n\t\t\t\tcontext.uniform1f (shader.pointSizeUniform, material.pointSize);\n\t\t\t\tcontext.drawArrays (context.POINTS, 0, vertexBuffer.numItems);\n\t\t\t} else if (this.currentType == JSM.ShaderType.Line) {\n\t\t\t\tcontext.drawArrays (context.LINES, 0, vertexBuffer.numItems);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderer',[\"../core/jsm\"],function(JSM){\n\tJSM.Renderer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.shader = null;\n\t\t\n\t\tthis.ambientLight = null;\n\t\tthis.directionalLights = null;\n\t\tthis.bodies = null;\n\t};\n\n\tJSM.Renderer.prototype.Init = function (canvas)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitContext (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitView ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\tif (!this.InitBodies ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitContext = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (this.canvas === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas.getContext === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = this.canvas.getContext ('webgl') || this.canvas.getContext ('experimental-webgl');\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = JSM.WebGLInitContext (canvas);\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitShaders = function ()\n\t{\n\t\tthis.shader = new JSM.ShaderProgram (this.context);\n\t\treturn this.shader.Init ();\n\t};\n\n\tJSM.Renderer.prototype.InitLights = function ()\n\t{\n\t\tthis.ambientLight = new JSM.RenderAmbientLight (0x000000);\n\t\tthis.directionalLights = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitView = function ()\n\t{\n\t\tthis.directionalLights = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.context.clearColor (red, green, blue, 1.0);\n\t};\n\n\tJSM.Renderer.prototype.SetAmbientLight = function (light)\n\t{\n\t\tthis.ambientLight = light;\n\t};\n\n\tJSM.Renderer.prototype.AddLight = function (light)\n\t{\n\t\tvar maxLightCount = this.shader.GetMaxLightCount ();\n\t\tif (this.directionalLights.length >= maxLightCount) {\n\t\t\treturn -1;\n\t\t}\n\t\tthis.directionalLights.push (light);\n\t\treturn this.directionalLights.length - 1;\n\t};\n\n\tJSM.Renderer.prototype.RemoveLight = function (light)\n\t{\n\t\tvar index = this.directionalLights.indexOf (light);\n\t\tif (index != -1) {\n\t\t\tthis.directionalLights.splice (index, 1);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveLights = function ()\n\t{\n\t\tthis.directionalLights = [];\n\t};\n\n\tJSM.Renderer.prototype.GetLight = function (index)\n\t{\n\t\treturn this.directionalLights[index];\n\t};\n\n\tJSM.Renderer.prototype.AddBody = function (renderBody, textureLoaded)\n\t{\n\t\tvar shader = this.shader;\n\t\trenderBody.EnumerateMeshes (function (mesh) {\n\t\t\tshader.CompileMaterial (mesh.GetMaterial (), textureLoaded);\n\t\t\tshader.CompileMesh (mesh);\n\t\t});\n\t\tthis.bodies.push (renderBody);\n\t};\n\n\tJSM.Renderer.prototype.AddBodies = function (renderBodies, textureLoaded)\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < renderBodies.length; i++) {\n\t\t\tbody = renderBodies[i];\n\t\t\tthis.AddBody (body, textureLoaded);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.EnumerateBodies = function (onBodyFound)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tonBodyFound (this.bodies[i]);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveBody = function (body)\n\t{\n\t\tvar index = this.bodies.indexOf (body);\n\t\tif (index != -1) {\n\t\t\tthis.bodies.splice (index, 1);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t};\n\n\tJSM.Renderer.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\tJSM.Renderer.prototype.Resize = function ()\n\t{\n\t\tthis.context.viewport (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\tJSM.Renderer.prototype.FindObjects = function (camera, screenX, screenY)\n\t{\n\t\tvar screenCoord = new JSM.Coord (screenX, this.canvas.height - screenY, 0.5);\n\t\tvar aspectRatio = this.canvas.width / this.canvas.height;\n\t\tvar viewPort = [0, 0, this.canvas.width, this.canvas.height];\n\t\tvar unprojected = JSM.Unproject (screenCoord, camera.eye, camera.center, camera.up, camera.fieldOfView * JSM.DegRad, aspectRatio, camera.nearClippingPlane, camera.farClippingPlane, viewPort);\n\t\tvar ray = new JSM.Ray (camera.eye, JSM.CoordSub (unprojected, camera.eye), null);\n\t\t\n\t\tvar result = [];\n\t\tthis.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshesWithFlag (JSM.RenderMaterialFlags.Triangle, function (mesh) {\n\t\t\t\tvar vertexCount = mesh.VertexCount ();\n\t\t\t\tvar i, v0, v1, v2, intersection;\n\t\t\t\tfor (i = 0; i < vertexCount; i += 3) {\n\t\t\t\t\tv0 = mesh.GetTransformedVertex (i + 0, transformation);\n\t\t\t\t\tv1 = mesh.GetTransformedVertex (i + 1, transformation);\n\t\t\t\t\tv2 = mesh.GetTransformedVertex (i + 2, transformation);\n\t\t\t\t\tintersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\t\tif (intersection !== null) {\n\t\t\t\t\t\tresult.push ({\n\t\t\t\t\t\t\trenderBody : body,\n\t\t\t\t\t\t\trenderMesh : mesh,\n\t\t\t\t\t\t\ttriangleIndex : parseInt (i / 3, 10),\n\t\t\t\t\t\t\tintersection : intersection\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tresult.sort (function (a, b) {\n\t\t\treturn a.intersection.distance - b.intersection.distance;\n\t\t});\n\t\treturn result;\n\t};\n\n\tJSM.Renderer.prototype.Render = function (camera)\n\t{\n\t\tfunction DrawMeshes (renderer, materialType, viewMatrix, projectionMatrix)\n\t\t{\n\t\t\tfunction MaterialTypeToShaderType (materialType)\n\t\t\t{\n\t\t\t\tfunction HasFlag (type, flag)\n\t\t\t\t{\n\t\t\t\t\treturn type & flag;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (HasFlag (materialType, JSM.RenderMaterialFlags.Triangle)) {\n\t\t\t\t\tif (HasFlag (materialType, JSM.RenderMaterialFlags.Textured)) {\n\t\t\t\t\t\treturn JSM.ShaderType.TexturedTriangle;\n\t\t\t\t\t} else if (!HasFlag (materialType, JSM.RenderMaterialFlags.Textured)) {\n\t\t\t\t\t\treturn JSM.ShaderType.Triangle;\n\t\t\t\t\t}\n\t\t\t\t} else if (HasFlag (materialType, JSM.RenderMaterialFlags.Line)) {\n\t\t\t\t\treturn JSM.ShaderType.Line;\n\t\t\t\t} else if (HasFlag (materialType, JSM.RenderMaterialFlags.Point)) {\n\t\t\t\t\treturn JSM.ShaderType.Point;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar shaderType = null;\n\t\t\trenderer.EnumerateBodies (function (body) {\n\t\t\t\tif (body.HasTypedMeshes (materialType)) {\n\t\t\t\t\tvar matrix = body.GetTransformationMatrix ();\n\t\t\t\t\tbody.EnumerateTypedMeshes (materialType, function (mesh) {\n\t\t\t\t\t\tif (shaderType === null) {\n\t\t\t\t\t\t\tshaderType = MaterialTypeToShaderType (materialType);\n\t\t\t\t\t\t\trenderer.shader.UseShader (shaderType);\n\t\t\t\t\t\t\trenderer.shader.SetParameters (renderer.ambientLight, renderer.directionalLights, viewMatrix, projectionMatrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar material = mesh.GetMaterial ();\n\t\t\t\t\t\tvar vertexBuffer = mesh.GetVertexBuffer ();\n\t\t\t\t\t\tvar normalBuffer = mesh.GetNormalBuffer ();\n\t\t\t\t\t\tvar uvBuffer = mesh.GetUVBuffer ();\n\t\t\t\t\t\trenderer.shader.DrawArrays (material, matrix, vertexBuffer, normalBuffer, uvBuffer);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.context.clear (this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n\t\t\n\t\tvar viewMatrix = JSM.MatrixView (camera.eye, camera.center, camera.up);\n\t\tvar projectionMatrix = JSM.MatrixPerspective (camera.fieldOfView * JSM.DegRad, this.canvas.width / this.canvas.height, camera.nearClippingPlane, camera.farClippingPlane);\n\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Textured, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Line, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Point, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Transparent, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Transparent + JSM.RenderMaterialFlags.Textured, viewMatrix, projectionMatrix);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/pointcloudrenderer',[\"../core/jsm\"],function(JSM){\n\tJSM.PointCloudRenderer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.shader = null;\n\t\t\n\t\tthis.camera = null;\n\t\tthis.points = null;\n\t\tthis.pointSize = null;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitContext (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitBuffers ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitView (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitContext = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (this.canvas === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas.getContext === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = this.canvas.getContext ('experimental-webgl');\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context.clearColor (1.0, 1.0, 1.0, 1.0);\n\t\tthis.context.enable (this.context.DEPTH_TEST);\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitShaders = function ()\n\t{\n\t\tfunction CreateShaderFromScript (context, script, type)\n\t\t{\n\t\t\tvar shader = context.createShader (type);\n\t\t\tcontext.shaderSource (shader, script);\n\t\t\tcontext.compileShader (shader);\n\t\t\tif (!context.getShaderParameter (shader, context.COMPILE_STATUS)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn shader;\n\t\t}\n\n\t\tvar fragmentShaderScript = [\n\t\t\t'varying highp vec3 vColor;',\n\t\t\t'void main (void) {',\n\t\t\t'\tgl_FragColor = vec4 (vColor, 1.0);',\n\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\n\t\tvar vertexShaderScript = [\n\t\t\t'attribute highp vec3 aVertexPosition;',\n\t\t\t'attribute highp vec3 aVertexColor;',\n\n\t\t\t'uniform highp mat4 uViewMatrix;',\n\t\t\t'uniform highp mat4 uProjectionMatrix;',\n\n\t\t\t'uniform highp float uPointSize;',\n\t\t\t\n\t\t\t'varying highp vec3 vColor;',\n\t\t\t\n\t\t\t'void main (void) {',\n\t\t\t'\tvColor = aVertexColor;',\n\t\t\t'\tgl_PointSize = uPointSize;',\n\t\t\t'\tgl_Position = uProjectionMatrix * uViewMatrix * vec4 (aVertexPosition, 1.0);',\n\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\n\t\tvar fragmentShader = CreateShaderFromScript (this.context, fragmentShaderScript, this.context.FRAGMENT_SHADER);\n\t\tvar vertexShader = CreateShaderFromScript (this.context, vertexShaderScript, this.context.VERTEX_SHADER);\n\t\tif (fragmentShader === null || vertexShader === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.shader = this.context.createProgram ();\n\t\tthis.context.attachShader (this.shader, vertexShader);\n\t\tthis.context.attachShader (this.shader, fragmentShader);\n\t\tthis.context.linkProgram (this.shader);\n\t\tif (!this.context.getProgramParameter (this.shader, this.context.LINK_STATUS)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.context.useProgram (this.shader);\n\n\t\tthis.shader.vertexPositionAttribute = this.context.getAttribLocation (this.shader, 'aVertexPosition');\n\t\tthis.context.enableVertexAttribArray (this.shader.vertexPositionAttribute);\n\n\t\tthis.shader.vertexColorAttribute = this.context.getAttribLocation (this.shader, 'aVertexColor');\n\t\tthis.context.enableVertexAttribArray (this.shader.vertexColorAttribute);\n\n\t\tthis.shader.pMatrixUniform = this.context.getUniformLocation (this.shader, 'uProjectionMatrix');\n\t\tthis.shader.vMatrixUniform = this.context.getUniformLocation (this.shader, 'uViewMatrix');\n\t\t\n\t\tthis.shader.pointSizeUniform = this.context.getUniformLocation (this.shader, 'uPointSize');\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitBuffers = function ()\n\t{\n\t\tthis.points = [];\n\t\tthis.pointSize = 1.0;\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitView = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.context.clearColor (red, green, blue, 1.0);\n\t};\n\n\tJSM.PointCloudRenderer.prototype.SetPointSize = function (pointSize)\n\t{\n\t\tthis.pointSize = pointSize;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.AddPoints = function (points, colors)\n\t{\n\t\tvar pointBuffer = this.context.createBuffer ();\n\t\tvar pointArray = new Float32Array (points);\n\n\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, pointBuffer);\n\t\tthis.context.bufferData (this.context.ARRAY_BUFFER, pointArray, this.context.STATIC_DRAW);\n\t\tpointBuffer.itemSize = 3;\n\t\tpointBuffer.numItems = parseInt (pointArray.length / 3, 10);\n\t\t\n\t\tvar colorBuffer = this.context.createBuffer ();\n\t\tvar colorArray = new Float32Array (colors);\n\n\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, colorBuffer);\n\t\tthis.context.bufferData (this.context.ARRAY_BUFFER, colorArray, this.context.STATIC_DRAW);\n\t\tcolorBuffer.itemSize = 3;\n\t\tcolorBuffer.numItems = parseInt (colorArray.length / 3, 10);\n\n\t\tthis.points.push ({pointArray : pointArray, pointBuffer : pointBuffer, colorBuffer : colorBuffer});\n\t};\n\n\tJSM.PointCloudRenderer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.points = [];\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Resize = function ()\n\t{\n\t\tthis.context.viewport (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Render = function ()\n\t{\n\t\tthis.context.clear (this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n\t\t\n\t\tvar projectionMatrix = JSM.MatrixPerspective (this.camera.fieldOfView * JSM.DegRad, this.canvas.width / this.canvas.height, this.camera.nearClippingPlane, this.camera.farClippingPlane);\n\t\tthis.context.uniformMatrix4fv (this.shader.pMatrixUniform, false, projectionMatrix);\n\n\t\tvar viewMatrix = JSM.MatrixView (this.camera.eye, this.camera.center, this.camera.up);\n\t\tthis.context.uniformMatrix4fv (this.shader.vMatrixUniform, false, viewMatrix);\n\n\t\tthis.context.uniform1f (this.shader.pointSizeUniform, this.pointSize);\n\t\t\n\t\tvar i, pointBuffer, colorBuffer;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tpointBuffer = this.points[i].pointBuffer;\n\t\t\tcolorBuffer = this.points[i].colorBuffer;\n\t\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, pointBuffer);\n\t\t\tthis.context.vertexAttribPointer (this.shader.vertexPositionAttribute, pointBuffer.itemSize, this.context.FLOAT, false, 0, 0);\n\t\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, colorBuffer);\n\t\t\tthis.context.vertexAttribPointer (this.shader.vertexColorAttribute, colorBuffer.itemSize, this.context.FLOAT, false, 0, 0);\n\t\t\tthis.context.drawArrays (this.context.POINTS, 0, pointBuffer.numItems);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderconverter',[\"../core/jsm\"],function(JSM){\n\tJSM.ConvertBodyToRenderBody = function (body, materials, parameters)\n\t{\n\t\tfunction MaterialToRenderMaterial (material, materialType)\n\t\t{\n\t\t\tvar renderAmbient = JSM.HexColorToNormalizedRGBComponents (material.ambient);\n\t\t\tvar renderDiffuse = JSM.HexColorToNormalizedRGBComponents (material.diffuse);\n\t\t\tvar renderSpecular = JSM.HexColorToNormalizedRGBComponents (material.specular);\n\t\t\tvar renderMaterial = new JSM.RenderMaterial (materialType, {\n\t\t\t\tambient : renderAmbient,\n\t\t\t\tdiffuse : renderDiffuse,\n\t\t\t\tspecular : renderSpecular,\n\t\t\t\tshininess : material.shininess,\n\t\t\t\topacity : material.opacity,\n\t\t\t\tsingleSided : material.singleSided,\n\t\t\t\tpointSize : material.pointSize,\n\t\t\t\ttexture : material.texture\n\t\t\t});\n\t\t\treturn renderMaterial;\n\t\t}\n\t\t\n\t\tvar hasConvexPolygons = false;\n\t\tif (parameters !== undefined && parameters !== null) {\n\t\t\tif (parameters.hasConvexPolygons !== undefined && parameters.hasConvexPolygons !== null) {\n\t\t\t\thasConvexPolygons = parameters.hasConvexPolygons;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar renderBody = new JSM.RenderBody ();\n\t\t\n\t\tvar vertices = null;\n\t\tvar normals = null;\n\t\tvar uvs = null;\n\t\t\n\t\tvar explodeData = {\n\t\t\thasConvexPolygons : hasConvexPolygons,\n\t\t\tonPointGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = null;\n\t\t\t\tuvs = null;\n\t\t\t},\t\t\n\t\t\tonPointGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Point;\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonPoint : function (vertex) {\n\t\t\t\tvertices.push (vertex.x, vertex.y, vertex.z);\n\t\t\t},\t\t\n\t\t\tonLineGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = null;\n\t\t\t\tuvs = null;\n\t\t\t},\n\t\t\tonLineGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Line;\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonLine : function (begVertex, endVertex) {\n\t\t\t\tvertices.push (begVertex.x, begVertex.y, begVertex.z);\n\t\t\t\tvertices.push (endVertex.x, endVertex.y, endVertex.z);\n\t\t\t},\t\t\n\t\t\tonGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = [];\n\t\t\t\tuvs = [];\n\t\t\t},\n\t\t\tonGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Triangle;\n\t\t\t\tif (material.texture !== null) {\n\t\t\t\t\tmaterialType += JSM.RenderMaterialFlags.Textured;\n\t\t\t\t}\n\t\t\t\tif (material.opacity < 1.0) {\n\t\t\t\t\tmaterialType += JSM.RenderMaterialFlags.Transparent;\n\t\t\t\t}\n\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\tmesh.SetNormalArray (normals);\n\t\t\t\tif (material.texture !== null) {\n\t\t\t\t\tmesh.SetUVArray (uvs);\n\t\t\t\t}\n\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonTriangle : function (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3) {\n\t\t\t\tvertices.push (vertex1.x, vertex1.y, vertex1.z);\n\t\t\t\tvertices.push (vertex2.x, vertex2.y, vertex2.z);\n\t\t\t\tvertices.push (vertex3.x, vertex3.y, vertex3.z);\n\t\t\t\t\n\t\t\t\tnormals.push (normal1.x, normal1.y, normal1.z);\n\t\t\t\tnormals.push (normal2.x, normal2.y, normal2.z);\n\t\t\t\tnormals.push (normal3.x, normal3.y, normal3.z);\n\t\t\t\t\n\t\t\t\tif (uv1 !== null && uv2 !== null && uv3 !== null) {\n\t\t\t\t\tuvs.push (uv1.x, uv1.y);\n\t\t\t\t\tuvs.push (uv2.x, uv2.y);\n\t\t\t\t\tuvs.push (uv3.x, uv3.y);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tJSM.ExplodeBody (body, materials, explodeData);\n\t\treturn renderBody;\n\t};\n\n\tJSM.ConvertModelToRenderBodies = function (model, parameters)\n\t{\n\t\tvar bodies = [];\n\t\tvar materials = model.GetMaterialSet ();\n\t\tvar i, body, renderBody;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\trenderBody = JSM.ConvertBodyToRenderBody (body, materials, parameters);\n\t\t\tbodies.push (renderBody);\n\t\t}\n\t\treturn bodies;\n\t};\n\n\tJSM.ConvertJSONDataToRenderBodies = function (jsonData, asyncCallbacks)\n\t{\n\t\tfunction ConvertMeshToRenderBody (mesh, materials)\n\t\t{\n\t\t\tfunction ConvertTrianglesToRenderMesh (mesh, triangles, materials)\n\t\t\t{\n\t\t\t\tfunction GetTextureCoordinate (u, v, offset, scale, rotation)\n\t\t\t\t{\n\t\t\t\t\tvar result = new JSM.Vector2D (u, v);\n\t\t\t\t\tif (!JSM.IsZero (rotation)) {\n\t\t\t\t\t\tvar si = Math.sin (rotation * JSM.DegRad);\n\t\t\t\t\t\tvar co = Math.cos (rotation * JSM.DegRad);\n\t\t\t\t\t\tresult.x = co * u - si * v;\n\t\t\t\t\t\tresult.y = si * u + co * v;\n\t\t\t\t\t}\n\t\t\t\t\tresult.x = offset[0] + result.x * scale[0];\n\t\t\t\t\tresult.y = offset[1] + result.y * scale[1];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tfunction AppendTriangleCoords (targetArray, sourceArray, indexArray, startIndex, componentCount)\n\t\t\t\t{\n\t\t\t\t\tvar vertexIndex, sourceVertexIndex, componentIndex;\n\t\t\t\t\tfor (vertexIndex = 0; vertexIndex < 3; vertexIndex++) {\n\t\t\t\t\t\tsourceVertexIndex = indexArray[startIndex + vertexIndex];\n\t\t\t\t\t\tfor (componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n\t\t\t\t\t\t\ttargetArray.push (sourceArray[sourceVertexIndex * componentCount + componentIndex]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials[triangles.material];\n\t\t\t\tvar renderMaterial = new JSM.RenderMaterial (JSM.RenderMaterialFlags.Triangle, {\n\t\t\t\t\tambient : material.ambient || [1.0, 1.0, 1.0],\n\t\t\t\t\tdiffuse : material.diffuse || [1.0, 1.0, 1.0],\n\t\t\t\t\tspecular : material.specular || [1.0, 1.0, 1.0],\n\t\t\t\t\tshininess : material.shininess || 0.0,\n\t\t\t\t\topacity : material.opacity || 1.0,\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar hasTexture = (material.texture !== undefined && material.texture !== null);\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\trenderMaterial.SetType (JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Textured);\n\t\t\t\t\trenderMaterial.texture = material.texture;\n\t\t\t\t\trenderMaterial.ambient = [1.0, 1.0, 1.0];\n\t\t\t\t\trenderMaterial.diffuse = [1.0, 1.0, 1.0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar renderMesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tvar vertexArray = [];\n\t\t\t\tvar normalArray = [];\n\t\t\t\tvar uvArray = [];\n\t\t\t\t\n\t\t\t\tvar i;\n\t\t\t\tfor\t(i = 0; i < triangles.parameters.length; i += 9) {\n\t\t\t\t\tAppendTriangleCoords (vertexArray, mesh.vertices, triangles.parameters, i, 3);\n\t\t\t\t\tAppendTriangleCoords (normalArray, mesh.normals, triangles.parameters, i + 3, 3);\n\t\t\t\t\tAppendTriangleCoords (uvArray, mesh.uvs, triangles.parameters, i + 6, 2);\n\t\t\t\t}\n\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\tvar offset = material.offset || [0.0, 0.0];\n\t\t\t\t\tvar scale = material.scale || [1.0, 1.0];\n\t\t\t\t\tvar rotation = material.rotation || 0.0;\n\t\t\t\t\tvar transformedUV;\n\t\t\t\t\tfor\t(i = 0; i < uvArray.length; i += 2) {\n\t\t\t\t\t\ttransformedUV = GetTextureCoordinate (uvArray[i + 0], uvArray[i + 1], offset, scale, rotation);\n\t\t\t\t\t\tuvArray[i + 0] = transformedUV.x;\n\t\t\t\t\t\tuvArray[i + 1] = -transformedUV.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trenderMesh.SetVertexArray (vertexArray);\n\t\t\t\trenderMesh.SetNormalArray (normalArray);\n\t\t\t\trenderMesh.SetUVArray (uvArray);\n\t\t\t\treturn renderMesh;\n\t\t\t}\n\t\t\t\n\t\t\tvar renderBody = new JSM.RenderBody ();\n\t\t\tvar i, triangles, renderMesh;\n\t\t\tfor (i = 0; i < mesh.triangles.length; i++) {\n\t\t\t\ttriangles = mesh.triangles[i];\n\t\t\t\trenderMesh = ConvertTrianglesToRenderMesh (mesh, triangles, materials);\n\t\t\t\trenderBody.AddMesh (renderMesh);\n\t\t\t}\n\t\t\treturn renderBody;\n\t\t}\n\t\t\n\t\tfunction AddMesh (meshes, materials, meshIndex, resultBodies)\n\t\t{\n\t\t\tvar renderBody = ConvertMeshToRenderBody (meshes[meshIndex], materials);\n\t\t\tresultBodies.push (renderBody);\n\t\t}\n\t\t\n\t\tvar resultBodies = [];\n\n\t\tvar materials = jsonData.materials;\n\t\tif (materials === undefined) {\n\t\t\treturn resultBodies;\n\t\t}\n\t\t\n\t\tvar meshes = jsonData.meshes;\n\t\tif (meshes === undefined) {\n\t\t\treturn resultBodies;\n\t\t}\n\t\t\n\t\tvar meshIndex = 0;\n\t\tJSM.AsyncRunTask (\n\t\t\tfunction () {\n\t\t\t\tAddMesh (meshes, materials, meshIndex, resultBodies);\n\t\t\t\tmeshIndex = meshIndex + 1;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tasyncCallbacks,\n\t\t\tmeshes.length, 0, resultBodies\n\t\t);\n\n\t\treturn resultBodies;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/mouse',[\"../core/jsm\"],function(JSM){\n\tJSM.Mouse = function ()\n\t{\n\t\tthis.down = false;\n\t\tthis.button = 0;\n\t\tthis.shift = false;\n\t\tthis.ctrl = false;\n\t\tthis.alt = false;\n\t\tthis.prev = new JSM.Coord2D (0, 0);\n\t\tthis.curr = new JSM.Coord2D (0, 0);\n\t\tthis.diff = new JSM.Coord2D (0, 0);\n\t};\n\n\tJSM.Mouse.prototype.Down = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\n\t\tthis.down = true;\n\t\tthis.button = event.which;\n\t\tthis.shift = event.shiftKey;\n\t\tthis.ctrl = event.ctrlKey;\n\t\tthis.alt = event.altKey;\n\t\t\n\t\tthis.SetCurrent (eventParameters, div);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Mouse.prototype.Move = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.shift = event.shiftKey;\n\t\tthis.ctrl = event.ctrlKey;\n\t\tthis.alt = event.altKey;\n\t\t\n\t\tthis.SetCurrent (eventParameters, div);\n\t\tthis.diff = JSM.CoordSub2D (this.curr, this.prev);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Mouse.prototype.Up = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.down = false;\n\t\tthis.SetCurrent (eventParameters, div);\n\t};\n\n\tJSM.Mouse.prototype.Out = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.down = false;\n\t\tthis.SetCurrent (eventParameters, div);\n\t};\n\n\tJSM.Mouse.prototype.SetCurrent = function (eventParameters, div)\n\t{\n\t\tvar currX = eventParameters.clientX;\n\t\tvar currY = eventParameters.clientY;\n\t\tif (div.getBoundingClientRect !== undefined) {\n\t\t\tvar clientRect = div.getBoundingClientRect ();\n\t\t\tcurrX -= clientRect.left;\n\t\t\tcurrY -= clientRect.top;\n\t\t}\n\t\tif (window.pageXOffset !== undefined && window.pageYOffset !== undefined) {\n\t\t\tcurrX += window.pageXOffset;\n\t\t\tcurrY += window.pageYOffset;\n\t\t}\n\t\tthis.curr = new JSM.Coord2D (currX, currY);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/touch',[\"../core/jsm\"],function(JSM){\n\tJSM.Touch = function ()\n\t{\n\t\tthis.down = false;\n\t\tthis.fingers = 0;\n\t\tthis.prev = new JSM.Coord2D ();\n\t\tthis.curr = new JSM.Coord2D ();\n\t\tthis.diff = new JSM.Coord2D ();\n\t};\n\n\tJSM.Touch.prototype.Start = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.down = true;\n\t\tthis.fingers = event.touches.length;\n\n\t\tthis.SetCurrent (event, div);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Touch.prototype.Move = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fingers = event.touches.length;\n\n\t\tthis.SetCurrent (event, div);\n\t\tthis.diff = JSM.CoordSub2D (this.curr, this.prev);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Touch.prototype.End = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.down = false;\n\t\tthis.SetCurrent (event, div);\n\t};\n\n\tJSM.Touch.prototype.SetCurrent = function (event, div)\n\t{\n\t\tfunction GetEventCoord (touch, div)\n\t\t{\n\t\t\tvar currX = touch.pageX;\n\t\t\tvar currY = touch.pageY;\n\t\t\tif (div.getBoundingClientRect !== undefined) {\n\t\t\t\tvar clientRect = div.getBoundingClientRect ();\n\t\t\t\tcurrX -= clientRect.left;\n\t\t\t\tcurrY -= clientRect.top;\n\t\t\t}\n\t\t\tif (window.pageXOffset !== undefined && window.pageYOffset !== undefined) {\n\t\t\t\tcurrX += window.pageXOffset;\n\t\t\t\tcurrY += window.pageYOffset;\n\t\t\t}\n\t\t\treturn new JSM.Coord2D (currX, currY);\n\t\t}\n\t\t\n\t\tif (event.touches.length == 1 || event.touches.length == 3) {\n\t\t\tthis.curr = GetEventCoord (event.touches[0], div);\n\t\t} else if (event.touches.length == 2) {\n\t\t\tvar distance = GetEventCoord (event.touches[0], div).DistanceTo (GetEventCoord (event.touches[1], div));\n\t\t\tthis.curr = new JSM.Coord2D (distance, distance);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/painter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: OrderPolygons\n\t* Description: Order body polygons from front to back depending on the eye position.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\teye {Coord} the camera eye position\n\t*\tcenter {Coord} the camera center position\n\t* Returns:\n\t*\t{integer[]} the ordered polygon indices\n\t*/\n\tJSM.OrderPolygons = function (body, eye, center)\n\t{\n\t\tfunction SwapArrayValues (array, from, to)\n\t\t{\n\t\t\tvar temp = array[from];\n\t\t\tarray[from] = array[to];\n\t\t\tarray[to] = temp;\n\t\t}\n\n\t\tfunction GetPolygonCenter (p)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (p);\n\t\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult = JSM.CoordAdd (result, coord);\n\t\t\t}\n\t\t\t\n\t\t\tresult.MultiplyScalar (1.0 / polygon.VertexIndexCount ());\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction CalculatePolygonValues ()\n\t\t{\n\t\t\tvar viewDirection = JSM.CoordSub (center, eye).Normalize ();\n\t\t\tvar cameraPlane = JSM.GetPlaneFromCoordAndDirection (eye, viewDirection);\n\t\t\t\n\t\t\tvar i, j, polygon, coord, distance, minDistance, maxDistance;\n\t\t\tvar polygonCenter, polygonCenterDistance;\n\t\t\tvar polygonNormal, polygonViewVector, polygonDirection, polygonPlane;\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tminDistance = JSM.Inf;\n\t\t\t\tmaxDistance = -JSM.Inf;\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\t\tdistance = cameraPlane.CoordDistance (coord);\n\t\t\t\t\tif (JSM.IsLower (distance, minDistance)) {\n\t\t\t\t\t\tminDistance = distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (JSM.IsGreater (distance, maxDistance)) {\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tminViewDistances.push (minDistance);\n\t\t\t\tmaxViewDistances.push (maxDistance);\n\t\t\t\t\n\t\t\t\tpolygonCenter = GetPolygonCenter (i);\n\t\t\t\tpolygonCenterDistance = cameraPlane.CoordDistance (polygonCenter);\n\t\t\t\tpolygonCenters.push (polygonCenter);\n\t\t\t\tpolygonCenterDistances.push (polygonCenterDistance);\n\n\t\t\t\tpolygonNormal = JSM.CalculateBodyPolygonNormal (body, i);\n\t\t\t\tpolygonViewVector = JSM.CoordSub (polygonCenter, eye).Normalize ();\n\t\t\t\tpolygonDirection = JSM.VectorDot (polygonNormal, polygonViewVector);\n\t\t\t\tif (JSM.IsGreaterOrEqual (polygonDirection, 0.0)) {\n\t\t\t\t\tpolygonNormal.MultiplyScalar (-1);\n\t\t\t\t}\n\n\t\t\t\tpolygonPlane = JSM.GetPlaneFromCoordAndDirection (polygonCenter, polygonNormal);\n\t\t\t\tpolygonPlanes.push (polygonPlane);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction PolygonViewOverlap (s, p)\n\t\t{\n\t\t\treturn JSM.IsLowerOrEqual (minViewDistances[s], maxViewDistances[p]);\n\t\t}\n\n\t\tfunction PolygonIsFrontOfPlane (s, p)\n\t\t{\n\t\t\tvar sPlane = polygonPlanes[s];\n\t\t\tvar pPlane = polygonPlanes[p];\n\n\t\t\tvar i, coord;\n\n\t\t\tvar isSBehindP = true;\n\t\t\tvar sPolygon = body.GetPolygon (s);\n\t\t\tfor (i = 0; i < sPolygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (sPolygon.GetVertexIndex (i));\n\t\t\t\tif (pPlane.CoordPosition (coord) === JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tisSBehindP = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (isSBehindP) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar isPFrontOfS = true;\n\t\t\tvar pPolygon = body.GetPolygon (p);\n\t\t\tfor (i = 0; i < pPolygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (pPolygon.GetVertexIndex (i));\n\t\t\t\tif (sPlane.CoordPosition (coord) === JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tisPFrontOfS = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (isPFrontOfS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction HasLowerDistance (s, p)\n\t\t{\n\t\t\tif (JSM.IsLower (maxViewDistances[s], maxViewDistances[p])) {\n\t\t\t\treturn true;\n\t\t\t} else if (JSM.IsEqual (maxViewDistances[s], maxViewDistances[p])) {\n\t\t\t\tif (JSM.IsLower (polygonCenterDistances[s], polygonCenterDistances[p])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction OrderPolygonsByMaxViewDistance ()\n\t\t{\n\t\t\tvar count = ordered.length;\n\t\t\t\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tfor (j = 0; j < count - i - 1; j++) {\n\t\t\t\t\tif (HasLowerDistance (ordered[j], ordered[j + 1])) {\n\t\t\t\t\t\tSwapArrayValues (ordered, j, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction NeedToChangeOrder (s, p)\n\t\t{\n\t\t\tif (needToChangeOrderCache[s][p] !== null) {\n\t\t\t\treturn needToChangeOrderCache[s][p];\n\t\t\t}\n\n\t\t\tif (PolygonViewOverlap (s, p)) {\n\t\t\t\tif (PolygonIsFrontOfPlane (s, p)) {\n\t\t\t\t\tneedToChangeOrderCache[s][p] = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tneedToChangeOrderCache[s][p] = false;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction ReorderPolygons ()\n\t\t{\n\t\t\tvar count = ordered.length;\n\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tfor (j = 0; j < count - i - 1; j++) {\n\t\t\t\t\tif (NeedToChangeOrder (ordered[j], ordered[j + 1])) {\n\t\t\t\t\t\tSwapArrayValues (ordered, j, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\t\n\t\tvar minViewDistances = [];\n\t\tvar maxViewDistances = [];\n\t\tvar polygonCenters = [];\n\t\tvar polygonCenterDistances = [];\n\t\tvar polygonPlanes = [];\n\t\t\n\t\tvar ordered = [];\n\t\tvar needToChangeOrderCache = [];\n\t\tvar count = body.PolygonCount ();\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tordered.push (i);\n\t\t\tneedToChangeOrderCache.push ([]);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tneedToChangeOrderCache[i].push (null);\n\t\t\t}\n\t\t}\n\n\t\tCalculatePolygonValues ();\n\t\tOrderPolygonsByMaxViewDistance ();\n\t\tReorderPolygons ();\n\t\t\n\t\tresult = ordered;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/drawing',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: CanvasDrawer\n\t* Description: Represents an object which can draw primitives to a canvas.\n\t* Parameters:\n\t*\tcanvas {html canvas element} the destination element\n\t*/\n\tJSM.CanvasDrawer = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tthis.context = this.canvas.getContext ('2d');\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.GetWidth\n\t* Description: Returns the width of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.CanvasDrawer.prototype.GetWidth = function ()\n\t{\n\t\treturn this.canvas.width;\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.GetHeight\n\t* Description: Returns the height of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.CanvasDrawer.prototype.GetHeight = function ()\n\t{\n\t\treturn this.canvas.height;\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.Clear\n\t* Description: Clears the target.\n\t*/\n\tJSM.CanvasDrawer.prototype.Clear = function ()\n\t{\n\t\tthis.context.clearRect (0, 0, this.canvas.width, this.canvas.height);\n\t\tthis.context.fillStyle = '#ffffff';\n\t\tthis.context.fillRect (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.DrawLine\n\t* Description: Draws a line to the target.\n\t* Parameters:\n\t*\tfrom {Coord2D} the start of the line\n\t*\tto {Coord2D} the end of the line\n\t*/\n\tJSM.CanvasDrawer.prototype.DrawLine = function (from, to)\n\t{\n\t\tthis.context.beginPath ();\n\t\tthis.context.moveTo (from.x, this.canvas.height - from.y);\n\t\tthis.context.lineTo (to.x, this.canvas.height - to.y);\n\t\tthis.context.stroke ();\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.DrawPolygon\n\t* Description: Draws a polygon to the target.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tcolor {string} the hex color string\n\t*\tcontour {boolean} need to draw contour\n\t*/\n\tJSM.CanvasDrawer.prototype.DrawPolygon = function (polygon, color, contour)\n\t{\n\t\tfunction HexColorToHTMLColor (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tthis.context.fillStyle = HexColorToHTMLColor (color);\n\t\tthis.context.beginPath ();\n\n\t\tvar i, vertex, nextVertex;\n\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tif (i === 0) {\n\t\t\t\tthis.context.moveTo (vertex.x, this.canvas.height - vertex.y);\n\t\t\t} else {\n\t\t\t\tthis.context.lineTo (vertex.x, this.canvas.height - vertex.y);\n\t\t\t}\n\t\t}\n\n\t\tthis.context.closePath ();\n\t\tthis.context.fill ();\n\n\t\tif (contour) {\n\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\tnextVertex = polygon.GetVertex (i < polygon.VertexCount () - 1 ? i + 1 : 0);\n\t\t\t\tthis.DrawLine (vertex, nextVertex);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Class: SVGDrawer\n\t* Description: Represents an object which can draw primitives to an svg.\n\t* Parameters:\n\t*\tsvgObject {html svg element} the destination element\n\t*/\n\tJSM.SVGDrawer = function (svgObject)\n\t{\n\t\tthis.svgObject = svgObject;\n\t\tthis.svgNameSpace = 'http://www.w3.org/2000/svg';\n\t};\n\n\t/**\n\t* Function: SVGDrawer.GetWidth\n\t* Description: Returns the width of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SVGDrawer.prototype.GetWidth = function ()\n\t{\n\t\treturn this.svgObject.getAttribute ('width');\n\t};\n\n\t/**\n\t* Function: SVGDrawer.GetHeight\n\t* Description: Returns the height of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SVGDrawer.prototype.GetHeight = function ()\n\t{\n\t\treturn this.svgObject.getAttribute ('height');\n\t};\n\n\t/**\n\t* Function: SVGDrawer.Clear\n\t* Description: Clears the target.\n\t*/\n\tJSM.SVGDrawer.prototype.Clear = function ()\n\t{\n\t\twhile (this.svgObject.lastChild) {\n\t\t\tthis.svgObject.removeChild (this.svgObject.lastChild);\n\t\t}\n\t};\n\n\t/**\n\t* Function: SVGDrawer.DrawLine\n\t* Description: Draws a line to the target.\n\t* Parameters:\n\t*\tfrom {Coord2D} the start of the line\n\t*\tto {Coord2D} the end of the line\n\t*/\n\tJSM.SVGDrawer.prototype.DrawLine = function (from, to)\n\t{\n\t\tvar svgLine = document.createElementNS (this.svgNameSpace, 'line');\n\t\tvar height = this.GetHeight ();\n\t\tsvgLine.setAttributeNS (null, 'stroke', 'black');\n\t\tsvgLine.setAttributeNS (null, 'x1', from.x);\n\t\tsvgLine.setAttributeNS (null, 'y1', height - from.y);\n\t\tsvgLine.setAttributeNS (null, 'x2', to.x);\n\t\tsvgLine.setAttributeNS (null, 'y2', height - to.y);\n\t\tthis.svgObject.appendChild (svgLine);\n\t};\n\n\t/**\n\t* Function: SVGDrawer.DrawPolygon\n\t* Description: Draws a polygon to the target.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tcolor {string} the hex color string\n\t*\tcontour {boolean} need to draw contour\n\t*/\n\tJSM.SVGDrawer.prototype.DrawPolygon = function (polygon, color/*, contour*/)\n\t{\n\t\tfunction HexColorToHTMLColor (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';\n\t\t\treturn result;\n\t\t}\n\n\t\tvar pointsString = '';\n\t\tvar height = this.GetHeight ();\n\t\t\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tpointsString = pointsString + vertex.x + ', ' + (height - vertex.y);\n\t\t\tif (i < polygon.VertexCount () - 1) {\n\t\t\t\tpointsString = pointsString + ', ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar svgPolyon = document.createElementNS (this.svgNameSpace, 'polygon');\n\t\tsvgPolyon.setAttributeNS (null, 'points', pointsString);\n\t\tsvgPolyon.setAttributeNS (null, 'fill', HexColorToHTMLColor (color));\n\t\tsvgPolyon.setAttributeNS (null, 'fill-opacity', '1.0');\n\t\tsvgPolyon.setAttributeNS (null, 'stroke', 'black');\n\t\tthis.svgObject.appendChild (svgPolyon);\n\t};\n\n\t/**\n\t* Function: DrawProjectedBody\n\t* Description: Draws a projected body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the material container\n\t*\tcamera {Camera} the camera for projection\n\t*\tdrawMode {string} draw mode ('HiddenLinePainter', 'HiddenLineFrontFacing' or 'Wireframe')\n\t*\tneedClear {boolean} clear the display before draw\n\t*\tdrawer {drawer object} the drawer object\n\t*/\n\tJSM.DrawProjectedBody = function (body, materials, camera, drawMode, needClear, drawer)\n\t{\n\t\tfunction AddProjectedCoord (projectedPolygon, coord)\n\t\t{\n\t\t\tvar projected = JSM.Project (coord, eye, center, up, fieldOfView * JSM.DegRad, aspectRatio, nearPlane, farPlane, viewPort);\n\t\t\tprojectedPolygon.AddVertex (projected.x, projected.y);\n\t\t}\n\n\t\tfunction GetProjectedPolygonFromBody (polygon)\n\t\t{\n\t\t\tvar projectedPolygon = new JSM.Polygon2D ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tAddProjectedCoord (projectedPolygon, coord);\n\t\t\t}\n\t\t\treturn projectedPolygon;\n\t\t}\n\n\t\tfunction GetProjectedPolygonFromPolygon (polygon)\n\t\t{\n\t\t\tvar projectedPolygon = new JSM.Polygon2D ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\tAddProjectedCoord (projectedPolygon, coord);\n\t\t\t}\n\t\t\treturn projectedPolygon;\n\t\t}\n\n\t\tif (needClear) {\n\t\t\tdrawer.Clear ();\n\t\t}\n\n\t\tvar width = drawer.GetWidth ();\n\t\tvar height = drawer.GetHeight ();\n\t\t\n\t\tvar eye = camera.eye;\n\t\tvar center = camera.center;\n\t\tvar up = camera.up;\n\t\tvar fieldOfView = camera.fieldOfView;\n\t\tvar aspectRatio = width / height;\n\t\tvar nearPlane = camera.nearClippingPlane;\n\t\tvar farPlane = camera.farClippingPlane;\n\t\tvar viewPort = [0, 0, width, height];\n\n\t\tvar i, j, polygon, coord, projected, materialIndex, color;\n\t\tif (drawMode == 'HiddenLinePainter') {\n\t\t\tvar orderedPolygons = JSM.OrderPolygons (body, eye, center);\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\t\t\tfor (i = 0; i < orderedPolygons.length; i++) {\n\t\t\t\tpolygon = body.GetPolygon (orderedPolygons[i]);\n\t\t\t\tprojected = GetProjectedPolygonFromBody (polygon);\n\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t}\n\t\t} else if (drawMode == 'HiddenLineBSPTree') {\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\n\t\t\tvar bspTree = new JSM.BSPTree ();\n\t\t\tJSM.AddBodyToBSPTree (body, bspTree);\n\n\t\t\tJSM.TraverseBSPTreeForEyePosition (bspTree, camera.eye, function (node) {\n\t\t\t\tprojected = GetProjectedPolygonFromPolygon (node.polygon);\n\t\t\t\tpolygon = body.GetPolygon (node.userData.originalPolygon);\n\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t});\t\t\n\t\t} else if (drawMode == 'HiddenLineFrontFacing') {\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tprojected = GetProjectedPolygonFromBody (polygon);\n\t\t\t\tif (projected.GetOrientation () == JSM.Orientation.CounterClockwise) {\n\t\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (drawMode == 'Wireframe') {\n\t\t\tvar vertexCount, currentCoord, currentVertex, vertex;\n\t\t\tvar drawedLines = [];\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tcurrentCoord = null;\n\t\t\t\tcurrentVertex = null;\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tvertexCount = polygon.VertexIndexCount ();\n\t\t\t\tfor (j = 0; j <= vertexCount; j++) {\n\t\t\t\t\tvertex = polygon.GetVertexIndex (j % vertexCount);\n\t\t\t\t\tcoord = body.GetVertexPosition (vertex);\n\t\t\t\t\tprojected = JSM.Project (coord, eye, center, up, fieldOfView * JSM.DegRad, aspectRatio, nearPlane, farPlane, viewPort);\n\t\t\t\t\tif (currentCoord !== null && currentVertex !== null && drawedLines[[currentVertex, vertex]] === undefined) {\n\t\t\t\t\t\tdrawer.DrawLine (currentCoord, projected);\n\t\t\t\t\t\tdrawedLines[[currentVertex, vertex]] = true;\n\t\t\t\t\t\tdrawedLines[[vertex, currentVertex]] = true;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentVertex = vertex;\n\t\t\t\t\tcurrentCoord = projected;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/navigation',[\"../core/jsm\"],function(JSM){\n\tJSM.Navigation = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.drawCallback = null;\n\t\tthis.resizeCallback = null;\n\t\t\n\t\tthis.mouse = null;\n\t\tthis.touch = null;\n\t\t\n\t\tthis.cameraFixUp = null;\n\t\tthis.cameraEnableOrbit = null;\n\t\tthis.cameraEnablePan = null;\n\t\tthis.cameraEnableZoom = null;\n\t\tthis.cameraNearDistanceLimit = null;\n\t\tthis.cameraFarDistanceLimit = null;\n\t\t\n\t\tthis.orbitCenter = null;\n\t\tthis.fullscreen = null;\n\t};\n\n\tJSM.Navigation.prototype.Init = function (canvas, camera, drawCallback, resizeCallback)\n\t{\n\t\tthis.canvas = canvas;\n\t\tthis.camera = camera;\n\t\tthis.drawCallback = drawCallback;\n\t\tthis.resizeCallback = resizeCallback;\n\n\t\tthis.mouse = new JSM.Mouse ();\n\t\tthis.touch = new JSM.Touch ();\n\t\t\n\t\tthis.cameraFixUp = true;\n\t\tthis.cameraEnableOrbit = true;\n\t\tthis.cameraEnablePan = true;\n\t\tthis.cameraEnableZoom = true;\n\t\t\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t\tthis.fullscreen = false;\n\n\t\tvar myThis = this;\n\t\tif (document.addEventListener) {\n\t\t\tdocument.addEventListener ('mousemove', function (event) {myThis.OnMouseMove (event);});\n\t\t\tdocument.addEventListener ('mouseup', function (event) {myThis.OnMouseUp (event);});\n\t\t}\n\t\tif (this.canvas.addEventListener) {\n\t\t\tthis.canvas.addEventListener ('mousedown', function (event) {myThis.OnMouseDown (event);}, false);\n\t\t\tthis.canvas.addEventListener ('DOMMouseScroll', function (event) {myThis.OnMouseWheel (event);}, false);\n\t\t\tthis.canvas.addEventListener ('mousewheel', function (event) {myThis.OnMouseWheel (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchstart', function (event) {myThis.OnTouchStart (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchmove', function (event) {myThis.OnTouchMove (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchend', function (event) {myThis.OnTouchEnd (event);}, false);\n\t\t\tthis.canvas.addEventListener ('contextmenu', function (event) {myThis.OnContextMenu (event);}, false);\n\t\t}\n\t\tif (window.addEventListener) {\n\t\t\twindow.addEventListener ('resize', function (event) {myThis.OnResize (event);}, false);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.Navigation.prototype.SetCamera = function (eye, center, up)\n\t{\n\t\tthis.camera.Set (eye, center, up);\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t};\n\n\tJSM.Navigation.prototype.EnableFixUp = function (enable)\n\t{\n\t\tthis.cameraFixUp = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnableOrbit = function (enable)\n\t{\n\t\tthis.cameraEnableOrbit = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnablePan = function (enable)\n\t{\n\t\tthis.cameraEnablePan = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnableZoom = function (enable)\n\t{\n\t\tthis.cameraEnableZoom = enable;\n\t};\n\n\tJSM.Navigation.prototype.SetNearDistanceLimit = function (limit)\n\t{\n\t\tthis.cameraNearDistanceLimit = limit;\n\t};\n\n\tJSM.Navigation.prototype.SetFarDistanceLimit = function (limit)\n\t{\n\t\tthis.cameraFarDistanceLimit = limit;\n\t};\n\n\tJSM.Navigation.prototype.SetOrbitCenter = function (orbitCenter)\n\t{\n\t\tthis.orbitCenter = orbitCenter;\n\t};\n\n\tJSM.Navigation.prototype.FitInWindow = function (center, radius)\n\t{\n\t\tif (JSM.IsZero (radius)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar offsetToOrigo = JSM.CoordSub (this.camera.center, center);\n\t\tthis.camera.center = center;\n\t\tthis.camera.eye = JSM.CoordSub (this.camera.eye, offsetToOrigo);\n\t\t\n\t\tvar centerEyeDirection = JSM.CoordSub (this.camera.eye, this.camera.center).Normalize ();\n\t\tvar fieldOfView = this.camera.fieldOfView / 2.0;\n\t\tif (this.canvas.width < this.canvas.height) {\n\t\t\tfieldOfView = fieldOfView * this.canvas.width / this.canvas.height;\n\t\t}\n\t\tvar distance = radius / Math.sin (fieldOfView * JSM.DegRad);\n\t\t\n\t\tthis.camera.eye = this.camera.center.Clone ().Offset (centerEyeDirection, distance);\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t};\n\n\tJSM.Navigation.prototype.SetFullscreen = function (fullscreen)\n\t{\n\t\tthis.fullscreen = fullscreen;\n\t\tthis.ResizeCallback ();\n\t};\n\n\tJSM.Navigation.prototype.Orbit = function (angleX, angleY)\n\t{\n\t\tvar radAngleX = angleX * JSM.DegRad;\n\t\tvar radAngleY = angleY * JSM.DegRad;\n\t\t\n\t\tvar viewDirection = JSM.CoordSub (this.camera.center, this.camera.eye).Normalize ();\n\t\tvar horizontalDirection = JSM.VectorCross (viewDirection, this.camera.up).Normalize ();\n\t\tvar differentCenter = !this.orbitCenter.IsEqual (this.camera.center);\n\t\t\n\t\tif (this.cameraFixUp) {\n\t\t\tvar originalAngle = viewDirection.AngleTo (this.camera.up);\n\t\t\tvar newAngle = originalAngle + radAngleY;\n\t\t\tif (JSM.IsGreater (newAngle, 0.0) && JSM.IsLower (newAngle, Math.PI)) {\n\t\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\tif (differentCenter) {\n\t\t\t\t\tthis.camera.center.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.camera.eye.Rotate (this.camera.up, -radAngleX, this.orbitCenter);\n\t\t\tif (differentCenter) {\n\t\t\t\tthis.camera.center.Rotate (this.camera.up, -radAngleX, this.orbitCenter);\n\t\t\t}\n\t\t} else {\n\t\t\tvar verticalDirection = JSM.VectorCross (horizontalDirection, viewDirection).Normalize ();\n\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\tthis.camera.eye.Rotate (verticalDirection, -radAngleX, this.orbitCenter);\n\t\t\tif (differentCenter) {\n\t\t\t\tthis.camera.center.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\tthis.camera.center.Rotate (verticalDirection, -radAngleX, this.orbitCenter);\n\t\t\t}\n\t\t\tthis.camera.up = verticalDirection;\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.Pan = function (moveX, moveY)\n\t{\n\t\tvar viewDirection = JSM.CoordSub (this.camera.center, this.camera.eye).Normalize ();\n\t\tvar horizontalDirection = JSM.VectorCross (viewDirection, this.camera.up).Normalize ();\n\t\tvar verticalDirection = JSM.VectorCross (horizontalDirection, viewDirection).Normalize ();\n\t\t\n\t\tthis.camera.eye.Offset (horizontalDirection, -moveX);\n\t\tthis.camera.center.Offset (horizontalDirection, -moveX);\n\n\t\tthis.camera.eye.Offset (verticalDirection, moveY);\n\t\tthis.camera.center.Offset (verticalDirection, moveY);\n\t};\n\n\tJSM.Navigation.prototype.Zoom = function (ratio)\n\t{\n\t\tvar direction = JSM.CoordSub (this.camera.center, this.camera.eye);\n\t\tvar distance = direction.Length ();\n\t\tvar zoomIn = ratio > 0;\n\t\tif (zoomIn && this.cameraNearDistanceLimit !== null && distance < this.cameraNearDistanceLimit) {\n\t\t\treturn 0;\n\t\t} else if (!zoomIn && this.cameraFarDistanceLimit !== null && distance > this.cameraFarDistanceLimit) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar move = distance * ratio;\n\t\tthis.camera.eye.Offset (direction, move);\n\t};\n\n\tJSM.Navigation.prototype.DrawCallback = function ()\n\t{\n\t\tif (this.drawCallback !== undefined && this.drawCallback !== null) {\n\t\t\tthis.drawCallback ();\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.ResizeCallback = function ()\n\t{\n\t\tif (this.resizeCallback !== undefined && this.resizeCallback !== null) {\n\t\t\tif (this.fullscreen) {\n\t\t\t\tthis.canvas.width = window.innerWidth;\n\t\t\t\tthis.canvas.height = window.innerHeight;\n\t\t\t}\n\t\t\tthis.resizeCallback ();\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.OnMouseDown = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Down (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseMove = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Move (event, this.canvas);\n\t\tif (!this.mouse.down) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ratio = 0.0;\n\t\tif (this.mouse.button == 1) {\n\t\t\tif (!this.cameraEnableOrbit) {\n\t\t\t\treturn;\n\t\t\t}\t\t\n\t\t\tratio = 0.5;\n\t\t\tthis.Orbit (this.mouse.diff.x * ratio, this.mouse.diff.y * ratio);\n\t\t} else if (this.mouse.button == 3) {\n\t\t\tif (!this.cameraEnablePan) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar eyeCenterDistance = this.camera.eye.DistanceTo (this.camera.center);\n\t\t\tratio = 0.001 * eyeCenterDistance;\n\t\t\tthis.Pan (this.mouse.diff.x * ratio, this.mouse.diff.y * ratio);\n\t\t}\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnMouseUp = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Up (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseOut = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Out (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseWheel = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tif (!this.cameraEnableZoom) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar eventParameters = event;\n\t\tif (eventParameters === null) {\n\t\t\teventParameters = window.event;\n\t\t}\n\t\t\n\t\tvar delta = 0;\n\t\tif (eventParameters.detail) {\n\t\t\tdelta = -eventParameters.detail;\n\t\t} else if (eventParameters.wheelDelta) {\n\t\t\tdelta = eventParameters.wheelDelta / 40;\n\t\t}\n\n\t\tvar ratio = 0.1;\n\t\tif (delta < 0) {\n\t\t\tratio = ratio * -1.0;\n\t\t}\n\n\t\tthis.Zoom (ratio);\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnTouchStart = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.Start (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnTouchMove = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.Move (event, this.canvas);\n\t\tif (!this.touch.down) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ratio = 0.0;\n\t\tif (this.touch.fingers == 1) {\n\t\t\tif (!this.cameraEnableOrbit) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tratio = 0.5;\n\t\t\tthis.Orbit (this.touch.diff.x * ratio, this.touch.diff.y * ratio);\n\t\t} else if (this.touch.fingers == 2) {\n\t\t\tif (!this.cameraEnableZoom) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tratio = 0.005;\n\t\t\tthis.Zoom (this.touch.diff.x * ratio);\n\t\t} else if (this.touch.fingers == 3) {\n\t\t\tif (!this.cameraEnablePan) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar eyeCenterDistance = this.camera.eye.DistanceTo (this.camera.center);\n\t\t\tratio = 0.001 * eyeCenterDistance;\n\t\t\tthis.Pan (this.touch.diff.x * ratio, this.touch.diff.y * ratio);\n\t\t}\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnTouchEnd = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.End (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnContextMenu = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t};\n\n\tJSM.Navigation.prototype.OnResize = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.ResizeCallback ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/softwareviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.SoftwareViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.bodies = null;\n\t\tthis.drawer = null;\n\t\tthis.drawMode = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.SoftwareViewer.prototype.Start = function (canvas, camera)\n\t{\n\t\tif (!this.InitCanvas (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.InitCanvas = function (canvas)\n\t{\n\t\tthis.bodies = [];\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas instanceof (HTMLCanvasElement)) {\n\t\t\tthis.drawer = new JSM.CanvasDrawer (this.canvas);\n\t\t} else if (this.canvas instanceof (SVGSVGElement)) {\n\t\t\tthis.drawer = new JSM.SVGDrawer (this.canvas);\n\t\t}\n\t\t\n\t\tif (!this.drawer) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.drawMode = 'Wireframe';\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.InitCamera = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.AddBody = function (body, materials)\n\t{\n\t\tthis.bodies.push ([body, materials]);\n\t};\n\n\tJSM.SoftwareViewer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t};\n\n\tJSM.SoftwareViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, j, body, vertex;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i][0];\n\t\t\tfor (j = 0; j < body.VertexCount (); j++) {\n\t\t\t\tvertex = body.GetVertex (j);\n\t\t\t\tmin.x = JSM.Minimum (min.x, vertex.position.x);\n\t\t\t\tmin.y = JSM.Minimum (min.y, vertex.position.y);\n\t\t\t\tmin.z = JSM.Minimum (min.z, vertex.position.z);\n\t\t\t\tmax.x = JSM.Maximum (max.x, vertex.position.x);\n\t\t\t\tmax.y = JSM.Maximum (max.y, vertex.position.y);\n\t\t\t\tmax.z = JSM.Maximum (max.z, vertex.position.z);\n\t\t\t}\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, j, body, vertex, distance;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i][0];\n\t\t\tfor (j = 0; j < body.VertexCount (); j++) {\n\t\t\t\tvertex = body.GetVertex (j);\n\t\t\t\tdistance = center.DistanceTo (vertex.position);\n\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\tradius = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.SoftwareViewer.prototype.Resize = function ()\n\t{\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.Draw = function ()\n\t{\n\t\tvar i, bodyAndMaterials;\n\t\tthis.drawer.Clear ();\n\t\t\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbodyAndMaterials = this.bodies[i];\n\t\t\tJSM.DrawProjectedBody (bodyAndMaterials[0], bodyAndMaterials[1], this.camera, this.drawMode, false, this.drawer);\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/spriteviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.SpriteViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.callbacks = null;\n\t\tthis.points = null;\n\t\tthis.projected = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.SpriteViewer.prototype.Start = function (canvas, camera, callbacks)\n\t{\n\t\tif (!this.InitCanvas (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCallbacks (callbacks)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCanvas = function (canvas)\n\t{\n\t\tthis.points = [];\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCamera = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.camera, this.Draw.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCallbacks = function (callbacks)\n\t{\n\t\tthis.callbacks = {\n\t\t\tonPointDraw : null\n\t\t};\n\n\t\tif (callbacks !== undefined) {\n\t\t\tif (callbacks.onDrawStart !== undefined) { this.callbacks.onDrawStart = callbacks.onDrawStart; }\n\t\t\tif (callbacks.onPointDraw !== undefined) { this.callbacks.onPointDraw = callbacks.onPointDraw; }\n\t\t\tif (callbacks.onDrawEnd !== undefined) { this.callbacks.onDrawEnd = callbacks.onDrawEnd; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.AddPoint = function (point)\n\t{\n\t\tthis.points.push (point);\n\t};\n\n\tJSM.SpriteViewer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.points = [];\n\t};\n\n\tJSM.SpriteViewer.prototype.Resize = function ()\n\t{\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderPosition = function (maxDistance, x, y)\n\t{\n\t\tvar position = new JSM.Coord2D (x, y);\n\t\t\n\t\tvar minIndex = -1;\n\t\tvar minDistance = JSM.Inf;\n\t\tvar i, projected, distance;\n\t\tfor (i = 0; i < this.projected.length; i++) {\n\t\t\tprojected = this.projected[i];\n\t\t\tdistance = position.DistanceTo (new JSM.Coord2D (projected.position.x, projected.position.y));\n\t\t\tif (JSM.IsLower (distance, maxDistance) && JSM.IsLower (distance, minDistance)) {\n\t\t\t\tminIndex = projected.originalIndex;\n\t\t\t\tminDistance = distance;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn minIndex;\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderMouse = function (maxDistance)\n\t{\n\t\treturn this.NearestPointUnderPosition (maxDistance, this.navigation.mouse.curr.x, this.navigation.mouse.curr.y);\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderTouch = function (maxDistance)\n\t{\n\t\treturn this.NearestPointUnderPosition (maxDistance, this.navigation.touch.curr.x, this.navigation.touch.curr.y);\n\t};\n\n\tJSM.SpriteViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SpriteViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.SpriteViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.SpriteViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, coord, distance;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tdistance = center.DistanceTo (coord);\n\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\tradius = distance;\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.SpriteViewer.prototype.Draw = function ()\n\t{\n\t\tif (this.callbacks.onDrawStart !== null) {\n\t\t\tthis.callbacks.onDrawStart (this.canvas);\n\t\t}\n\n\t\tvar aspectRatio = this.canvas.width / this.canvas.height;\n\t\tvar viewPort = [0, 0, this.canvas.width, this.canvas.height];\n\t\tthis.projected = [];\n\t\t\n\t\tvar i, coord, projected;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tprojected = JSM.Project (coord, this.camera.eye, this.camera.center, this.camera.up, this.camera.fieldOfView * JSM.DegRad, aspectRatio, this.camera.nearClippingPlane, this.camera.farClippingPlane, viewPort);\n\t\t\tprojected.y = this.canvas.height - projected.y;\n\t\t\tif (projected !== null) {\n\t\t\t\tthis.projected.push ({position : projected, originalIndex : i});\n\t\t\t}\n\t\t}\n\n\t\tthis.projected.sort (function (a, b) {\n\t\t\tif (a.position.z > b.position.z) {\n\t\t\t\treturn -1;\n\t\t\t} else if (a.position.z < b.position.z) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\tfor (i = 0; i < this.projected.length; i++) {\n\t\t\tif (this.callbacks.onPointDraw !== null) {\n\t\t\t\tthis.callbacks.onPointDraw (this.canvas, this.projected[i].originalIndex, this.projected[i].position);\n\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks.onDrawEnd !== null) {\n\t\t\tthis.callbacks.onDrawEnd (this.canvas);\n\t\t}\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/viewer',[\"../core/jsm\"],function(JSM){\n\tJSM.Viewer = function ()\n\t{\n\t\tthis.camera = null;\n\t\tthis.renderer = null;\n\t\tthis.navigation = null;\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!this.InitRenderer (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitNavigation (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.Reset = function ()\n\t{\n\t\tthis.RemoveBodies ();\n\t\tthis.RemoveLights ();\n\t\tthis.SetAmbientLight (new JSM.RenderAmbientLight (0x7f7f7f));\n\t\tthis.EnableCameraLight ();\n\t};\n\n\tJSM.Viewer.prototype.InitRenderer = function (canvas)\n\t{\n\t\tthis.renderer = new JSM.Renderer ();\n\t\tif (!this.renderer.Init (canvas)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.InitNavigation = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.renderer.canvas, this.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.InitLights = function ()\n\t{\n\t\tthis.SetAmbientLight (new JSM.RenderAmbientLight (0x7f7f7f));\n\t\tthis.EnableCameraLight ();\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.renderer.SetClearColor (red, green, blue);\n\t};\n\n\tJSM.Viewer.prototype.EnableCameraLight = function ()\n\t{\n\t\tif (this.cameraLight !== null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cameraLight = new JSM.RenderDirectionalLight (0x7f7f7f, 0xffffff, new JSM.Vector (1.0, 0.0, 0.0));\n\t\tthis.AddLight (this.cameraLight);\n\t};\n\n\tJSM.Viewer.prototype.DisableCameraLight = function ()\n\t{\n\t\tif (this.cameraLight === null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.RemoveLight (this.cameraLight);\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.GetCameraLight = function ()\n\t{\n\t\treturn this.cameraLight;\n\t};\n\n\tJSM.Viewer.prototype.SetAmbientLight = function (light)\n\t{\n\t\tthis.renderer.SetAmbientLight (light);\n\t};\n\n\tJSM.Viewer.prototype.AddLight = function (light)\n\t{\n\t\tthis.renderer.AddLight (light);\n\t};\n\n\tJSM.Viewer.prototype.RemoveLight = function (light)\n\t{\n\t\tthis.renderer.RemoveLight (light);\n\t};\n\n\tJSM.Viewer.prototype.RemoveLights = function ()\n\t{\n\t\tthis.renderer.RemoveLights ();\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.AddBody = function (renderBody)\n\t{\n\t\tthis.renderer.AddBody (renderBody, this.Draw.bind (this));\n\t};\n\n\tJSM.Viewer.prototype.AddBodies = function (renderBodies)\n\t{\n\t\tthis.renderer.AddBodies (renderBodies, this.Draw.bind (this));\n\t};\n\n\tJSM.Viewer.prototype.RemoveBody = function (body)\n\t{\n\t\tthis.renderer.RemoveBody (body);\n\t};\n\n\tJSM.Viewer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.renderer.RemoveBodies ();\n\t};\n\n\tJSM.Viewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t};\n\n\tJSM.Viewer.prototype.SetFullscreen = function (fullscreen)\n\t{\n\t\tthis.navigation.SetFullscreen (fullscreen);\n\t};\n\n\tJSM.Viewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.Viewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tthis.renderer.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshes (function (mesh) {\n\t\t\t\tvar i, vertex;\n\t\t\t\tfor (i = 0; i < mesh.VertexCount (); i++) {\n\t\t\t\t\tvertex = mesh.GetTransformedVertex (i, transformation);\n\t\t\t\t\tmin.x = JSM.Minimum (min.x, vertex.x);\n\t\t\t\t\tmin.y = JSM.Minimum (min.y, vertex.y);\n\t\t\t\t\tmin.z = JSM.Minimum (min.z, vertex.z);\n\t\t\t\t\tmax.x = JSM.Maximum (max.x, vertex.x);\n\t\t\t\t\tmax.y = JSM.Maximum (max.y, vertex.y);\n\t\t\t\t\tmax.z = JSM.Maximum (max.z, vertex.z);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.Viewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tthis.renderer.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshes (function (mesh) {\n\t\t\t\tvar i, vertex, distance;\n\t\t\t\tfor (i = 0; i < mesh.VertexCount (); i++) {\n\t\t\t\t\tvertex = mesh.GetTransformedVertex (i, transformation);\n\t\t\t\t\tdistance = center.DistanceTo (vertex);\n\t\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\t\tradius = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.Viewer.prototype.FindObjects = function (screenX, screenY)\n\t{\n\t\treturn this.renderer.FindObjects (this.camera, screenX, screenY);\n\t};\n\n\tJSM.Viewer.prototype.Resize = function ()\n\t{\n\t\tthis.renderer.Resize ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.Viewer.prototype.Draw = function ()\n\t{\n\t\tvar camera = this.camera;\n\t\tvar cameraLight = this.GetCameraLight ();\n\t\tif (cameraLight !== null) {\n\t\t\tcameraLight.direction = JSM.CoordSub (camera.center, camera.eye).Normalize ();\n\t\t}\n\t\tthis.renderer.Render (camera);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/pointcloudviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.PointCloudViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.renderer = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.PointCloudViewer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!this.InitRenderer (canvas, camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitNavigation ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.InitRenderer = function (canvas, camera)\n\t{\n\t\tthis.renderer = new JSM.PointCloudRenderer ();\n\t\tif (!this.renderer.Init (canvas, camera)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.InitNavigation = function ()\n\t{\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.renderer.canvas, this.renderer.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.renderer.SetClearColor (red, green, blue);\n\t};\n\n\tJSM.PointCloudViewer.prototype.SetPointSize = function (pointSize)\n\t{\n\t\tthis.renderer.SetPointSize (pointSize);\n\t};\n\n\tJSM.PointCloudViewer.prototype.AddPoints = function (points, colors)\n\t{\n\t\tthis.renderer.AddPoints (points, colors);\n\t};\n\n\tJSM.PointCloudViewer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.renderer.RemovePoints ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, j, points, point;\n\t\tfor (i = 0; i < this.renderer.points.length; i++) {\n\t\t\tpoints = this.renderer.points[i].pointArray;\n\t\t\tfor (j = 0; j < points.length; j = j + 3) {\n\t\t\t\tpoint = new JSM.Coord (points[j], points[j + 1], points[j + 2]);\n\t\t\t\tmin.x = JSM.Minimum (min.x, point.x);\n\t\t\t\tmin.y = JSM.Minimum (min.y, point.y);\n\t\t\t\tmin.z = JSM.Minimum (min.z, point.z);\n\t\t\t\tmax.x = JSM.Maximum (max.x, point.x);\n\t\t\t\tmax.y = JSM.Maximum (max.y, point.y);\n\t\t\t\tmax.z = JSM.Maximum (max.z, point.z);\n\t\t\t}\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, j, points, point, distance;\n\t\tfor (i = 0; i < this.renderer.points.length; i++) {\n\t\t\tpoints = this.renderer.points[i].pointArray;\n\t\t\tfor (j = 0; j < points.length; j = j + 3) {\n\t\t\t\tpoint = new JSM.Coord (points[j], points[j + 1], points[j + 2]);\n\t\t\t\tdistance = center.DistanceTo (point);\n\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\tradius = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.PointCloudViewer.prototype.Resize = function ()\n\t{\n\t\tthis.renderer.Resize ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.Draw = function ()\n\t{\n\t\tthis.renderer.Render ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/solidgenerator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSolidWithRadius\n\t* Description: Generates a special solid with the given radius.\n\t* Parameters:\n\t*\tsolidName {string} the name of the solid\n\t*\tradius {number} the radius of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSolidWithRadius = function (solidName, radius)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar equalRadius = true;\n\t\t\n\t\tif (solidName === 'Tetrahedron') {\n\t\t\tresult = JSM.GenerateTetrahedron ();\n\t\t} else if (solidName === 'Hexahedron') {\n\t\t\tresult = JSM.GenerateHexahedron ();\n\t\t} else if (solidName === 'Octahedron') {\n\t\t\tresult = JSM.GenerateOctahedron ();\n\t\t} else if (solidName === 'Dodecahedron') {\n\t\t\tresult = JSM.GenerateDodecahedron ();\n\t\t} else if (solidName === 'Icosahedron') {\n\t\t\tresult = JSM.GenerateIcosahedron ();\n\t\t} else if (solidName === 'TruncatedTetrahedron') {\n\t\t\tresult = JSM.GenerateTruncatedTetrahedron ();\n\t\t} else if (solidName === 'Cuboctahedron') {\n\t\t\tresult = JSM.GenerateCuboctahedron ();\n\t\t} else if (solidName === 'TruncatedCube') {\n\t\t\tresult = JSM.GenerateTruncatedCube ();\n\t\t} else if (solidName === 'TruncatedOctahedron') {\n\t\t\tresult = JSM.GenerateTruncatedOctahedron ();\n\t\t} else if (solidName === 'Rhombicuboctahedron') {\n\t\t\tresult = JSM.GenerateRhombicuboctahedron ();\n\t\t} else if (solidName === 'TruncatedCuboctahedron') {\n\t\t\tresult = JSM.GenerateTruncatedCuboctahedron ();\n\t\t} else if (solidName === 'SnubCube') {\n\t\t\tresult = JSM.GenerateSnubCube ();\n\t\t} else if (solidName === 'Icosidodecahedron') {\n\t\t\tresult = JSM.GenerateIcosidodecahedron ();\n\t\t} else if (solidName === 'TruncatedDodecahedron') {\n\t\t\tresult = JSM.GenerateTruncatedDodecahedron ();\n\t\t} else if (solidName === 'TruncatedIcosahedron') {\n\t\t\tresult = JSM.GenerateTruncatedIcosahedron ();\n\t\t} else if (solidName === 'Rhombicosidodecahedron') {\n\t\t\tresult = JSM.GenerateRhombicosidodecahedron ();\n\t\t} else if (solidName === 'TruncatedIcosidodecahedron') {\n\t\t\tresult = JSM.GenerateTruncatedIcosidodecahedron ();\n\t\t} else if (solidName === 'SnubDodecahedron') {\n\t\t\tresult = JSM.GenerateSnubDodecahedron ();\n\t\t} else if (solidName === 'TetrakisHexahedron') {\n\t\t\tresult = JSM.GenerateTetrakisHexahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'RhombicDodecahedron') {\n\t\t\tresult = JSM.GenerateRhombicDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'PentakisDodecahedron') {\n\t\t\tresult = JSM.GeneratePentakisDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallStellatedDodecahedron') {\n\t\t\tresult = JSM.GenerateSmallStellatedDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'GreatDodecahedron') {\n\t\t\tresult = JSM.GenerateGreatDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallTriambicIcosahedron') {\n\t\t\tresult = JSM.GenerateSmallTriambicIcosahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'GreatStellatedDodecahedron') {\n\t\t\tresult = JSM.GenerateGreatStellatedDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallTriakisOctahedron') {\n\t\t\tresult = JSM.GenerateSmallTriakisOctahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'StellaOctangula') {\n\t\t\tresult = JSM.GenerateStellaOctangula ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'TriakisTetrahedron') {\n\t\t\tresult = JSM.GenerateTriakisTetrahedron ();\n\t\t\tequalRadius = false;\n\t\t}\n\n\t\tif (result.VertexCount () > 0) {\n\t\t\tvar i;\n\t\t\n\t\t\tvar maxRadius = 0.0;\n\t\t\tif (equalRadius) {\n\t\t\t\tmaxRadius = result.GetVertexPosition (0).Length ();\n\t\t\t} else {\n\t\t\t\tvar currentRadius;\n\t\t\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\t\t\tcurrentRadius = result.GetVertexPosition (i).Length ();\n\t\t\t\t\tif (JSM.IsGreater (currentRadius, maxRadius)) {\n\t\t\t\t\t\tmaxRadius = currentRadius;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar scale = radius / maxRadius;\n\t\t\t\n\t\t\tvar vertex;\n\t\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\t\tvertex = result.GetVertex (i);\n\t\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTetrahedron\n\t* Description: Generates a tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTetrahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, +a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, -a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, +a, -a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, -a, -a)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 2, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 3, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 2, 3]));\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateHexahedron\n\t* Description: Generates a hexahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateHexahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 1, 5, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 2, 3, 1]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 7, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 5, 7, 6]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateOctahedron\n\t* Description: Generates an octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateOctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +b);\n\t\tJSM.AddVertexToBody (result, -a, +b, +b);\n\t\tJSM.AddVertexToBody (result, +b, +a, +b);\n\t\tJSM.AddVertexToBody (result, +b, -a, +b);\n\t\tJSM.AddVertexToBody (result, +b, +b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 3, 5]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 3]);\n\t\tJSM.AddPolygonToBody (result, [0, 5, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 2, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 3]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateDodecahedron\n\t* Description: Generates a dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\t\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +d, +c);\n\t\tJSM.AddVertexToBody (result, +b, +d, -c);\n\t\tJSM.AddVertexToBody (result, +b, -d, +c);\n\t\tJSM.AddVertexToBody (result, +b, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +b);\n\t\tJSM.AddVertexToBody (result, +d, -c, +b);\n\t\tJSM.AddVertexToBody (result, -d, +c, +b);\n\t\tJSM.AddVertexToBody (result, -d, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +d);\n\t\tJSM.AddVertexToBody (result, -c, +b, +d);\n\t\tJSM.AddVertexToBody (result, +c, +b, -d);\n\t\tJSM.AddVertexToBody (result, -c, +b, -d);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 10, 2, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 16, 18, 1, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 12, 14, 3, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5, 14, 12]);\n\t\tJSM.AddPolygonToBody (result, [1, 18, 4, 11, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6, 15, 13]);\n\t\tJSM.AddPolygonToBody (result, [2, 13, 4, 18, 16]);\n\t\tJSM.AddPolygonToBody (result, [3, 14, 5, 19, 17]);\n\t\tJSM.AddPolygonToBody (result, [3, 17, 6, 10, 8]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 15, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 11, 7, 19]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 19, 7, 15]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateIcosahedron\n\t* Description: Generates an icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateIcosahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 6, 10]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 10, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [4, 8, 9]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 8]);\n\t\tJSM.AddPolygonToBody (result, [6, 11, 10]);\n\t\tJSM.AddPolygonToBody (result, [7, 10, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedTetrahedron\n\t* Description: Generates a truncated tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedTetrahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 3.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 7]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 6, 5, 9, 8]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 7, 11, 10, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 7, 4, 8, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 6, 10, 11, 3]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboctahedron\n\t* Description: Generates a cuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 5, 11]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 7, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6]);\n\t\tJSM.AddPolygonToBody (result, [3, 6, 8]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 7]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 4, 1, 5]);\n\t\tJSM.AddPolygonToBody (result, [0, 11, 3, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 2, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 3, 7]);\n\t\tJSM.AddPolygonToBody (result, [4, 8, 6, 10]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 7, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedCube\n\t* Description: Generates a truncated cube.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedCube = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = Math.sqrt (2.0) - 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, -b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 21, 13]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 1, 17, 21, 5, 3, 19, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 10, 2, 4, 12, 9, 1]);\n\t\tJSM.AddPolygonToBody (result, [2, 18, 22, 6, 7, 23, 20, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 5, 13, 15, 7, 6, 14, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 16, 19, 11, 14, 22, 18, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 20, 23, 15, 13, 21, 17]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedOctahedron\n\t* Description: Generates a truncated octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedOctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, +b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +c, +a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, -a, +b);\n\n\t\tJSM.AddPolygonToBody (result, [0, 10, 2, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 3, 11]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [5, 15, 7, 13]);\n\t\tJSM.AddPolygonToBody (result, [16, 22, 18, 20]);\n\t\tJSM.AddPolygonToBody (result, [17, 21, 19, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 4, 14, 21, 17, 10]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 16, 20, 12, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 6, 12, 20, 18, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 19, 21, 14, 6]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 13, 22, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 17, 23, 15, 5]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 15, 23, 19, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 9, 18, 22, 13, 7]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRhombicuboctahedron\n\t* Description: Generates a rhombicuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 1.0 + Math.sqrt (2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, -b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 21, 13]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 18, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 11, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 13, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 20, 4]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 22, 6]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 15, 7]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 23, 21]);\n\t\tJSM.AddPolygonToBody (result, [8, 9, 13, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 16, 17, 9]);\n\t\tJSM.AddPolygonToBody (result, [10, 12, 20, 18]);\n\t\tJSM.AddPolygonToBody (result, [10, 14, 15, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 13, 21, 19]);\n\t\tJSM.AddPolygonToBody (result, [14, 22, 23, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 18, 20, 17]);\n\t\tJSM.AddPolygonToBody (result, [19, 21, 23, 22]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedCuboctahedron\n\t* Description: Generates a truncated cuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedCuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 1.0 + Math.sqrt (2.0);\n\t\tvar c = 1.0 + 2.0 * Math.sqrt (2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, +a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, -b, -c);\n\t\tJSM.AddVertexToBody (result, -a, +b, -c);\n\t\tJSM.AddVertexToBody (result, -a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, -b, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, +a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, -b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, -b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\t\tJSM.AddVertexToBody (result, -b, -a, +c);\n\t\tJSM.AddVertexToBody (result, -b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, -b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, -a);\n\t\tJSM.AddVertexToBody (result, -b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, +c, +a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, +a, -b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, -b);\n\t\tJSM.AddVertexToBody (result, -c, -a, +b);\n\t\tJSM.AddVertexToBody (result, +c, -a, -b);\n\t\tJSM.AddVertexToBody (result, -c, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, -b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, -b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\t\tJSM.AddVertexToBody (result, +c, -b, -a);\n\t\tJSM.AddVertexToBody (result, -c, -b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 11, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 13, 9]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 15, 7]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 35, 32]);\n\t\tJSM.AddPolygonToBody (result, [17, 34, 38, 21]);\n\t\tJSM.AddPolygonToBody (result, [18, 33, 37, 22]);\n\t\tJSM.AddPolygonToBody (result, [23, 39, 36, 20]);\n\t\tJSM.AddPolygonToBody (result, [24, 40, 43, 27]);\n\t\tJSM.AddPolygonToBody (result, [25, 29, 46, 42]);\n\t\tJSM.AddPolygonToBody (result, [26, 30, 45, 41]);\n\t\tJSM.AddPolygonToBody (result, [28, 44, 47, 31]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 32, 40, 24, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 27, 43, 34, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 9, 25, 42, 35, 19]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 26, 41, 33, 18]);\n\t\tJSM.AddPolygonToBody (result, [4, 21, 38, 46, 29, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 20, 36, 45, 30, 14]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 37, 44, 28, 13]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 31, 47, 39, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 18, 22, 6, 2, 19, 16]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 21, 4, 7, 23, 20, 5]);\n\t\tJSM.AddPolygonToBody (result, [8, 24, 27, 10, 14, 30, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [9, 13, 28, 31, 15, 12, 29, 25]);\n\t\tJSM.AddPolygonToBody (result, [32, 35, 42, 46, 38, 34, 43, 40]);\n\t\tJSM.AddPolygonToBody (result, [33, 41, 45, 36, 39, 47, 44, 37]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSnubCube\n\t* Description: Generates a snub cube.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSnubCube = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = (1.0 / 3.0) * (Math.pow (17 + 3.0 * Math.sqrt (33.0), 1.0 / 3.0) - Math.pow (-17 + 3.0 * Math.sqrt (33.0), 1.0 / 3.0) - 1.0);\n\t\tvar c = 1.0 / b;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, +a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, -a, -b, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, -b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, +a, -b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, -b);\n\t\tJSM.AddVertexToBody (result, -a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, -b, +a, -c);\n\t\tJSM.AddVertexToBody (result, -b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, -b, +a);\n\t\tJSM.AddVertexToBody (result, +c, -b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\tJSM.AddPolygonToBody (result, [0, 9, 22]);\n\t\tJSM.AddPolygonToBody (result, [0, 17, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 22, 19]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 20]);\n\t\tJSM.AddPolygonToBody (result, [1, 18, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 20, 16]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 8, 21]);\n\t\tJSM.AddPolygonToBody (result, [2, 16, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 21, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 23]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 23, 17]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 10]);\n\t\tJSM.AddPolygonToBody (result, [4, 18, 15]);\n\t\tJSM.AddPolygonToBody (result, [5, 14, 8]);\n\t\tJSM.AddPolygonToBody (result, [5, 16, 12]);\n\t\tJSM.AddPolygonToBody (result, [6, 12, 9]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 11]);\n\t\tJSM.AddPolygonToBody (result, [7, 19, 13]);\n\t\tJSM.AddPolygonToBody (result, [8, 14, 23]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 20]);\n\t\tJSM.AddPolygonToBody (result, [10, 13, 22]);\n\t\tJSM.AddPolygonToBody (result, [11, 15, 21]);\n\t\tJSM.AddPolygonToBody (result, [12, 16, 20]);\n\t\tJSM.AddPolygonToBody (result, [13, 19, 22]);\n\t\tJSM.AddPolygonToBody (result, [14, 17, 23]);\n\t\tJSM.AddPolygonToBody (result, [15, 18, 21]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 19, 3, 17]);\n\t\tJSM.AddPolygonToBody (result, [1, 16, 2, 18]);\n\t\tJSM.AddPolygonToBody (result, [4, 15, 7, 13]);\n\t\tJSM.AddPolygonToBody (result, [5, 12, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [8, 23, 11, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 20, 10, 22]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateIcosidodecahedron\n\t* Description: Generates an icosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateIcosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = 1.0 / 2.0;\n\t\tvar d = b / 2.0;\n\t\tvar e = (1.0 + b) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\n\t\tJSM.AddVertexToBody (result, +c, +d, +e);\n\t\tJSM.AddVertexToBody (result, +c, +d, -e);\n\t\tJSM.AddVertexToBody (result, +c, -d, +e);\n\t\tJSM.AddVertexToBody (result, -c, +d, +e);\n\t\tJSM.AddVertexToBody (result, +c, -d, -e);\n\t\tJSM.AddVertexToBody (result, -c, +d, -e);\n\t\tJSM.AddVertexToBody (result, -c, -d, +e);\n\t\tJSM.AddVertexToBody (result, -c, -d, -e);\n\n\t\tJSM.AddVertexToBody (result, +d, +e, +c);\n\t\tJSM.AddVertexToBody (result, +d, -e, +c);\n\t\tJSM.AddVertexToBody (result, -d, +e, +c);\n\t\tJSM.AddVertexToBody (result, +d, +e, -c);\n\t\tJSM.AddVertexToBody (result, -d, -e, +c);\n\t\tJSM.AddVertexToBody (result, +d, -e, -c);\n\t\tJSM.AddVertexToBody (result, -d, +e, -c);\n\t\tJSM.AddVertexToBody (result, -d, -e, -c);\n\n\t\tJSM.AddVertexToBody (result, +e, +c, +d);\n\t\tJSM.AddVertexToBody (result, -e, +c, +d);\n\t\tJSM.AddVertexToBody (result, +e, +c, -d);\n\t\tJSM.AddVertexToBody (result, +e, -c, +d);\n\t\tJSM.AddVertexToBody (result, -e, +c, -d);\n\t\tJSM.AddVertexToBody (result, -e, -c, +d);\n\t\tJSM.AddVertexToBody (result, +e, -c, -d);\n\t\tJSM.AddVertexToBody (result, -e, -c, -d);\n\n\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\tJSM.AddPolygonToBody (result, [0, 12, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 13]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 7]);\n\t\tJSM.AddPolygonToBody (result, [2, 14, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 20, 16]);\n\t\tJSM.AddPolygonToBody (result, [3, 18, 21]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 15]);\n\t\tJSM.AddPolygonToBody (result, [4, 22, 25]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 24]);\n\t\tJSM.AddPolygonToBody (result, [5, 26, 29]);\n\t\tJSM.AddPolygonToBody (result, [5, 27, 23]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 17, 24]);\n\t\tJSM.AddPolygonToBody (result, [8, 15, 25]);\n\t\tJSM.AddPolygonToBody (result, [9, 16, 23]);\n\t\tJSM.AddPolygonToBody (result, [10, 28, 19]);\n\t\tJSM.AddPolygonToBody (result, [11, 26, 20]);\n\t\tJSM.AddPolygonToBody (result, [12, 27, 18]);\n\t\tJSM.AddPolygonToBody (result, [13, 21, 29]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 25, 22, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 9, 23, 27, 12]);\n\t\tJSM.AddPolygonToBody (result, [1, 7, 24, 28, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 29, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [2, 16, 9, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [2, 17, 7, 11, 20]);\n\t\tJSM.AddPolygonToBody (result, [3, 15, 8, 12, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 21, 13, 10, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 24, 17, 14, 22]);\n\t\tJSM.AddPolygonToBody (result, [4, 25, 15, 19, 28]);\n\t\tJSM.AddPolygonToBody (result, [5, 23, 16, 20, 26]);\n\t\tJSM.AddPolygonToBody (result, [5, 29, 21, 18, 27]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedDodecahedron\n\t* Description: Generates a truncated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 2.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\t\tvar e = 2.0 + c;\n\t\tvar f = 2.0 * c;\n\t\tvar g = Math.pow (c, 2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +d, +e);\n\t\tJSM.AddVertexToBody (result, +a, +d, -e);\n\t\tJSM.AddVertexToBody (result, +a, -d, +e);\n\t\tJSM.AddVertexToBody (result, +a, -d, -e);\n\n\t\tJSM.AddVertexToBody (result, +e, +a, +d);\n\t\tJSM.AddVertexToBody (result, -e, +a, +d);\n\t\tJSM.AddVertexToBody (result, +e, +a, -d);\n\t\tJSM.AddVertexToBody (result, -e, +a, -d);\n\n\t\tJSM.AddVertexToBody (result, +d, +e, +a);\n\t\tJSM.AddVertexToBody (result, +d, -e, +a);\n\t\tJSM.AddVertexToBody (result, -d, +e, +a);\n\t\tJSM.AddVertexToBody (result, -d, -e, +a);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +g);\n\t\tJSM.AddVertexToBody (result, +c, +b, -g);\n\t\tJSM.AddVertexToBody (result, +c, -b, +g);\n\t\tJSM.AddVertexToBody (result, -c, +b, +g);\n\t\tJSM.AddVertexToBody (result, +c, -b, -g);\n\t\tJSM.AddVertexToBody (result, -c, +b, -g);\n\t\tJSM.AddVertexToBody (result, -c, -b, +g);\n\t\tJSM.AddVertexToBody (result, -c, -b, -g);\n\n\t\tJSM.AddVertexToBody (result, +g, +c, +b);\n\t\tJSM.AddVertexToBody (result, +g, +c, -b);\n\t\tJSM.AddVertexToBody (result, +g, -c, +b);\n\t\tJSM.AddVertexToBody (result, -g, +c, +b);\n\t\tJSM.AddVertexToBody (result, +g, -c, -b);\n\t\tJSM.AddVertexToBody (result, -g, +c, -b);\n\t\tJSM.AddVertexToBody (result, -g, -c, +b);\n\t\tJSM.AddVertexToBody (result, -g, -c, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +g, +c);\n\t\tJSM.AddVertexToBody (result, +b, +g, -c);\n\t\tJSM.AddVertexToBody (result, +b, -g, +c);\n\t\tJSM.AddVertexToBody (result, -b, +g, +c);\n\t\tJSM.AddVertexToBody (result, +b, -g, -c);\n\t\tJSM.AddVertexToBody (result, -b, +g, -c);\n\t\tJSM.AddVertexToBody (result, -b, -g, +c);\n\t\tJSM.AddVertexToBody (result, -b, -g, -c);\n\n\t\tJSM.AddPolygonToBody (result, [0, 12, 15]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 13]);\n\t\tJSM.AddPolygonToBody (result, [2, 18, 14]);\n\t\tJSM.AddPolygonToBody (result, [3, 16, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 22]);\n\t\tJSM.AddPolygonToBody (result, [5, 26, 23]);\n\t\tJSM.AddPolygonToBody (result, [6, 24, 21]);\n\t\tJSM.AddPolygonToBody (result, [7, 25, 27]);\n\t\tJSM.AddPolygonToBody (result, [8, 28, 29]);\n\t\tJSM.AddPolygonToBody (result, [9, 32, 30]);\n\t\tJSM.AddPolygonToBody (result, [10, 33, 31]);\n\t\tJSM.AddPolygonToBody (result, [11, 34, 35]);\n\t\tJSM.AddPolygonToBody (result, [36, 44, 52]);\n\t\tJSM.AddPolygonToBody (result, [37, 53, 45]);\n\t\tJSM.AddPolygonToBody (result, [38, 54, 46]);\n\t\tJSM.AddPolygonToBody (result, [39, 55, 47]);\n\t\tJSM.AddPolygonToBody (result, [40, 48, 56]);\n\t\tJSM.AddPolygonToBody (result, [41, 49, 57]);\n\t\tJSM.AddPolygonToBody (result, [42, 50, 58]);\n\t\tJSM.AddPolygonToBody (result, [43, 59, 51]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 14, 38, 46, 22, 20, 44, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 15, 39, 47, 23, 26, 50, 42, 18, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 19, 43, 51, 27, 25, 49, 41, 17]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 37, 45, 21, 24, 48, 40, 16, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 6, 21, 45, 53, 29, 28, 52, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [4, 22, 46, 54, 30, 32, 56, 48, 24, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 27, 51, 59, 35, 34, 58, 50, 26]);\n\t\tJSM.AddPolygonToBody (result, [5, 23, 47, 55, 31, 33, 57, 49, 25, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 31, 55, 39, 15, 12, 36, 52, 28]);\n\t\tJSM.AddPolygonToBody (result, [8, 29, 53, 37, 13, 17, 41, 57, 33, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 11, 35, 59, 43, 19, 16, 40, 56, 32]);\n\t\tJSM.AddPolygonToBody (result, [9, 30, 54, 38, 14, 18, 42, 58, 34, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedIcosahedron\n\t* Description: Generates a truncated icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedIcosahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 1.0;\n\t\tvar c = 2.0;\n\t\tvar d = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar e = 3.0 * d;\n\t\tvar f = 1.0 + 2.0 * d;\n\t\tvar g = 2.0 + d;\n\t\tvar h = 2.0 * d;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +e);\n\t\tJSM.AddVertexToBody (result, +a, +b, -e);\n\t\tJSM.AddVertexToBody (result, +a, -b, +e);\n\t\tJSM.AddVertexToBody (result, +a, -b, -e);\n\n\t\tJSM.AddVertexToBody (result, +b, +e, +a);\n\t\tJSM.AddVertexToBody (result, +b, -e, +a);\n\t\tJSM.AddVertexToBody (result, -b, +e, +a);\n\t\tJSM.AddVertexToBody (result, -b, -e, +a);\n\n\t\tJSM.AddVertexToBody (result, +e, +a, +b);\n\t\tJSM.AddVertexToBody (result, -e, +a, +b);\n\t\tJSM.AddVertexToBody (result, +e, +a, -b);\n\t\tJSM.AddVertexToBody (result, -e, +a, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +b, +g, +h);\n\t\tJSM.AddVertexToBody (result, +b, +g, -h);\n\t\tJSM.AddVertexToBody (result, +b, -g, +h);\n\t\tJSM.AddVertexToBody (result, -b, +g, +h);\n\t\tJSM.AddVertexToBody (result, +b, -g, -h);\n\t\tJSM.AddVertexToBody (result, -b, +g, -h);\n\t\tJSM.AddVertexToBody (result, -b, -g, +h);\n\t\tJSM.AddVertexToBody (result, -b, -g, -h);\n\n\t\tJSM.AddVertexToBody (result, +g, +h, +b);\n\t\tJSM.AddVertexToBody (result, +g, -h, +b);\n\t\tJSM.AddVertexToBody (result, -g, +h, +b);\n\t\tJSM.AddVertexToBody (result, +g, +h, -b);\n\t\tJSM.AddVertexToBody (result, -g, -h, +b);\n\t\tJSM.AddVertexToBody (result, +g, -h, -b);\n\t\tJSM.AddVertexToBody (result, -g, +h, -b);\n\t\tJSM.AddVertexToBody (result, -g, -h, -b);\n\n\t\tJSM.AddVertexToBody (result, +h, +b, +g);\n\t\tJSM.AddVertexToBody (result, -h, +b, +g);\n\t\tJSM.AddVertexToBody (result, +h, +b, -g);\n\t\tJSM.AddVertexToBody (result, +h, -b, +g);\n\t\tJSM.AddVertexToBody (result, -h, +b, -g);\n\t\tJSM.AddVertexToBody (result, -h, -b, +g);\n\t\tJSM.AddVertexToBody (result, +h, -b, -g);\n\t\tJSM.AddVertexToBody (result, -h, -b, -g);\n\n\t\tJSM.AddPolygonToBody (result, [0, 28, 36, 39, 29]);\n\t\tJSM.AddPolygonToBody (result, [1, 32, 41, 37, 30]);\n\t\tJSM.AddPolygonToBody (result, [2, 33, 42, 38, 31]);\n\t\tJSM.AddPolygonToBody (result, [3, 34, 40, 43, 35]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 44, 47, 13]);\n\t\tJSM.AddPolygonToBody (result, [5, 16, 49, 45, 14]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 50, 46, 15]);\n\t\tJSM.AddPolygonToBody (result, [7, 18, 48, 51, 19]);\n\t\tJSM.AddPolygonToBody (result, [8, 20, 52, 55, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 24, 57, 53, 22]);\n\t\tJSM.AddPolygonToBody (result, [10, 25, 58, 54, 23]);\n\t\tJSM.AddPolygonToBody (result, [11, 26, 56, 59, 27]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 31, 55, 52, 28]);\n\t\tJSM.AddPolygonToBody (result, [0, 29, 53, 57, 33, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 35, 59, 56, 32]);\n\t\tJSM.AddPolygonToBody (result, [1, 30, 54, 58, 34, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 6, 15, 39, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 37, 41, 17, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 19, 43, 40, 16]);\n\t\tJSM.AddPolygonToBody (result, [5, 14, 38, 42, 18, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 23, 47, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [8, 21, 45, 49, 25, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 11, 27, 51, 48, 24]);\n\t\tJSM.AddPolygonToBody (result, [9, 22, 46, 50, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 28, 52, 20, 44]);\n\t\tJSM.AddPolygonToBody (result, [13, 47, 23, 54, 30, 37]);\n\t\tJSM.AddPolygonToBody (result, [14, 45, 21, 55, 31, 38]);\n\t\tJSM.AddPolygonToBody (result, [15, 46, 22, 53, 29, 39]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 34, 58, 25, 49]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 32, 56, 26, 50]);\n\t\tJSM.AddPolygonToBody (result, [18, 42, 33, 57, 24, 48]);\n\t\tJSM.AddPolygonToBody (result, [19, 51, 27, 59, 35, 43]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRhombicosidodecahedron\n\t* Description: Generates a rhombicosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 1.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = Math.pow (c, 2.0);\n\t\tvar e = Math.pow (c, 3.0);\n\t\tvar f = 2.0 * c;\n\t\tvar g = 2.0 + c;\n\n\t\tJSM.AddVertexToBody (result, +b, +b, +e);\n\t\tJSM.AddVertexToBody (result, +b, +b, -e);\n\t\tJSM.AddVertexToBody (result, +b, -b, +e);\n\t\tJSM.AddVertexToBody (result, -b, +b, +e);\n\t\tJSM.AddVertexToBody (result, +b, -b, -e);\n\t\tJSM.AddVertexToBody (result, -b, +b, -e);\n\t\tJSM.AddVertexToBody (result, -b, -b, +e);\n\t\tJSM.AddVertexToBody (result, -b, -b, -e);\n\n\t\tJSM.AddVertexToBody (result, +e, +b, +b);\n\t\tJSM.AddVertexToBody (result, +e, +b, -b);\n\t\tJSM.AddVertexToBody (result, +e, -b, +b);\n\t\tJSM.AddVertexToBody (result, -e, +b, +b);\n\t\tJSM.AddVertexToBody (result, +e, -b, -b);\n\t\tJSM.AddVertexToBody (result, -e, +b, -b);\n\t\tJSM.AddVertexToBody (result, -e, -b, +b);\n\t\tJSM.AddVertexToBody (result, -e, -b, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +e, +b);\n\t\tJSM.AddVertexToBody (result, +b, +e, -b);\n\t\tJSM.AddVertexToBody (result, +b, -e, +b);\n\t\tJSM.AddVertexToBody (result, -b, +e, +b);\n\t\tJSM.AddVertexToBody (result, +b, -e, -b);\n\t\tJSM.AddVertexToBody (result, -b, +e, -b);\n\t\tJSM.AddVertexToBody (result, -b, -e, +b);\n\t\tJSM.AddVertexToBody (result, -b, -e, -b);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +g, +a, +d);\n\t\tJSM.AddVertexToBody (result, +g, +a, -d);\n\t\tJSM.AddVertexToBody (result, -g, +a, +d);\n\t\tJSM.AddVertexToBody (result, -g, +a, -d);\n\n\t\tJSM.AddVertexToBody (result, +d, +g, +a);\n\t\tJSM.AddVertexToBody (result, -d, +g, +a);\n\t\tJSM.AddVertexToBody (result, +d, -g, +a);\n\t\tJSM.AddVertexToBody (result, -d, -g, +a);\n\n\t\tJSM.AddVertexToBody (result, +a, +d, +g);\n\t\tJSM.AddVertexToBody (result, +a, -d, +g);\n\t\tJSM.AddVertexToBody (result, +a, +d, -g);\n\t\tJSM.AddVertexToBody (result, +a, -d, -g);\n\n\t\tJSM.AddPolygonToBody (result, [0, 56, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 58]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 57]);\n\t\tJSM.AddPolygonToBody (result, [4, 59, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 48, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 49]);\n\t\tJSM.AddPolygonToBody (result, [11, 14, 50]);\n\t\tJSM.AddPolygonToBody (result, [13, 51, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 52, 17]);\n\t\tJSM.AddPolygonToBody (result, [18, 20, 54]);\n\t\tJSM.AddPolygonToBody (result, [19, 21, 53]);\n\t\tJSM.AddPolygonToBody (result, [22, 55, 23]);\n\t\tJSM.AddPolygonToBody (result, [24, 32, 40]);\n\t\tJSM.AddPolygonToBody (result, [25, 41, 33]);\n\t\tJSM.AddPolygonToBody (result, [26, 42, 34]);\n\t\tJSM.AddPolygonToBody (result, [27, 43, 35]);\n\t\tJSM.AddPolygonToBody (result, [28, 36, 44]);\n\t\tJSM.AddPolygonToBody (result, [29, 37, 45]);\n\t\tJSM.AddPolygonToBody (result, [30, 38, 46]);\n\t\tJSM.AddPolygonToBody (result, [31, 47, 39]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [0, 24, 40, 56]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 58, 41, 25]);\n\t\tJSM.AddPolygonToBody (result, [2, 57, 42, 26]);\n\t\tJSM.AddPolygonToBody (result, [3, 56, 43, 27]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 44, 59]);\n\t\tJSM.AddPolygonToBody (result, [5, 29, 45, 58]);\n\t\tJSM.AddPolygonToBody (result, [6, 30, 46, 57]);\n\t\tJSM.AddPolygonToBody (result, [7, 59, 47, 31]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 12, 9]);\n\t\tJSM.AddPolygonToBody (result, [8, 32, 24, 48]);\n\t\tJSM.AddPolygonToBody (result, [9, 49, 25, 33]);\n\t\tJSM.AddPolygonToBody (result, [10, 48, 26, 34]);\n\t\tJSM.AddPolygonToBody (result, [11, 13, 15, 14]);\n\t\tJSM.AddPolygonToBody (result, [11, 50, 27, 35]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 28, 49]);\n\t\tJSM.AddPolygonToBody (result, [13, 37, 29, 51]);\n\t\tJSM.AddPolygonToBody (result, [14, 38, 30, 50]);\n\t\tJSM.AddPolygonToBody (result, [15, 51, 31, 39]);\n\t\tJSM.AddPolygonToBody (result, [16, 17, 21, 19]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 32, 52]);\n\t\tJSM.AddPolygonToBody (result, [17, 52, 33, 41]);\n\t\tJSM.AddPolygonToBody (result, [18, 22, 23, 20]);\n\t\tJSM.AddPolygonToBody (result, [18, 54, 34, 42]);\n\t\tJSM.AddPolygonToBody (result, [19, 53, 35, 43]);\n\t\tJSM.AddPolygonToBody (result, [20, 44, 36, 54]);\n\t\tJSM.AddPolygonToBody (result, [21, 45, 37, 53]);\n\t\tJSM.AddPolygonToBody (result, [22, 46, 38, 55]);\n\t\tJSM.AddPolygonToBody (result, [23, 55, 39, 47]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 26, 48, 24]);\n\t\tJSM.AddPolygonToBody (result, [1, 25, 49, 28, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 27, 50, 30, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 31, 51, 29]);\n\t\tJSM.AddPolygonToBody (result, [8, 9, 33, 52, 32]);\n\t\tJSM.AddPolygonToBody (result, [10, 34, 54, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 35, 53, 37, 13]);\n\t\tJSM.AddPolygonToBody (result, [14, 15, 39, 55, 38]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 43, 56, 40]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 58, 45, 21]);\n\t\tJSM.AddPolygonToBody (result, [18, 42, 57, 46, 22]);\n\t\tJSM.AddPolygonToBody (result, [20, 23, 47, 59, 44]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedIcosidodecahedron\n\t* Description: Generates a truncated icosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedIcosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 2.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = 1.0 / b;\n\t\tvar d = 3.0 + b;\n\t\tvar e = 2.0 / b;\n\t\tvar f = 1 + 2.0 * b;\n\t\tvar g = Math.pow (b, 2.0);\n\t\tvar h = -1.0 + 3.0 * b;\n\t\tvar i = -1.0 + 2.0 * b;\n\t\tvar j = 2.0 + b;\n\t\tvar k = 3.0;\n\t\tvar l = 2.0 * b;\n\n\t\tJSM.AddVertexToBody (result, +c, +c, +d);\n\t\tJSM.AddVertexToBody (result, +c, +c, -d);\n\t\tJSM.AddVertexToBody (result, +c, -c, +d);\n\t\tJSM.AddVertexToBody (result, -c, +c, +d);\n\t\tJSM.AddVertexToBody (result, +c, -c, -d);\n\t\tJSM.AddVertexToBody (result, -c, +c, -d);\n\t\tJSM.AddVertexToBody (result, -c, -c, +d);\n\t\tJSM.AddVertexToBody (result, -c, -c, -d);\n\n\t\tJSM.AddVertexToBody (result, +c, +d, +c);\n\t\tJSM.AddVertexToBody (result, +c, -d, +c);\n\t\tJSM.AddVertexToBody (result, -c, +d, +c);\n\t\tJSM.AddVertexToBody (result, +c, +d, -c);\n\t\tJSM.AddVertexToBody (result, -c, -d, +c);\n\t\tJSM.AddVertexToBody (result, +c, -d, -c);\n\t\tJSM.AddVertexToBody (result, -c, +d, -c);\n\t\tJSM.AddVertexToBody (result, -c, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +c);\n\t\tJSM.AddVertexToBody (result, -d, +c, +c);\n\t\tJSM.AddVertexToBody (result, +d, +c, -c);\n\t\tJSM.AddVertexToBody (result, +d, -c, +c);\n\t\tJSM.AddVertexToBody (result, -d, +c, -c);\n\t\tJSM.AddVertexToBody (result, -d, -c, +c);\n\t\tJSM.AddVertexToBody (result, +d, -c, -c);\n\t\tJSM.AddVertexToBody (result, -d, -c, -c);\n\n\t\tJSM.AddVertexToBody (result, +e, +b, +f);\n\t\tJSM.AddVertexToBody (result, +e, +b, -f);\n\t\tJSM.AddVertexToBody (result, +e, -b, +f);\n\t\tJSM.AddVertexToBody (result, -e, +b, +f);\n\t\tJSM.AddVertexToBody (result, +e, -b, -f);\n\t\tJSM.AddVertexToBody (result, -e, +b, -f);\n\t\tJSM.AddVertexToBody (result, -e, -b, +f);\n\t\tJSM.AddVertexToBody (result, -e, -b, -f);\n\n\t\tJSM.AddVertexToBody (result, +b, +f, +e);\n\t\tJSM.AddVertexToBody (result, +b, -f, +e);\n\t\tJSM.AddVertexToBody (result, -b, +f, +e);\n\t\tJSM.AddVertexToBody (result, +b, +f, -e);\n\t\tJSM.AddVertexToBody (result, -b, -f, +e);\n\t\tJSM.AddVertexToBody (result, +b, -f, -e);\n\t\tJSM.AddVertexToBody (result, -b, +f, -e);\n\t\tJSM.AddVertexToBody (result, -b, -f, -e);\n\n\t\tJSM.AddVertexToBody (result, +f, +e, +b);\n\t\tJSM.AddVertexToBody (result, -f, +e, +b);\n\t\tJSM.AddVertexToBody (result, +f, +e, -b);\n\t\tJSM.AddVertexToBody (result, +f, -e, +b);\n\t\tJSM.AddVertexToBody (result, -f, +e, -b);\n\t\tJSM.AddVertexToBody (result, -f, -e, +b);\n\t\tJSM.AddVertexToBody (result, +f, -e, -b);\n\t\tJSM.AddVertexToBody (result, -f, -e, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +g, +h);\n\t\tJSM.AddVertexToBody (result, +c, +g, -h);\n\t\tJSM.AddVertexToBody (result, +c, -g, +h);\n\t\tJSM.AddVertexToBody (result, -c, +g, +h);\n\t\tJSM.AddVertexToBody (result, +c, -g, -h);\n\t\tJSM.AddVertexToBody (result, -c, +g, -h);\n\t\tJSM.AddVertexToBody (result, -c, -g, +h);\n\t\tJSM.AddVertexToBody (result, -c, -g, -h);\n\n\t\tJSM.AddVertexToBody (result, +g, +h, +c);\n\t\tJSM.AddVertexToBody (result, +g, -h, +c);\n\t\tJSM.AddVertexToBody (result, -g, +h, +c);\n\t\tJSM.AddVertexToBody (result, +g, +h, -c);\n\t\tJSM.AddVertexToBody (result, -g, -h, +c);\n\t\tJSM.AddVertexToBody (result, +g, -h, -c);\n\t\tJSM.AddVertexToBody (result, -g, +h, -c);\n\t\tJSM.AddVertexToBody (result, -g, -h, -c);\n\n\t\tJSM.AddVertexToBody (result, +h, +c, +g);\n\t\tJSM.AddVertexToBody (result, -h, +c, +g);\n\t\tJSM.AddVertexToBody (result, +h, +c, -g);\n\t\tJSM.AddVertexToBody (result, +h, -c, +g);\n\t\tJSM.AddVertexToBody (result, -h, +c, -g);\n\t\tJSM.AddVertexToBody (result, -h, -c, +g);\n\t\tJSM.AddVertexToBody (result, +h, -c, -g);\n\t\tJSM.AddVertexToBody (result, -h, -c, -g);\n\n\t\tJSM.AddVertexToBody (result, +i, +a, +j);\n\t\tJSM.AddVertexToBody (result, +i, +a, -j);\n\t\tJSM.AddVertexToBody (result, +i, -a, +j);\n\t\tJSM.AddVertexToBody (result, -i, +a, +j);\n\t\tJSM.AddVertexToBody (result, +i, -a, -j);\n\t\tJSM.AddVertexToBody (result, -i, +a, -j);\n\t\tJSM.AddVertexToBody (result, -i, -a, +j);\n\t\tJSM.AddVertexToBody (result, -i, -a, -j);\n\n\t\tJSM.AddVertexToBody (result, +a, +j, +i);\n\t\tJSM.AddVertexToBody (result, +a, -j, +i);\n\t\tJSM.AddVertexToBody (result, -a, +j, +i);\n\t\tJSM.AddVertexToBody (result, +a, +j, -i);\n\t\tJSM.AddVertexToBody (result, -a, -j, +i);\n\t\tJSM.AddVertexToBody (result, +a, -j, -i);\n\t\tJSM.AddVertexToBody (result, -a, +j, -i);\n\t\tJSM.AddVertexToBody (result, -a, -j, -i);\n\n\t\tJSM.AddVertexToBody (result, +j, +i, +a);\n\t\tJSM.AddVertexToBody (result, -j, +i, +a);\n\t\tJSM.AddVertexToBody (result, +j, +i, -a);\n\t\tJSM.AddVertexToBody (result, +j, -i, +a);\n\t\tJSM.AddVertexToBody (result, -j, +i, -a);\n\t\tJSM.AddVertexToBody (result, -j, -i, +a);\n\t\tJSM.AddVertexToBody (result, +j, -i, -a);\n\t\tJSM.AddVertexToBody (result, -j, -i, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +k, +l);\n\t\tJSM.AddVertexToBody (result, +b, +k, -l);\n\t\tJSM.AddVertexToBody (result, +b, -k, +l);\n\t\tJSM.AddVertexToBody (result, -b, +k, +l);\n\t\tJSM.AddVertexToBody (result, +b, -k, -l);\n\t\tJSM.AddVertexToBody (result, -b, +k, -l);\n\t\tJSM.AddVertexToBody (result, -b, -k, +l);\n\t\tJSM.AddVertexToBody (result, -b, -k, -l);\n\n\t\tJSM.AddVertexToBody (result, +k, +l, +b);\n\t\tJSM.AddVertexToBody (result, +k, -l, +b);\n\t\tJSM.AddVertexToBody (result, -k, +l, +b);\n\t\tJSM.AddVertexToBody (result, +k, +l, -b);\n\t\tJSM.AddVertexToBody (result, -k, -l, +b);\n\t\tJSM.AddVertexToBody (result, +k, -l, -b);\n\t\tJSM.AddVertexToBody (result, -k, +l, -b);\n\t\tJSM.AddVertexToBody (result, -k, -l, -b);\n\n\t\tJSM.AddVertexToBody (result, +l, +b, +k);\n\t\tJSM.AddVertexToBody (result, -l, +b, +k);\n\t\tJSM.AddVertexToBody (result, +l, +b, -k);\n\t\tJSM.AddVertexToBody (result, +l, -b, +k);\n\t\tJSM.AddVertexToBody (result, -l, +b, -k);\n\t\tJSM.AddVertexToBody (result, -l, -b, +k);\n\t\tJSM.AddVertexToBody (result, +l, -b, -k);\n\t\tJSM.AddVertexToBody (result, -l, -b, -k);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [8, 11, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 15, 13]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 22, 18]);\n\t\tJSM.AddPolygonToBody (result, [17, 20, 23, 21]);\n\t\tJSM.AddPolygonToBody (result, [24, 72, 96, 48]);\n\t\tJSM.AddPolygonToBody (result, [25, 49, 97, 73]);\n\t\tJSM.AddPolygonToBody (result, [26, 50, 98, 74]);\n\t\tJSM.AddPolygonToBody (result, [27, 51, 99, 75]);\n\t\tJSM.AddPolygonToBody (result, [28, 76, 100, 52]);\n\t\tJSM.AddPolygonToBody (result, [29, 77, 101, 53]);\n\t\tJSM.AddPolygonToBody (result, [30, 78, 102, 54]);\n\t\tJSM.AddPolygonToBody (result, [31, 55, 103, 79]);\n\t\tJSM.AddPolygonToBody (result, [32, 80, 104, 56]);\n\t\tJSM.AddPolygonToBody (result, [33, 57, 105, 81]);\n\t\tJSM.AddPolygonToBody (result, [34, 58, 106, 82]);\n\t\tJSM.AddPolygonToBody (result, [35, 59, 107, 83]);\n\t\tJSM.AddPolygonToBody (result, [36, 84, 108, 60]);\n\t\tJSM.AddPolygonToBody (result, [37, 85, 109, 61]);\n\t\tJSM.AddPolygonToBody (result, [38, 86, 110, 62]);\n\t\tJSM.AddPolygonToBody (result, [39, 63, 111, 87]);\n\t\tJSM.AddPolygonToBody (result, [40, 88, 112, 64]);\n\t\tJSM.AddPolygonToBody (result, [41, 65, 113, 89]);\n\t\tJSM.AddPolygonToBody (result, [42, 66, 114, 90]);\n\t\tJSM.AddPolygonToBody (result, [43, 67, 115, 91]);\n\t\tJSM.AddPolygonToBody (result, [44, 92, 116, 68]);\n\t\tJSM.AddPolygonToBody (result, [45, 93, 117, 69]);\n\t\tJSM.AddPolygonToBody (result, [46, 94, 118, 70]);\n\t\tJSM.AddPolygonToBody (result, [47, 71, 119, 95]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 24, 48, 51, 27, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 29, 53, 49, 25]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 30, 54, 50, 26]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 52, 55, 31, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 32, 56, 59, 35, 11]);\n\t\tJSM.AddPolygonToBody (result, [9, 13, 37, 61, 57, 33]);\n\t\tJSM.AddPolygonToBody (result, [10, 14, 38, 62, 58, 34]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 60, 63, 39, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 64, 67, 43, 19]);\n\t\tJSM.AddPolygonToBody (result, [17, 21, 45, 69, 65, 41]);\n\t\tJSM.AddPolygonToBody (result, [18, 22, 46, 70, 66, 42]);\n\t\tJSM.AddPolygonToBody (result, [20, 44, 68, 71, 47, 23]);\n\t\tJSM.AddPolygonToBody (result, [72, 112, 88, 104, 80, 96]);\n\t\tJSM.AddPolygonToBody (result, [73, 97, 83, 107, 90, 114]);\n\t\tJSM.AddPolygonToBody (result, [74, 98, 81, 105, 91, 115]);\n\t\tJSM.AddPolygonToBody (result, [75, 99, 82, 106, 89, 113]);\n\t\tJSM.AddPolygonToBody (result, [76, 118, 94, 109, 85, 100]);\n\t\tJSM.AddPolygonToBody (result, [78, 117, 93, 108, 84, 102]);\n\t\tJSM.AddPolygonToBody (result, [79, 103, 87, 111, 95, 119]);\n\t\tJSM.AddPolygonToBody (result, [86, 101, 77, 116, 92, 110]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 26, 74, 115, 67, 64, 112, 72, 24]);\n\t\tJSM.AddPolygonToBody (result, [1, 25, 73, 114, 66, 70, 118, 76, 28, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 27, 75, 113, 65, 69, 117, 78, 30, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 31, 79, 119, 71, 68, 116, 77, 29]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 34, 82, 99, 51, 48, 96, 80, 32]);\n\t\tJSM.AddPolygonToBody (result, [9, 33, 81, 98, 50, 54, 102, 84, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 35, 83, 97, 49, 53, 101, 86, 38, 14]);\n\t\tJSM.AddPolygonToBody (result, [13, 15, 39, 87, 103, 55, 52, 100, 85, 37]);\n\t\tJSM.AddPolygonToBody (result, [16, 18, 42, 90, 107, 59, 56, 104, 88, 40]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 89, 106, 58, 62, 110, 92, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [19, 43, 91, 105, 57, 61, 109, 94, 46, 22]);\n\t\tJSM.AddPolygonToBody (result, [21, 23, 47, 95, 111, 63, 60, 108, 93, 45]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSnubDodecahedron\n\t* Description: Generates a snub dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSnubDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 2.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = Math.pow (b / 2.0 + (1.0 / 2.0) * Math.sqrt (b - (5.0 / 27.0)), 1.0 / 3.0) + Math.pow (b / 2.0 - (1.0 / 2.0) * Math.sqrt (b - (5.0 / 27.0)), 1.0 / 3.0);\n\t\tvar d = c - (1.0 / c);\n\t\tvar e = c * b + Math.pow (b, 2.0) + b / c;\n\t\tvar f = 2.0 * d;\n\t\tvar g = 2.0 * e;\n\t\tvar h = d + (e / b) + b;\n\t\tvar i = -(d * b) + e + (1.0 / b);\n\t\tvar j = (d / b) + (e * b) - 1.0;\n\t\tvar k = -(d / b) + (e * b) + 1.0;\n\t\tvar l = -d + (e / b) - b;\n\t\tvar m = (d * b) + e - (1.0 / b);\n\t\tvar n = -(d / b) + (e * b) - 1.0;\n\t\tvar o = d - (e / b) - b;\n\t\tvar p = (d * b) + e + (1.0 / b);\n\t\tvar q = d + (e / b) - b;\n\t\tvar r = (d * b) - e + (1.0 / b);\n\t\tvar s = (d / b) + (e * b) + 1.0;\n\n\t\tJSM.AddVertexToBody (result, +f, +a, -g);\n\t\tJSM.AddVertexToBody (result, +f, -a, +g);\n\t\tJSM.AddVertexToBody (result, -f, +a, +g);\n\t\tJSM.AddVertexToBody (result, -f, -a, -g);\n\n\t\tJSM.AddVertexToBody (result, +a, -g, +f);\n\t\tJSM.AddVertexToBody (result, -a, +g, +f);\n\t\tJSM.AddVertexToBody (result, +a, +g, -f);\n\t\tJSM.AddVertexToBody (result, -a, -g, -f);\n\n\t\tJSM.AddVertexToBody (result, -g, +f, +a);\n\t\tJSM.AddVertexToBody (result, +g, +f, -a);\n\t\tJSM.AddVertexToBody (result, +g, -f, +a);\n\t\tJSM.AddVertexToBody (result, -g, -f, -a);\n\n\t\tJSM.AddVertexToBody (result, +h, +i, -j);\n\t\tJSM.AddVertexToBody (result, +h, -i, +j);\n\t\tJSM.AddVertexToBody (result, -h, +i, +j);\n\t\tJSM.AddVertexToBody (result, -h, -i, -j);\n\n\t\tJSM.AddVertexToBody (result, +i, -j, +h);\n\t\tJSM.AddVertexToBody (result, -i, +j, +h);\n\t\tJSM.AddVertexToBody (result, +i, +j, -h);\n\t\tJSM.AddVertexToBody (result, -i, -j, -h);\n\n\t\tJSM.AddVertexToBody (result, -j, +h, +i);\n\t\tJSM.AddVertexToBody (result, +j, +h, -i);\n\t\tJSM.AddVertexToBody (result, +j, -h, +i);\n\t\tJSM.AddVertexToBody (result, -j, -h, -i);\n\n\t\tJSM.AddVertexToBody (result, +k, +l, -m);\n\t\tJSM.AddVertexToBody (result, +k, -l, +m);\n\t\tJSM.AddVertexToBody (result, -k, +l, +m);\n\t\tJSM.AddVertexToBody (result, -k, -l, -m);\n\n\t\tJSM.AddVertexToBody (result, +l, -m, +k);\n\t\tJSM.AddVertexToBody (result, -l, +m, +k);\n\t\tJSM.AddVertexToBody (result, +l, +m, -k);\n\t\tJSM.AddVertexToBody (result, -l, -m, -k);\n\n\t\tJSM.AddVertexToBody (result, -m, +k, +l);\n\t\tJSM.AddVertexToBody (result, +m, +k, -l);\n\t\tJSM.AddVertexToBody (result, +m, -k, +l);\n\t\tJSM.AddVertexToBody (result, -m, -k, -l);\n\n\t\tJSM.AddVertexToBody (result, +n, +o, -p);\n\t\tJSM.AddVertexToBody (result, +n, -o, +p);\n\t\tJSM.AddVertexToBody (result, -n, +o, +p);\n\t\tJSM.AddVertexToBody (result, -n, -o, -p);\n\n\t\tJSM.AddVertexToBody (result, +o, -p, +n);\n\t\tJSM.AddVertexToBody (result, -o, +p, +n);\n\t\tJSM.AddVertexToBody (result, +o, +p, -n);\n\t\tJSM.AddVertexToBody (result, -o, -p, -n);\n\n\t\tJSM.AddVertexToBody (result, -p, +n, +o);\n\t\tJSM.AddVertexToBody (result, +p, +n, -o);\n\t\tJSM.AddVertexToBody (result, +p, -n, +o);\n\t\tJSM.AddVertexToBody (result, -p, -n, -o);\n\n\t\tJSM.AddVertexToBody (result, +q, +r, -s);\n\t\tJSM.AddVertexToBody (result, +q, -r, +s);\n\t\tJSM.AddVertexToBody (result, -q, +r, +s);\n\t\tJSM.AddVertexToBody (result, -q, -r, -s);\n\n\t\tJSM.AddVertexToBody (result, +r, -s, +q);\n\t\tJSM.AddVertexToBody (result, -r, +s, +q);\n\t\tJSM.AddVertexToBody (result, +r, +s, -q);\n\t\tJSM.AddVertexToBody (result, -r, -s, -q);\n\n\t\tJSM.AddVertexToBody (result, -s, +q, +r);\n\t\tJSM.AddVertexToBody (result, +s, +q, -r);\n\t\tJSM.AddVertexToBody (result, +s, -q, +r);\n\t\tJSM.AddVertexToBody (result, -s, -q, -r);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 51]);\n\t\tJSM.AddPolygonToBody (result, [0, 30, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 48, 3]);\n\t\tJSM.AddPolygonToBody (result, [0, 51, 30]);\n\t\tJSM.AddPolygonToBody (result, [1, 2, 50]);\n\t\tJSM.AddPolygonToBody (result, [1, 28, 13]);\n\t\tJSM.AddPolygonToBody (result, [1, 49, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 50, 28]);\n\t\tJSM.AddPolygonToBody (result, [2, 29, 14]);\n\t\tJSM.AddPolygonToBody (result, [2, 49, 29]);\n\t\tJSM.AddPolygonToBody (result, [3, 31, 15]);\n\t\tJSM.AddPolygonToBody (result, [3, 48, 31]);\n\t\tJSM.AddPolygonToBody (result, [4, 7, 55]);\n\t\tJSM.AddPolygonToBody (result, [4, 34, 16]);\n\t\tJSM.AddPolygonToBody (result, [4, 52, 7]);\n\t\tJSM.AddPolygonToBody (result, [4, 55, 34]);\n\t\tJSM.AddPolygonToBody (result, [5, 6, 54]);\n\t\tJSM.AddPolygonToBody (result, [5, 32, 17]);\n\t\tJSM.AddPolygonToBody (result, [5, 53, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 54, 32]);\n\t\tJSM.AddPolygonToBody (result, [6, 33, 18]);\n\t\tJSM.AddPolygonToBody (result, [6, 53, 33]);\n\t\tJSM.AddPolygonToBody (result, [7, 35, 19]);\n\t\tJSM.AddPolygonToBody (result, [7, 52, 35]);\n\t\tJSM.AddPolygonToBody (result, [8, 11, 59]);\n\t\tJSM.AddPolygonToBody (result, [8, 26, 20]);\n\t\tJSM.AddPolygonToBody (result, [8, 56, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 59, 26]);\n\t\tJSM.AddPolygonToBody (result, [9, 10, 58]);\n\t\tJSM.AddPolygonToBody (result, [9, 24, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 57, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 58, 24]);\n\t\tJSM.AddPolygonToBody (result, [10, 25, 22]);\n\t\tJSM.AddPolygonToBody (result, [10, 57, 25]);\n\t\tJSM.AddPolygonToBody (result, [11, 27, 23]);\n\t\tJSM.AddPolygonToBody (result, [11, 56, 27]);\n\t\tJSM.AddPolygonToBody (result, [12, 18, 21]);\n\t\tJSM.AddPolygonToBody (result, [12, 21, 24]);\n\t\tJSM.AddPolygonToBody (result, [12, 30, 18]);\n\t\tJSM.AddPolygonToBody (result, [13, 16, 22]);\n\t\tJSM.AddPolygonToBody (result, [13, 22, 25]);\n\t\tJSM.AddPolygonToBody (result, [13, 28, 16]);\n\t\tJSM.AddPolygonToBody (result, [14, 17, 20]);\n\t\tJSM.AddPolygonToBody (result, [14, 20, 26]);\n\t\tJSM.AddPolygonToBody (result, [14, 29, 17]);\n\t\tJSM.AddPolygonToBody (result, [15, 19, 23]);\n\t\tJSM.AddPolygonToBody (result, [15, 23, 27]);\n\t\tJSM.AddPolygonToBody (result, [15, 31, 19]);\n\t\tJSM.AddPolygonToBody (result, [16, 34, 22]);\n\t\tJSM.AddPolygonToBody (result, [17, 32, 20]);\n\t\tJSM.AddPolygonToBody (result, [18, 33, 21]);\n\t\tJSM.AddPolygonToBody (result, [19, 35, 23]);\n\t\tJSM.AddPolygonToBody (result, [24, 58, 36]);\n\t\tJSM.AddPolygonToBody (result, [25, 57, 37]);\n\t\tJSM.AddPolygonToBody (result, [26, 59, 38]);\n\t\tJSM.AddPolygonToBody (result, [27, 56, 39]);\n\t\tJSM.AddPolygonToBody (result, [28, 50, 40]);\n\t\tJSM.AddPolygonToBody (result, [29, 49, 41]);\n\t\tJSM.AddPolygonToBody (result, [30, 51, 42]);\n\t\tJSM.AddPolygonToBody (result, [31, 48, 43]);\n\t\tJSM.AddPolygonToBody (result, [32, 54, 44]);\n\t\tJSM.AddPolygonToBody (result, [33, 53, 45]);\n\t\tJSM.AddPolygonToBody (result, [34, 55, 46]);\n\t\tJSM.AddPolygonToBody (result, [35, 52, 47]);\n\t\tJSM.AddPolygonToBody (result, [36, 43, 48]);\n\t\tJSM.AddPolygonToBody (result, [36, 46, 43]);\n\t\tJSM.AddPolygonToBody (result, [36, 58, 46]);\n\t\tJSM.AddPolygonToBody (result, [37, 41, 49]);\n\t\tJSM.AddPolygonToBody (result, [37, 45, 41]);\n\t\tJSM.AddPolygonToBody (result, [37, 57, 45]);\n\t\tJSM.AddPolygonToBody (result, [38, 40, 50]);\n\t\tJSM.AddPolygonToBody (result, [38, 47, 40]);\n\t\tJSM.AddPolygonToBody (result, [38, 59, 47]);\n\t\tJSM.AddPolygonToBody (result, [39, 42, 51]);\n\t\tJSM.AddPolygonToBody (result, [39, 44, 42]);\n\t\tJSM.AddPolygonToBody (result, [39, 56, 44]);\n\t\tJSM.AddPolygonToBody (result, [40, 47, 52]);\n\t\tJSM.AddPolygonToBody (result, [41, 45, 53]);\n\t\tJSM.AddPolygonToBody (result, [42, 44, 54]);\n\t\tJSM.AddPolygonToBody (result, [43, 46, 55]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 12, 24, 36, 48]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 25, 37, 49]);\n\t\tJSM.AddPolygonToBody (result, [2, 14, 26, 38, 50]);\n\t\tJSM.AddPolygonToBody (result, [3, 15, 27, 39, 51]);\n\t\tJSM.AddPolygonToBody (result, [4, 16, 28, 40, 52]);\n\t\tJSM.AddPolygonToBody (result, [5, 17, 29, 41, 53]);\n\t\tJSM.AddPolygonToBody (result, [6, 18, 30, 42, 54]);\n\t\tJSM.AddPolygonToBody (result, [7, 19, 31, 43, 55]);\n\t\tJSM.AddPolygonToBody (result, [8, 20, 32, 44, 56]);\n\t\tJSM.AddPolygonToBody (result, [9, 21, 33, 45, 57]);\n\t\tJSM.AddPolygonToBody (result, [10, 22, 34, 46, 58]);\n\t\tJSM.AddPolygonToBody (result, [11, 23, 35, 47, 59]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: AddCumulatedPolygonToBody\n\t* Description: Adds polygons to a body by cumulating the original polygons vertex index array.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} the vertices of the original polygon\n\t*\theight {number} the height of the cumulation\n\t*/\n\tJSM.AddCumulatedPolygonToBody = function (body, vertices, height)\n\t{\n\t\tfunction CalculatePolygonCentroidAndNormal (vertices, centroidCoord, normalVector)\n\t\t{\n\t\t\tvar vertexCoords = [];\n\t\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\t\tvertexCoords.push (body.GetVertexPosition (vertices[i]));\n\t\t\t}\n\t\t\t\n\t\t\tvar centroid = JSM.CalculateCentroid (vertexCoords);\n\t\t\tvar normal = JSM.CalculateNormal (vertexCoords);\n\n\t\t\tcentroidCoord.Set (centroid.x, centroid.y, centroid.z);\n\t\t\tnormalVector.Set (normal.x, normal.y, normal.z);\n\t\t}\n\n\t\tvar centroidCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar normalVector = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tCalculatePolygonCentroidAndNormal (vertices, centroidCoord, normalVector);\n\t\tcentroidCoord.Offset (normalVector, height);\n\t\t\n\t\tvar centroid = body.VertexCount ();\n\t\tJSM.AddVertexToBody (body, centroidCoord.x, centroidCoord.y, centroidCoord.z);\n\n\t\tvar count = vertices.length;\n\n\t\tvar i, curr, next;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = vertices[i];\n\t\t\tnext = vertices [i < count - 1 ? i + 1 : 0];\n\t\t\tJSM.AddPolygonToBody (body, [curr, next, centroid]);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedTetrahedron\n\t* Description: Generates a cumulated tetrahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedTetrahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, +a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, -a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, +a, -a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, -a, -a)));\n\n\t\tvar edgeLength = 2.0 * Math.sqrt (2.0);\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 1, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 1], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 2, 3], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedHexahedron\n\t* Description: Generates a cumulated hexahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedHexahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tvar edgeLength = 2.0;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 1, 5, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 4, 1], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 6, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 7, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 6, 7, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 5, 7, 6], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedOctahedron\n\t* Description: Generates a cumulated octahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedOctahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +b);\n\t\tJSM.AddVertexToBody (result, -a, +b, +b);\n\t\tJSM.AddVertexToBody (result, +b, +a, +b);\n\t\tJSM.AddVertexToBody (result, +b, -a, +b);\n\t\tJSM.AddVertexToBody (result, +b, +b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +b, -a);\n\n\t\tvar edgeLength = Math.sqrt (2.0);\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 4, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 5, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 2, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 3, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 5, 3], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedDodecahedron\n\t* Description: Generates a cumulated dodecahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedDodecahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +d, +c);\n\t\tJSM.AddVertexToBody (result, +b, +d, -c);\n\t\tJSM.AddVertexToBody (result, +b, -d, +c);\n\t\tJSM.AddVertexToBody (result, +b, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +b);\n\t\tJSM.AddVertexToBody (result, +d, -c, +b);\n\t\tJSM.AddVertexToBody (result, -d, +c, +b);\n\t\tJSM.AddVertexToBody (result, -d, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +d);\n\t\tJSM.AddVertexToBody (result, -c, +b, +d);\n\t\tJSM.AddVertexToBody (result, +c, +b, -d);\n\t\tJSM.AddVertexToBody (result, -c, +b, -d);\n\n\t\tvar edgeLength = Math.sqrt (5.0) - 1.0;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 8, 10, 2, 16], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 16, 18, 1, 12], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 12, 14, 3, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 9, 5, 14, 12], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 18, 4, 11, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 10, 6, 15, 13], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 13, 4, 18, 16], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 14, 5, 19, 17], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 17, 6, 10, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [4, 13, 15, 7, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [5, 9, 11, 7, 19], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [6, 17, 19, 7, 15], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedIcosahedron\n\t* Description: Generates a cumulated icosahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedIcosahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tvar edgeLength = 2;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 4, 6], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 6, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 8, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 9, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 3, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 10], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 6, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 10, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 11, 6], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 5, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 7, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 9, 7], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 5, 7], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 7, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 10, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [4, 8, 10], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [6, 11, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [5, 10, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [7, 9, 11], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTetrakisHexahedron\n\t* Description: Generates a tetrakis hexahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTetrakisHexahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = 1.0 / 4.0;\n\t\treturn JSM.GenerateCumulatedHexahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateRhombicDodecahedron\n\t* Description: Generates a rhombic dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = 1.0 / 2.0;\n\t\treturn JSM.GenerateCumulatedHexahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GeneratePentakisDodecahedron\n\t* Description: Generates a pentakis dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePentakisDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt ((65.0 + 22.0 * Math.sqrt (5.0)) / 5.0) / 19.0;\n\t\treturn JSM.GenerateCumulatedDodecahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallStellatedDodecahedron\n\t* Description: Generates a small stellated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallStellatedDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt ((5.0 + 2.0 * Math.sqrt (5.0)) / 5.0);\n\t\treturn JSM.GenerateCumulatedDodecahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateGreatDodecahedron\n\t* Description: Generates a great dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGreatDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = (Math.sqrt (3.0) * (Math.sqrt (5.0) - 3.0)) / 6.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallTriambicIcosahedron\n\t* Description: Generates a small triambic icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallTriambicIcosahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (15.0) / 15.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateGreatStellatedDodecahedron\n\t* Description: Generates a great stellated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGreatStellatedDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = (Math.sqrt (3.0) * (3.0 + Math.sqrt (5.0))) / 6.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallTriakisOctahedron\n\t* Description: Generates a small triakis octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallTriakisOctahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (3.0) - 2.0 * Math.sqrt (6.0) / 3.0;\n\t\treturn JSM.GenerateCumulatedOctahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateStellaOctangula\n\t* Description: Generates a stella octangula.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateStellaOctangula = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (6.0) / 3.0;\n\t\treturn JSM.GenerateCumulatedOctahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateTriakisTetrahedron\n\t* Description: Generates a triakis tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriakisTetrahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (6.0) / 15.0;\n\t\treturn JSM.GenerateCumulatedTetrahedron (pyramidUnitHeight);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/extgenerator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: LegoDimensions\n\t* Description: Class that contains lego brick dimensions.\n\t*/\n\tJSM.LegoDimensions = function ()\n\t{\n\t\tthis.legoWidth = 0.78;\n\t\tthis.legoSmallHeight = 0.32;\n\t\tthis.legoLargeHeight = 0.96;\n\t\tthis.legoWallWidth = 0.16;\n\t\tthis.legoCylinderWidth = 0.5;\n\t\tthis.legoCylinderHeight = 0.17;\n\t\tthis.legoBottomSmallCylinderWidth = 0.3;\n\t\tthis.legoBottomLargeCylinderWidth = 0.6;\n\t\tthis.legoBottomLargeCylinderWallWidth = 0.1;\n\t};\n\n\t/**\n\t* Function: GenerateLegoBrick\n\t* Description: Generates a lego brick.\n\t* Parameters:\n\t*\trows {integer} the row count\n\t*\tcolumns {integer} the columns count\n\t*\tisLarge {boolean} the brick is large\n\t*\thasTopCylinders {boolean} the brick has top cylinders\n\t*\thasBottomCylinders {boolean} the brick has bottom cylinders\n\t*\tsegmentation {integer} the segmentation of cylinders\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLegoBrick = function (rows, columns, isLarge, hasTopCylinders, hasBottomCylinders, segmentation, isCurved)\n\t{\n\t\tfunction OffsetBody (body, offset)\n\t\t{\n\t\t\tvar i, vertex;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\tvertex.position = JSM.CoordAdd (vertex.position, offset);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar legoDimensions = new JSM.LegoDimensions ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar unitWidth = legoDimensions.legoWidth;\n\t\tvar unitHeight = legoDimensions.legoLargeHeight;\n\t\tif (!isLarge) {\n\t\t\tunitHeight = legoDimensions.legoSmallHeight;\n\t\t}\n\t\tvar wallWidth = legoDimensions.legoWallWidth;\n\t\tvar topCylinderWidth = legoDimensions.legoCylinderWidth;\n\t\tvar topCylinderHeight = legoDimensions.legoCylinderHeight;\n\t\tvar bottomSmallCylinderWidth = legoDimensions.legoBottomSmallCylinderWidth;\n\t\tvar bottomLargeCylinderWidth = legoDimensions.legoBottomLargeCylinderWidth;\n\t\tvar bottomLargeCylinderWallWidth = legoDimensions.legoBottomLargeCylinderWallWidth;\n\n\t\tvar basePolygon = [];\n\t\tbasePolygon.push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, unitWidth * columns, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (0.0, unitWidth * columns, 0.0));\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar walls = JSM.GeneratePrismShell (basePolygon, normal, unitHeight - wallWidth, wallWidth, true);\n\t\tresult.Merge (walls);\n\t\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbasePolygon[i].z = unitHeight - wallWidth;\n\t\t}\n\t\t\n\t\tvar top = JSM.GeneratePrism (basePolygon, normal, wallWidth, true, null);\n\t\tresult.Merge (top);\n\t\t\n\t\tvar cylinderCenter, cylinder;\n\t\tif (hasTopCylinders) {\n\t\t\tfor (i = 0; i < rows; i++) {\n\t\t\t\tfor (j = 0; j < columns; j++) {\n\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * i + unitWidth / 2.0, unitWidth * j + unitWidth / 2.0, unitHeight + topCylinderHeight / 2.0);\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (topCylinderWidth / 2.0, topCylinderHeight, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasBottomCylinders) {\n\t\t\tvar circle, bigger, columnWise;\n\t\t\tif ((rows === 1 && columns > 1) || (columns === 1 && rows > 1)) {\n\t\t\t\tbigger = columns;\n\t\t\t\tcolumnWise = true;\n\t\t\t\tif (rows > columns) {\n\t\t\t\t\tbigger = rows;\n\t\t\t\t\tcolumnWise = false;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < bigger - 1; i++) {\n\t\t\t\t\tif (columnWise) {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth / 2.0, unitWidth * (i + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth / 2.0, (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t}\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (bottomSmallCylinderWidth / 2.0, unitHeight - wallWidth, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t} else if (rows > 1 && columns > 1) {\n\t\t\t\tfor (i = 0; i < rows - 1; i++) {\n\t\t\t\t\tfor (j = 0; j < columns - 1; j++) {\n\t\t\t\t\t\tcircle = [];\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth * (j + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t\tcylinder = JSM.GenerateCylinderShell (bottomLargeCylinderWidth / 2.0, unitHeight - wallWidth, bottomLargeCylinderWallWidth, segmentation, true, isCurved);\n\t\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateConvexHullBody\n\t* Description: Generates a convex hull body from the given coordinates.\n\t* Parameters:\n\t*\tcoord {Coord[*]} the coordinates\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateConvexHullBody = function (coords)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar convexHull = JSM.ConvexHull3D (coords);\n\t\t\n\t\tvar oldToNewIndexTable = {};\n\t\tvar i, j, current, index;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tif (!(index in oldToNewIndexTable)) {\n\t\t\t\t\toldToNewIndexTable[index] = result.VertexCount ();\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coords[index]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tnewPolygon = [];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tnewPolygon.push (oldToNewIndexTable[index]);\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon (newPolygon));\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSuperShape\n\t* Description: Generates a supershape.\n\t* Parameters:\n\t*\tparameters {12 numbers} the supershape parameters\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSuperShape = function (\taLon, bLon, mLon, n1Lon, n2Lon, n3Lon,\n\t\t\t\t\t\t\t\t\t\taLat, bLat, mLat, n1Lat, n2Lat, n3Lat,\n\t\t\t\t\t\t\t\t\t\tsegmentation, isCurved)\n\t{\n\t\tfunction CartesianToSpherical (coord)\n\t\t{\n\t\t\tvar radius = Math.sqrt (coord.x * coord.x + coord.y * coord.y + coord.z * coord.z);\n\t\t\tvar phi = Math.asin (coord.z / radius);\n\t\t\tvar theta = Math.atan2 (coord.y, coord.x);\n\t\t\treturn [radius, phi, theta];\n\t\t}\n\n\t\tfunction CalculateSuperFormula (p, a, b, m, n1, n2, n3)\n\t\t{\n\t\t\tvar abs1 = Math.abs (Math.cos (m * p / 4.0) / a);\n\t\t\tvar abs2 = Math.abs (Math.sin (m * p / 4.0) / b);\n\t\t\treturn Math.pow (Math.pow (abs1, n2) + Math.pow (abs2, n3), -1.0 / n1);\n\t\t}\n\n\t\tfunction CalculateSuperFormulaCoordinate (phi, theta)\n\t\t{\n\t\t\tvar coord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tvar rPhi = CalculateSuperFormula (phi, aLat, bLat, mLat, n1Lat, n2Lat, n3Lat);\n\t\t\tvar rTheta = CalculateSuperFormula (theta, aLon, bLon, mLon, n1Lon, n2Lon, n3Lon);\n\t\t\tcoord.x = rTheta * Math.cos (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.y = rTheta * Math.sin (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.z = rPhi * Math.sin (phi);\n\t\t\treturn coord;\n\t\t}\n\n\t\tvar result = JSM.GenerateSphere (1.0, segmentation, isCurved);\n\n\t\tvar i, vertex, coord, spherical, newCoord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tcoord = vertex.position;\n\t\t\tspherical = CartesianToSpherical (coord);\n\t\t\tnewCoord = CalculateSuperFormulaCoordinate (spherical[1], spherical[2]);\n\t\t\tvertex.SetPosition (newCoord);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/subdivision',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CatmullClarkSubdivisionOneIteration\n\t* Description: Runs one iteration of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivisionOneIteration = function (body)\n\t{\n\t\tfunction AddOriginalVertices (body, result, adjacencyInfo)\n\t\t{\n\t\t\tvar i, vertCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvertCoord = body.GetVertexPosition (i);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertCoord.Clone ()));\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tvar i, j, pgon, vertCoord, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tpgonCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j < pgon.verts.length; j++) {\n\t\t\t\t\tvertCoord = body.GetVertexPosition (pgon.verts[j]);\n\t\t\t\t\tpgonCoord = JSM.CoordAdd (pgonCoord, vertCoord);\n\t\t\t\t}\n\n\t\t\t\tpgonCoord.MultiplyScalar (1.0 / pgon.verts.length);\n\t\t\t\tpgonVertices.push (result.AddVertex (new JSM.BodyVertex (pgonCoord)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar i, j, edge, edgeCoord1, edgeCoord2, edgeCoord, pgonIndex, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord1 = body.GetVertexPosition (edge.vert1);\n\t\t\t\tedgeCoord2 = body.GetVertexPosition (edge.vert2);\n\t\t\t\tif (adjacencyInfo.IsContourEdge (edge)) {\n\t\t\t\t\tedgeCoord = JSM.MidCoord (edgeCoord1, edgeCoord2);\n\t\t\t\t} else {\n\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord1, edgeCoord2);\n\t\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t\tpgonIndex = (j === 0 ? edge.pgon1 : edge.pgon2);\n\t\t\t\t\t\tpgonCoord = result.GetVertexPosition (pgonVertices[pgonIndex]);\n\t\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord, pgonCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeCoord.MultiplyScalar (1.0 / 4.0);\n\t\t\t\t}\n\t\t\t\tedgeVertices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord)));\n\t\t\t}\n\t\t}\n\n\t\tfunction MoveOriginalVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tfunction MoveContourVertex (newVertCoord, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = newVertCoord.x;\n\t\t\t\tvertCoord.y = newVertCoord.y;\n\t\t\t\tvertCoord.z = newVertCoord.z;\n\t\t\t}\t\t\n\t\t\t\n\t\t\tfunction MoveVertex (pgonAverage, edgeAverage, vertEdgeCount, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = (pgonAverage.x + 2.0 * edgeAverage.x + (vertEdgeCount - 3) * vertCoord.x) / vertEdgeCount;\n\t\t\t\tvertCoord.y = (pgonAverage.y + 2.0 * edgeAverage.y + (vertEdgeCount - 3) * vertCoord.y) / vertEdgeCount;\n\t\t\t\tvertCoord.z = (pgonAverage.z + 2.0 * edgeAverage.z + (vertEdgeCount - 3) * vertCoord.z) / vertEdgeCount;\n\t\t\t}\n\t\t\n\t\t\tvar edgeMidCoords = [];\n\t\t\t\n\t\t\tvar edge, edgeCoord;\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (body.GetVertexPosition (edge.vert1), body.GetVertexPosition (edge.vert2));\n\t\t\t\tedgeMidCoords.push (edgeCoord);\n\t\t\t}\n\t\t\n\t\t\tvar vert, pgon, vertCoord, currentVertCoord;\n\t\t\tvar pgonAverage, edgeAverage, edgeCountForAverage;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvert = adjacencyInfo.verts[i];\n\t\t\t\tvertCoord = result.GetVertexPosition (i);\n\t\t\t\tif (adjacencyInfo.IsContourVertex (vert)) {\n\t\t\t\t\tedgeCountForAverage = 0;\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tif (adjacencyInfo.IsContourEdge (adjacencyInfo.edges[edge])) {\n\t\t\t\t\t\t\tedgeCoord = edgeMidCoords [vert.edges[j]];\n\t\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.Add (vertCoord);\n\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / edgeCountForAverage);\n\t\t\t\t\tMoveContourVertex (edgeAverage, vertCoord);\n\t\t\t\t} else {\n\t\t\t\t\tpgonAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < vert.pgons.length; j++) {\n\t\t\t\t\t\tpgon = vert.pgons[j];\n\t\t\t\t\t\tcurrentVertCoord = result.GetVertexPosition (pgonVertices[pgon]);\n\t\t\t\t\t\tpgonAverage.Add (currentVertCoord);\n\t\t\t\t\t}\n\t\t\t\t\tpgonAverage.MultiplyScalar (1.0 / vert.pgons.length);\n\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tedgeCoord = edgeMidCoords [edge];\n\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / vert.edges.length);\n\t\t\t\t\tMoveVertex (pgonAverage, edgeAverage, vert.edges.length, vertCoord);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar edgeCount, currentEdge, nextEdge;\n\t\t\tvar centroid, currentEdgeVertex, originalVertex, nextEdgeVertex;\n\t\t\tvar polygon, oldPolygon;\n\t\t\tvar i, j, pgon;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tedgeCount = pgon.verts.length;\n\t\t\t\tfor (j = 0; j < edgeCount; j++) {\n\t\t\t\t\tcurrentEdge = pgon.pedges[j];\n\t\t\t\t\tnextEdge = pgon.pedges[(j + 1) % edgeCount];\n\n\t\t\t\t\tcentroid = pgonVertices[i];\n\t\t\t\t\tcurrentEdgeVertex = edgeVertices[currentEdge.index];\n\t\t\t\t\toriginalVertex = adjacencyInfo.GetPolyEdgeStartVertex (nextEdge);\n\t\t\t\t\tnextEdgeVertex = edgeVertices[nextEdge.index];\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([centroid, currentEdgeVertex, originalVertex, nextEdgeVertex]);\n\t\t\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\t\t\tpolygon.material = oldPolygon.material;\n\t\t\t\t\tpolygon.curved = oldPolygon.curved;\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\n\t\tvar pgonVertices = [];\n\t\tvar edgeVertices = [];\n\n\t\tAddOriginalVertices (body, result, adjacencyInfo);\n\t\tAddPolygonVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\n\t\tMoveOriginalVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CatmullClarkSubdivision\n\t* Description: Runs multiple iterations of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\titerations {integer} the iteration number\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivision = function (body, iterations)\n\t{\n\t\tvar result = body;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < iterations; i++) {\n\t\t\tresult = JSM.CatmullClarkSubdivisionOneIteration (result);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/csg',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: BooleanOperation\n\t* Description: Makes a boolean operation on the given bodies.\n\t* Parameters:\n\t*\toperation {string} the operation ('Union', 'Difference', or 'Intersection')\n\t*\taBody {Body} the first body\n\t*\tbBody {Body} the second body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.BooleanOperation = function (operation, aBody, bBody)\n\t{\n\t\tfunction AddPolygonToBody (polygon, body, octree, reversed)\n\t\t{\n\t\t\tfunction AddBodyVertex (coord, octree)\n\t\t\t{\n\t\t\t\tvar merge = false;\n\t\t\t\tif (merge) {\n\t\t\t\t\tvar index = octree.FindCoord (coord);\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\tindex = body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\toctree.AddCoord (coord);\n\t\t\t\t\t}\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t}\n\n\t\t\tvar bodyPolygon = new JSM.BodyPolygon ([]);\n\n\t\t\tvar i, vertexIndex;\n\t\t\tif (!reversed) {\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (polygon.userData !== undefined) {\n\t\t\t\tbodyPolygon.SetMaterialIndex (polygon.userData.material);\n\t\t\t}\n\t\t\tbody.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tfunction AddPolygonsToBody (polygons, body, octree, reversed)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tAddPolygonToBody (polygons[i], body, octree, reversed);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ClipNodePolygonsWithTree (nodes, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t\t{\n\t\t\tfunction SetPolygonsUserData (polygons, userData)\n\t\t\t{\n\t\t\t\tvar i, polygon;\n\t\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\t\tpolygon = polygons[i];\n\t\t\t\t\tif (polygon.userData === undefined) {\n\t\t\t\t\t\tpolygon.userData = userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < nodes.length; i++) {\n\t\t\t\tnode = nodes[i];\n\t\t\t\tJSM.ClipPolygonWithBSPTree (node.polygon, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons);\n\t\t\t\tSetPolygonsUserData (frontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (backPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarFrontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarBackPolygons, node.userData);\n\t\t\t}\n\t\t}\n\n\t\tvar aTree = new JSM.BSPTree ();\n\t\tvar bTree = new JSM.BSPTree ();\n\t\tJSM.AddBodyToBSPTree (aBody, aTree, 'a');\n\t\tJSM.AddBodyToBSPTree (bBody, bTree, 'b');\n\n\t\tvar aFrontPolygons = [];\n\t\tvar aBackPolygons = [];\n\t\tvar aPlanarFrontPolygons = [];\n\t\tvar aPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (aTree.GetNodes (), bTree, aFrontPolygons, aBackPolygons, aPlanarFrontPolygons, aPlanarBackPolygons);\n\n\t\tvar bFrontPolygons = [];\n\t\tvar bBackPolygons = [];\n\t\tvar bPlanarFrontPolygons = [];\n\t\tvar bPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (bTree.GetNodes (), aTree, bFrontPolygons, bBackPolygons, bPlanarFrontPolygons, bPlanarBackPolygons);\n\n\t\tvar result = new JSM.Body ();\n\t\tvar resultOctree = new JSM.Octree (JSM.BoxUnion (aBody.GetBoundingBox (), bBody.GetBoundingBox ()));\n\t\t\n\t\tif (operation == 'Union') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bPlanarFrontPolygons, result, resultOctree, false);\n\t\t} else if (operation == 'Difference') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, true);\n\t\t} else if (operation == 'Intersection') {\n\t\t\tAddPolygonsToBody (aBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, false);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/surfaces',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSurface\n\t* Description: Generates a parametric surface.\n\t* Parameters:\n\t*\txRange {number[2]} the from-to range on x axis\n\t*\tyRange {number[2]} the from-to range on y axis\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tuseTriangles {boolean} generate triangles instead of quadrangles\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tgetPointCallback {function} callback function which returns the point for a position\n\t*\tuserData {anything} user data which will be passed to getPointCallback\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSurface = function (xRange, yRange, xSegmentation, ySegmentation, useTriangles, isCurved, getPointCallback, userData)\n\t{\n\t\tfunction AddVertices (result, xStart, yStart, xSegment, ySegment)\n\t\t{\n\t\t\tvar i, j, u, v, coord;\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tu = xStart + j * xSegment;\n\t\t\t\t\tv = yStart + i * ySegment;\n\t\t\t\t\tcoord = getPointCallback (i, j, u, v, userData);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (result)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\tvar polygon;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (useTriangles) {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xRange[0];\n\t\tvar yStart = yRange[0];\n\t\tvar xDiff = xRange[1] - xRange[0];\n\t\tvar yDiff = yRange[1] - yRange[0];\n\t\tvar xSegment = xDiff / xSegmentation;\n\t\tvar ySegment = yDiff / ySegmentation;\n\t\t\n\t\tAddVertices (result, xStart, yStart, xSegment, ySegment);\n\t\tAddPolygons (result);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: SurfaceControlPoints\n\t* Description: Represents control points for surface generation.\n\t* Parameters:\n\t*\tn {integer} the first dimension\n\t*\tm {integer} the second dimension\n\t*/\n\tJSM.SurfaceControlPoints = function (n, m)\n\t{\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\tthis.points = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tthis.points.push ([]);\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tthis.points[i].push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetNValue\n\t* Description: Returns the n value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetNValue = function ()\n\t{\n\t\treturn this.n;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetMValue\n\t* Description: Returns the m value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetMValue = function ()\n\t{\n\t\treturn this.m;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetControlPoint\n\t* Description: Returns a control point.\n\t* Parameters:\n\t*\ti {integer} the first dimension\n\t*\tj {integer} the second dimension\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetControlPoint = function (i, j)\n\t{\n\t\treturn this.points[i][j];\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.InitPlanar\n\t* Description: Inits planar control points.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\txSize {number} the y size\n\t*/\n\tJSM.SurfaceControlPoints.prototype.InitPlanar = function (xSize, ySize)\n\t{\n\t\tvar iStep = xSize / this.n;\n\t\tvar jStep = ySize / this.m;\n\n\t\tvar i, j, point;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tpoint = this.points[i][j];\n\t\t\t\tpoint.x = i * iStep;\n\t\t\t\tpoint.y = j * jStep;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateBezierSurface\n\t* Description: Generates a bezier surface base on the given control points.\n\t* Parameters:\n\t*\tsurfaceControlPoints {SurfaceControlPoints} the control points\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateBezierSurface = function (surfaceControlPoints, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tfunction GetBezierSurfacePoint (uIndex, vIndex, u, v, surfaceControlPoints)\n\t\t{\n\t\t\tvar i, j, result, tmp1, tmp2, scalar;\n\t\t\tvar n = surfaceControlPoints.GetNValue ();\n\t\t\tvar m = surfaceControlPoints.GetMValue ();\n\t\t\t\n\t\t\tresult = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tfor (i = 0; i <= n; i++) {\n\t\t\t\ttmp1 = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j <= m; j++) {\n\t\t\t\t\tscalar = JSM.BernsteinPolynomial (i, n, u) * JSM.BernsteinPolynomial (j, m, v);\n\t\t\t\t\ttmp2 = surfaceControlPoints.GetControlPoint (i, j).Clone ().MultiplyScalar (scalar);\n\t\t\t\t\ttmp1 = JSM.CoordAdd (tmp1, tmp2);\n\t\t\t\t}\n\t\t\t\tresult = JSM.CoordAdd (result, tmp1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = JSM.GenerateSurface ([0, 1], [0, 1], xSegmentation, ySegmentation, false, isCurved, GetBezierSurfacePoint, surfaceControlPoints);\n\t\treturn body;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/svgtomodel/svgtomodel',[\"../../core/jsm\"],function(JSM){\n\t/**\n\t* Function: SvgToModel\n\t* Description: Converts an svg objects rect, path and polygon elements to a body.\n\t* Parameters:\n\t*\tsvgObject {html svg element} the svg element\n\t*\theight {number} the height of the result body\n\t*\tsegmentLength {number} the maximum length of curved segments\n\t*\tcurveAngle {number} if not null, defines the curve angle of the model\n\t* Returns:\n\t*\t{Model} the result\n\t*/\n\tJSM.SvgToModel = function (svgObject, height, segmentLength, curveAngle)\n\t{\n\t\tfunction SegmentElem (elem, segmentLength)\n\t\t{\n\t\t\tfunction AddTransformedVertex (dummySVG, result, elem, x, y)\n\t\t\t{\n\t\t\t\tvar point = dummySVG.createSVGPoint ();\n\t\t\t\tpoint.x = x;\n\t\t\t\tpoint.y = y;\n\t\t\t\t\n\t\t\t\tvar transformed = point;\n\t\t\t\tvar matrix = elem.getCTM ();\n\t\t\t\tif (matrix !== undefined && matrix !== null) {\n\t\t\t\t\ttransformed = point.matrixTransform (matrix);\t\t\t\t\n\t\t\t\t}\n\t\t\t\tvar transformedCoord = new JSM.Coord2D (transformed.x, transformed.y);\n\t\t\t\tvar resultCoord = new JSM.Coord2D (x, y);\n\t\t\t\t\n\t\t\t\tvar contour = result.GetLastContour ();\n\t\t\t\tvar contourVertexCount = contour.VertexCount ();\n\t\t\t\tif (contourVertexCount > 0) {\n\t\t\t\t\tif (contour.GetVertex (contourVertexCount - 1).IsEqualWithEps (transformedCoord, 0.1)) {\n\t\t\t\t\t\treturn resultCoord;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontour.AddVertex (transformed.x, transformed.y);\n\t\t\t\treturn resultCoord;\n\t\t\t}\n\n\t\t\tfunction SegmentCurve (dummySVG, originalPath, segmentLength, lastCoord, items, result)\n\t\t\t{\n\t\t\t\tfunction CreatePath (items)\n\t\t\t\t{\n\t\t\t\t\tfunction GenerateMoveCommand (x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 'M ' + x + ' ' + y + ' ';\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tvar svgNameSpace = 'http://www.w3.org/2000/svg';\n\t\t\t\t\tvar path = document.createElementNS (svgNameSpace, 'path');\n\n\t\t\t\t\tvar commandString = GenerateMoveCommand (lastCoord.x, lastCoord.y);\n\t\t\t\t\tvar i, item, command, largeArcFlag, sweepFlag;\n\t\t\t\t\tfor (i = 0; i < items.length; i++) {\n\t\t\t\t\t\titem = items[i];\n\t\t\t\t\t\tif (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ||\n\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL) {\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ? 'C' : 'c');\n\t\t\t\t\t\t\tcommandString += command + ' ' + item.x1 + ' ' + item.y1 + ' ' + item.x2 + ' ' + item.y2 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ? 'Q' : 'q');\n\t\t\t\t\t\t\tcommandString += command + ' ' + item.x1 + ' ' + item.y1 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ? 'A' : 'a');\n\t\t\t\t\t\t\tlargeArcFlag = (item.largeArcFlag ? 1 : 0);\n\t\t\t\t\t\t\tsweepFlag = (item.sweepFlag ? 1 : 0);\n\t\t\t\t\t\t\tcommandString +=  command + ' ' + item.r1 + ' ' + item.r2 + ' ' + item.angle + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ? 'S' : 's');\n\t\t\t\t\t\t\tcommandString +=  command + ' ' + item.x2 + ' ' + item.y2 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// unknown segment type\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpath.setAttributeNS (null, 'd', commandString);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar path = CreatePath (items);\n\t\t\t\tvar pathLength = path.getTotalLength ();\n\n\t\t\t\tvar segmentation = 0;\n\t\t\t\tif (segmentLength > 0) {\n\t\t\t\t\tsegmentation = parseInt (pathLength / segmentLength, 10);\n\t\t\t\t}\n\t\t\t\tif (segmentation < 3) {\n\t\t\t\t\tsegmentation = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar step = pathLength / segmentation;\n\t\t\t\tvar i, point;\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tpoint = path.getPointAtLength (i * step);\n\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, originalPath, point.x, point.y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn lastCoord;\n\t\t\t}\n\t\t\t\n\t\t\tfunction IsCurvedItem (item)\n\t\t\t{\n\t\t\t\treturn\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\t\t\t}\n\t\t\t\n\t\t\tfunction IsSmoothItem (item)\n\t\t\t{\n\t\t\t\treturn\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\t\t\t}\n\n\t\t\tfunction RemoveEqualEndVertices (polygon)\n\t\t\t{\n\t\t\t\tvar contour = polygon.GetLastContour ();\n\t\t\t\tvar vertexCount = contour.VertexCount ();\n\t\t\t\tif (vertexCount === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar firstCoord = contour.GetVertex (0);\n\t\t\t\tvar lastCoord = contour.GetVertex (vertexCount - 1);\n\t\t\t\tif (firstCoord.IsEqualWithEps (lastCoord, 0.1)) {\n\t\t\t\t\t// TODO: Do not access vertices directly\n\t\t\t\t\tcontour.vertices.pop ();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction StartNewContour (result)\n\t\t\t{\n\t\t\t\tif (result.GetLastContour ().VertexCount () > 0) {\n\t\t\t\t\tRemoveEqualEndVertices (result);\n\t\t\t\t\tresult.AddContour ();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction SVGColorToHex (path)\n\t\t\t{\n\t\t\t\tvar svgColor = '';\n\t\t\t\tvar target = path;\n\t\t\t\twhile (target !== null && target !== undefined && svgColor.length === 0) {\n\t\t\t\t\tsvgColor = target.getAttribute ('fill');\n\t\t\t\t\tif (svgColor === null) {\n\t\t\t\t\t\tsvgColor = target.style.fill;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = target.parentElement;\n\t\t\t\t}\n\n\t\t\t\tvar result = 0x000000;\n\t\t\t\tif (svgColor.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (svgColor[0] == '#') {\n\t\t\t\t\tresult = JSM.HexColorToRGBColor (svgColor.substring (1));\n\t\t\t\t} else {\n\t\t\t\t\tvar firstBracket = svgColor.indexOf ('(');\n\t\t\t\t\tvar secondBracket = svgColor.indexOf (')');\n\t\t\t\t\tif (firstBracket == -1 || secondBracket == -1) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar numbers = svgColor.substring (firstBracket + 1, secondBracket);\n\t\t\t\t\tvar rgb = numbers.split (', ');\n\t\t\t\t\tif (rgb.length != 3) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tresult = JSM.RGBComponentsToHexColor (rgb[0], rgb[1], rgb[2]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\n\t\t\tvar result = new JSM.ContourPolygon2D ();\n\t\t\tresult.AddContour ();\n\n\t\t\tvar dummySVG = document.createElementNS ('http://www.w3.org/2000/svg', 'svg');\n\n\t\t\tvar i, j;\n\t\t\tif (elem instanceof SVGPathElement) {\n\t\t\t\tvar lastCoord = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lastMoveCoord = new JSM.Coord2D (0.0, 0.0);\n\n\t\t\t\tvar currentSegmentLength = segmentLength;\n\t\t\t\tif (elem.hasAttribute ('segmentlength')) {\n\t\t\t\t\tcurrentSegmentLength = parseFloat (elem.getAttribute ('segmentlength'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar item, items, currentItem;\n\t\t\t\tfor (i = 0; i < elem.pathSegList.numberOfItems; i++) {\n\t\t\t\t\titem = elem.pathSegList.getItem (i);\n\t\t\t\t\tif (item.pathSegType == SVGPathSeg.PATHSEG_CLOSEPATH) {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_MOVETO_ABS) {\n\t\t\t\t\t\tStartNewContour (result);\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, item.y);\n\t\t\t\t\t\tlastMoveCoord = lastCoord.Clone ();\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_MOVETO_REL) {\n\t\t\t\t\t\tStartNewContour (result);\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastMoveCoord.x + item.x, lastMoveCoord.y + item.y);\n\t\t\t\t\t\tlastMoveCoord = lastCoord.Clone ();\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x + item.x, lastCoord.y + item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, lastCoord.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x, item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x + item.x, lastCoord.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x, lastCoord.y + item.y);\n\t\t\t\t\t} else if (IsCurvedItem (item)) {\n\t\t\t\t\t\titems = [];\n\t\t\t\t\t\tif (IsSmoothItem (item)) {\n\t\t\t\t\t\t\tfor (j = i; j < elem.pathSegList.numberOfItems; j++) {\n\t\t\t\t\t\t\t\tcurrentItem = elem.pathSegList.getItem (j);\n\t\t\t\t\t\t\t\tif (!IsSmoothItem (currentItem)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titems.push (currentItem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti = j - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems.push (item);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastCoord = SegmentCurve (dummySVG, elem, currentSegmentLength, lastCoord, items, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unknown segment type\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRemoveEqualEndVertices (result);\n\t\t\t} else if (elem instanceof SVGRectElement) {\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value, elem.y.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value + elem.width.baseVal.value, elem.y.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value + elem.width.baseVal.value, elem.y.baseVal.value + elem.height.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value, elem.y.baseVal.value + elem.height.baseVal.value);\n\t\t\t} else if (elem instanceof SVGPolygonElement) {\n\t\t\t\tvar point;\n\t\t\t\tfor (i = 0; i < elem.points.numberOfItems; i++) {\n\t\t\t\t\tpoint = elem.points.getItem (i);\n\t\t\t\t\tAddTransformedVertex (dummySVG, result, elem, point.x, point.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.color = SVGColorToHex (elem);\n\t\t\tresult.originalElem = elem;\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction SegmentPaths (svgObject, segmentLength)\n\t\t{\n\t\t\tfunction AddElemType (svgObject, elemType, result)\n\t\t\t{\n\t\t\t\tvar elems = svgObject.getElementsByTagName (elemType);\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\t\t\tresult.push (elems[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar result = [];\n\t\t\tvar elems = [];\n\t\t\tAddElemType (svgObject, 'path', elems);\n\t\t\tAddElemType (svgObject, 'rect', elems);\n\t\t\tAddElemType (svgObject, 'polygon', elems);\n\t\t\t\n\t\t\tvar currentSegmentLength = segmentLength;\n\t\t\tif (svgObject.hasAttribute ('segmentlength')) {\n\t\t\t\tcurrentSegmentLength = parseFloat (svgObject.getAttribute ('segmentlength'));\n\t\t\t}\n\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\t\tcurrent = SegmentElem (elems[i], currentSegmentLength);\n\t\t\t\tresult.push (current);\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction ContourPolygonToPrisms (polygon, height, curveAngle)\n\t\t{\n\t\t\tfunction AppendPolygonVertices (polygon, vertexArray, reversed)\n\t\t\t{\n\t\t\t\tvar i, coord;\n\t\t\t\tif (!reversed) {\n\t\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\t\t\tvertexArray.push (new JSM.Coord (coord.x, -coord.y, 0.0));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\t\t\tvertexArray.push (new JSM.Coord (coord.x, -coord.y, 0.0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction CreateBasePolygon (polygon)\n\t\t\t{\n\t\t\t\tvar basePolygon = [];\n\t\t\t\tvar orientation = polygon.GetOrientation ();\n\t\t\t\tvar reversed = (orientation == JSM.Orientation.CounterClockwise);\n\t\t\t\tAppendPolygonVertices (polygon, basePolygon, reversed);\n\t\t\t\treturn basePolygon;\n\t\t\t}\n\t\t\n\t\t\tfunction AddHoleToBasePolygon (basePolygon, holePolygon)\n\t\t\t{\n\t\t\t\tbasePolygon.push (null);\n\t\t\t\tvar orientation = holePolygon.GetOrientation ();\n\t\t\t\tvar reversed = (orientation == JSM.Orientation.Clockwise);\n\t\t\t\tAppendPolygonVertices (holePolygon, basePolygon, reversed);\n\t\t\t}\n\n\t\t\tvar prisms = [];\n\t\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\t\t\n\t\t\tvar currentHeight = height;\n\t\t\tif (polygon.originalElem !== undefined) {\n\t\t\t\tif (polygon.originalElem.hasAttribute ('modelheight')) {\n\t\t\t\t\tcurrentHeight = parseFloat (polygon.originalElem.getAttribute ('modelheight'));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar basePolygon, baseOrientation, prism;\n\t\t\tvar contourCount = polygon.ContourCount ();\n\t\t\tif (contourCount === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif (contourCount == 1) {\n\t\t\t\tbaseOrientation = polygon.GetContour (0).GetOrientation ();\n\t\t\t\tbasePolygon = CreateBasePolygon (polygon.GetContour (0));\n\t\t\t\tprism = JSM.GeneratePrism (basePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\tprisms.push (prism);\n\t\t\t} else if (contourCount > 1) {\n\t\t\t\tbaseOrientation = polygon.GetContour (0).GetOrientation ();\n\t\t\t\tvar holeBasePolygon = CreateBasePolygon (polygon.GetContour (0));\n\t\t\t\tvar hasHoles = false;\n\t\t\t\t\n\t\t\t\tvar i, orientation;\n\t\t\t\tfor (i = 1; i < polygon.ContourCount (); i++) {\n\t\t\t\t\torientation = polygon.GetContour (i).GetOrientation ();\n\t\t\t\t\tif (orientation == baseOrientation) {\n\t\t\t\t\t\tbasePolygon = CreateBasePolygon (polygon.GetContour (i));\n\t\t\t\t\t\tprism = JSM.GeneratePrism (basePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\t\tprisms.push (prism);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAddHoleToBasePolygon (holeBasePolygon, polygon.GetContour (i));\n\t\t\t\t\t\thasHoles = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasHoles) {\n\t\t\t\t\tprism = JSM.GeneratePrism (holeBasePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\tprisms.push (prism);\n\t\t\t\t} else {\n\t\t\t\t\tprism = JSM.GeneratePrismWithHole (holeBasePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\tprisms.push (prism);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar material = new JSM.Material ({ambient : polygon.color, diffuse : polygon.color});\n\t\t\treturn [prisms, material];\n\t\t}\n\t\t\n\t\tvar model = new JSM.Model ();\n\t\tvar polygons = SegmentPaths (svgObject, segmentLength);\n\n\t\tvar currentHeight = height;\n\t\tif (svgObject.hasAttribute ('modelheight')) {\n\t\t\tcurrentHeight = parseFloat (svgObject.getAttribute ('modelheight'));\n\t\t}\n\t\t\n\t\tvar i, j, prismsAndMaterial, currentPrisms, currentPrism, currentMaterial;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tprismsAndMaterial = ContourPolygonToPrisms (polygons[i], currentHeight, curveAngle);\n\t\t\tif (prismsAndMaterial === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentPrisms = prismsAndMaterial[0];\n\t\t\tcurrentMaterial = prismsAndMaterial[1];\n\t\t\tmodel.AddMaterial (currentMaterial);\n\t\t\tfor (j = 0; j < currentPrisms.length; j++) {\n\t\t\t\tcurrentPrism = currentPrisms[j];\n\t\t\t\tcurrentPrism.SetPolygonsMaterialIndex (model.MaterialCount () - 1);\n\t\t\t\tmodel.AddBody (currentPrism);\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/textgenerator/textgenerator',[\"../../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateText\n\t* Description:\n\t*\tGenerates 3D model from the given text. It should get a font\n\t*\tspecification object created with facetype.js.\n\t* Parameters:\n\t*\ttext {string} the text\n\t*\tfontSpec {object} the font specification object generated with facetype.js\n\t*\tfontScale {number} the scale of the generated model\n\t*\tfontHeight {number} the height of the generated model\n\t*\tfontSegmentation {integer} the segmentation of font glyphs\n\t* Returns:\n\t*\t{Model} the result\n\t*/\n\tJSM.GenerateText = function (text, fontSpec, fontScale, fontHeight, fontSegmentation)\n\t{\n\t\tfunction CreatePathFromSpecification (commands, segmentation, offset, scale)\n\t\t{\n\t\t\tfunction Num (str)\n\t\t\t{\n\t\t\t\treturn parseFloat (str);\n\t\t\t}\n\t\t\n\t\t\tvar path = new JSM.Path2D ({\n\t\t\t\tsegmentation : segmentation,\n\t\t\t\toffset : offset,\n\t\t\t\tscale : scale\n\t\t\t});\n\t\t\t\n\t\t\tvar parts = commands.split (' ');\n\t\t\tvar index = 0;\n\t\t\tvar current;\n\t\t\twhile (index < parts.length) {\n\t\t\t\tcurrent = parts[index++];\n\t\t\t\tif (current.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (current == 'm') {\n\t\t\t\t\tpath.MoveTo (Num (parts[index + 0]), Num (parts[index + 1]));\n\t\t\t\t\tindex += 2;\n\t\t\t\t} else if (current == 'l') {\n\t\t\t\t\tpath.LineTo (Num (parts[index + 0]), Num (parts[index + 1]));\n\t\t\t\t\tindex += 2;\n\t\t\t\t} else if (current == 'b') {\n\t\t\t\t\tpath.CubicBezierTo (Num (parts[index + 0]), Num (parts[index + 1]), Num (parts[index + 2]), Num (parts[index + 3]), Num (parts[index + 4]), Num (parts[index + 5]));\n\t\t\t\t\tindex += 6;\n\t\t\t\t} else if (current == 'z') {\n\t\t\t\t\tpath.Close ();\n\t\t\t\t} else {\n\t\t\t\t\tJSM.Message ('Invalid path command found: ' + current);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n\t\tvar model = new JSM.Model ();\n\t\tvar offset = new JSM.Vector2D (0.0, 0.0);\n\t\tvar scale = new JSM.Coord2D (fontScale, fontScale);\n\t\tvar i, character, glyphs, path, bodies;\n\t\tfor (i = 0; i < text.length; i++) {\n\t\t\tcharacter = text[i];\n\t\t\tglyphs = fontSpec.glyphs[character];\n\t\t\tif (glyphs === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpath = CreatePathFromSpecification (glyphs.o, fontSegmentation, offset, scale);\n\t\t\tbodies = JSM.GeneratePrismsFromPath2D (path, fontHeight, true, 160 * JSM.DegRad);\n\t\t\tmodel.AddBodies (bodies);\n\t\t\toffset.x += glyphs.ha * scale.x;\n\t\t}\n\t\treturn model;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/threeviewer/threeconverter',[\"../../core/jsm\"],function(JSM){\n\tJSM.ConvertBodyToThreeMeshes = function (body, materials, conversionData)\n\t{\n\t\tvar theConversionData = {\n\t\t\ttextureLoadedCallback : null,\n\t\t\thasConvexPolygons : false\n\t\t};\n\n\t\tif (conversionData !== undefined && conversionData !== null) {\n\t\t\ttheConversionData.textureLoadedCallback = JSM.ValueOrDefault (conversionData.textureLoadedCallback, theConversionData.textureLoadedCallback);\n\t\t\ttheConversionData.hasConvexPolygons = JSM.ValueOrDefault (conversionData.hasConvexPolygons, theConversionData.hasConvexPolygons);\n\t\t}\n\t\t\n\t\tvar meshes = [];\n\t\tvar threeGeometry = null;\n\t\tvar threeMaterial = null;\n\n\t\tvar explodeData = {\n\t\t\thasConvexPolygons : theConversionData.hasConvexPolygons,\n\t\t\tonPointGeometryStart : function (material) {\n\t\t\t\t\tthreeMaterial = new JSM.THREE.PointsMaterial ({\n\t\t\t\t\t\tcolor : material.diffuse,\n\t\t\t\t\t\tsize: material.pointSize\n\t\t\t\t\t});\n\t\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t},\n\t\t\tonPointGeometryEnd : function () {\n\t\t\t\tvar points = new JSM.THREE.Points (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (points);\n\t\t\t},\n\t\t\tonPoint : function (vertex)\t{\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex.x, vertex.y, vertex.z));\n\t\t\t},\n\t\t\tonLineGeometryStart : function (material) {\n\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t\tthreeMaterial = new JSM.THREE.LineBasicMaterial ({\n\t\t\t\t\tcolor : material.diffuse\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLineGeometryEnd : function () {\n\t\t\t\tvar lines = new JSM.THREE.LineSegments (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (lines);\n\t\t\t},\n\t\t\tonLine : function (begVertex, endVertex) {\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (begVertex.x, begVertex.y, begVertex.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (endVertex.x, endVertex.y, endVertex.z));\n\t\t\t},\n\t\t\tonGeometryStart : function (material) {\n\t\t\t\tvar hasTexture = (material.texture !== null);\n\t\t\t\tvar hasOpacity = (material.opacity !== 1.0);\n\n\t\t\t\tvar diffuse = material.diffuse;\n\t\t\t\tvar specular = material.specular;\n\t\t\t\tvar shininess = material.shininess;\n\t\t\t\tif (shininess === 0.0) {\n\t\t\t\t\tspecular = 0x000000;\n\t\t\t\t\tshininess = 1;\n\t\t\t\t}\n\n\t\t\t\tthreeMaterial = new JSM.THREE.MeshPhongMaterial ({\n\t\t\t\t\tcolor : diffuse,\n\t\t\t\t\tspecular : specular,\n\t\t\t\t\tshininess : shininess\n\t\t\t\t});\n\n\t\t\t\tif (!material.singleSided) {\n\t\t\t\t\tthreeMaterial.side = JSM.THREE.DoubleSide;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hasOpacity) {\n\t\t\t\t\tthreeMaterial.opacity = material.opacity;\n\t\t\t\t\tthreeMaterial.transparent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\tvar theMaterial = threeMaterial;\n\t\t\t\t\tvar textureName = material.texture;\n\t\t\t\t\tvar loader = new JSM.THREE.TextureLoader ();\n\t\t\t\t\tloader.load (textureName, function (texture) {\n\t\t\t\t\t\ttexture.image = JSM.ResizeImageToPowerOfTwoSides (texture.image);\n\t\t\t\t\t\ttexture.wrapS = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttheMaterial.map = texture;\n\t\t\t\t\t\ttheMaterial.needsUpdate = true;\n\t\t\t\t\t\tif (theConversionData.textureLoadedCallback !== null) {\n\t\t\t\t\t\t\ttheConversionData.textureLoadedCallback ();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t},\n\t\t\tonGeometryEnd : function () {\n\t\t\t\tthreeGeometry.computeFaceNormals ();\n\t\t\t\tvar mesh = new JSM.THREE.Mesh (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (mesh);\n\t\t\t},\n\t\t\tonTriangle : function (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3) {\n\t\t\t\tvar lastVertexIndex = threeGeometry.vertices.length;\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex1.x, vertex1.y, vertex1.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex2.x, vertex2.y, vertex2.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex3.x, vertex3.y, vertex3.z));\n\t\t\t\tvar face = new JSM.THREE.Face3 (lastVertexIndex + 0, lastVertexIndex + 1, lastVertexIndex + 2);\n\t\t\t\tthreeGeometry.faces.push (face);\n\t\t\t\t\n\t\t\t\tif (normal1 !== null && normal2 !== null && normal3 !== null) {\n\t\t\t\t\tvar normalArray = [];\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal1.x, normal1.y, normal1.z));\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal2.x, normal2.y, normal2.z));\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal3.x, normal3.y, normal3.z));\n\t\t\t\t\tthreeGeometry.faces[threeGeometry.faces.length - 1].vertexNormals = normalArray;\n\t\t\t\t}\n\n\t\t\t\tif (uv1 !== null && uv2 !== null && uv3 !== null) {\n\t\t\t\t\tvar uvArray = [];\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv1.x, -uv1.y));\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv2.x, -uv2.y));\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv3.x, -uv3.y));\n\t\t\t\t\tthreeGeometry.faceVertexUvs[0].push (uvArray);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tJSM.ExplodeBody (body, materials, explodeData);\n\t\treturn meshes;\n\t};\n\n\tJSM.ConvertModelToThreeMeshes = function (model, conversionData)\n\t{\n\t\tvar meshes = [];\n\t\tvar materials = model.GetMaterialSet ();\n\t\t\n\t\tvar i, j, body, currentMeshes;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentMeshes = JSM.ConvertBodyToThreeMeshes (body, materials, conversionData);\n\t\t\tfor (j = 0; j < currentMeshes.length; j++) {\n\t\t\t\tmeshes.push (currentMeshes[j]);\n\t\t\t}\n\t\t}\n\n\t\treturn meshes;\n\t};\n\n\tJSM.ConvertJSONDataToThreeMeshes = function (jsonData, textureLoadedCallback, asyncCallbacks)\n\t{\n\t\tfunction AddMesh (mesh, meshIndex, materials, resultMeshes)\n\t\t{\n\t\t\tfunction AddTriangles (currentTriangles, vertices, normals, uvs, materials, resultMeshes)\n\t\t\t{\n\t\t\t\tfunction GetTextureCoordinate (u, v, offset, scale, rotation)\n\t\t\t\t{\n\t\t\t\t\tvar result = new JSM.THREE.Vector2 (u, v);\n\t\t\t\t\tif (!JSM.IsZero (rotation)) {\n\t\t\t\t\t\tvar si = Math.sin (rotation * JSM.DegRad);\n\t\t\t\t\t\tvar co = Math.cos (rotation * JSM.DegRad);\n\t\t\t\t\t\tresult.x = co * u - si * v;\n\t\t\t\t\t\tresult.y = si * u + co * v;\n\t\t\t\t\t}\n\t\t\t\t\tresult.x = offset[0] + result.x * scale[0];\n\t\t\t\t\tresult.y = offset[1] + result.y * scale[1];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar materialIndex = currentTriangles.material;\n\t\t\t\tvar parameters = currentTriangles.parameters;\n\t\t\t\tvar materialData = materials[materialIndex];\n\t\t\t\t\n\t\t\t\tvar textureName = materialData.texture;\n\t\t\t\tvar textureOffset = materialData.offset;\n\t\t\t\tvar textureScale = materialData.scale;\n\t\t\t\tvar textureRotation = materialData.rotation;\n\t\t\t\t\n\t\t\t\tvar diffuseColor = new JSM.THREE.Color ();\n\t\t\t\tvar specularColor = new JSM.THREE.Color ();\n\t\t\t\tvar shininess = materialData.shininess || 0.0;\n\n\t\t\t\tdiffuseColor.setRGB (materialData.diffuse[0], materialData.diffuse[1], materialData.diffuse[2]);\n\t\t\t\tspecularColor.setRGB (materialData.specular[0], materialData.specular[1], materialData.specular[2]);\n\n\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\tdiffuseColor.setRGB (1.0, 1.0, 1.0);\n\t\t\t\t\tspecularColor.setRGB (1.0, 1.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\tif (textureOffset === undefined || textureOffset === null) {\n\t\t\t\t\t\ttextureOffset = [0.0, 0.0];\n\t\t\t\t\t}\n\t\t\t\t\tif (textureScale === undefined || textureScale === null) {\n\t\t\t\t\t\ttextureScale = [1.0, 1.0];\n\t\t\t\t\t}\n\t\t\t\t\tif (textureRotation === undefined || textureRotation === null) {\n\t\t\t\t\t\ttextureRotation = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shininess === 0.0) {\n\t\t\t\t\tspecularColor.setRGB (0.0, 0.0, 0.0);\n\t\t\t\t\tshininess = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = new JSM.THREE.MeshPhongMaterial ({\n\t\t\t\t\t\tcolor : diffuseColor.getHex (),\n\t\t\t\t\t\tspecular : specularColor.getHex (),\n\t\t\t\t\t\tshininess : shininess,\n\t\t\t\t\t\tside : JSM.THREE.DoubleSide\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (materialData.opacity !== 1.0) {\n\t\t\t\t\tmaterial.opacity = materialData.opacity;\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\tvar loader = new JSM.THREE.TextureLoader ();\n\t\t\t\t\tvar theMaterial = material;\n\t\t\t\t\tloader.load (textureName, function (texture) {\n\t\t\t\t\t\ttexture.image = JSM.ResizeImageToPowerOfTwoSides (texture.image);\n\t\t\t\t\t\ttexture.wrapS = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttheMaterial.map = texture;\n\t\t\t\t\t\ttheMaterial.needsUpdate = true;\n\t\t\t\t\t\tif (textureLoadedCallback !== undefined && textureLoadedCallback !== null) {\n\t\t\t\t\t\t\ttextureLoadedCallback ();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar geometry = new JSM.THREE.Geometry ();\n\n\t\t\t\tvar v1, v2, v3, n1, n2, n3, u1, u2, u3;\n\t\t\t\tvar lastVertex, lastFace, vertexNormals, textureUVs;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < parameters.length; j += 9) {\n\t\t\t\t\tv1 = 3 * parameters[j + 0];\n\t\t\t\t\tv2 = 3 * parameters[j + 1];\n\t\t\t\t\tv3 = 3 * parameters[j + 2];\n\t\t\t\t\tn1 = 3 * parameters[j + 3];\n\t\t\t\t\tn2 = 3 * parameters[j + 4];\n\t\t\t\t\tn3 = 3 * parameters[j + 5];\n\t\t\t\t\tu1 = 2 * parameters[j + 6];\n\t\t\t\t\tu2 = 2 * parameters[j + 7];\n\t\t\t\t\tu3 = 2 * parameters[j + 8];\n\t\t\t\t\t\n\t\t\t\t\tlastVertex = geometry.vertices.length;\n\t\t\t\t\tlastFace = geometry.faces.length;\n\t\t\t\t\t\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v1 + 0], vertices[v1 + 1], vertices[v1 + 2]));\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v2 + 0], vertices[v2 + 1], vertices[v2 + 2]));\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v3 + 0], vertices[v3 + 1], vertices[v3 + 2]));\n\t\t\t\t\tgeometry.faces.push (new JSM.THREE.Face3 (lastVertex + 0, lastVertex + 1, lastVertex + 2));\n\n\t\t\t\t\tvertexNormals = [];\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n1 + 0], normals[n1 + 1], normals[n1 + 2]));\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n2 + 0], normals[n2 + 1], normals[n2 + 2]));\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n3 + 0], normals[n3 + 1], normals[n3 + 2]));\n\t\t\t\t\tgeometry.faces[lastFace].vertexNormals = vertexNormals;\n\n\t\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\t\ttextureUVs = [];\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u1 + 0], uvs[u1 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u2 + 0], uvs[u2 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u3 + 0], uvs[u3 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\tgeometry.faceVertexUvs[0].push (textureUVs);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar mesh = new JSM.THREE.Mesh (geometry, material);\n\t\t\t\tmesh.originalJsonMaterialIndex = materialIndex;\n\t\t\t\tmesh.originalJsonMeshIndex = meshIndex;\n\t\t\t\tresultMeshes.push (mesh);\n\t\t\t}\n\n\t\t\tvar vertices = mesh.vertices;\n\t\t\tif (vertices === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar normals = mesh.normals;\n\t\t\tif (normals === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar uvs = mesh.uvs;\n\t\t\tif (uvs === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tvar triangles = mesh.triangles;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\tAddTriangles (triangles[i], vertices, normals, uvs, materials, resultMeshes);\n\t\t\t}\n\t\t}\n\n\t\tvar resultMeshes = [];\n\n\t\tvar materials = jsonData.materials;\n\t\tif (materials === undefined) {\n\t\t\treturn resultMeshes;\n\t\t}\n\t\t\n\t\tvar meshes = jsonData.meshes;\n\t\tif (meshes === undefined) {\n\t\t\treturn resultMeshes;\n\t\t}\n\t\t\n\t\tvar i = 0;\n\t\tJSM.AsyncRunTask (\n\t\t\tfunction () {\n\t\t\t\tAddMesh (meshes[i], i, materials, resultMeshes);\n\t\t\t\ti = i + 1;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tasyncCallbacks,\n\t\t\tmeshes.length, 0, resultMeshes\n\t\t);\n\n\t\treturn resultMeshes;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/threeviewer/threeviewer',[\"../../core/jsm\"],function(JSM){\n\tJSM.ThreeViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\t\n\t\tthis.scene = null;\n\t\tthis.camera = null;\n\t\tthis.renderer = null;\n\t\tthis.ambientLight = null;\n\t\tthis.directionalLight = null;\n\t\tthis.runBeforeRender = null;\n\t\tthis.runAfterRender = null;\n\n\t\tthis.cameraMove = null;\n\t\tthis.navigation = null;\n\t\tthis.settings = null;\n\t\tthis.drawLoop = null;\n\t\tthis.enableDraw = null;\n\t};\n\n\tJSM.ThreeViewer.prototype.Start = function (canvas, settings)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitSettings (settings)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.InitThree (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (settings)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.drawLoop = false;\n\t\tthis.enableDraw = true;\n\t\tthis.DrawIfNeeded ();\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitSettings = function (settings)\n\t{\n\t\tthis.settings = {\n\t\t\tcameraEyePosition : new JSM.Coord (1.0, 1.0, 1.0),\n\t\t\tcameraCenterPosition : new JSM.Coord (0.0, 0.0, 0.0),\n\t\t\tcameraUpVector : new JSM.Coord (0.0, 0.0, 1.0),\n\t\t\tlightAmbientColor : [0.5, 0.5, 0.5],\n\t\t\tlightDiffuseColor : [0.5, 0.5, 0.5]\n\t\t};\n\n\t\tif (settings !== undefined) {\n\t\t\tif (settings.cameraEyePosition !== undefined) { this.settings.cameraEyePosition = JSM.CoordFromArray (settings.cameraEyePosition); }\n\t\t\tif (settings.cameraCenterPosition !== undefined) { this.settings.cameraCenterPosition = JSM.CoordFromArray (settings.cameraCenterPosition); }\n\t\t\tif (settings.cameraUpVector !== undefined) { this.settings.cameraUpVector = JSM.CoordFromArray (settings.cameraUpVector); }\n\t\t\tif (settings.lightAmbientColor !== undefined) { this.settings.lightAmbientColor = settings.lightAmbientColor; }\n\t\t\tif (settings.lightDiffuseColor !== undefined) { this.settings.lightDiffuseColor = settings.lightDiffuseColor; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitThree = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas || !this.canvas.getContext) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.scene = new JSM.THREE.Scene();\n\t\tif (!this.scene) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar parameters = {\n\t\t\tcanvas : this.canvas,\n\t\t\tantialias : true\n\t\t};\n\t\tthis.renderer = new JSM.THREE.WebGLRenderer (parameters);\n\t\tif (!this.renderer) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.renderer.setClearColor (new JSM.THREE.Color (0xffffff));\n\t\tthis.renderer.setSize (this.canvas.width, this.canvas.height);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitCamera = function (settings)\n\t{\n\t\tthis.cameraMove = new JSM.Camera (\n\t\t\tJSM.CoordFromArray (settings.cameraEyePosition),\n\t\t\tJSM.CoordFromArray (settings.cameraCenterPosition),\n\t\t\tJSM.CoordFromArray (settings.cameraUpVector),\n\t\t\tsettings.fieldOfView,\n\t\t\tsettings.nearClippingPlane,\n\t\t\tsettings.farClippingPlane\n\t\t);\n\t\tif (!this.cameraMove) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.cameraMove, this.DrawIfNeeded.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.camera = new JSM.THREE.PerspectiveCamera (this.cameraMove.fieldOfView, this.canvas.width / this.canvas.height, this.cameraMove.nearClippingPlane, this.cameraMove.farClippingPlane);\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.scene.add (this.camera);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitLights = function ()\n\t{\n\t\tvar ambientColor = new JSM.THREE.Color ();\n\t\tvar diffuseColor = new JSM.THREE.Color ();\n\t\tambientColor.setRGB (this.settings.lightAmbientColor[0], this.settings.lightAmbientColor[1], this.settings.lightAmbientColor[2]);\n\t\tdiffuseColor.setRGB (this.settings.lightDiffuseColor[0], this.settings.lightDiffuseColor[1], this.settings.lightDiffuseColor[2]);\n\n\t\tthis.ambientLight = new JSM.THREE.AmbientLight (ambientColor.getHex ());\n\t\tif (!this.ambientLight) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.scene.add (this.ambientLight);\n\t\t\n\t\tthis.directionalLight = new JSM.THREE.DirectionalLight (diffuseColor.getHex ());\n\t\tif (!this.directionalLight) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar lightPosition = new JSM.THREE.Vector3 ().subVectors (this.cameraMove.eye, this.cameraMove.center);\n\t\tthis.directionalLight.position.set (lightPosition.x, lightPosition.y, lightPosition.z);\n\n\t\tthis.scene.add (this.directionalLight);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetRunBeforeRender = function (runBeforeRender)\n\t{\n\t\tthis.runBeforeRender = runBeforeRender;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetRunAfterRender = function (runAfterRender)\n\t{\n\t\tthis.runAfterRender = runAfterRender;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetClearColor = function (color)\n\t{\n\t\tthis.renderer.setClearColor (new JSM.THREE.Color (color));\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AddMesh = function (mesh)\n\t{\n\t\tthis.scene.add (mesh);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AddMeshes = function (meshes)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < meshes.length; i++) {\n\t\t\tthis.scene.add (meshes[i]);\n\t\t}\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.MeshCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.VisibleMeshCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsVisibleObject (current)) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.VertexCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tcount = count + current.geometry.vertices.length;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.FaceCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (current instanceof JSM.THREE.Mesh) {\n\t\t\t\tcount = count + current.geometry.faces.length;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.GetMesh = function (index)\n\t{\n\t\tvar current = null;\n\t\tvar currIndex = 0;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < this.scene.children.length; i++) {\n\t\t\tcurrent = this.scene.children[i];\n\t\t\tif (this.IsRelevantObject (current)) {\n\t\t\t\tif (currIndex == index) {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\tcurrIndex = currIndex + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\n\tJSM.ThreeViewer.prototype.ShowMesh = function (mesh)\n\t{\n\t\tmesh.visible = true;\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.HideMesh = function (mesh)\n\t{\n\t\tmesh.visible = false;\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveMesh = function (mesh)\n\t{\n\t\tmesh.geometry.dispose ();\n\t\tthis.scene.remove (mesh);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveMeshes = function ()\n\t{\n\t\tvar current;\n\t\tvar i;\n\t\tfor (i = 0; i < this.scene.children.length; i++) {\n\t\t\tcurrent = this.scene.children[i];\n\t\t\tif (this.IsRelevantObject (current)) {\n\t\t\t\tcurrent.geometry.dispose ();\n\t\t\t\tthis.scene.remove (current);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveLastMesh = function ()\n\t{\n\t\tvar found = null;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tfound = current;\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (found !== null) {\n\t\t\tthis.scene.remove (found);\n\t\t}\n\t\t\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.SetCamera = function (eye, center, up)\n\t{\n\t\tthis.navigation.SetCamera (eye, center, up);\n\t\tthis.navigation.SetOrbitCenter (center.Clone ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.Resize = function ()\n\t{\n\t\tthis.camera.aspect = this.canvas.width / this.canvas.height;\n\t\tthis.camera.updateProjectionMatrix ();\n\t\tthis.renderer.setSize (this.canvas.width, this.canvas.height);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.FitInWindow = function ()\n\t{\n\t\tif (this.VisibleMeshCount () === 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.FitMeshesInWindow = function (meshes)\n\t{\n\t\tif (meshes.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar sphere = this.GetFilteredBoundingSphere (function (obj) {\n\t\t\treturn meshes.indexOf (obj) != -1;\n\t\t});\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AdjustClippingPlanes = function (radiusLimit)\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tif (sphere.GetRadius () < radiusLimit) {\n\t\t\tthis.camera.near = 0.1;\n\t\t\tthis.camera.far = 1000.0;\n\t\t} else {\n\t\t\tthis.camera.near = 10.0;\n\t\t\tthis.camera.far = 1000000.0;\n\t\t}\n\t\tthis.camera.updateProjectionMatrix ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.ThreeViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredCenter (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredBoundingBox (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredBoundingSphere (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredCenter = function (needToProcess)\n\t{\n\t\tvar boundingBox = this.GetFilteredBoundingBox (needToProcess);\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredBoundingBox = function (needToProcess)\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar geometry, coord;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (needToProcess (current)) {\n\t\t\t\tgeometry = current.geometry;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < geometry.vertices.length; j++) {\n\t\t\t\t\tcoord = geometry.vertices[j].clone ();\n\t\t\t\t\tcoord.add (current.position);\n\t\t\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredBoundingSphere = function (needToProcess)\n\t{\n\t\tvar center = this.GetFilteredCenter (needToProcess);\n\t\tvar radius = 0.0;\n\n\t\tvar geometry, coord, distance;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (needToProcess (current)) {\n\t\t\t\tgeometry = current.geometry;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < geometry.vertices.length; j++) {\n\t\t\t\t\tcoord = geometry.vertices[j].clone ();\n\t\t\t\t\tcoord.add (current.position);\n\t\t\t\t\tdistance = center.DistanceTo (new JSM.Coord (coord.x, coord.y, coord.z));\n\t\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\t\tradius = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderPosition = function (x, y)\n\t{\n\t\tvar mouseX = (x / this.canvas.width) * 2 - 1;\n\t\tvar mouseY = -(y / this.canvas.height) * 2 + 1;\n\n\t\tvar cameraPosition = this.camera.position;\n\t\tvar vector = new JSM.THREE.Vector3 (mouseX, mouseY, 0.5);\n\t\tvector.unproject (this.camera);\n\t\tvector.sub (cameraPosition);\n\t\tvector.normalize ();\n\n\t\tvar ray = new JSM.THREE.Raycaster (cameraPosition, vector);\n\t\treturn ray.intersectObjects (this.scene.children);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderMouse = function ()\n\t{\n\t\treturn this.GetObjectsUnderPosition (this.navigation.mouse.curr.x, this.navigation.mouse.curr.y);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderTouch = function ()\n\t{\n\t\treturn this.GetObjectsUnderPosition (this.navigation.touch.curr.x, this.navigation.touch.curr.y);\n\t};\n\n\tJSM.ThreeViewer.prototype.ProjectVector = function (x, y, z)\n\t{\n\t\tvar width = this.canvas.width;\n\t\tvar height = this.canvas.height;\n\t\tvar halfWidth = width / 2;\n\t\tvar halfHeight = height / 2;\n\n\t\tvar vector = new JSM.THREE.Vector3 (x, y, z);\n\t\tvector.project (this.camera);\n\t\tvector.x = (vector.x * halfWidth) + halfWidth;\n\t\tvector.y = -(vector.y * halfHeight) + halfHeight;\n\t\treturn vector;\n\t};\n\n\tJSM.ThreeViewer.prototype.EnableDraw = function (enable)\n\t{\n\t\tthis.enableDraw = enable;\n\t};\n\n\tJSM.ThreeViewer.prototype.Draw = function ()\n\t{\n\t\tif (!this.enableDraw) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.runBeforeRender !== null) {\n\t\t\tthis.runBeforeRender ();\n\t\t}\n\n\t\tthis.camera.position.set (this.cameraMove.eye.x, this.cameraMove.eye.y, this.cameraMove.eye.z);\n\t\tthis.camera.up.set (this.cameraMove.up.x, this.cameraMove.up.y, this.cameraMove.up.z);\n\t\tthis.camera.lookAt (new JSM.THREE.Vector3 (this.cameraMove.center.x, this.cameraMove.center.y, this.cameraMove.center.z));\n\n\t\tvar lightPosition = new JSM.THREE.Vector3 ().subVectors (this.cameraMove.eye, this.cameraMove.center);\n\t\tthis.directionalLight.position.set (lightPosition.x, lightPosition.y, lightPosition.z);\n\n\t\tthis.renderer.render (this.scene, this.camera);\n\t\t\n\t\tif (this.runAfterRender !== null) {\n\t\t\tthis.runAfterRender ();\n\t\t}\n\t\t\n\t\tif (this.drawLoop) {\n\t\t\trequestAnimationFrame (this.Draw.bind (this));\n\t\t}\n\t};\n\n\tJSM.ThreeViewer.prototype.DrawIfNeeded = function ()\n\t{\n\t\tif (!this.drawLoop) {\n\t\t\tthis.Draw ();\n\t\t}\n\t};\n\n\tJSM.ThreeViewer.prototype.StartDrawLoop = function ()\n\t{\n\t\tthis.drawLoop = true;\n\t\tthis.Draw ();\n\t};\n\n\tJSM.ThreeViewer.prototype.IsRelevantObject = function (threeObj)\n\t{\n\t\treturn (threeObj instanceof JSM.THREE.Mesh || threeObj instanceof JSM.THREE.LineSegments || threeObj instanceof JSM.THREE.Points);\n\t};\n\n\tJSM.ThreeViewer.prototype.IsVisibleObject = function (threeObj)\n\t{\n\t\treturn this.IsRelevantObject (threeObj) && threeObj.visible;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/main',[\r\n\t\"skylark-langx/skylark\",\r\n\t\"./core/jsm\",\r\n\t\"./core/timer\",\r\n\t\"./core/algorithm\",\r\n\t\"./core/async\",\r\n\t\"./core/check\",\r\n\t\"./core/jsonloader\",\r\n\t\"./geometry/definitions\",\r\n\t\"./geometry/coord2d\",\r\n\t\"./geometry/coord\",\r\n\t\"./geometry/determinant\",\r\n\t\"./geometry/coordutils\",\r\n\t\"./geometry/matrix\",\r\n\t\"./geometry/coordsystem\",\r\n\t\"./geometry/sector\",\r\n\t\"./geometry/line\",\r\n\t\"./geometry/box\",\r\n\t\"./geometry/sphere\",\r\n\t\"./geometry/transformation\",\r\n\t\"./geometry/plane\",\r\n\t\"./geometry/projection\",\r\n\t\"./geometry/convexhull\",\r\n\t\"./geometry/polygon2d\",\r\n\t\"./geometry/polygon\",\r\n\t\"./geometry/cutpolygon\",\r\n\t\"./geometry/triangulation\",\r\n\t\"./geometry/octree\",\r\n\t\"./geometry/bsptree\",\r\n\t\"./geometry/curves\",\r\n\t\"./geometry/utilities\",\r\n\t\"./geometry/ray\",\r\n\t\"./geometry/path\",\r\n\t\"./modeler/color\",\r\n\t\"./modeler/material\",\r\n\t\"./modeler/materialset\",\r\n\t\"./modeler/body\",\r\n\t\"./modeler/model\",\r\n\t\"./modeler/adjacencyinfo\",\r\n\t\"./modeler/bodyutils\",\r\n\t\"./modeler/textureutils\",\r\n\t\"./modeler/cututils\",\r\n\t\"./modeler/generator\",\r\n\t\"./modeler/camera\",\r\n\t\"./modeler/explode\",\r\n\t\"./modeler/exporter\",\r\n\t\"./modeler/trianglebody\",\r\n\t\"./modeler/trianglemodel\",\r\n\t\"./modeler/converter\",\r\n\t\"./modeler/rayutils\",\r\n\t\"./import/binaryreader\",\r\n\t\"./import/importerutils\",\r\n\t\"./import/importer3ds\",\r\n\t\"./import/importerobj\",\r\n\t\"./import/importerstl\",\r\n\t\"./import/importeroff\",\r\n\t\"./import/importercommon\",\r\n\t\"./renderer/webglutils\",\r\n\t\"./renderer/renderlight\",\r\n\t\"./renderer/rendermaterial\",\r\n\t\"./renderer/rendermesh\",\r\n\t\"./renderer/renderbody\",\r\n\t\"./renderer/shaderprogram\",\r\n\t\"./renderer/renderer\",\r\n\t\"./renderer/pointcloudrenderer\",\r\n\t\"./renderer/renderconverter\",\r\n\t\"./viewer/mouse\",\r\n\t\"./viewer/touch\",\r\n\t\"./viewer/painter\",\r\n\t\"./viewer/drawing\",\r\n\t\"./viewer/navigation\",\r\n\t\"./viewer/softwareviewer\",\r\n\t\"./viewer/spriteviewer\",\r\n\t\"./viewer/viewer\",\r\n\t\"./viewer/pointcloudviewer\",\r\n\t\"./extras/solidgenerator\",\r\n\t\"./extras/extgenerator\",\r\n\t\"./extras/subdivision\",\r\n\t\"./extras/csg\",\r\n\t\"./extras/surfaces\",\r\n\t\"./extensions/svgtomodel/svgtomodel\",\r\n\t\"./extensions/textgenerator/textgenerator\",\r\n\t\"./extensions/threeviewer/threeconverter\",\r\n\t\"./extensions/threeviewer/threeviewer\"\r\n\r\n],function(skyalrk,jsm){\r\n\treturn skylark.attach(\"intg.jsmodeler\",jsm);\r\n});\ndefine('skylark-jsmodeler', ['skylark-jsmodeler/main'], function (main) { return main; });\n\n"]}