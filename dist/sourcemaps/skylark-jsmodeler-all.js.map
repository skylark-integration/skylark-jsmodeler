{"version":3,"sources":["skylark-jsmodeler-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","_attach","skylark","attach","obj","main","JSM","this","mainVersion","subVersion","RandomNumber","from","to","Math","random","RandomInt","floor","RandomBoolean","SeededRandomInt","seed","ValueOrDefault","val","def","undefined","PrevIndex","index","NextIndex","CopyObjectProperties","source","target","overwrite","property","hasOwnProperty","GetObjectProperty","object","propertyName","defaultValue","propertyValue","Message","message","console","log","Timer","start","stop","prototype","Start","date","Date","getTime","Stop","end","Result","FPSCounter","frames","current","Get","interval","elapsed","parseInt","SwapArrayValues","array","temp","BubbleSort","onCompare","onSwap","compareFunction","j","swapFunction","ShiftArray","count","push","shift","AsyncRunTask","taskFunction","callbacks","runCount","timeout","userData","onStart","OnStart","RunTask","currentCount","needContinue","onProgress","OnProgress","setTimeout","onFinish","OnFinished","IsWebGLEnabled","window","WebGLRenderingContext","canvas","document","createElement","getContext","exception","IsFileApiEnabled","File","FileReader","FileList","Blob","URL","LoadJsonFile","fileName","onReady","request","XMLHttpRequest","overrideMimeType","open","onreadystatechange","readyState","jsonData","JSON","parse","responseText","send","Eps","Inf","RadDeg","DegRad","IsZero","a","abs","IsPositive","IsNegative","IsLower","b","IsGreater","IsEqual","IsEqualWithEps","eps","IsLowerOrEqual","IsGreaterOrEqual","Minimum","Maximum","ArcSin","value","PI","asin","ArcCos","acos","Coord2D","x","y","Set","coord","DistanceTo","sqrt","AngleTo","aDirection","Clone","Normalize","bDirection","product","VectorDot2D","Length","MultiplyScalar","scalar","SetLength","thisLength","Offset","direction","distance","normal","Rotate","angle","origo","co","cos","si","sin","ToString","Vector2D","CoordFromArray2D","CoordToArray2D","CoordAdd2D","CoordSub2D","Coord","z","VectorDot","IsCollinearWith","IsPerpendicularWith","Add","Sub","axis","u","v","w","ToCoord2D","zNormal","Vector","VectorCross","rotated","CoordFromArray","CoordToArray","CoordAdd","CoordSub","result","MatrixDeterminant2x2","m00","m01","m10","m11","MatrixDeterminant3x3","m02","m12","m20","m21","m22","subDet1","subDet2","subDet3","MatrixDeterminant4x4","m03","m13","m23","m30","m31","m32","m33","subDet4","Orientation","Invalid","CounterClockwise","Clockwise","MidCoord2D","CoordOrientation2D","c","determinant","CoordSignedDistance2D","abDirection","PolarToCartesian","radius","theta","GetArcLengthFromAngle","GetAngleFromArcLength","arcLength","MidCoord","CoordSignedDistance","GetVectorsFullAngle","CoordOrientation","a2","b2","c2","orientation","SphericalToCartesian","phi","CylindricalToCartesian","height","GetArcLength","GetFullArcLength","CalculateCentroid","coords","centroid","CalculateTriangleNormal","v0","v1","v2","CalculateNormal","nextIndex","next","BarycentricInterpolation","vertex0","vertex1","vertex2","value0","value1","value2","position","GetTriangleArea","s","areaSquare","edge0","edge1","edge2","distance0","distance1","distance2","area","area0","area1","area2","interpolated0","interpolated1","interpolated2","interpolated","MatrixIdentity","MatrixClone","matrix","MatrixTranspose","MatrixVectorMultiply","vector","a00","a01","a02","a03","b00","b01","b02","b03","b10","b11","b12","b13","b20","b21","b22","b23","b30","b31","b32","b33","MatrixMultiply","matrix1","matrix2","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","MatrixDeterminant","b04","b05","b06","b07","b08","b09","MatrixInvert","MatrixTranslation","MatrixRotation","u2","w2","MatrixRotationQuaternion","quaternion","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","MatrixRotationX","MatrixRotationY","MatrixRotationZ","ApplyTransformation","resultVector","ApplyRotation","CoordSystem","e1","e2","e3","ToDirectionVectors","ToAbsoluteCoords","CoordSectorPosition2D","CoordInsideOfSector","CoordOnSectorEndCoord","CoordOutsideOfSector","SectorSectorPosition2D","SectorsDontIntersect","SectorsIntersectCoincident","SectorsIntersectEndPoint","SectorsIntersectOnePoint","CoordSectorPosition","Sector2D","beg","GetLength","CoordPosition","x1","y1","ux","uy","SectorPosition","sector","intersection","IsOnSegment","max","min","calcIntersection","aBeg","aEnd","bBeg","bEnd","equalBeg","equalEnd","x3","y3","x4","y4","numeratorA","numeratorB","denominator","distA","distB","ProjectCoord","denom","dir","Sector","z1","bu","GetSectorSegmentation2D","segmentation","offseted","step","GetSectorSegmentation","CoordLinePosition2D","CoordOnLine","CoordAtLineLeft","CoordAtLineRight","LineLinePosition2D","LinesDontIntersect","LinesIntersectsOnePoint","LinesIntersectsCoincident","CoordLinePosition","CoordOutsideOfLine","LineLinePosition","Line2D","LinePosition","line","Line","projected","ClosestPoint","thisClosestPoint","lineClosestPoint","Dmnop","m","n","o","p","aDir","aStart","bDir","bStart","d1010","d0210","d0232","d3210","d3232","nom","mua","mub","aClosest","bClosest","Box2D","GetCenter","Box","GetSize","IsCoordInside","BoxUnion","aBox","bBox","Sphere","center","GetRadius","Transformation","GetMatrix","SetMatrix","Append","Apply","IdentityTransformation","transformation","TranslationTransformation","translation","OffsetTransformation","RotationTransformation","RotationXTransformation","RotationYTransformation","RotationZTransformation","RotationXYZTransformation","xAngle","yAngle","zAngle","CoordPlanePosition","CoordOnPlane","CoordInFrontOfPlane","CoordAtBackOfPlane","LinePlanePosition","LineParallelToPlane","LineIntersectsPlane","Plane","d","GetNormal","CoordDistance","signed","side","LineIntersection","GetPlaneFromCoordAndDirection","plane","pa","pb","pc","pd","GetPlaneFromThreeCoords","CoordPlaneSignedDirectionalDistance","CoordPlaneDirectionalDistance","MatrixView","eye","up","MatrixPerspective","fieldOfView","aspectRatio","nearPlane","farPlane","f","tan","nf","Project","viewPort","input","viewMatrix","perspectiveMatrix","projectionMatrix","output","Unproject","inverseMatrix","ConvexHull2D","FindNextCoord","first","minValue","minIndex","FindLeftMostCoord","ConvexHull3D","AddVertex","body","vertex","vertices","AddEdge","triangleIndex","edgeIndex","edges","vert1","vert2","newEdge","tri1","tri2","edge","AddTriangle","triangles","edge3","triangle","valid","RemoveTriangleFromEdge","RemoveTriangle","CheckTetrahedronOrientation","aCoord","bCoord","cCoord","dCoord","adSub","bdSub","cdSub","GetTetrahedronVolume","AddCoordToHull","edge1Vis","edge2Vis","edge3Vis","visibleTriangles","newTriangle","newTriangles","AddInitialTetrahedron","Complexity","Convex","Concave","Complex","CoordPolygonPosition2D","OnVertex","OnEdge","Inside","Outside","SectorPolygonPosition2D","IntersectionOnePoint","IntersectionCoincident","IntersectionOnVertex","NoIntersection","Polygon2D","cache","Clear","AddVertexCoord","ClearCache","GetVertex","RemoveVertex","splice","VertexCount","EnumerateVertices","callback","GetNextVertex","GetPrevVertex","ShiftVertices","ReverseVertices","reverse","GetVertexAngle","prev","curr","prevDir","nextDir","GetSignedArea","signedArea","GetArea","GetOrientation","GetComplexity","complexity","polygonOrientain","IsConcaveVertex","GetVertexOrientation","vertexOrientations","IsConvexVertex","vertexOrientation","IntersectionCount","begYDist","endYDist","begBelow","begAbove","endBelow","endAbove","begOnLine","endOnLine","yMoveRatio","GetIntersection","upwardEdge","edgeFrom","edgeTo","vertexCount","intersections","begIndex","endIndex","edgeBegIndex","edgeEndIndex","edgeBeg","edgeEnd","currentSector","IsDiagonal","fromVertex","toVertex","polygon","DiagonalIntersectsAnyEdges","midCoord","DiagonalInsideOfPolygon","ToArray","FromArray","GetBoundingBox","boundingBox","ContourPolygon2D","contours","lastContour","AddContourVertex","contourIndex","AddContourVertexCoord","ContourVertexCount","AddContour","contour","GetLastContour","GetContourVertex","vertexIndex","GetContour","ContourCount","contourOrientation","Polygon","ToPolygon2D","ContourPolygon","ToContourPolygon2D","OffsetPolygonContour","width","prevVertex","currVertex","nextVertex","offsetedCoord","CutVertexType","Left","Right","Cut","PolygonCutter","geometryInterface","Reset","aSidePolygons","bSidePolygons","cutPolygons","allVertexType","CalculateOriginalPolygonData","cloned","CalculateCutPolygonData","CalculateEntryVertices","CalculateCuttedPolygons","originalPolygon","originalPolygonVertexTypes","cutPolygon","cutPolygonVertexTypes","cutPolygonVertexDistances","cutVertexIndices","entryVertices","entryVertexTypes","type","aSideFound","bSideFound","getVertexSide","IsIntersectionVertex","originalType","prevType","AddCutVertexToPolygon","polygonCutter","AddIntersectionVertex","originalIndex","prevIndex","getIntersectionVertex","AddOriginalVertex","nextType","createPolygon","lastVertex","getVertexDistances","aDist","bDist","SortCutVertices","GetEntryVertexType","currIndex","currSideType","prevSideType","nextSideType","currVertexDistance","prevVertexDistance","nextVertexDistance","vertexType","AddOneSideCuttedPolygons","reversed","AddEntryPairToArray","entryPairs","fromIndex","toIndex","currVertexIndex","RemoveEntryPairFromArray","AddCutPolygon","currEntryVertex","AddVertexIfNotDuplicated","startVertexIndex","currPolygon","polygonSide","FindPairIndex","startIndex","pairIndex","CreateEntryPairsArray","CutPolygon2DWithLine","leftPolygons","rightPolygons","edgeLine","lineLinePosition","refLineStart","refLineDir","refLine","distances","cutter","CutPolygonWithPlane","frontPolygons","backPolygons","linePlanePosition","polygonNormal","planeNormal","refPlaneNormal","refPlaneOrigin","refPlane","SegmentPolygon2D","xSegments","ySegments","CutPolygonsOneDirection","inputPolygons","resultPolygons","segmentCount","segmentSize","startCoordinate","segmentDir","cutDir","CutPolygon","left","right","newPolygonsToProcess","polygonsToProcess","startCoord","xSize","ySize","xSegmentSize","ySegmentSize","originalPolygons","bottomLeft","topLeft","xCuttedPolygons","yCuttedPolygons","ConvertContourPolygonToPolygon2D","inputPolygon","vertexMap","AddResultVertex","resultPolygon","originalContour","originalVertex","holeIndex","conversionData","entryPoint","IsEntryPoint","resultVertex","holeVertex","SegmentIntersectsPolygon","segmentBeg","segmentEnd","addedHoles","IsExistingEntryPosition","entryPositions","resultVertexIndex","holeVertexIndex","holePolygon","GetEntryPoint","mainContourBeg","mainEntryVertex","mainEntryContourIndex","mainEntryVertexIndex","contourBeg","contourEnd","AddHole","contourCount","mainContour","holeQueue","holeTryouts","TriangulateConvexPolygon","TriangulateConcavePolygon2D","FindSplitDiagonal","SplitPolygon","polygonData","diagonal","resultData","map","resultData1","resultData2","polygonStack","inputMap","GetInitialVertexMap","pop","TriangulatePolygon2D","TriangulatePolygon","polygon2D","TraverseOctreeNodes","octree","nodeFound","TraverseNode","node","children","child","root","CreateOctreeChildNodes","originalBox","createNodeCallback","CreateNode","dirX","dirY","dirZ","size","box","Octree","maxCoordNumInNodes","CreateNewNode","AddCoord","AddCoordToNode","FindCoord","FindNodeForCoord","FindCoordInNode","found","SplitNode","xGreater","yGreater","zGreater","myThis","nodeBox","nodeCoords","parent","newNode","TriangleOctree","AddTriangleToNode","IsTriangleInNode","BSPTree","AddPolygon","AddPolygonToNode","Traverse","inside","outside","GetNodes","NodeCount","planePolygons","cutSucceeded","AddInsidePolygonsToNode","AddOutsidePolygonsToNode","polygons","ClipPolygonWithBSPTree","bspTree","planarFrontPolygons","planarBackPolygons","CutPolygonWithNode","isPlanar","cutBackPolygons","cutFrontPolygons","cutPlanarPolygons","AddInsidePolygons","AddOutsidePolygons","CutPolygonsWithNode","AddPolygonsToArray","polygonArray","TraverseBSPTreeForEyePosition","eyePosition","coordPlanePosition","GenerateCubicBezierCurve","p0","p1","p2","p3","GetCubicBezierPoint","t","t2","t3","invT","invT2","invT3","BernsteinPolynomial","k","coefficient","BinomialCoefficient","pow","GenerateBezierCurve","points","point","bernstein","GetGaussianCParameter","epsilon","GetGaussianValue","exp","GenerateCirclePoints","segments","GetRuledMesh","aCoords","bCoords","lineSegmentation","meshSegmentation","directions","lengths","Ray","origin","GetOrigin","GetDirection","IsLengthReached","Path2D","settings","offset","scale","positionAdded","currentPolygon","MoveTo","Close","LineTo","AddPolygonPoint","CubicBezierTo","cp1x","cp1y","cp2x","cp2y","bezierPoints","CheckAndCorrectPolygon","basePolygon","IsBasePolygon","baseOrientation","baseContour","polygonOrientation","firstVertex","firstVertexPosition","FindBasePolygon","contourPolygon","PolygonCount","GetPolygon","GetPolygons","GetCurrentPolygon","polygonX","polygonY","HexColorToRGBComponents","hexColor","hexString","toString","r","substr","g","HexColorToNormalizedRGBComponents","rgb","HexColorToRGBColor","RGBComponentsToHexColor","red","green","blue","IntegerToHex","intString","Material","parameters","ambient","diffuse","specular","shininess","opacity","reflection","singleSided","pointSize","texture","textureWidth","textureHeight","MaterialSet","materials","defaultMaterial","AddMaterial","material","GetMaterial","GetDefaultMaterial","Count","BodyVertex","GetPosition","SetPosition","BodyPoint","GetVertexIndex","SetVertexIndex","HasMaterialIndex","GetMaterialIndex","SetMaterialIndex","InheritAttributes","BodyLine","GetBegVertexIndex","SetBegVertexIndex","GetEndVertexIndex","SetEndVertexIndex","BodyPolygon","curved","AddVertexIndex","InsertVertexIndex","polygonIndex","vertIndex","GetVertexIndices","SetVertexIndices","VertexIndexCount","HasCurveGroup","GetCurveGroup","SetCurveGroup","group","ReverseVertexIndices","TextureProjectionType","Planar","Cubic","Cylindrical","BodyTextureProjection","SetCubic","GetType","GetCoords","SetType","SetCoords","SetPlanar","xDirection","yDirection","zDirection","SetCylindrical","Transform","Body","AddPoint","AddLine","lines","GetVertexPosition","SetVertexPosition","GetPoint","GetLine","SetPointsMaterialIndex","SetLinesMaterialIndex","SetPolygonsMaterialIndex","SetPolygonsCurveGroup","bodyVertIndex","pointsToDelete","linesToDelete","polygonsToDelete","RemovePoint","RemoveLine","RemovePolygon","PointCount","LineCount","GetTextureProjection","projection","SetTextureProjection","SetPlanarTextureProjection","SetCubicTextureProjection","SetCylindricalTextureProjection","GetBoundingSphere","OffsetToOrigo","Merge","newPoint","newLine","newPolygon","oldVertexCount","Model","bodies","AddBody","AddBodies","GetBody","BodyCount","GetMaterialSet","MaterialCount","VertInfo","pgons","EdgeInfo","pgon1","pgon2","PolyEdgeInfo","PgonInfo","verts","pedges","AdjacencyInfo","Calculate","adjacencyInfo","pgonInfo","fromVertexIndex","toVertexIndex","pedge","currEdge","ConnectPgonAndEdgeToVert","vert","pgonIndex","indexOf","ConnectEdge","pgon","IsContourVertex","IsContourEdge","pgonCount","GetEdgePolygonCount","GetAnotherPgonOfEdge","GetPolyEdgeStartVertex","polyEdge","GetPolyEdgeEndVertex","CalculateBodyVertexToPolygon","IsSolidBody","CheckSolidBody","pgon1Reverse","pgon2Reverse","TraversePgonsAlongEdges","onPgonFound","AddNeighboursToStack","pgonStack","anotherPgon","currentPgonIndex","pgonIsProcessed","AddVertexToBody","AddPointToBody","AddLineToBody","AddPolygonToBody","CheckBody","CalculateBodyPolygonNormal","currentIndex","CalculateBodyPolygonNormals","CalculateBodyVertexNormals","average","neighbourPolygons","polygonNormals","vertexToPolygon","CalculatePolygonCurveGroups","curveAngle","curveGroups","firstGroup","lastGroup","CalculatePolygonCentroid","MakeBodyInsideOut","SoftMoveBodyVertex","currentDistance","newDistance","referenceCoord","GenerateWireBody","TriangulateWithCentroids","centroidCoord","centroidIndex","oldPolygon","oldPolygonCount","TriangulatePolygons","triangleIndices","bodyTriangle","GenerateRandomMaterials","seeded","GetRandomInt","color","AddBodyToBSPTree","id","ConvertBodyPolygonToPolygon","CalculatePlanarTextureCoord","system","xyPlane","xzPlane","yzPlane","CalculateCubicTextureCoord","currentDirection","correctPlane","maxProduct","planeSystem","CalculateCylindricalTextureCoord","e3Direction","baseLine","projectedCoord","projectedDistance","e1Direction","coordDirection","CalculatePolygonPlanarTextureCoords","CalculatePolygonCubicTextureCoords","CalculatePolygonCylindricalTextureCoords","textureValues","angles","needRepair","CalculateBodyPlanarTextureCoords","CalculateBodyCubicTextureCoords","CalculateBodyCylindricalTextureCoords","CalculateBodyTextureCoords","CutBodyByPlane","CutBodyPolygonByPlane","indexTable","rawResult","rawIndexTable","hasIndexTable","front","needCut","currentVertex","lastIndex","GetInsertedVertexIndex","originalVertexCount","polygon3D","vertexPosition","cuttedPolygon","cuttedPolygons","cuttedIndexTables","remainsVertex","originalOldToNewIndex","newPolygonVertices","GenerateRectangle","GenerateCuboid","zSize","GenerateCuboidSides","sides","GenerateSegmentedRectangle","xSegmentation","ySegmentation","xStart","yStart","xSegment","ySegment","AddVertices","top","ntop","AddPolygons","GenerateSegmentedCuboid","GetLevelOffset","level","GetLevelSideVertices","zCoord","zSegment","zStart","prevSideVertices","levelSideVertices","currSideVertices","GenerateCircle","circlePoints","topPolygon","GenerateSphere","isCurved","circle","topIndex","bottomIndex","GenerateTriangulatedSphere","iterations","iteration","oldVertexCoord","oldBody","currentEdge","edgeVertexIndices","currentPgon","polygonVertexIndices","edgeCoord","currentPolyEdge","GenerateIcosahedron","currentRadius","GenerateCylinder","withTopAndBottom","bottomPolygon","GeneratePie","GenerateCone","topRadius","bottomRadius","topDegenerated","bottomDegenerated","avgRadius","GeneratePrismGeometry","bottomVertices","topVertices","bodyPolygon","GeneratePrismFromPolygon","firtVertex","firstDirection","GeneratePrism","GeneratePrismWithHole","contourOffsets","AddContours","contourPolygon2D","simplePolygon","mapValue","topTriangle","bottomTriangle","AddTopBottomPolygons","GeneratePrismsFromPath2D","GetPrismPolygon","GeneratePrismShell","offsetedPolygon","innerBasePolygon","GenerateCylinderShell","bottom","cartesian","GenerateLineShell","basePolyLine","withStartAndEnd","innerCoord","offsetDirection","innerBasePolyLine","GenerateTorus","outerRadius","innerRadius","outerSegmentation","innerSegmentation","coord2D","axisDir","GeneratePolyTorus","GenerateRuledFromSectors","aSector","bSector","GenerateGrid","xSector","ySector","GenerateSquareGrid","GenerateRuledFromSectorsWithHeight","newVertex","newpolygonVertexIndices","topVertexCount","GenerateRuledFromCoords","GenerateRevolved","polyLine","curveMode","circular","curveModeFlag","axisNormalDir","axisLine","projectedToBaseLine","GenerateTube","basePolygons","GenerateFunctionSurface","function3D","intervalMin","intervalMax","GenerateFunctionSurfaceSolid","bottomZ","Camera","nearClippingPlane","farClippingPlane","ExplodeBody","explodeData","SeparateByMaterial","itemsByMaterial","itemsWithNoMaterial","itemCount","getMaterial","ExplodePointsByMaterial","pointIndices","materialIndex","onPointGeometryStart","onPoint","onPointGeometryEnd","pointsByMaterial","pointsWithNoMaterial","ExplodePoints","ExplodeLinesByMaterial","lineIndices","onLineGeometryStart","onLine","onLineGeometryEnd","linesByMaterial","linesWithNoMaterial","ExplodeLines","ExplodePolygonsByMaterial","polygonIndices","derivedData","ExplodePolygon","CreateTriangle","vertex3","normal1","normal2","normal3","uv1","uv2","uv3","onTriangle","convexPolygon","hasConvexPolygons","vertexNormals","textureCoords","onGeometryStart","onGeometryEnd","polygonsByMaterial","polygonsWithNoMaterial","hasTextureCoords","CalculatePolygonsDerivedData","ExplodePolygons","ExportBodyContentToStl","AddLineToContent","stlContent","AddTriangleToContent","useTriangulation","ExportBodyToStl","ExportModelToStl","model","ExportBodyContentToObj","vertexOffset","normalOffset","AddToContent","objContent","AddNormal","normalVector","vertCoord","ExportBodyToObj","ExportModelToObj","ExportMaterialsToGdl","rgbString","gdlContent","writeMaterials","ExportBodyGeometryToGdl","character","status","lastMaterialIndex","pedgeList","ExportBodyToGdl","ExportModelToGdl","TriangleBody","normals","uvs","defaultUVIndex","SetName","GetName","SetVertex","GetTriangleNormal","normalPosition","curve","n0","n1","n2","NormalCount","AddUV","AddDefaultUV","GetUV","UVCount","u0","u1","mat","GetTriangle","TriangleCount","Finalize","FinalizeTriangle","triangleNormals","vertexToTriangles","AddAverageNormal","neighbourTriangleIndex","neighbourTriangle","averageNormal","averageCount","neighbourTriangles","normalIndex","GetDefaultMaterialIndex","ConvertTriangleBodyToOctree","TriangleModel","AddDefaultMaterial","AddBodyToIndex","FinalizeMaterials","defaultMaterialData","rotation","FinalizeBodies","ConvertBodyToTriangleBody","ConvertModelToTriangleModel","triangleBody","ConvertTriangleModelToJsonData","ConvertBody","mesh","trianglesByMaterial","materialCount","jsonTriangles","version","meshes","jsonMaterial","ConvertMaterials","MergeJsonDataMeshes","MergeMesh","currentMesh","materialToTriangles","MergeTriangles","currentTriangles","uvOffset","trianglesIndex","triangleParameters","MergeAttributes","RayTriangleIntersection","ray","rayOrigin","rayDirection","edgeDir1","edgeDir2","pVector","isFrontFacing","invDeterminant","tVector","qVector","scaledDirection","RayBoxIntersection","rayOriginVec","rayDirectionVec","minB","maxB","quadrant","candidatePlane","originInBox","maxT","whichPlane","xCoord","intersectionCoord","RayOctreeIntersection","minIntersection","foundIntersection","calcMinIntersection","currentIntersection","RayTriangleBodyIntersection","RayTriangleModelIntersection","bodyIndex","RayTriangleModelIntersectionWithOctree","hasIntersection","BinaryReader","arrayBuffer","isLittleEndian","dataView","DataView","GetByteLength","byteLength","Skip","bytes","End","ReadBoolean","getInt8","ReadCharacter","ReadUnsignedCharacter","getUint8","ReadInteger16","getInt16","ReadUnsignedInteger16","getUint16","ReadInteger32","getInt32","ReadUnsignedInteger32","getUint32","ReadFloat32","getFloat32","ReadDouble64","getFloat64","GetArrayBufferFromURL","url","responseType","onload","response","onerror","onError","GetArrayBufferFromFile","file","reader","onloadend","event","DONE","readAsArrayBuffer","GetStringBufferFromURL","stringBuffer","GetStringBufferFromFile","readAsText","LoadMultipleBuffers","inputList","LoadMultipleBuffersInternal","currentInput","loaderFunction","isFile","isArrayBuffer","originalObject","resultBuffer","Read3dsFile","OnLog","logText","logLevel","onLog","onVertex","OnTextureVertex","onTextureVertex","OnFace","flags","onFace","OnFaceMaterial","faceIndex","materialName","onFaceMaterial","OnFaceSmoothingGroup","smoothingGroup","onFaceSmoothingGroup","ReadChunk","chunkId","chunkLength","SkipChunk","GetChunkEnd","ReadName","letter","String","fromCharCode","ReadVector","ReadChunks","endByte","chunks","ReadColorChunk","hasLinColor","MAT_COLOR","MAT_LIN_COLOR","MAT_COLOR_F","MAT_LIN_COLOR_F","ReadPercentageChunk","percentage","PERCENTAGE","PERCENTAGE_F","ReadMaterialChunk","MAT_NAME","MAT_AMBIENT","MAT_DIFFUSE","MAT_SPECULAR","MAT_SHININESS","MAT_SHININESS_STRENGTH","shininessStrength","MAT_TRANSPARENCY","transparency","MAT_TEXMAP","MAT_TEXMAP_NAME","MAT_TEXMAP_UOFFSET","MAT_TEXMAP_VOFFSET","MAT_TEXMAP_USCALE","MAT_TEXMAP_VSCALE","MAT_TEXMAP_ROTATION","ReadTextureMapChunk","onMaterial","OnMaterial","ReadFacesChunk","faceCount","TRI_MATERIAL","ReadFaceMaterialsChunk","TRI_SMOOTH","ReadFaceSmoothingGroupsChunk","ReadTransformationChunk","onTransformation","OnTransformation","ReadMeshChunk","objectName","onMesh","OnMesh","TRI_VERTEX","ReadVerticesChunk","TRI_TEXVERTEX","texVertexCount","ReadTextureVerticesChunk","TRI_FACE","TRI_TRANSFORMATION","ReadObjectChunk","OBJ_TRIMESH","OBJ_LIGHT","ReadLightChunk","OBJ_CAMERA","ReadCameraChunk","ReadObjectNodeChunk","ReadTrackVector","tmp","keyNum","OBJECT_ROTATION","objectNode","nodeId","userId","pivot","positions","rotations","scales","OBJECT_HIERARCHY","OBJECT_PIVOT","OBJECT_POSITION","OBJECT_SCALE","OBJECT_ID","onObjectNode","OnObjectNode","ReadMainChunk","EDIT3DS","EDIT_MATERIAL","EDIT_OBJECT","ReadEditorChunk","KF3DS","OBJECT_NODE","ReadKeyFrameChunk","MAIN3DS","ReadFile","Convert3dsToJsonData","OnFileRequested","onFileRequested","triangleModel","currentBody","materialNameToIndex","bodyNameToIndex","nodeHierarcy","nodes","nodeIdToIndex","GetShininess","GetOpacity","currentMaterial","textureBuffer","blob","blobURL","createObjectURL","meshName","meshData","faceToMaterial","faceToSmoothingGroup","objectNodes","nodeIndex","MatrixScale","MatrixTranslate","TransformBodyVertices","transformedVertex","currentMeshData","meshTransformation","GetMeshTransformation","nodeTransformation","GetNodeTransformation","GetNodePosition","quat","omega","GetQuatFromAxisAndAngle","GetNodeRotation","GetNodeScale","parentIndex","parentNode","parentTransformation","meshMatrix","invMeshMatrix","invMatrix","flippedMatrix","finalMatrix","FlipByXCoordinates","nodePivotPoint","GetNodePivotPoint","FinalizeMesh","hasTextureCoordinates","DuplicateBody","instanceIndex","clonedBody","currentNode","firstNode","addedBody","FinalizeMeshes","ReadObjFile","ProcessLine","objectCounter","GetIndex","GetFileName","keyword","fileNameIndex","trim","textureName","lineParts","parseFloat","normalCount","onNormal","OnNormal","uvCount","onTexCoord","OnTexCoord","partSplitted","onUseMaterial","onNewMaterial","OnNewMaterial","onMaterialComponent","OnMaterialComponent","onMaterialParameter","OnMaterialParameter","onMaterialTexture","fileStringBuffer","ProcessFile","ConvertObjToJsonData","currentMaterialIndex","globalVertices","globalNormals","globalUVs","globalToLocalVertices","globalToLocalNormals","globalToLocalUVs","log2","GetLocalIndex","globalValueArray","globalToLocalIndices","globalIndex","valueAdderFunc","globalValue","GetLocalVertexIndex","GetLocalNormalIndex","GetLocalUVIndex","hasNormals","hasUVs","ReadBinaryStlFile","triangleCount","ReadAsciiStlFile","lineIndex","nextLineIndex","currentLineIndex","currentLine","GetVertices","IsBinaryStlFile","ConvertStlToJsonData","v0Index","v1Index","v2Index","triangleNormal","ReadOffFile","readState","offHeaderFound","infoFound","readVertices","readFaces","ConvertOffToJsonData","ImportFileList","descriptors","InitFromFiles","fileList","descriptor","originalFileName","toUpperCase","extension","GetFileExtension","InitFromURLs","urlList","GetInputList","IsArrayBuffer","inputListElem","fullFileName","splitted","decodeURI","GetFileDescriptor","GetMainFileIndex","IsSupportedExtension","GetFileIndexByName","currentFileName","lastPoint","lastIndexOf","ConvertImportFileListToJsonData","importFileList","OnError","OnReady","fileNames","FileRequested","resultBuffers","requestedFileIndex","missing","requested","mainFileIndex","mainFile","mainFileBuffer","ConvertFileListToJsonData","ConvertURLListToJsonData","IsPowerOfTwo","NextPowerOfTwo","ResizeImageToPowerOfTwoSides","image","context","drawImage","getImageData","WebGLInitContext","viewport","clearColor","WebGLInitShaderProgram","vertexShader","fragmentShader","CompileShader","script","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","fragmentShaderScript","vertexShaderScript","FRAGMENT_SHADER","VERTEX_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","CreateShader","useProgram","WebGLGetFloatTextureBufferSize","ceil","WebGLCreateFloatTextureBuffer","floatArray","Float32Array","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","RGBA","FLOAT","RenderAmbientLight","RenderDirectionalLight","RenderMaterialFlags","Point","Triangle","Textured","Transparent","RenderMaterial","SetBuffers","textureImage","RenderMesh","vertexArray","normalArray","uvArray","vertexBuffer","normalBuffer","uvBuffer","SetMaterial","SetVertexArray","SetNormalArray","SetUVArray","HasVertexArray","HasNormalArray","HasUVArray","GetVertexArray","GetNormalArray","GetUVArray","GetVertexBuffer","GetNormalBuffer","GetUVBuffer","GetTransformedVertex","RenderBody","AddMesh","EnumerateMeshes","onMeshFound","meshType","EnumerateTypedMeshes","HasTypedMeshes","typedMesh","typedMeshes","EnumerateMeshesWithFlag","flag","GetTransformation","GetTransformationMatrix","SetTransformation","AppendTransformation","ShaderType","TexturedTriangle","ShaderProgram","globalParams","shaders","currentShader","currentType","cullEnabled","Init","InitGlobalParams","InitShaders","GetMaxLightCount","maxLightCount","noDirectionalLight","InitShader","shaderType","join","GetVertexShaderScript","GetFragmentShaderScript","vertexPositionAttribute","getAttribLocation","vertexNormalAttribute","ambientLightColorUniform","getUniformLocation","lightUniforms","diffuseColor","specularColor","materialUniforms","ambientColor","vMatrixUniform","pMatrixUniform","tMatrixUniform","vertexUVAttribute","samplerUniform","pointSizeUniform","InitShaderParameters","enable","DEPTH_TEST","depthFunc","LEQUAL","BLEND","blendEquation","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","disable","CULL_FACE","CompileMaterial","textureLoaded","Image","src","resizedImage","LINEAR","LINEAR_MIPMAP_LINEAR","UNSIGNED_BYTE","generateMipmap","CompileMesh","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","itemSize","numItems","GetShader","UseShader","SetParameters","ambientLight","directionalLights","GetLight","light","lightDirection","uniform3f","uniformMatrix4fv","SetCullEnabled","DrawArrays","uniform1f","enableVertexAttribArray","vertexAttribPointer","activeTexture","TEXTURE0","uniform1i","drawArrays","TRIANGLES","POINTS","LINES","Renderer","InitContext","InitView","InitLights","InitBodies","SetClearColor","SetAmbientLight","AddLight","RemoveLight","RemoveLights","renderBody","renderBodies","EnumerateBodies","onBodyFound","RemoveBody","RemoveBodies","Resize","FindObjects","camera","screenX","screenY","screenCoord","unprojected","renderMesh","sort","Render","DrawMeshes","renderer","materialType","HasFlag","MaterialTypeToShaderType","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","PointCloudRenderer","InitBuffers","CreateShaderFromScript","vertexColorAttribute","SetPointSize","AddPoints","colors","pointBuffer","pointArray","colorBuffer","colorArray","RemovePoints","ConvertBodyToRenderBody","MaterialToRenderMaterial","renderAmbient","renderDiffuse","renderSpecular","renderMaterial","begVertex","endVertex","ConvertModelToRenderBodies","ConvertJSONDataToRenderBodies","asyncCallbacks","meshIndex","resultBodies","ConvertTrianglesToRenderMesh","GetTextureCoordinate","AppendTriangleCoords","targetArray","sourceArray","indexArray","componentCount","sourceVertexIndex","componentIndex","hasTexture","transformedUV","ConvertMeshToRenderBody","Mouse","down","button","ctrl","alt","diff","Down","div","eventParameters","which","shiftKey","ctrlKey","altKey","SetCurrent","Move","Up","Out","currX","clientX","currY","clientY","getBoundingClientRect","clientRect","pageXOffset","pageYOffset","Touch","fingers","touches","GetEventCoord","touch","pageX","pageY","OrderPolygons","GetPolygonCenter","HasLowerDistance","maxViewDistances","polygonCenterDistances","NeedToChangeOrder","needToChangeOrderCache","minViewDistances","PolygonViewOverlap","sPlane","polygonPlanes","pPlane","isSBehindP","sPolygon","isPFrontOfS","pPolygon","PolygonIsFrontOfPlane","polygonCenters","ordered","minDistance","maxDistance","polygonCenter","polygonCenterDistance","polygonViewVector","polygonDirection","polygonPlane","viewDirection","cameraPlane","CalculatePolygonValues","OrderPolygonsByMaxViewDistance","ReorderPolygons","CanvasDrawer","GetWidth","GetHeight","clearRect","fillStyle","fillRect","DrawLine","beginPath","moveTo","lineTo","stroke","DrawPolygon","closePath","fill","SVGDrawer","svgObject","svgNameSpace","getAttribute","lastChild","removeChild","svgLine","createElementNS","setAttributeNS","appendChild","pointsString","svgPolyon","DrawProjectedBody","drawMode","needClear","drawer","AddProjectedCoord","projectedPolygon","GetProjectedPolygonFromBody","orderedPolygons","GetProjectedPolygonFromPolygon","currentCoord","drawedLines","Navigation","drawCallback","resizeCallback","mouse","cameraFixUp","cameraEnableOrbit","cameraEnablePan","cameraEnableZoom","cameraNearDistanceLimit","cameraFarDistanceLimit","orbitCenter","fullscreen","addEventListener","OnMouseMove","OnMouseUp","OnMouseDown","OnMouseWheel","OnTouchStart","OnTouchMove","OnTouchEnd","OnContextMenu","OnResize","SetCamera","EnableFixUp","EnableOrbit","EnablePan","EnableZoom","SetNearDistanceLimit","limit","SetFarDistanceLimit","SetOrbitCenter","FitInWindow","offsetToOrigo","centerEyeDirection","SetFullscreen","ResizeCallback","Orbit","angleX","angleY","radAngleX","radAngleY","horizontalDirection","differentCenter","originalAngle","newAngle","verticalDirection","Pan","moveX","moveY","Zoom","ratio","zoomIn","move","DrawCallback","innerWidth","innerHeight","preventDefault","eyeCenterDistance","OnMouseOut","delta","detail","wheelDelta","SoftwareViewer","navigation","InitCanvas","InitCamera","Draw","bind","sphere","bodyAndMaterials","SpriteViewer","InitCallbacks","onPointDraw","onDrawStart","onDrawEnd","NearestPointUnderPosition","NearestPointUnderMouse","NearestPointUnderTouch","Viewer","cameraLight","InitRenderer","InitNavigation","EnableCameraLight","DisableCameraLight","GetCameraLight","PointCloudViewer","GenerateSolidWithRadius","solidName","equalRadius","GenerateTetrahedron","GenerateHexahedron","GenerateOctahedron","GenerateDodecahedron","GenerateTruncatedTetrahedron","GenerateCuboctahedron","GenerateTruncatedCube","GenerateTruncatedOctahedron","GenerateRhombicuboctahedron","GenerateTruncatedCuboctahedron","GenerateSnubCube","GenerateIcosidodecahedron","GenerateTruncatedDodecahedron","GenerateTruncatedIcosahedron","GenerateRhombicosidodecahedron","GenerateTruncatedIcosidodecahedron","GenerateSnubDodecahedron","GenerateTetrakisHexahedron","GenerateRhombicDodecahedron","GeneratePentakisDodecahedron","GenerateSmallStellatedDodecahedron","GenerateGreatDodecahedron","GenerateSmallTriambicIcosahedron","GenerateGreatStellatedDodecahedron","GenerateSmallTriakisOctahedron","GenerateStellaOctangula","GenerateTriakisTetrahedron","maxRadius","e","h","l","q","AddCumulatedPolygonToBody","vertexCoords","CalculatePolygonCentroidAndNormal","GenerateCumulatedTetrahedron","pyramidUnitHeight","edgeLength","GenerateCumulatedHexahedron","GenerateCumulatedOctahedron","GenerateCumulatedDodecahedron","GenerateCumulatedIcosahedron","LegoDimensions","legoWidth","legoSmallHeight","legoLargeHeight","legoWallWidth","legoCylinderWidth","legoCylinderHeight","legoBottomSmallCylinderWidth","legoBottomLargeCylinderWidth","legoBottomLargeCylinderWallWidth","GenerateLegoBrick","rows","columns","isLarge","hasTopCylinders","hasBottomCylinders","OffsetBody","legoDimensions","unitWidth","unitHeight","wallWidth","topCylinderWidth","topCylinderHeight","bottomSmallCylinderWidth","bottomLargeCylinderWidth","bottomLargeCylinderWallWidth","walls","cylinderCenter","cylinder","bigger","columnWise","GenerateConvexHullBody","convexHull","oldToNewIndexTable","GenerateSuperShape","aLon","bLon","mLon","n1Lon","n2Lon","n3Lon","aLat","bLat","mLat","n1Lat","n2Lat","n3Lat","CartesianToSpherical","atan2","CalculateSuperFormula","n3","abs1","abs2","CalculateSuperFormulaCoordinate","rPhi","rTheta","spherical","newCoord","CatmullClarkSubdivisionOneIteration","pgonVertices","edgeVertices","AddOriginalVertices","pgonCoord","AddPolygonVertices","edgeCoord1","edgeCoord2","AddEdgeVertices","MoveContourVertex","newVertCoord","MoveVertex","pgonAverage","edgeAverage","vertEdgeCount","currentVertCoord","edgeCountForAverage","edgeMidCoords","MoveOriginalVertices","edgeCount","nextEdge","currentEdgeVertex","nextEdgeVertex","AddNewPolygons","CatmullClarkSubdivision","BooleanOperation","operation","aBody","bBody","AddBodyVertex","AddPolygonsToBody","ClipNodePolygonsWithTree","tree","SetPolygonsUserData","aTree","bTree","aFrontPolygons","aBackPolygons","aPlanarFrontPolygons","aPlanarBackPolygons","bFrontPolygons","bBackPolygons","bPlanarFrontPolygons","resultOctree","GenerateSurface","xRange","yRange","useTriangles","getPointCallback","xDiff","yDiff","SurfaceControlPoints","GetNValue","GetMValue","GetControlPoint","InitPlanar","iStep","jStep","GenerateBezierSurface","surfaceControlPoints","uIndex","vIndex","tmp1","tmp2","SvgToModel","segmentLength","SegmentElem","elem","AddTransformedVertex","dummySVG","createSVGPoint","transformed","getCTM","matrixTransform","transformedCoord","resultCoord","contourVertexCount","SegmentCurve","originalPath","lastCoord","items","item","command","largeArcFlag","sweepFlag","commandString","pathSegType","SVGPathSeg","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_ABS","PATHSEG_ARC_REL","r1","r2","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","CreatePath","pathLength","getTotalLength","getPointAtLength","IsCurvedItem","IsSmoothItem","RemoveEqualEndVertices","firstCoord","StartNewContour","SVGPathElement","currentItem","lastMoveCoord","currentSegmentLength","hasAttribute","pathSegList","numberOfItems","getItem","PATHSEG_CLOSEPATH","PATHSEG_MOVETO_ABS","PATHSEG_MOVETO_REL","PATHSEG_LINETO_ABS","PATHSEG_LINETO_REL","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","SVGRectElement","baseVal","SVGPolygonElement","svgColor","style","parentElement","substring","firstBracket","secondBracket","numbers","SVGColorToHex","originalElem","ContourPolygonToPrisms","AppendPolygonVertices","CreateBasePolygon","AddHoleToBasePolygon","prism","prisms","currentHeight","holeBasePolygon","hasHoles","prismsAndMaterial","currentPrisms","currentPrism","AddElemType","elemType","elems","getElementsByTagName","SegmentPaths","GenerateText","text","fontSpec","fontScale","fontHeight","fontSegmentation","CreatePathFromSpecification","commands","Num","str","parts","glyphs","ha","ConvertBodyToThreeMeshes","theConversionData","textureLoadedCallback","threeGeometry","threeMaterial","THREE","PointsMaterial","Geometry","Points","Vector3","LineBasicMaterial","LineSegments","hasOpacity","MeshPhongMaterial","DoubleSide","transparent","theMaterial","loader","TextureLoader","load","wrapS","RepeatWrapping","wrapT","needsUpdate","computeFaceNormals","Mesh","lastVertexIndex","face","Face3","faces","Vector2","faceVertexUvs","ConvertModelToThreeMeshes","currentMeshes","ConvertJSONDataToThreeMeshes","resultMeshes","AddTriangles","materialData","textureOffset","textureScale","textureRotation","Color","setRGB","getHex","v3","u3","lastFace","textureUVs","geometry","originalJsonMaterialIndex","originalJsonMeshIndex","ThreeViewer","scene","directionalLight","runBeforeRender","runAfterRender","cameraMove","drawLoop","enableDraw","InitSettings","InitThree","DrawIfNeeded","cameraEyePosition","cameraCenterPosition","cameraUpVector","lightAmbientColor","lightDiffuseColor","Scene","antialias","WebGLRenderer","setClearColor","setSize","PerspectiveCamera","add","AmbientLight","DirectionalLight","lightPosition","subVectors","set","SetRunBeforeRender","SetRunAfterRender","AddMeshes","MeshCount","traverse","IsRelevantObject","VisibleMeshCount","IsVisibleObject","FaceCount","GetMesh","ShowMesh","visible","HideMesh","RemoveMesh","dispose","remove","RemoveMeshes","RemoveLastMesh","aspect","updateProjectionMatrix","FitMeshesInWindow","GetFilteredBoundingSphere","AdjustClippingPlanes","radiusLimit","near","far","GetFilteredCenter","GetFilteredBoundingBox","needToProcess","clone","GetObjectsUnderPosition","mouseX","mouseY","cameraPosition","unproject","sub","normalize","Raycaster","intersectObjects","GetObjectsUnderMouse","GetObjectsUnderTouch","ProjectVector","halfWidth","halfHeight","project","EnableDraw","lookAt","render","requestAnimationFrame","StartDrawLoop","threeObj","skyalrk","jsm"],"mappings":"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AA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KAEAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KAEAA,GAS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,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KAEAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,KACAhM,EAAA6n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,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KAEAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,MACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,MACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,MACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MAEAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,I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,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,GAAA,GAAA,KAEAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAhM,EAAA6nC,iBAAA77B,G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","file":"../skylark-jsmodeler-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        return ns[name] = obj2;\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-langx/skylark',[\r\n    \"skylark-langx-ns\"\r\n], function(ns) {\r\n\treturn ns;\r\n});\r\n\ndefine('skylark-jsmodeler/core/jsm',[],function(){\n\tvar JSM = function ()\n\t{\n\t\tthis.mainVersion = 0;\n\t\tthis.subVersion = 45;\n\t};\n\n\t/**\n\t* Function: RandomNumber\n\t* Description: Generates a random number between two numbers.\n\t* Parameters:\n\t*\tfrom {number} lowest random result\n\t*\tto {number} highest random result\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.RandomNumber = function (from, to)\n\t{\n\t\treturn Math.random () * (to - from) + from;\n\t};\n\n\t/**\n\t* Function: RandomInt\n\t* Description: Generates a random integer between two integers.\n\t* Parameters:\n\t*\tfrom {integer} lowest random result\n\t*\tto {integer} highest random result\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.RandomInt = function (from, to)\n\t{\n\t\treturn Math.floor ((Math.random () * (to - from + 1)) + from);\n\t};\n\n\t/**\n\t* Function: RandomBoolean\n\t* Description: Generates a random boolean value.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.RandomBoolean = function ()\n\t{\n\t\treturn JSM.RandomInt (0, 1) === 1;\n\t};\n\n\t/**\n\t* Function: SeededRandomInt\n\t* Description: Generates a random integer between two integers. A seed number can be specified.\n\t* Parameters:\n\t*\tfrom {integer} lowest random result\n\t*\tto {integer} highest random result\n\t*\tseed {integer} seed value\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SeededRandomInt = function (from, to, seed)\n\t{\n\t    var random = ((seed * 9301 + 49297) % 233280) / 233280;\n\t\treturn Math.floor ((random * (to - from + 1)) + from);\n\t};\n\n\t/**\n\t* Function: ValueOrDefault\n\t* Description: Returns the given value, or a default if it is undefined.\n\t* Parameters:\n\t*\tval {anything} new value\n\t*\tdef {anything} default value\n\t* Returns:\n\t*\t{anything} the result\n\t*/\n\tJSM.ValueOrDefault = function (val, def)\n\t{\n\t\tif (val === undefined || val === null) {\n\t\t\treturn def;\n\t\t}\n\t\treturn val;\n\t};\n\n\t/**\n\t* Function: PrevIndex\n\t* Description: Returns the circular previous index for an array with the given length.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t*\tlength {integer} the number of indices\n\t*/\n\tJSM.PrevIndex = function (index, length)\n\t{\n\t\treturn index > 0 ? index - 1 : length - 1;\n\t};\n\n\t/**\n\t* Function: NextIndex\n\t* Description: Returns the circular next index for an array with the given length.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t*\tlength {integer} the number of indices\n\t*/\n\tJSM.NextIndex = function (index, length)\n\t{\n\t\treturn index < length - 1 ? index + 1 : 0;\n\t};\n\n\t/**\n\t* Function: CopyObjectProperties\n\t* Description: Copies one object properties to another object.\n\t* Parameters:\n\t*\tsource {anything} source object\n\t*\ttarget {anything} target object\n\t*\toverwrite {boolean} overwrite existing properties\n\t*/\n\tJSM.CopyObjectProperties = function (source, target, overwrite)\n\t{\n\t\tif (source === undefined || source === null ||\n\t\t\ttarget === undefined || target === null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar property;\n\t\tfor (property in source) {\n\t\t\tif (source.hasOwnProperty (property)) {\n\t\t\t\tif (overwrite || target[property] === undefined || target[property] === null) {\n\t\t\t\t\ttarget[property] = source[property];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GetObjectProperty\n\t* Description: Returns the given property of the object. If it doesn't exist, returns the given default value.\n\t* Parameters:\n\t*\tobject {anything} the object\n\t*\tpropertyName {string} the name of the property\n\t*\tdefaultValue {anything} the default value\n\t*/\n\tJSM.GetObjectProperty = function (object, propertyName, defaultValue)\n\t{\n\t\tif (object === undefined || object === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tvar propertyValue = object[propertyName];\n\t\tif (propertyValue === undefined || propertyValue === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\t\n\t\treturn propertyValue;\n\t};\n\n\t/**\n\t* Function: Message\n\t* Description: Writes a message to the console.\n\t* Parameters:\n\t*\tmessage {string} the message\n\t*/\n\tJSM.Message = function (message)\n\t{\n\t\tconsole.log ('JSModeler: ' + message);\n\t};\n\n\treturn JSM;\n});\n\n\n\ndefine('skylark-jsmodeler/core/timer',[\"./jsm\"],function(JSM){\n\t/**\n\t* Class: Timer\n\t* Description: Utility class for time measure.\n\t*/\n\tJSM.Timer = function ()\t{\n\t\tthis.start = 0;\n\t\tthis.stop = 0;\n\t};\n\n\t/**\n\t* Function: Timer.Start\n\t* Description: Starts the timer.\n\t*/\n\tJSM.Timer.prototype.Start = function ()\t{\n\t\tvar date = new Date ();\n\t\tthis.start = date.getTime ();\n\t};\n\n\t/**\n\t* Function: Timer.Stop\n\t* Description: Stops the timer.\n\t*/\n\tJSM.Timer.prototype.Stop = function ()\t{\n\t\tvar date = new Date ();\n\t\tthis.end = date.getTime ();\n\t};\n\n\t/**\n\t* Function: Timer.Result\n\t* Description: Returns the time between start and stop.\n\t* Returns:\n\t*\t{number} The result.\n\t*/\n\tJSM.Timer.prototype.Result = function (){\n\t\treturn (this.end - this.start);\n\t};\n\n\t/**\n\t* Class: FPSCounter\n\t* Description:\n\t*\tUtility class for FPS count. It calculates the frames and returns FPS count for the last interval\n\t*\twith the given length. The Get function should called in every frame.\n\t*/\n\tJSM.FPSCounter = function (){\n\t\tthis.start = null;\n\t\tthis.frames = null;\n\t\tthis.current = null;\n\t};\n\n\t/**\n\t* Function: FPSCounter.Get\n\t* Description: Returns the FPS count for the last interval with the given length.\n\t* Parameters:\n\t*\tinterval {integer} the interval length in milliseconds\n\t* Returns:\n\t*\t{integer} The result.\n\t*/\n\tJSM.FPSCounter.prototype.Get = function (interval)\t{\n\t\tvar date = new Date ();\n\t\tvar end = date.getTime ();\n\t\tif (this.start === null) {\n\t\t\tthis.start = end;\n\t\t\tthis.frames = 0;\n\t\t\tthis.current = 0;\n\t\t}\n\n\t\tif (interval === null || interval === undefined) {\n\t\t\tinterval = 1000;\n\t\t}\n\t\t\n\t\tthis.frames = this.frames + 1;\n\t\tvar elapsed = end - this.start;\n\t\tif (elapsed >= interval) {\n\t\t\tthis.current = 1000 * (this.frames / elapsed);\n\t\t\tthis.start = end;\n\t\t\tthis.frames = 0;\n\t\t}\n\n\t\treturn parseInt (this.current, 10);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/algorithm',[\"./jsm\"],function(JSM){\n\n\t/**\n\t* Function: SwapArrayValues\n\t* Description: Swaps to array values.\n\t* Parameters:\n\t*\tarray {anything[]} the array\n\t*\tfrom {integer} from index\n\t*\tto {integer} to index\n\t*/\n\tJSM.SwapArrayValues = function (array, from, to){\n\t\tvar temp = array[from];\n\t\tarray[from] = array[to];\n\t\tarray[to] = temp;\n\t};\n\n\t/**\n\t* Function: BubbleSort\n\t* Description: Sorts an array with bubble sort.\n\t* Parameters:\n\t*\tarray {anything[]} the array to sort\n\t*\tonCompare {function} the compare function\n\t*\tonSwap {function} the swap function\n\t*/\n\tJSM.BubbleSort = function (array, onCompare, onSwap){\n\t\tif (array.length < 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar compareFunction = onCompare;\n\t\tif (compareFunction === undefined || compareFunction === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar swapFunction = onSwap;\n\t\tif (swapFunction === undefined || swapFunction === null) {\n\t\t\tswapFunction = function (i, j) {\n\t\t\t\tJSM.SwapArrayValues (array, i, j);\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < array.length - 1; i++) {\n\t\t\tfor (j = 0; j < array.length - i - 1; j++) {\n\t\t\t\tif (!compareFunction (array[j], array[j + 1])) {\n\t\t\t\t\tswapFunction (j, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: ShiftArray\n\t* Description: Shifts an array.\n\t* Parameters:\n\t*\tarray {anything[]} the array to shift\n\t*\tcount {integer} shift count\n\t*/\n\tJSM.ShiftArray = function (array, count){\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tarray.push (array.shift ());\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/async',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: AsyncRunTask\n\t* Description:\n\t*\tCalls a function multiple times asynchronously. If the environment\n\t*\tis not specified, it will run synchronously.\n\t* Parameters:\n\t*\ttaskFunction {function} the function to run\n\t*\tcallbacks {object} callbacks for start, process, and finish\n\t*\trunCount {integer} the count of runs\n\t*\ttimeout {integer} the timeout between runs\n\t*\tuserData {anything} task specific data\n\t*/\n\tJSM.AsyncRunTask = function (taskFunction, callbacks, runCount, timeout, userData)\n\t{\n\t\tfunction OnStart (runCount, userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onStart !== undefined && callbacks.onStart !== null) {\n\t\t\t\tcallbacks.onStart (runCount, userData);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnProgress (currentCount, userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onProgress !== undefined && callbacks.onProgress !== null) {\n\t\t\t\tcallbacks.onProgress (currentCount, userData);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnFinished (userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onFinish !== undefined && callbacks.onFinish !== null) {\n\t\t\t\tcallbacks.onFinish (userData);\n\t\t\t}\n\t\t}\n\n\t\tfunction RunTask (currentCount, userData, callbacks)\n\t\t{\n\t\t\tvar needContinue = taskFunction ();\n\t\t\tOnProgress (currentCount, userData, callbacks);\n\t\t\tif (needContinue && currentCount < runCount - 1) {\n\t\t\t\tsetTimeout (function () {\n\t\t\t\t\tRunTask (currentCount + 1, userData, callbacks);\n\t\t\t\t}, timeout);\n\t\t\t} else {\n\t\t\t\tsetTimeout (function () {\n\t\t\t\t\tOnFinished (userData, callbacks);\n\t\t\t\t}, timeout);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tvar i, needContinue;\n\t\t\tfor (i = 0; i < runCount; i++) {\n\t\t\t\tneedContinue = taskFunction ();\n\t\t\t\tif (!needContinue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tOnStart (runCount, userData, callbacks);\n\t\tRunTask (0, userData, callbacks);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/check',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: IsWebGLEnabled\n\t* Description: Returns if WebGL is enabled in the browser.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsWebGLEnabled = function (){\n\t\tif (!window.WebGLRenderingContext) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tvar canvas = document.createElement ('canvas');\n\t\t\tif (!canvas.getContext ('experimental-webgl') && !canvas.getContext ('webgl')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (exception) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: IsFileApiEnabled\n\t* Description: Returns if file api is enabled in the browser.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsFileApiEnabled = function ()\t{\n\t\tif (!window.File || !window.FileReader || !window.FileList || !window.Blob || !window.URL) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/jsonloader',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: LoadJsonFile\n\t* Description: Loads a json file, and calls a callback with the parsed json.\n\t* Parameters:\n\t*\tfileName {string} the name of the json\n\t*\tonReady {function} the callback\n\t*/\n\tJSM.LoadJsonFile = function (fileName, onReady)\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.overrideMimeType ('application/json');\n\t\trequest.open ('GET', fileName, true);\n\t\trequest.onreadystatechange = function () {\n\t\t\tif (request.readyState == 4) {\n\t\t\t\tvar jsonData = JSON.parse (request.responseText);\n\t\t\t\tonReady (jsonData);\n\t\t\t}\n\t\t};\n\t\trequest.send (null);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/definitions',[\"../core/jsm\"],function(JSM){\n\tJSM.Eps = 0.00000001;\n\tJSM.Inf = 9999999999;\n\tJSM.RadDeg = 57.29577951308232;\n\tJSM.DegRad = 0.017453292519943;\n\n\t/**\n\t* Function: IsZero\n\t* Description: Determines if the given value is near zero. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsZero = function (a)\n\t{\n\t\treturn Math.abs (a) < JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsPositive\n\t* Description: Determines if the given value is positive. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsPositive = function (a)\n\t{\n\t\treturn a > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsNegative\n\t* Description: Determines if the given value is negative. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsNegative = function (a)\n\t{\n\t\treturn a < -JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsLower\n\t* Description: Determines if a value is lower than an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsLower = function (a, b)\n\t{\n\t\treturn b - a > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsGreater\n\t* Description: Determines if a value is greater than an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsGreater = function (a, b)\n\t{\n\t\treturn a - b > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsEqual\n\t* Description: Determines if two values are equal. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsEqual = function (a, b)\n\t{\n\t\treturn Math.abs (b - a) < JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsEqualWithEps\n\t* Description: Determines if two values are equal. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t*\teps {number} epsilon value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsEqualWithEps = function (a, b, eps)\n\t{\n\t\treturn Math.abs (b - a) < eps;\n\t};\n\n\t/**\n\t* Function: IsLowerOrEqual\n\t* Description: Determines if a value is lower or equal to an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsLowerOrEqual = function (a, b)\n\t{\n\t\treturn JSM.IsLower (a, b) || JSM.IsEqual (a, b);\n\t};\n\n\t/**\n\t* Function: IsGreaterOrEqual\n\t* Description: Determines if a value is greater or equal to an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsGreaterOrEqual = function (a, b)\n\t{\n\t\treturn JSM.IsGreater (a, b) || JSM.IsEqual (a, b);\n\t};\n\n\t/**\n\t* Function: Minimum\n\t* Description: Returns the minimum of two values. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Minimum = function (a, b)\n\t{\n\t\treturn JSM.IsLower (a, b) ? a : b;\n\t};\n\n\t/**\n\t* Function: Maximum\n\t* Description: Returns the maximum of two values. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Maximum = function (a, b)\n\t{\n\t\treturn JSM.IsGreater (a, b) ? a : b;\n\t};\n\n\t/**\n\t* Function: ArcSin\n\t* Description: Calculates the arcus sinus value.\n\t* Parameters:\n\t*\tvalue {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ArcSin = function (value)\n\t{\n\t\tif (JSM.IsGreaterOrEqual (value, 1.0)) {\n\t\t\treturn Math.PI / 2.0;\n\t\t} else if (JSM.IsLowerOrEqual (value, -1.0)) {\n\t\t\treturn - Math.PI / 2.0;\n\t\t}\n\t\t\n\t\treturn Math.asin (value);\n\t};\n\n\t/**\n\t* Function: ArcCos\n\t* Description: Calculates the arcus cosinus value.\n\t* Parameters:\n\t*\tvalue {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ArcCos = function (value)\n\t{\n\t\tif (JSM.IsGreaterOrEqual (value, 1.0)) {\n\t\t\treturn 0.0;\n\t\t} else if (JSM.IsLowerOrEqual (value, -1.0)) {\n\t\t\treturn Math.PI;\n\t\t}\n\t\t\n\t\treturn Math.acos (value);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coord2d',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Coord2D\n\t* Description: Represents a 2D coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*/\n\tJSM.Coord2D = function (x, y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t};\n\n\t/**\n\t* Function: Coord2D.Set\n\t* Description: Sets the coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*/\n\tJSM.Coord2D.prototype.Set = function (x, y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t};\n\n\t/**\n\t* Function: Coord2D.IsEqual\n\t* Description: Returns if the coordinate is equal with the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord2D.prototype.IsEqual = function (coord)\n\t{\n\t\treturn JSM.IsEqual (this.x, coord.x) && JSM.IsEqual (this.y, coord.y);\n\t};\n\n\t/**\n\t* Function: Coord2D.IsEqualWithEps\n\t* Description: Returns if the coordinate is equal with the given one. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*\teps {number} the epsilon\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord2D.prototype.IsEqualWithEps = function (coord, eps)\n\t{\n\t\treturn JSM.IsEqualWithEps (this.x, coord.x, eps) && JSM.IsEqualWithEps (this.y, coord.y, eps);\n\t};\n\n\t/**\n\t* Function: Coord2D.DistanceTo\n\t* Description: Calculates the coordinate distance to the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.DistanceTo = function (coord)\n\t{\n\t\treturn Math.sqrt ((coord.x - this.x) * (coord.x - this.x) + (coord.y - this.y) * (coord.y - this.y));\n\t};\n\n\t/**\n\t* Function: Coord2D.AngleTo\n\t* Description: Calculates the coordinate vector angle to the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.AngleTo = function (coord)\n\t{\n\t\tvar aDirection = this.Clone ().Normalize ();\n\t\tvar bDirection = coord.Clone ().Normalize ();\n\t\tif (aDirection.IsEqual (bDirection)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvar product = JSM.VectorDot2D (aDirection, bDirection);\n\t\treturn JSM.ArcCos (product);\n\t};\n\n\t/**\n\t* Function: Coord2D.Length\n\t* Description: Calculates the length of the coordinate vector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.Length = function ()\n\t{\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y);\n\t};\n\n\t/**\n\t* Function: Coord2D.MultiplyScalar\n\t* Description: Multiplies the vector with a scalar.\n\t* Parameters:\n\t*\tscalar {number} the scalar\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.MultiplyScalar = function (scalar)\n\t{\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Normalize\n\t* Description: Normalizes the coordinate vector.\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Normalize = function ()\n\t{\n\t\tvar length = this.Length ();\n\t\tif (JSM.IsPositive (length)) {\n\t\t\tthis.MultiplyScalar (1.0 / length);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.SetLength\n\t* Description: Sets the length of the coordinate vector.\n\t* Parameters:\n\t*\tlength {number} the length\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.SetLength = function (length)\n\t{\n\t\tvar thisLength = this.Length ();\n\t\tif (JSM.IsPositive (thisLength)) {\n\t\t\tthis.MultiplyScalar (length / thisLength);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Offset\n\t* Description: Offsets the coordinate.\n\t* Parameters:\n\t*\tdirection {Vector2D} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Offset = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tthis.x += normal.x * distance;\n\t\tthis.y += normal.y * distance;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Rotate\n\t* Description: Rotates the coordinate.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord2D} the origo of the rotation\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Rotate = function (angle, origo)\n\t{\n\t\tvar x = this.x - origo.x;\n\t\tvar y = this.y - origo.y;\n\t\tvar co = Math.cos (angle);\n\t\tvar si = Math.sin (angle);\n\t\tthis.x = x * co - y * si + origo.x;\n\t\tthis.y = x * si + y * co + origo.y;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.ToString\n\t* Description: Converts the coordinate values to string.\n\t* Returns:\n\t*\t{string} the string representation of the coordinate\n\t*/\n\tJSM.Coord2D.prototype.ToString = function ()\n\t{\n\t\treturn ('(' + this.x + ', ' + this.y + ')');\n\t};\n\n\t/**\n\t* Function: Coord2D.Clone\n\t* Description: Clones the coordinate.\n\t* Returns:\n\t*\t{Coord2D} a cloned instance\n\t*/\n\tJSM.Coord2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Coord2D (this.x, this.y);\n\t};\n\n\t/**\n\t* Class: Vector2D\n\t* Description: Same as Coord2D.\n\t*/\n\tJSM.Vector2D = JSM.Coord2D;\n\n\t/**\n\t* Function: CoordFromArray2D\n\t* Description: Returns a coordinate from an array of components.\n\t* Parameters:\n\t*\tarray {number[2]} the array of components\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordFromArray2D = function (array)\n\t{\n\t\treturn new JSM.Coord2D (array[0], array[1]);\n\t};\n\n\t/**\n\t* Function: CoordToArray2D\n\t* Description: Returns array of components from a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\tarray {number[2]} the result\n\t*/\n\tJSM.CoordToArray2D = function (coord)\n\t{\n\t\treturn [coord.x, coord.y];\n\t};\n\n\t/**\n\t* Function: CoordAdd2D\n\t* Description: Adds two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordAdd2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D (a.x + b.x, a.y + b.y);\n\t};\n\n\t/**\n\t* Function: CoordSub2D\n\t* Description: Subs two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordSub2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D (a.x - b.x, a.y - b.y);\n\t};\n\n\t/**\n\t* Function: VectorDot2D\n\t* Description: Calculates the dot product of two vectors.\n\t* Parameters:\n\t*\ta {Vector2D} the first vector\n\t*\tb {Vector2D} the second vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.VectorDot2D = function (a, b)\n\t{\n\t\treturn a.x * b.x + a.y * b.y;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coord',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Coord\n\t* Description: Represents a 3D coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*\tz {number} the third component\n\t*/\n\tJSM.Coord = function (x, y, z)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t};\n\n\t/**\n\t* Function: Coord.Set\n\t* Description: Sets the coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*\tz {number} the third component\n\t*/\n\tJSM.Coord.prototype.Set = function (x, y, z)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t};\n\n\t/**\n\t* Function: Coord.IsEqual\n\t* Description: Returns if the coordinate is equal with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsEqual = function (coord)\n\t{\n\t\treturn JSM.IsEqual (this.x, coord.x) && JSM.IsEqual (this.y, coord.y) && JSM.IsEqual (this.z, coord.z);\n\t};\n\n\t/**\n\t* Function: Coord.IsEqualWithEps\n\t* Description: Returns if the coordinate is equal with the given one. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\teps {number} the epsilon\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsEqualWithEps = function (coord, eps)\n\t{\n\t\treturn JSM.IsEqualWithEps (this.x, coord.x, eps) && JSM.IsEqualWithEps (this.y, coord.y, eps) && JSM.IsEqualWithEps (this.z, coord.z, eps);\n\t};\n\n\t/**\n\t* Function: Coord.DistanceTo\n\t* Description: Calculates the coordinate distance to the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.DistanceTo = function (coord)\n\t{\n\t\treturn Math.sqrt ((coord.x - this.x) * (coord.x - this.x) + (coord.y - this.y) * (coord.y - this.y) + (coord.z - this.z) * (coord.z - this.z));\n\t};\n\n\t/**\n\t* Function: Coord.AngleTo\n\t* Description: Calculates the coordinate vector angle to the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.AngleTo = function (coord)\n\t{\n\t\tvar aDirection = this.Clone ().Normalize ();\n\t\tvar bDirection = coord.Clone ().Normalize ();\n\t\tif (aDirection.IsEqual (bDirection)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvar product = JSM.VectorDot (aDirection, bDirection);\n\t\treturn JSM.ArcCos (product);\n\t};\n\n\t/**\n\t* Function: Coord.IsCollinearWith\n\t* Description: Returns if the coordinate vector is collinear with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsCollinearWith = function (coord)\n\t{\n\t\tvar angle = this.AngleTo (coord);\n\t\treturn JSM.IsEqual (angle, 0.0) || JSM.IsEqual (angle, Math.PI);\n\t};\n\n\t/**\n\t* Function: Coord.IsPerpendicularWith\n\t* Description: Returns if the coordinate vector is perpendicular with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsPerpendicularWith = function (coord)\n\t{\n\t\tvar angle = this.AngleTo (coord);\n\t\treturn JSM.IsEqual (angle, Math.PI / 2.0);\n\t};\n\n\t/**\n\t* Function: Coord.Length\n\t* Description: Calculates the length of the coordinate vector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.Length = function ()\n\t{\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y + this.z * this.z);\n\t};\n\n\t/**\n\t* Function: Coord.Add\n\t* Description: Adds the given coordinate to coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Coord.prototype.Add = function (coord)\n\t{\n\t\tthis.x += coord.x;\n\t\tthis.y += coord.y;\n\t\tthis.z += coord.z;\n\t};\n\n\t/**\n\t* Function: Coord.Sub\n\t* Description: Subs the given coordinate from coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Coord.prototype.Sub = function (coord)\n\t{\n\t\tthis.x -= coord.x;\n\t\tthis.y -= coord.y;\n\t\tthis.z -= coord.z;\n\t};\n\n\t/**\n\t* Function: Coord.MultiplyScalar\n\t* Description: Multiplies the vector with a scalar.\n\t* Parameters:\n\t*\tscalar {number} the scalar\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.MultiplyScalar = function (scalar)\n\t{\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Normalize\n\t* Description: Normalizes the coordinate vector.\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.Normalize = function ()\n\t{\n\t\tvar length = this.Length ();\n\t\tif (JSM.IsPositive (length)) {\n\t\t\tthis.MultiplyScalar (1.0 / length);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.SetLength\n\t* Description: Sets the length of the coordinate vector.\n\t* Parameters:\n\t*\tlength {number} the length\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.SetLength = function (length)\n\t{\n\t\tvar thisLength = this.Length ();\n\t\tif (JSM.IsPositive (thisLength)) {\n\t\t\tthis.MultiplyScalar (length / thisLength);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Offset\n\t* Description: Offsets the coordinate.\n\t* Parameters:\n\t*\tdirection {Vector} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.Offset = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tthis.x += normal.x * distance;\n\t\tthis.y += normal.y * distance;\n\t\tthis.z += normal.z * distance;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Rotate\n\t* Description: Rotates the coordinate.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\n\tJSM.Coord.prototype.Rotate = function (axis, angle, origo)\n\t{\n\t\tvar normal = axis.Clone ().Normalize ();\n\n\t\tvar u = normal.x;\n\t\tvar v = normal.y;\n\t\tvar w = normal.z;\n\n\t\tvar x = this.x - origo.x;\n\t\tvar y = this.y - origo.y;\n\t\tvar z = this.z - origo.z;\n\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\t\tthis.x = - u * (- u * x - v * y - w * z) * (1.0 - co) + x * co + (- w * y + v * z) * si;\n\t\tthis.y = - v * (- u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;\n\t\tthis.z = - w * (- u * x - v * y - w * z) * (1.0 - co) + z * co + (- v * x + u * y) * si;\n\t\t\n\t\tthis.x += origo.x;\n\t\tthis.y += origo.y;\n\t\tthis.z += origo.z;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.ToCoord2D\n\t* Description: Converts the coordinate to a 2D coordinate.\n\t* Parameters:\n\t*\tnormal {Vector} the normal vector for conversion\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.Coord.prototype.ToCoord2D = function (normal)\n\t{\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar zNormal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar axis = JSM.VectorCross (normal, zNormal);\n\t\tvar angle = normal.AngleTo (zNormal);\n\t\tvar rotated = this.Clone ().Rotate (axis, angle, origo);\n\t\treturn new JSM.Coord2D (rotated.x, rotated.y);\n\t};\n\n\t/**\n\t* Function: Coord.ToString\n\t* Description: Converts the coordinate values to string.\n\t* Returns:\n\t*\t{string} the string representation of the coordinate\n\t*/\n\tJSM.Coord.prototype.ToString = function ()\n\t{\n\t\treturn ('(' + this.x + ', ' + this.y + ', ' + this.z + ')');\n\t};\n\n\t/**\n\t* Function: Coord.Clone\n\t* Description: Clones the coordinate.\n\t* Returns:\n\t*\t{Coord} a cloned instance\n\t*/\n\tJSM.Coord.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Coord (this.x, this.y, this.z);\n\t};\n\n\t/**\n\t* Class: Vector\n\t* Description: Same as Coord.\n\t*/\n\tJSM.Vector = JSM.Coord;\n\n\t/**\n\t* Function: CoordFromArray\n\t* Description: Returns a coordinate from an array of components.\n\t* Parameters:\n\t*\tarray {number[3]} the array of components\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordFromArray = function (array)\n\t{\n\t\treturn new JSM.Coord (array[0], array[1], array[2]);\n\t};\n\n\t/**\n\t* Function: CoordToArray\n\t* Description: Returns array of components from a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\tarray {number[3]} the result\n\t*/\n\tJSM.CoordToArray = function (coord)\n\t{\n\t\treturn [coord.x, coord.y, coord.z];\n\t};\n\n\t/**\n\t* Function: CoordAdd\n\t* Description: Adds two coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordAdd = function (a, b)\n\t{\n\t\treturn new JSM.Coord (a.x + b.x, a.y + b.y, a.z + b.z);\n\t};\n\n\t/**\n\t* Function: CoordSub\n\t* Description: Subs two coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordSub = function (a, b)\n\t{\n\t\treturn new JSM.Coord (a.x - b.x, a.y - b.y, a.z - b.z);\n\t};\n\n\t/**\n\t* Function: VectorDot\n\t* Description: Calculates the dot product of two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.VectorDot = function (a, b)\n\t{\n\t\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n\t};\n\n\t/**\n\t* Function: VectorCross\n\t* Description: Calculates the cross product of two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.VectorCross = function (a, b)\n\t{\n\t\tvar result = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tresult.x = a.y * b.z - a.z * b.y;\n\t\tresult.y = a.z * b.x - a.x * b.z;\n\t\tresult.z = a.x * b.y - a.y * b.x;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/determinant',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixDeterminant2x2\n\t* Description: Calculates the determinant of a 2x2 matrix.\n\t* Parameters:\n\t*\tm00..m11 {4 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant2x2 = function (m00, m01,\n\t\t\t\t\t\t\t\t\t\tm10, m11)\n\t{\n\t\treturn m00 * m11 - m01 * m10;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant3x3\n\t* Description: Calculates the determinant of a 3x3 matrix.\n\t* Parameters:\n\t*\tm00..m22 {9 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant3x3 = function (m00, m01, m02,\n\t\t\t\t\t\t\t\t\t\tm10, m11, m12,\n\t\t\t\t\t\t\t\t\t\tm20, m21, m22)\n\t{\n\t\tvar subDet1 = JSM.MatrixDeterminant2x2 (m11, m12, m21, m22);\n\t\tvar subDet2 = JSM.MatrixDeterminant2x2 (m10, m12, m20, m22);\n\t\tvar subDet3 = JSM.MatrixDeterminant2x2 (m10, m11, m20, m21);\n\t\treturn m00 * subDet1 - m01 * subDet2 + m02 * subDet3;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant4x4\n\t* Description: Calculates the determinant of a 4x4 matrix.\n\t* Parameters:\n\t*\tm00..m33 {16 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant4x4 = function (m00, m01, m02, m03,\n\t\t\t\t\t\t\t\t\t\tm10, m11, m12, m13,\n\t\t\t\t\t\t\t\t\t\tm20, m21, m22, m23,\n\t\t\t\t\t\t\t\t\t\tm30, m31, m32, m33)\n\t{\n\t\tvar subDet1 = JSM.MatrixDeterminant3x3 (m11, m12, m13, m21, m22, m23, m31, m32, m33);\n\t\tvar subDet2 = JSM.MatrixDeterminant3x3 (m10, m12, m13, m20, m22, m23, m30, m32, m33);\n\t\tvar subDet3 = JSM.MatrixDeterminant3x3 (m10, m11, m13, m20, m21, m23, m30, m31, m33);\n\t\tvar subDet4 = JSM.MatrixDeterminant3x3 (m10, m11, m12, m20, m21, m22, m30, m31, m32);\n\t\treturn subDet1 * m00 - subDet2 * m01 + subDet3 * m02 - subDet4 * m03;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coordutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Orientation\n\t* Description: Orientation of coordinates.\n\t* Values:\n\t*\t{Invalid} invalid orientation or collinear\n\t*\t{CounterClockwise} counter clockwise orientation\n\t*\t{Clockwise} clockwise orientation\n\t*/\n\tJSM.Orientation = {\n\t\tInvalid : 0,\n\t\tCounterClockwise : 1,\n\t\tClockwise : 2\n\t};\n\n\t/**\n\t* Function: MidCoord2D\n\t* Description: Calculates the coordinate in the middle of two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} first coordinate\n\t*\tb {Coord2D} second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.MidCoord2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D ((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n\t};\n\n\t/**\n\t* Function: CoordOrientation2D\n\t* Description: Calculates the turn type of three coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t*\tc {Coord2D} the third coordinate\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.CoordOrientation2D = function (a, b, c)\n\t{\n\t\tvar m00 = a.x;\n\t\tvar m01 = a.y;\n\t\tvar m10 = b.x;\n\t\tvar m11 = b.y;\n\t\tvar m20 = c.x;\n\t\tvar m21 = c.y;\n\t    \n\t\tvar determinant = m00 * m11 + m01 * m20 + m10 * m21 - m11 * m20 - m01 * m10 - m00 * m21;\n\t\tif (JSM.IsPositive (determinant)) {\n\t\t\treturn JSM.Orientation.CounterClockwise;\n\t\t} else if (JSM.IsNegative (determinant)) {\n\t\t\treturn JSM.Orientation.Clockwise;\n\t\t}\n\t\t\n\t\treturn JSM.Orientation.Invalid;\t\n\t};\n\n\t/**\n\t* Function: CoordSignedDistance2D\n\t* Description: Calculates the distance of two coordinates along a direction vector.\n\t* Parameters:\n\t*\ta {Coord2D} first coordinate\n\t*\tb {Coord2D} second coordinate\n\t*\tdirection {Vector2D} direction vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordSignedDistance2D = function (a, b, direction)\n\t{\n\t\tvar abDirection = JSM.CoordSub2D (b, a);\n\t\tvar distance = a.DistanceTo (b);\n\t\t\n\t\tvar angle = abDirection.AngleTo (direction);\n\t\tif (JSM.IsPositive (angle)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: PolarToCartesian\n\t* Description: Converts a polar coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\ttheta {number} the angle component\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.PolarToCartesian = function (radius, theta)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\t\tresult.x = radius * Math.cos (theta);\n\t\tresult.y = radius * Math.sin (theta);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetArcLengthFromAngle\n\t* Description: Calculates arc length from radius and angle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\ttheta {number} the angle of rotation\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetArcLengthFromAngle = function (radius, theta)\n\t{\n\t\treturn theta * radius;\n\t};\n\n\t/**\n\t* Function: GetAngleFromArcLength\n\t* Description: Calculates angle from arc length.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tarcLength {number} the arc length\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetAngleFromArcLength = function (radius, arcLength)\n\t{\n\t\tif (JSM.IsEqual (radius, 0.0)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\t\n\t\treturn arcLength / radius;\n\t};\n\n\t/**\n\t* Function: MidCoord\n\t* Description: Calculates the coordinate in the middle of two coordinates.\n\t* Parameters:\n\t*\ta {Coord} first coordinate\n\t*\tb {Coord} second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.MidCoord = function (a, b)\n\t{\n\t\treturn new JSM.Coord ((a.x + b.x) / 2.0, (a.y + b.y) / 2.0, (a.z + b.z) / 2.0);\n\t};\n\n\t/**\n\t* Function: CoordSignedDistance\n\t* Description: Calculates the distance of two coordinates along a direction vector.\n\t* Parameters:\n\t*\ta {Coord} first coordinate\n\t*\tb {Coord} second coordinate\n\t*\tdirection {Vector} direction vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordSignedDistance = function (a, b, direction)\n\t{\n\t\tvar abDirection = JSM.CoordSub (b, a);\n\t\tvar distance = a.DistanceTo (b);\n\t\t\n\t\tvar angle = abDirection.AngleTo (direction);\n\t\tif (JSM.IsPositive (angle)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: GetVectorsFullAngle\n\t* Description: Calculates the full angle (0 to pi) of two vectors with the given normal vector.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tnormal {Vector} the normal vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetVectorsFullAngle = function (a, b, normal)\n\t{\n\t\tvar angle = a.AngleTo (b);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tif (JSM.CoordOrientation (a, origo, b, normal) == JSM.Orientation.Clockwise) {\n\t\t\tangle = 2.0 * Math.PI - angle;\n\t\t}\n\t\t\n\t\treturn angle;\n\t};\n\n\t/**\n\t* Function: CoordOrientation\n\t* Description: Calculates the turn type of three coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t*\tc {Coord} the third coordinate\n\t*\tnormal {Vector} normal vector for calculation\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.CoordOrientation = function (a, b, c, normal)\n\t{\n\t\tvar a2 = a.ToCoord2D (normal);\n\t\tvar b2 = b.ToCoord2D (normal);\n\t\tvar c2 = c.ToCoord2D (normal);\n\t\tvar orientation = JSM.CoordOrientation2D (a2, b2, c2);\n\n\t\tvar zNormal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar angle = normal.AngleTo (zNormal);\n\t\tif (JSM.IsEqual (angle, Math.PI)) {\n\t\t\tif (orientation == JSM.Orientation.CounterClockwise) {\n\t\t\t\torientation = JSM.Orientation.Clockwise;\n\t\t\t} else if (orientation == JSM.Orientation.Clockwise) {\n\t\t\t\torientation = JSM.Orientation.CounterClockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: SphericalToCartesian\n\t* Description: Converts a spherical coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\ttheta {number} the angle component\n\t*\tphi {number} the phi component\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SphericalToCartesian = function (radius, theta, phi)\n\t{\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = radius * Math.sin (theta) * Math.cos (phi);\n\t\tresult.y = radius * Math.sin (theta) * Math.sin (phi);\n\t\tresult.z = radius * Math.cos (theta);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CylindricalToCartesian\n\t* Description: Converts a cylindrical coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\theight {number} the height component\n\t*\ttheta {number} the theta component\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CylindricalToCartesian = function (radius, height, theta)\n\t{\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = radius * Math.cos (theta);\n\t\tresult.y = radius * Math.sin (theta);\n\t\tresult.z = height;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetArcLength\n\t* Description: Calculates arc length between two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tradius {number} the radius component\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetArcLength = function (a, b, radius)\n\t{\n\t\tvar angle = a.AngleTo (b);\n\t\treturn angle * radius;\n\t};\n\n\t/**\n\t* Function: GetFullArcLength\n\t* Description: Calculates arc length between two vectors with the given normal vector.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tradius {number} the radius component\n\t*\tnormal {Vector} the normal vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetFullArcLength = function (a, b, radius, normal)\n\t{\n\t\tvar angle = JSM.GetVectorsFullAngle (a, b, normal);\n\t\treturn angle * radius;\n\t};\n\n\t/**\n\t* Function: CalculateCentroid\n\t* Description: Calculates center points of the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the array of coordinates\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculateCentroid = function (coords)\n\t{\n\t\tvar count = coords.length;\n\t\tvar centroid = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tif (count >= 1) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcentroid = JSM.CoordAdd (centroid, coords[i]);\n\t\t\t}\n\t\t\tcentroid.MultiplyScalar (1.0 / count);\n\t\t}\n\n\t\treturn centroid;\n\t};\n\n\t/**\n\t* Function: CalculateTriangleNormal\n\t* Description: Calculates normal vector for the given triangle vertices.\n\t* Parameters:\n\t*\tv0 {Coord} the first vertex of the triangle\n\t*\tv1 {Coord} the second vertex of the triangle\n\t*\tv2 {Coord} the third vertex of the triangle\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateTriangleNormal = function (v0, v1, v2)\n\t{\n\t\tvar v = JSM.CoordSub (v1, v0);\n\t\tvar w = JSM.CoordSub (v2, v0);\n\t\t\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tnormal.x = (v.y * w.z - v.z * w.y);\n\t\tnormal.y = (v.z * w.x - v.x * w.z);\n\t\tnormal.z = (v.x * w.y - v.y * w.x);\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateNormal\n\t* Description: Calculates normal vector for the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the array of coordinates\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateNormal = function (coords)\n\t{\n\t\tvar count = coords.length;\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex;\n\t\t\tvar current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i % count;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = coords[currentIndex];\n\t\t\t\tnext = coords[nextIndex];\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: BarycentricInterpolation\n\t* Description: Calculates barycentric interpolation for the given values.\n\t* Parameters:\n\t*\tvertex0, vertex1, vertex2 {Coord} the vertices of interpolation\n\t*\tvalue0, value1, value2 {Coord} the values to interpolate\n\t*\tposition {Coord} the position of interpolation\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.BarycentricInterpolation = function (vertex0, vertex1, vertex2, value0, value1, value2, position)\n\t{\n\t\tfunction GetTriangleArea (a, b, c)\n\t\t{\n\t\t\tvar s = (a + b + c) / 2.0;\n\t\t\tvar areaSquare = s * (s - a) * (s - b) * (s - c);\n\t\t\tif (areaSquare < 0.0) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn Math.sqrt (areaSquare);\n\t\t}\n\t\t\n\t\tvar edge0 = vertex0.DistanceTo (vertex1);\n\t\tvar edge1 = vertex1.DistanceTo (vertex2);\n\t\tvar edge2 = vertex2.DistanceTo (vertex0);\n\t\t\n\t\tvar distance0 = vertex0.DistanceTo (position);\n\t\tvar distance1 = vertex1.DistanceTo (position);\n\t\tvar distance2 = vertex2.DistanceTo (position);\n\t\t\n\t\tvar area = GetTriangleArea (edge0, edge1, edge2);\n\t\tif (JSM.IsZero (area)) {\n\t\t\treturn value0;\n\t\t}\n\t\t\n\t\tvar area0 = GetTriangleArea (edge0, distance0, distance1);\n\t\tvar area1 = GetTriangleArea (edge1, distance1, distance2);\n\t\tvar area2 = GetTriangleArea (edge2, distance0, distance2);\n\t\t\n\t\tvar interpolated0 = value0.Clone ().MultiplyScalar (area1);\n\t\tvar interpolated1 = value1.Clone ().MultiplyScalar (area2);\n\t\tvar interpolated2 = value2.Clone ().MultiplyScalar (area0);\n\t\tvar interpolated = JSM.CoordAdd (JSM.CoordAdd (interpolated0, interpolated1), interpolated2);\n\t\tinterpolated.MultiplyScalar (1.0 / area);\n\t\treturn interpolated;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/matrix',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixIdentity\n\t* Description: Generates an identity matrix.\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixIdentity = function ()\n\t{\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixClone\n\t* Description: Clones a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixClone = function (matrix)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = matrix[0];\n\t\tresult[1] = matrix[1];\n\t\tresult[2] = matrix[2];\n\t\tresult[3] = matrix[3];\n\t\tresult[4] = matrix[4];\n\t\tresult[5] = matrix[5];\n\t\tresult[6] = matrix[6];\n\t\tresult[7] = matrix[7];\n\t\tresult[8] = matrix[8];\n\t\tresult[9] = matrix[9];\n\t\tresult[10] = matrix[10];\n\t\tresult[11] = matrix[11];\n\t\tresult[12] = matrix[12];\n\t\tresult[13] = matrix[13];\n\t\tresult[14] = matrix[14];\n\t\tresult[15] = matrix[15];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixTranspose\n\t* Description: Transposes a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixTranspose = function (matrix)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = matrix[0];\n\t\tresult[1] = matrix[4];\n\t\tresult[2] = matrix[8];\n\t\tresult[3] = matrix[12];\n\t\tresult[4] = matrix[1];\n\t\tresult[5] = matrix[5];\n\t\tresult[6] = matrix[9];\n\t\tresult[7] = matrix[13];\n\t\tresult[8] = matrix[2];\n\t\tresult[9] = matrix[6];\n\t\tresult[10] = matrix[10];\n\t\tresult[11] = matrix[14];\n\t\tresult[12] = matrix[3];\n\t\tresult[13] = matrix[7];\n\t\tresult[14] = matrix[11];\n\t\tresult[15] = matrix[15];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixVectorMultiply\n\t* Description: Multiplies a matrix with a vector.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tvector {number[4]} the vector\n\t* Returns:\n\t*\t{number[4]} the result vector\n\t*/\n\tJSM.MatrixVectorMultiply = function (matrix, vector)\n\t{\n\t\tvar a00 = vector[0];\n\t\tvar a01 = vector[1];\n\t\tvar a02 = vector[2];\n\t\tvar a03 = vector[3];\n\t\tvar b00 = matrix[0];\n\t\tvar b01 = matrix[1];\n\t\tvar b02 = matrix[2];\n\t\tvar b03 = matrix[3];\n\t\tvar b10 = matrix[4];\n\t\tvar b11 = matrix[5];\n\t\tvar b12 = matrix[6];\n\t\tvar b13 = matrix[7];\n\t\tvar b20 = matrix[8];\n\t\tvar b21 = matrix[9];\n\t\tvar b22 = matrix[10];\n\t\tvar b23 = matrix[11];\n\t\tvar b30 = matrix[12];\n\t\tvar b31 = matrix[13];\n\t\tvar b32 = matrix[14];\n\t\tvar b33 = matrix[15];\n\n\t\tvar result = [];\n\t\tresult[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n\t\tresult[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n\t\tresult[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n\t\tresult[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixMultiply\n\t* Description: Multiplies a two matrices.\n\t* Parameters:\n\t*\tmatrix1 {number[16]} first matrix\n\t*\tmatrix2 {number[16]} second matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixMultiply = function (matrix1, matrix2)\n\t{\n\t\tvar a00 = matrix1[0];\n\t\tvar a01 = matrix1[1];\n\t\tvar a02 = matrix1[2];\n\t\tvar a03 = matrix1[3];\n\t\tvar a10 = matrix1[4];\n\t\tvar a11 = matrix1[5];\n\t\tvar a12 = matrix1[6];\n\t\tvar a13 = matrix1[7];\n\t\tvar a20 = matrix1[8];\n\t\tvar a21 = matrix1[9];\n\t\tvar a22 = matrix1[10];\n\t\tvar a23 = matrix1[11];\n\t\tvar a30 = matrix1[12];\n\t\tvar a31 = matrix1[13];\n\t\tvar a32 = matrix1[14];\n\t\tvar a33 = matrix1[15];\n\t\t\n\t\tvar b00 = matrix2[0];\n\t\tvar b01 = matrix2[1];\n\t\tvar b02 = matrix2[2];\n\t\tvar b03 = matrix2[3];\n\t\tvar b10 = matrix2[4];\n\t\tvar b11 = matrix2[5];\n\t\tvar b12 = matrix2[6];\n\t\tvar b13 = matrix2[7];\n\t\tvar b20 = matrix2[8];\n\t\tvar b21 = matrix2[9];\n\t\tvar b22 = matrix2[10];\n\t\tvar b23 = matrix2[11];\n\t\tvar b30 = matrix2[12];\n\t\tvar b31 = matrix2[13];\n\t\tvar b32 = matrix2[14];\n\t\tvar b33 = matrix2[15];\n\t\t\t\n\t\tvar result = [];\n\t\tresult[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n\t\tresult[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n\t\tresult[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n\t\tresult[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n\t\tresult[4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n\t\tresult[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n\t\tresult[6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n\t\tresult[7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n\t\tresult[8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n\t\tresult[9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n\t\tresult[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n\t\tresult[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n\t\tresult[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n\t\tresult[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n\t\tresult[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n\t\tresult[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant\n\t* Description: Calculates the determinant of a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number} the determinant\n\t*/\n\tJSM.MatrixDeterminant = function (matrix)\n\t{\n\t\tvar a00 = matrix[0];\n\t\tvar a01 = matrix[1];\n\t\tvar a02 = matrix[2];\n\t\tvar a03 = matrix[3];\n\t\tvar a10 = matrix[4];\n\t\tvar a11 = matrix[5];\n\t\tvar a12 = matrix[6];\n\t\tvar a13 = matrix[7];\n\t\tvar a20 = matrix[8];\n\t\tvar a21 = matrix[9];\n\t\tvar a22 = matrix[10];\n\t\tvar a23 = matrix[11];\n\t\tvar a30 = matrix[12];\n\t\tvar a31 = matrix[13];\n\t\tvar a32 = matrix[14];\n\t\tvar a33 = matrix[15];\n\n\t\tvar b00 = a00 * a11 - a01 * a10;\n\t\tvar b01 = a00 * a12 - a02 * a10;\n\t\tvar b02 = a00 * a13 - a03 * a10;\n\t\tvar b03 = a01 * a12 - a02 * a11;\n\t\tvar b04 = a01 * a13 - a03 * a11;\n\t\tvar b05 = a02 * a13 - a03 * a12;\n\t\tvar b06 = a20 * a31 - a21 * a30;\n\t\tvar b07 = a20 * a32 - a22 * a30;\n\t\tvar b08 = a20 * a33 - a23 * a30;\n\t\tvar b09 = a21 * a32 - a22 * a31;\n\t\tvar b10 = a21 * a33 - a23 * a31;\n\t\tvar b11 = a22 * a33 - a23 * a32;\n\t\t\n\t\tvar determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\treturn determinant;\n\t};\n\n\t/**\n\t* Function: MatrixInvert\n\t* Description: Inverts a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixInvert = function (matrix)\n\t{\n\t\tvar a00 = matrix[0];\n\t\tvar a01 = matrix[1];\n\t\tvar a02 = matrix[2];\n\t\tvar a03 = matrix[3];\n\t\tvar a10 = matrix[4];\n\t\tvar a11 = matrix[5];\n\t\tvar a12 = matrix[6];\n\t\tvar a13 = matrix[7];\n\t\tvar a20 = matrix[8];\n\t\tvar a21 = matrix[9];\n\t\tvar a22 = matrix[10];\n\t\tvar a23 = matrix[11];\n\t\tvar a30 = matrix[12];\n\t\tvar a31 = matrix[13];\n\t\tvar a32 = matrix[14];\n\t\tvar a33 = matrix[15];\n\n\t\tvar b00 = a00 * a11 - a01 * a10;\n\t\tvar b01 = a00 * a12 - a02 * a10;\n\t\tvar b02 = a00 * a13 - a03 * a10;\n\t\tvar b03 = a01 * a12 - a02 * a11;\n\t\tvar b04 = a01 * a13 - a03 * a11;\n\t\tvar b05 = a02 * a13 - a03 * a12;\n\t\tvar b06 = a20 * a31 - a21 * a30;\n\t\tvar b07 = a20 * a32 - a22 * a30;\n\t\tvar b08 = a20 * a33 - a23 * a30;\n\t\tvar b09 = a21 * a32 - a22 * a31;\n\t\tvar b10 = a21 * a33 - a23 * a31;\n\t\tvar b11 = a22 * a33 - a23 * a32;\n\t\t\n\t\tvar determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = [];\n\t\t\n\t\tresult[0] = (a11 * b11 - a12 * b10 + a13 * b09) / determinant;\n\t\tresult[1] = (a02 * b10 - a01 * b11 - a03 * b09) / determinant;\n\t\tresult[2] = (a31 * b05 - a32 * b04 + a33 * b03) / determinant;\n\t\tresult[3] = (a22 * b04 - a21 * b05 - a23 * b03) / determinant;\n\t\tresult[4] = (a12 * b08 - a10 * b11 - a13 * b07) / determinant;\n\t\tresult[5] = (a00 * b11 - a02 * b08 + a03 * b07) / determinant;\n\t\tresult[6] = (a32 * b02 - a30 * b05 - a33 * b01) / determinant;\n\t\tresult[7] = (a20 * b05 - a22 * b02 + a23 * b01) / determinant;\n\t\tresult[8] = (a10 * b10 - a11 * b08 + a13 * b06) / determinant;\n\t\tresult[9] = (a01 * b08 - a00 * b10 - a03 * b06) / determinant;\n\t\tresult[10] = (a30 * b04 - a31 * b02 + a33 * b00) / determinant;\n\t\tresult[11] = (a21 * b02 - a20 * b04 - a23 * b00) / determinant;\n\t\tresult[12] = (a11 * b07 - a10 * b09 - a12 * b06) / determinant;\n\t\tresult[13] = (a00 * b09 - a01 * b07 + a02 * b06) / determinant;\n\t\tresult[14] = (a31 * b01 - a30 * b03 - a32 * b00) / determinant;\n\t\tresult[15] = (a20 * b03 - a21 * b01 + a22 * b00) / determinant;\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixTranslation\n\t* Description: Creates a translation matrix.\n\t* Parameters:\n\t*\tx {number} x offset of the transformation\n\t*\ty {number} y offset of the transformation\n\t*\tz {number} z offset of the transformation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixTranslation = function (x, y, z)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = x;\n\t\tresult[13] = y;\n\t\tresult[14] = z;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotation\n\t* Description: Creates a rotation matrix around the given axis.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotation = function (axis, angle, origo)\n\t{\n\t\tvar normal = axis.Clone ().Normalize ();\n\n\t\tvar u = normal.x;\n\t\tvar v = normal.y;\n\t\tvar w = normal.z;\n\n\t\tvar u2 = u * u;\n\t\tvar v2 = v * v;\n\t\tvar w2 = w * w;\n\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\t\t\n\t\tvar result = [];\n\t\tif (origo === undefined || origo === null) {\n\t\t\tresult[0] = u2 + (v2 + w2) * co;\n\t\t\tresult[1] = u * v * (1.0 - co) + w * si;\n\t\t\tresult[2] = u * w * (1.0 - co) - v * si;\n\t\t\tresult[3] = 0.0;\n\t\t\tresult[4] = u * v * (1.0 - co) - w * si;\n\t\t\tresult[5] = v2 + (u2 + w2) * co;\n\t\t\tresult[6] = v * w * (1.0 - co) + u * si;\n\t\t\tresult[7] = 0.0;\n\t\t\tresult[8] = u * w * (1.0 - co) + v * si;\n\t\t\tresult[9] = v * w * (1.0 - co) - u * si;\n\t\t\tresult[10] = w2 + (u2 + v2) * co;\n\t\t\tresult[11] = 0.0;\n\t\t\tresult[12] = 0.0;\n\t\t\tresult[13] = 0.0;\n\t\t\tresult[14] = 0.0;\n\t\t\tresult[15] = 1.0;\n\t\t} else {\n\t\t\tvar a = origo.x;\n\t\t\tvar b = origo.y;\n\t\t\tvar c = origo.z;\n\t\t\n\t\t\tresult[0] = u2 + (v2 + w2) * co;\n\t\t\tresult[1] = u * v * (1.0 - co) + w * si;\n\t\t\tresult[2] = u * w * (1.0 - co) - v * si;\n\t\t\tresult[3] = 0.0;\n\t\t\tresult[4] = u * v * (1.0 - co) - w * si;\n\t\t\tresult[5] = v2 + (u2 + w2) * co;\n\t\t\tresult[6] = v * w * (1.0 - co) + u * si;\n\t\t\tresult[7] = 0.0;\n\t\t\tresult[8] = u * w * (1.0 - co) + v * si;\n\t\t\tresult[9] = v * w * (1.0 - co) - u * si;\n\t\t\tresult[10] = w2 + (u2 + v2) * co;\n\t\t\tresult[11] = 0.0;\n\t\t\tresult[12] = (a * (v2 + w2) - u * (b * v + c * w)) * (1.0 - co) + (b * w - c * v) * si;\n\t\t\tresult[13] = (b * (u2 + w2) - v * (a * u + c * w)) * (1.0 - co) + (c * u - a * w) * si;\n\t\t\tresult[14] = (c * (u2 + v2) - w * (a * u + b * v)) * (1.0 - co) + (a * v - b * u) * si;\n\t\t\tresult[15] = 1.0;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationQuaternion\n\t* Description: Creates a rotation matrix from a given quaternion.\n\t* Parameters:\n\t*\tquaternion {number[4]} the quaternion\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationQuaternion = function (quaternion)\n\t{\n\t\tvar x = quaternion[0];\n\t\tvar y = quaternion[1];\n\t\tvar z = quaternion[2];\n\t\tvar w = quaternion[3];\n\n\t\tvar x2 = x + x;\n\t\tvar y2 = y + y;\n\t\tvar z2 = z + z;\n\n\t\tvar xx = x * x2;\n\t\tvar xy = x * y2;\n\t\tvar xz = x * z2;\n\t\tvar yy = y * y2;\n\t\tvar yz = y * z2;\n\t\tvar zz = z * z2;\n\t\tvar wx = w * x2;\n\t\tvar wy = w * y2;\n\t\tvar wz = w * z2;\n\n\t\tvar result = [];\n\t\tresult[0] = 1.0 - (yy + zz);\n\t\tresult[1] = xy + wz;\n\t\tresult[2] = xz - wy;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = xy - wz;\n\t\tresult[5] = 1.0 - (xx + zz);\n\t\tresult[6] = yz + wx;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = xz + wy;\n\t\tresult[9] = yz - wx;\n\t\tresult[10] = 1.0 - (xx + yy);\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationX\n\t* Description: Creates a rotation matrix around the x axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationX = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = co;\n\t\tresult[6] = si;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = -si;\n\t\tresult[10] = co;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationY\n\t* Description: Creates a rotation matrix around the y axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationY = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = co;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = -si;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = si;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = co;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationZ\n\t* Description: Creates a rotation matrix around the z axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationZ = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = co;\n\t\tresult[1] = si;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = -si;\n\t\tresult[5] = co;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ApplyTransformation\n\t* Description: Applies a matrix transformation to a coordinate.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.ApplyTransformation = function (matrix, coord)\n\t{\n\t\tvar vector = [];\n\t\tvector[0] = coord.x;\n\t\tvector[1] = coord.y;\n\t\tvector[2] = coord.z;\n\t\tvector[3] = 1.0;\n\t\t\n\t\tvar resultVector = JSM.MatrixVectorMultiply (matrix, vector);\n\t\tvar result = new JSM.Coord (resultVector[0], resultVector[1], resultVector[2]);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ApplyRotation\n\t* Description: Applies the rotation part of a matrix transformation to a coordinate.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.ApplyRotation = function (matrix, coord)\n\t{\n\t\tvar vector = [];\n\t\tvector[0] = coord.x;\n\t\tvector[1] = coord.y;\n\t\tvector[2] = coord.z;\n\t\tvector[3] = 0.0;\n\t\t\n\t\tvar resultVector = JSM.MatrixVectorMultiply (matrix, vector);\n\t\tvar result = new JSM.Coord (resultVector[0], resultVector[1], resultVector[2]);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coordsystem',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: CoordSystem\n\t* Description: Represents coordinate system.\n\t* Parameters:\n\t*\torigo {Coord} origo\n\t*\te1 {Vector} first direction vector\n\t*\te2 {Vector} second direction vector\n\t*\te3 {Vector} third direction vector\n\t*/\n\tJSM.CoordSystem = function (origo, e1, e2, e3)\n\t{\n\t\tthis.origo = origo;\n\t\tthis.e1 = e1;\n\t\tthis.e2 = e2;\n\t\tthis.e3 = e3;\n\t};\n\n\t/**\n\t* Function: CoordSystem.Set\n\t* Description: Sets the coordinate system.\n\t* Parameters:\n\t*\torigo {Coord} origo\n\t*\te1 {Vector} first direction vector\n\t*\te2 {Vector} second direction vector\n\t*\te3 {Vector} third direction vector\n\t*/\n\tJSM.CoordSystem.prototype.Set = function (origo, e1, e2, e3)\n\t{\n\t\tthis.origo = origo;\n\t\tthis.e1 = e1;\n\t\tthis.e2 = e2;\n\t\tthis.e3 = e3;\n\t};\n\n\t/**\n\t* Function: CoordSystem.CoordSystemToDirectionVectors\n\t* Description: Converts coordinate system vectors to origo relative direction vectors.\n\t* Returns:\n\t*\t{CoordSystem} this pointer\n\t*/\n\tJSM.CoordSystem.prototype.ToDirectionVectors = function ()\n\t{\n\t\tthis.e1 = JSM.CoordSub (this.e1, this.origo);\n\t\tthis.e2 = JSM.CoordSub (this.e2, this.origo);\n\t\tthis.e3 = JSM.CoordSub (this.e3, this.origo);\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: CoordSystem.CoordSystemToAbsoluteCoords\n\t* Description: Converts the coordinate system vectors to absolute coordinates.\n\t* Returns:\n\t*\t{CoordSystem} this pointer\n\t*/\n\tJSM.CoordSystem.prototype.ToAbsoluteCoords = function ()\n\t{\n\t\tthis.e1 = JSM.CoordAdd (this.e1, this.origo);\n\t\tthis.e2 = JSM.CoordAdd (this.e2, this.origo);\n\t\tthis.e3 = JSM.CoordAdd (this.e3, this.origo);\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: CoordSystem.Clone\n\t* Description: Clones the coordinate system.\n\t* Returns:\n\t*\t{CoordSystem} a cloned instance\n\t*/\n\tJSM.CoordSystem.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.CoordSystem (this.origo.Clone (), this.e1.Clone (), this.e2.Clone (), this.e3.Clone ());\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/sector',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordSectorPosition2D\n\t* Description: Position of a coordinate and a sector.\n\t* Values:\n\t*\t{CoordInsideOfSector} coordinate lies inside of sector\n\t*\t{CoordOnSectorEndCoord} coordinate lies at the end of the sector\n\t*\t{CoordOutsideOfSector} coordinate lies outside of the sector\n\t*/\n\tJSM.CoordSectorPosition2D = {\n\t\tCoordInsideOfSector : 0,\n\t\tCoordOnSectorEndCoord : 1,\n\t\tCoordOutsideOfSector : 2\n\t};\n\n\t/**\n\t* Enum: SectorSectorPosition2D\n\t* Description: Position of two sectors.\n\t* Values:\n\t*\t{SectorsDontIntersect} sectors do not intersect\n\t*\t{SectorsIntersectCoincident} sectors intersect coincident\n\t*\t{SectorsIntersectEndPoint} sectors intersect at end point\n\t*\t{SectorsIntersectOnePoint} sectors intersect one point\n\t*/\n\tJSM.SectorSectorPosition2D = {\n\t\tSectorsDontIntersect : 0,\n\t\tSectorsIntersectCoincident : 1,\n\t\tSectorsIntersectEndPoint : 2,\n\t\tSectorsIntersectOnePoint : 3\n\t};\n\n\t/**\n\t* Enum: CoordSectorPosition\n\t* Description: Position of a coordinate and a sector.\n\t* Values:\n\t*\t{CoordInsideOfSector} coordinate lies inside of sector\n\t*\t{CoordOnSectorEndCoord} coordinate lies at the end of the sector\n\t*\t{CoordOutsideOfSector} coordinate lies outside of the sector\n\t*/\n\tJSM.CoordSectorPosition = {\n\t\tCoordInsideOfSector : 0,\n\t\tCoordOnSectorEndCoord : 1,\n\t\tCoordOutsideOfSector : 2\n\t};\n\n\t/**\n\t* Class: Sector2D\n\t* Description: Represents a 2D sector.\n\t* Parameters:\n\t*\tbeg {Coord2D} the beginning coordinate\n\t*\tend {Coord2D} the ending coordinate\n\t*/\n\tJSM.Sector2D = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector2D.Set\n\t* Description: Sets the sector.\n\t* Parameters:\n\t*\tbeg {Coord2D} the beginning coordinate\n\t*\tend {Coord2D} the ending coordinate\n\t*/\n\tJSM.Sector2D.prototype.Set = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.GetLength\n\t* Description: Returns the length of the sector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sector2D.prototype.GetLength = function ()\n\t{\n\t\treturn this.beg.DistanceTo (this.end);\n\t};\n\n\t/**\n\t* Function: Sector2D.CoordPosition\n\t* Description: Calculates the position of the sector and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Sector2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar x1 = this.beg.x;\n\t\tvar y1 = this.beg.y;\n\t\tvar x2 = this.end.x;\n\t\tvar y2 = this.end.y;\n\n\t\tvar length = this.GetLength ();\n\t\tif (JSM.IsZero (length)) {\n\t\t\tif (coord.IsEqual (this.beg)) {\n\t\t\t\treturn JSM.CoordSectorPosition2D.CoordOnSectorEndCoord;\n\t\t\t}\n\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar u = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / (length * length);\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar ux = x1 + u * (x2 - x1);\n\t\tvar uy = y1 + u * (y2 - y1);\n\t\tif (!JSM.IsEqual (ux, x) || !JSM.IsEqual (uy, y)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tif (JSM.IsEqual (u, 0.0) || JSM.IsEqual (u, 1.0)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOnSectorEndCoord;\n\t\t}\n\n\t\treturn JSM.CoordSectorPosition2D.CoordInsideOfSector;\n\t};\n\n\t/**\n\t* Function: Sector2D.SectorPosition\n\t* Description: Calculates the position of the sector and the given sector.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tintersection {Coord2D} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{SectorSectorPosition2D} the result\n\t*/\n\tJSM.Sector2D.prototype.SectorPosition = function (sector, intersection)\n\t{\n\t\tfunction IsOnSegment (beg, end, coord)\n\t\t{\n\t\t\tif (!coord.IsEqual (beg) && !coord.IsEqual (end) &&\n\t\t\t\tJSM.IsLowerOrEqual (coord.x, Math.max (beg.x, end.x)) &&\n\t\t\t\tJSM.IsLowerOrEqual (coord.y, Math.max (beg.y, end.y)) &&\n\t\t\t\tJSM.IsGreaterOrEqual (coord.x, Math.min (beg.x, end.x)) &&\n\t\t\t\tJSM.IsGreaterOrEqual (coord.y, Math.min (beg.y, end.y)))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvar calcIntersection = (intersection !== undefined && intersection !== null);\n\t\t\n\t\tvar aBeg = this.beg;\n\t\tvar aEnd = this.end;\n\t\tvar bBeg = sector.beg;\n\t\tvar bEnd = sector.end;\n\t\t\n\t\tvar equalBeg = aBeg.IsEqual (bBeg) || aBeg.IsEqual (bEnd);\n\t\tvar equalEnd = aEnd.IsEqual (bBeg) || aEnd.IsEqual (bEnd);\n\t\tif (equalBeg && equalEnd) {\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectCoincident;\n\t\t}\n\n\t\tvar x1 = aBeg.x;\n\t\tvar y1 = aBeg.y;\n\t\tvar x2 = aEnd.x;\n\t\tvar y2 = aEnd.y;\n\t\tvar x3 = bBeg.x;\n\t\tvar y3 = bBeg.y;\n\t\tvar x4 = bEnd.x;\n\t\tvar y4 = bEnd.y;\n\n\t\tvar numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t\tvar numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t\tvar denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\tif (JSM.IsZero (denominator)) {\n\t\t\tif (JSM.IsZero (numeratorA) && JSM.IsZero (numeratorB)) {\n\t\t\t\tif (IsOnSegment (aBeg, aEnd, bBeg) ||\n\t\t\t\t\tIsOnSegment (aBeg, aEnd, bEnd) ||\n\t\t\t\t\tIsOnSegment (bBeg, bEnd, aBeg) ||\n\t\t\t\t\tIsOnSegment (bBeg, bEnd, aEnd))\n\t\t\t\t{\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectCoincident;\n\t\t\t\t} else if (equalBeg) {\n\t\t\t\t\tif (calcIntersection) {\n\t\t\t\t\t\tintersection.x = aBeg.x;\n\t\t\t\t\t\tintersection.y = aBeg.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t\t\t} else if (equalEnd) {\n\t\t\t\t\tif (calcIntersection) {\n\t\t\t\t\t\tintersection.x = aEnd.x;\n\t\t\t\t\t\tintersection.y = aEnd.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsDontIntersect;\n\t\t}\n\t\t\n\t\tvar distA = numeratorA / denominator;\n\t\tvar distB = numeratorB / denominator;\n\t\tif (JSM.IsLower (distA, 0.0) || JSM.IsGreater (distA, 1.0) ||\n\t\t\tJSM.IsLower (distB, 0.0) || JSM.IsGreater (distB, 1.0))\n\t\t{\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsDontIntersect;\n\t\t}\n\n\t\tif (equalBeg) {\n\t\t\tif (calcIntersection) {\n\t\t\t\tintersection.x = aBeg.x;\n\t\t\t\tintersection.y = aBeg.y;\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t} else if (equalEnd) {\n\t\t\tif (calcIntersection) {\n\t\t\t\tintersection.x = aEnd.x;\n\t\t\t\tintersection.y = aEnd.y;\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t}\n\t\t\n\t\tif (calcIntersection) {\n\t\t\tintersection.x = x1 + distA * (x2 - x1);\n\t\t\tintersection.y = y1 + distA * (y2 - y1);\n\t\t}\n\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectOnePoint;\n\t};\n\n\t/**\n\t* Function: Sector2D.ProjectCoord\n\t* Description: Calculates the projected coordinate of the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{Coord2D} the projected coordinate\n\t*/\n\tJSM.Sector2D.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\n\t\tvar beg = this.beg;\n\t\tvar end = this.end;\n\t\tvar x1 = beg.x;\n\t\tvar y1 = beg.y;\n\t\tvar x2 = end.x;\n\t\tvar y2 = end.y;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn beg.Clone ();\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1)) / denom;\n\t\tif (JSM.IsLower (u, 0.0)) {\n\t\t\treturn beg.Clone ();\n\t\t} else if (JSM.IsGreater (u, 1.0)) {\n\t\t\treturn end.Clone ();\n\t\t}\n\t\t\n\t\tvar dir = JSM.CoordSub2D (end, beg).MultiplyScalar (u);\n\t\tvar result = JSM.CoordAdd2D (beg, dir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Sector2D.Clone\n\t* Description: Clones the sector.\n\t* Returns:\n\t*\t{Sector2D} a cloned instance\n\t*/\n\tJSM.Sector2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sector2D (this.beg.Clone (), this.end.Clone ());\n\t};\n\n\t/**\n\t* Class: Sector\n\t* Description: Represents a 3D sector.\n\t* Parameters:\n\t*\tbeg {Coord} the beginning coordinate\n\t*\tend {Coord} the ending coordinate\n\t*/\n\tJSM.Sector = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.Set\n\t* Description: Sets the sector.\n\t* Parameters:\n\t*\tbeg {Coord} the beginning coordinate\n\t*\tend {Coord} the ending coordinate\n\t*/\n\tJSM.Sector.prototype.Set = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.GetLength\n\t* Description: Returns the length of the sector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sector.prototype.GetLength = function ()\n\t{\n\t\treturn this.beg.DistanceTo (this.end);\n\t};\n\n\t/**\n\t* Function: Sector.CoordPosition\n\t* Description: Calculates the position of the sector and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{CoordSectorPosition} the result\n\t*/\n\tJSM.Sector.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.beg;\n\t\tvar b = JSM.CoordSub (this.end, this.beg);\n\t\t\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\tif (a.IsEqual (coord)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOnSectorEndCoord;\n\t\t\t}\n\t\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\tvar c = JSM.CoordAdd (a, bu);\n\t\tvar distance = coord.DistanceTo (c);\n\t\tif (JSM.IsZero (distance)) {\n\t\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t\t\t} else if (JSM.IsEqual (u, 0.0) || JSM.IsEqual (u, 1.0)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOnSectorEndCoord;\n\t\t\t}\n\t\t\treturn JSM.CoordSectorPosition.CoordInsideOfSector;\n\t\t}\n\n\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t};\n\n\t/**\n\t* Function: Sector.Clone\n\t* Description: Clones the sector.\n\t* Returns:\n\t*\t{Sector} a cloned instance\n\t*/\n\tJSM.Sector.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sector (this.beg.Clone (), this.end.Clone ());\n\t};\n\n\t/**\n\t* Function: GetSectorSegmentation2D\n\t* Description: Returns the segmented coordinates of a sector.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tsegmentation {integer} the segmentation\n\t* Returns:\n\t*\t{Coord2D[*]} the result coordinates\n\t*/\n\tJSM.GetSectorSegmentation2D = function (sector, segmentation)\n\t{\n\t\tvar direction = JSM.CoordSub2D (sector.end, sector.beg);\n\t\tvar length = sector.beg.DistanceTo (sector.end);\n\t\tvar step = length / segmentation;\n\t\tvar distance = 0.0;\n\n\t\tvar result = [];\n\t\tvar i, offseted;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\toffseted = sector.beg.Clone ().Offset (direction, distance);\n\t\t\tresult.push (offseted);\n\t\t\tdistance += step;\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetSectorSegmentation\n\t* Description: Returns the segmented coordinates of a sector.\n\t* Parameters:\n\t*\tsector {Sector} the sector\n\t*\tsegmentation {integer} the segmentation\n\t* Returns:\n\t*\t{Coord[*]} the result coordinates\n\t*/\n\tJSM.GetSectorSegmentation = function (sector, segmentation)\n\t{\n\t\tvar direction = JSM.CoordSub (sector.end, sector.beg);\n\t\tvar length = sector.beg.DistanceTo (sector.end);\n\t\tvar step = length / segmentation;\n\t\tvar distance = 0.0;\n\n\t\tvar result = [];\n\t\tvar i, offseted;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\toffseted = sector.beg.Clone ().Offset (direction, distance);\n\t\t\tresult.push (offseted);\n\t\t\tdistance += step;\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/line',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordLinePosition2D\n\t* Description: Position of a coordinate and a line.\n\t* Values:\n\t*\t{CoordOnLine} coordinate lies on the line\n\t*\t{CoordAtLineLeft} coordinate lies on the left side of the line\n\t*\t{CoordAtLineRight} coordinate lies on the left side right the line\n\t*/\n\tJSM.CoordLinePosition2D = {\n\t\tCoordOnLine : 0,\n\t\tCoordAtLineLeft : 1,\n\t\tCoordAtLineRight : 2\n\t};\n\n\t/**\n\t* Enum: LineLinePosition2D\n\t* Description: Position of two lines.\n\t* Values:\n\t*\t{LinesDontIntersect} lines do not intersect\n\t*\t{LinesIntersectsCoincident} lines intersect coincident\n\t*\t{LinesIntersectsOnePoint} lines intersect one point\n\t*/\n\tJSM.LineLinePosition2D = {\n\t\tLinesDontIntersect : 0,\n\t\tLinesIntersectsOnePoint : 1,\n\t\tLinesIntersectsCoincident : 2\n\t};\n\n\t/**\n\t* Enum: CoordLinePosition\n\t* Description: Position of a coordinate and a line.\n\t* Values:\n\t*\t{CoordOnLine} coordinate lies on the line\n\t*\t{CoordOutsideOfLine} coordinate lies outside of the line\n\t*/\n\tJSM.CoordLinePosition = {\n\t\tCoordOnLine : 0,\n\t\tCoordOutsideOfLine : 1\n\t};\n\n\t/**\n\t* Enum: LineLinePosition\n\t* Description: Position of two lines.\n\t* Values:\n\t*\t{LinesDontIntersect} lines do not intersect\n\t*\t{LinesIntersectsCoincident} lines intersect coincident\n\t*\t{LinesIntersectsOnePoint} lines intersect one point\n\t*/\n\tJSM.LineLinePosition = {\n\t\tLinesDontIntersect : 0,\n\t\tLinesIntersectsOnePoint : 1,\n\t\tLinesIntersectsCoincident : 2\n\t};\n\n\t/**\n\t* Class: Line2D\n\t* Description: Represents a 2D infinite line.\n\t* Parameters:\n\t*\tstart {Coord2D} the start point of the line\n\t*\tdirection {Vector2D} the direction of the line\n\t*/\n\tJSM.Line2D = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line2D.Set\n\t* Description: Sets the line.\n\t* Parameters:\n\t*\tstart {Coord2D} the start point of the line\n\t*\tdirection {Vector2D} the direction of the line\n\t*/\n\tJSM.Line2D.prototype.Set = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line2D.CoordPosition\n\t* Description: Calculates the position of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordLinePosition2D} the result\n\t*/\n\tJSM.Line2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar position = this.CoordSignedDistance (coord);\n\t\tif (JSM.IsPositive (position)) {\n\t\t\treturn JSM.CoordLinePosition2D.CoordAtLineLeft;\n\t\t} else if (JSM.IsNegative (position)) {\n\t\t\treturn JSM.CoordLinePosition2D.CoordAtLineRight;\n\t\t}\n\n\t\treturn JSM.CoordLinePosition2D.CoordOnLine;\n\t};\n\n\t/**\n\t* Function: Line2D.CoordSignedDistance\n\t* Description: Calculates the signed distance of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Line2D.prototype.CoordSignedDistance = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\t\treturn b.x * (y - a.y) - b.y * (x - a.x);\n\t};\n\n\t/**\n\t* Function: Line2D.LinePosition\n\t* Description: Calculates the position of the line and the given line.\n\t* Parameters:\n\t*\tline {Line2D} the line\n\t*\tintersection {Coord2D} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{LineLinePosition2D} the result\n\t*/\n\tJSM.Line2D.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar x1 = this.start.x;\n\t\tvar y1 = this.start.y;\n\t\tvar x2 = this.start.x + this.direction.x;\n\t\tvar y2 = this.start.y + this.direction.y;\n\t\tvar x3 = line.start.x;\n\t\tvar y3 = line.start.y;\n\t\tvar x4 = line.start.x + line.direction.x;\n\t\tvar y4 = line.start.y + line.direction.y;\n\t\t\n\t\tvar numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t\tvar numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t\tvar denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\tif (JSM.IsZero (denominator)) {\n\t\t\tif (JSM.IsZero (numeratorA) && JSM.IsZero (numeratorB)) {\n\t\t\t\treturn JSM.LineLinePosition2D.LinesIntersectsCoincident;\n\t\t\t}\n\t\t\treturn JSM.LineLinePosition2D.LinesDontIntersect;\n\t\t}\n\n\t\tvar distance = numeratorA / denominator;\n\t\tif (intersection !== null) {\n\t\t\tintersection.x = x1 + distance * (x2 - x1);\n\t\t\tintersection.y = y1 + distance * (y2 - y1);\n\t\t}\n\t\treturn JSM.LineLinePosition2D.LinesIntersectsOnePoint;\n\t};\n\n\t/**\n\t* Function: Line2D.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{Line2D} a cloned instance\n\t*/\n\tJSM.Line2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Line2D (this.start.Clone (), this.direction.Clone ());\n\t};\n\n\t/**\n\t* Class: Line\n\t* Description: Represents a 3D infinite line.\n\t* Parameters:\n\t*\tstart {Coord} the start point of the line\n\t*\tdirection {Vector} the direction of the line\n\t*/\n\tJSM.Line = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line.Set\n\t* Description: Sets the line.\n\t* Parameters:\n\t*\tstart {Coord} the start point of the line\n\t*\tdirection {Vector} the direction of the line\n\t*/\n\tJSM.Line.prototype.Set = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line.CoordPosition\n\t* Description: Calculates the position of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tprojected {Coord} (out) the projected coordinate\n\t* Returns:\n\t*\t{CoordLinePosition} the result\n\t*/\n\tJSM.Line.prototype.CoordPosition = function (coord, projected)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\tif (projected !== undefined) {\n\t\t\t\tprojected.Set (a.x, a.y, a.z);\n\t\t\t}\n\n\t\t\tif (a.IsEqual (coord)) {\n\t\t\t\treturn JSM.CoordLinePosition.CoordOnLine;\n\t\t\t}\n\n\t\t\treturn JSM.CoordLinePosition.CoordOutsideOfLine;\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\tvar c = JSM.CoordAdd (a, bu);\n\t\tif (projected !== undefined) {\n\t\t\tprojected.Set (c.x, c.y, c.z);\n\t\t}\n\n\t\tvar distance = coord.DistanceTo (c);\n\t\tif (JSM.IsZero (distance)) {\n\t\t\treturn JSM.CoordLinePosition.CoordOnLine;\n\t\t}\n\n\t\treturn JSM.CoordLinePosition.CoordOutsideOfLine;\n\t};\n\n\t/**\n\t* Function: Line.ProjectCoord\n\t* Description: Calculates the projected coordinate of the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Line.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn a.Clone ();\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\treturn JSM.CoordAdd (a, bu);\n\t};\n\n\t/**\n\t* Function: Line.ClosestPoint\n\t* Description: Calculates the closest points between the line and a given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tthisClosestPoint {Coord} (out) the closest point on the current line\n\t*\tlineClosestPoint {Coord} (out) the closest point on the given line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.Line.prototype.ClosestPoint = function (line, thisClosestPoint, lineClosestPoint)\n\t{\n\t\tfunction Dmnop (v, m, n, o, p)\n\t\t{\n\t\t\tvar result = (v[m].x - v[n].x) * (v[o].x - v[p].x) + (v[m].y - v[n].y) * (v[o].y - v[p].y) + (v[m].z - v[n].z) * (v[o].z - v[p].z);\n\t\t\treturn result;\n\t\t}\n\n\t\tvar aDir = this.direction.Clone ().Normalize ();\n\t\tvar aStart = this.start;\n\t\tvar aEnd = JSM.CoordAdd (aStart, aDir);\n\n\t\tvar bDir = line.direction.Clone ().Normalize ();\n\t\tvar bStart = line.start;\n\t\tvar bEnd = JSM.CoordAdd (bStart, bDir);\n\t\t\n\t\tvar v = [aStart, aEnd, bStart, bEnd];\n\t\tvar d1010 = Dmnop (v, 1, 0, 1, 0);\n\t\tvar d0210 = Dmnop (v, 0, 2, 1, 0);\n\t\tvar d0232 = Dmnop (v, 0, 2, 3, 2);\n\t\tvar d3210 = Dmnop (v, 3, 2, 1, 0);\n\t\tvar d3232 = Dmnop (v, 3, 2, 3, 2);\n\t\tvar denom = (d1010 * d3232 - d3210 * d3210);\n\t\tif (JSM.IsEqual (denom, 0.0)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar nom = (d0232 * d3210 - d0210 * d3232);\n\t\tvar mua = nom / denom;\n\t\tvar mub = (d0232 + mua * d3210) / d3232;\n\n\t\tif (thisClosestPoint !== undefined) {\n\t\t\taDir.MultiplyScalar (mua);\n\t\t\tvar aClosest = JSM.CoordAdd (aStart, aDir);\n\t\t\tthisClosestPoint.Set (aClosest.x, aClosest.y, aClosest.z);\n\t\t}\n\t\t\n\t\tif (lineClosestPoint !== undefined) {\n\t\t\tbDir.MultiplyScalar (mub);\n\t\t\tvar bClosest = JSM.CoordAdd (bStart, bDir);\n\t\t\tlineClosestPoint.Set (bClosest.x, bClosest.y, bClosest.z);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Line.LinePosition\n\t* Description: Calculates the position of the line and the given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tintersection {Coord} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{LineLinePosition} the result\n\t*/\n\tJSM.Line.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar thisClosestPoint = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar lineClosestPoint = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tif (!this.ClosestPoint (line, thisClosestPoint, lineClosestPoint)) {\n\t\t\treturn JSM.LineLinePosition.LinesIntersectsCoincident;\n\t\t}\n\t\t\n\t\tif (thisClosestPoint.IsEqual (lineClosestPoint)) {\n\t\t\tif (intersection !== undefined) {\n\t\t\t\tintersection.Set (thisClosestPoint.x, thisClosestPoint.y, thisClosestPoint.z);\n\t\t\t}\n\t\t\treturn JSM.LineLinePosition.LinesIntersectsOnePoint;\n\t\t}\n\t\t\n\t\treturn JSM.LineLinePosition.LinesDontIntersect;\n\t};\n\n\t/**\n\t* Function: Line.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{Line} a cloned instance\n\t*/\n\tJSM.Line.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Line (this.start.Clone (), this.direction.Clone ());\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/box',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Box2D\n\t* Description: Represents a 2D box.\n\t* Parameters:\n\t*\tmin {Coord2D} the minimum position of the box\n\t*\tmin {Coord2D} the maximum position of the box\n\t*/\n\tJSM.Box2D = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box2D.Set\n\t* Description: Sets the box.\n\t* Parameters:\n\t*\tmin {Coord2D} the minimum position of the box\n\t*\tmin {Coord2D} the maximum position of the box\n\t*/\n\tJSM.Box2D.prototype.Set = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box2D.GetCenter\n\t* Description: Returns the center point of the box.\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.Box2D.prototype.GetCenter = function ()\n\t{\n\t\treturn JSM.MidCoord2D (this.min, this.max);\n\t};\n\n\t/**\n\t* Function: Box2D.Clone\n\t* Description: Clones the box.\n\t* Returns:\n\t*\t{Box2D} a cloned instance\n\t*/\n\tJSM.Box2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Box2D (this.min.Clone (), this.max.Clone ());\n\t};\n\n\t/**\n\t* Class: Box\n\t* Description: Represents a 3D box.\n\t* Parameters:\n\t*\tmin {Coord} the minimum position of the box\n\t*\tmin {Coord} the maximum position of the box\n\t*/\n\tJSM.Box = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box.Set\n\t* Description: Sets the box.\n\t* Parameters:\n\t*\tmin {Coord} the minimum position of the box\n\t*\tmin {Coord} the maximum position of the box\n\t*/\n\tJSM.Box.prototype.Set = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box.GetCenter\n\t* Description: Returns the center point of the box.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Box.prototype.GetCenter = function ()\n\t{\n\t\treturn JSM.MidCoord (this.min, this.max);\n\t};\n\n\t/**\n\t* Function: Box.GetSize\n\t* Description: Returns the size of the box.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Box.prototype.GetSize = function ()\n\t{\n\t\treturn JSM.CoordSub (this.max, this.min);\n\t};\n\n\t/**\n\t* Function: Box.IsCoordInside\n\t* Description: Determines if the given coordinate is inside the box.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Box.prototype.IsCoordInside = function (coord)\n\t{\n\t\tif (JSM.IsLower (coord.x, this.min.x) || JSM.IsLower (coord.y, this.min.y) || JSM.IsLower (coord.z, this.min.z)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (JSM.IsGreater (coord.x, this.max.x) || JSM.IsGreater (coord.y, this.max.y) || JSM.IsGreater (coord.z, this.max.z)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Box.Clone\n\t* Description: Clones the box.\n\t* Returns:\n\t*\t{Box} a cloned instance\n\t*/\n\tJSM.Box.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Box (this.min.Clone (), this.max.Clone ());\n\t};\n\n\t/**\n\t* Function: BoxUnion\n\t* Description: Calculates the union of two 3D boxes.\n\t* Parameters:\n\t*\taBox {Box} the first box\n\t*\tbBox {Box} the second box\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.BoxUnion = function (aBox, bBox)\n\t{\n\t\tvar min = new JSM.Coord (JSM.Minimum (aBox.min.x, bBox.min.x), JSM.Minimum (aBox.min.y, bBox.min.y), JSM.Minimum (aBox.min.z, bBox.min.z));\n\t\tvar max = new JSM.Coord (JSM.Maximum (aBox.max.x, bBox.max.x), JSM.Maximum (aBox.max.y, bBox.max.y), JSM.Maximum (aBox.max.z, bBox.max.z));\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/sphere',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Sphere\n\t* Description: Represents a sphere.\n\t* Parameters:\n\t*\tcenter {Coord} the center of the sphere\n\t*\tradius {number} the radius of the sphere\n\t*/\n\tJSM.Sphere = function (center, radius)\n\t{\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t};\n\n\t/**\n\t* Function: Sphere.Set\n\t* Description: Sets the sphere.\n\t* Parameters:\n\t*\tcenter {Coord} the center of the sphere\n\t*\tradius {number} the radius of the sphere\n\t*/\n\tJSM.Sphere.prototype.Set = function (center, radius)\n\t{\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t};\n\n\t/**\n\t* Function: Sphere.GetCenter\n\t* Description: Returns the center of the sphere.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Sphere.prototype.GetCenter = function ()\n\t{\n\t\treturn this.center;\n\t};\n\n\t/**\n\t* Function: Sphere.GetRadius\n\t* Description: Returns the radius of the sphere.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sphere.prototype.GetRadius = function ()\n\t{\n\t\treturn this.radius;\n\t};\n\n\t/**\n\t* Function: Sphere.Clone\n\t* Description: Clones the sphere.\n\t* Returns:\n\t*\t{Sphere} a cloned instance\n\t*/\n\tJSM.Sphere.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sphere (this.center.Clone (), this.radius);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/transformation',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Transformation\n\t* Description: Represents a transformation matrix.\n\t*/\n\tJSM.Transformation = function ()\n\t{\n\t\tthis.matrix = JSM.MatrixIdentity ();\n\t};\n\n\t/**\n\t* Function: Transformation.GetMatrix\n\t* Description: Returns the matrix of the transformation.\n\t* Returns:\n\t*\t{number[16]} the matrix\n\t*/\n\tJSM.Transformation.prototype.GetMatrix = function ()\n\t{\n\t\treturn this.matrix;\n\t};\n\n\t/**\n\t* Function: Transformation.SetMatrix\n\t* Description: Sets matrix of the transformation.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*/\n\tJSM.Transformation.prototype.SetMatrix = function (matrix)\n\t{\n\t\tthis.matrix = matrix;\n\t};\n\n\t/**\n\t* Function: Transformation.Append\n\t* Description: Adds a transformation to the matrix.\n\t* Parameters:\n\t*\tsource {Transformation} the another transformation\n\t*/\n\tJSM.Transformation.prototype.Append = function (source)\n\t{\n\t\tthis.matrix = JSM.MatrixMultiply (this.matrix, source.matrix);\n\t};\n\n\t/**\n\t* Function: Transformation.Apply\n\t* Description: Apply transformation to a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Transformation.prototype.Apply = function (coord)\n\t{\n\t\treturn JSM.ApplyTransformation (this.matrix, coord);\n\t};\n\n\t/**\n\t* Function: Transformation.Clone\n\t* Description: Clones the transformation.\n\t* Returns:\n\t*\t{Transformation} a cloned instance\n\t*/\n\tJSM.Transformation.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Transformation ();\n\t\tresult.matrix = JSM.MatrixClone (this.matrix);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IdentityTransformation\n\t* Description: Generates an identity transformation.\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.IdentityTransformation = function ()\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixIdentity ();\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: TranslationTransformation\n\t* Description: Generates a translation transformation.\n\t* Parameters:\n\t*\ttranslation {Vector} the translation vector\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.TranslationTransformation = function (translation)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixTranslation (translation.x, translation.y, translation.z);\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: OffsetTransformation\n\t* Description: Generates an offset transformation.\n\t* Parameters:\n\t*\tdirection {Vector} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.OffsetTransformation = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tvar translation = normal.Clone ().MultiplyScalar (distance);\n\t\treturn JSM.TranslationTransformation (translation);\n\t};\n\n\t/**\n\t* Function: RotationTransformation\n\t* Description: Generates a rotation transformation.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationTransformation = function (axis, angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixRotation (axis, angle, origo);\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationXTransformation\n\t* Description: Generates a rotation transformation around the x axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationXTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationX (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationXTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationYTransformation\n\t* Description: Generates a rotation transformation around the y axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationYTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationY (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationYTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationZTransformation\n\t* Description: Generates a rotation transformation around the z axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationZTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationZ (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationZTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationXYZTransformation\n\t* Description: Generates a rotation transformation around all axis in x, y, z order.\n\t* Parameters:\n\t*\txAngle {number} the x angle of the rotation\n\t*\tyAngle {number} the y angle of the rotation\n\t*\tzAngle {number} the z angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationXYZTransformation = function (xAngle, yAngle, zAngle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.Append (JSM.RotationXTransformation (xAngle, origo));\n\t\ttransformation.Append (JSM.RotationYTransformation (yAngle, origo));\n\t\ttransformation.Append (JSM.RotationZTransformation (zAngle, origo));\n\t\treturn transformation;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/plane',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordPlanePosition\n\t* Description: Position of a coordinate and a plane.\n\t* Values:\n\t*\t{CoordOnPlane} coordinate lies on the plane\n\t*\t{CoordInFrontOfPlane} coordinate lies in front of of the plane\n\t*\t{CoordAtBackOfPlane} coordinate lies at the back of the plane\n\t*/\n\tJSM.CoordPlanePosition = {\n\t\tCoordOnPlane : 0,\n\t\tCoordInFrontOfPlane : 1,\n\t\tCoordAtBackOfPlane : 2\n\t};\n\n\t/**\n\t* Enum: LinePlanePosition\n\t* Description: Position of a line and a plane.\n\t* Values:\n\t*\t{LineParallelToPlane} line is parallel to the plane\n\t*\t{LineIntersectsPlane} line intersects the plane\n\t*/\n\tJSM.LinePlanePosition = {\n\t\tLineParallelToPlane : 0,\n\t\tLineIntersectsPlane : 1\n\t};\n\n\t/**\n\t* Class: Plane\n\t* Description: Represents a plane.\n\t* Parameters:\n\t*\ta {number} the a component of plane equation\n\t*\tb {number} the b component of plane equation\n\t*\tc {number} the c component of plane equation\n\t*\td {number} the d component of plane equation\n\t*/\n\tJSM.Plane = function (a, b, c, d)\n\t{\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t};\n\n\t/**\n\t* Function: Plane.Set\n\t* Description: Sets the plane.\n\t* Parameters:\n\t*\ta {number} the a component of plane equation\n\t*\tb {number} the b component of plane equation\n\t*\tc {number} the c component of plane equation\n\t*\td {number} the d component of plane equation\n\t*/\n\tJSM.Plane.prototype.Set = function (a, b, c, d)\n\t{\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t};\n\n\t/**\n\t* Function: Plane.GetNormal\n\t* Description: Calculates the normal vector of the plane.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Plane.prototype.GetNormal = function ()\n\t{\n\t\treturn new JSM.Vector (this.a, this.b, this.c);\n\t};\n\n\t/**\n\t* Function: Plane.CoordSignedDistance\n\t* Description: Calculates the signed distance of a coordinate and the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Plane.prototype.CoordSignedDistance = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar distance = (a * x + b * y + c * z + d) / Math.sqrt (a * a + b * b + c * c);\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: Plane.CoordDistance\n\t* Description: Calculates the distance of a coordinate and the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Plane.prototype.CoordDistance = function (coord)\n\t{\n\t\tvar signed = this.CoordSignedDistance (coord);\n\t\treturn Math.abs (signed);\n\t};\n\n\t/**\n\t* Function: Plane.ProjectCoord\n\t* Description: Projects a coordinate to the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the projected coordinate\n\t*/\n\tJSM.Plane.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar distance = this.CoordDistance (coord);\n\t\tvar side = a * x + b * y + c * z + d;\n\t\tif (JSM.IsGreater (side, 0.0)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\tvar normal = this.GetNormal ().Normalize ();\n\t\tvar result = coord.Clone ().Offset (normal, distance);\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Plane.CoordPosition\n\t* Description: Calculates the position of the plane and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{CoordPlanePosition} thre result\n\t*/\n\tJSM.Plane.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar s = a * x + b * y + c * z + d;\n\t\tif (JSM.IsPositive (s)) {\n\t\t\treturn JSM.CoordPlanePosition.CoordInFrontOfPlane;\n\t\t} else if (JSM.IsNegative (s)) {\n\t\t\treturn JSM.CoordPlanePosition.CoordAtBackOfPlane;\n\t\t}\n\t\t\n\t\treturn JSM.CoordPlanePosition.CoordOnPlane;\n\t};\n\n\t/**\n\t* Function: Plane.LinePosition\n\t* Description: Calculates the position of the plane and the given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tintersection {Coord} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{CoordLinePosition} the result\n\t*/\n\tJSM.Plane.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar\tdirection = line.direction.Clone ().Normalize ();\n\n\t\tvar x1 = line.start.x;\n\t\tvar y1 = line.start.y;\n\t\tvar z1 = line.start.z;\n\n\t\tvar x2 = line.start.x + direction.x;\n\t\tvar y2 = line.start.y + direction.y;\n\t\tvar z2 = line.start.z + direction.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn JSM.LinePlanePosition.LineParallelToPlane;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tif (intersection !== undefined) {\n\t\t\tdirection.MultiplyScalar (u);\n\t\t\tvar i = JSM.CoordAdd (line.start, direction);\n\t\t\tintersection.Set (i.x, i.y, i.z);\n\t\t}\n\n\t\treturn JSM.LinePlanePosition.LineIntersectsPlane;\n\t};\n\n\t/**\n\t* Function: Plane.LineIntersection\n\t* Description:\n\t*\tCalculates the intersection point of a line and a plane.\n\t*\tThe line should not be parallel to the plane.\n\t* Parameters:\n\t*\tline {Line} the line\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Plane.prototype.LineIntersection = function (line)\n\t{\n\t\tvar\tdirection = line.direction.Clone ().Normalize ();\n\n\t\tvar x1 = line.start.x;\n\t\tvar y1 = line.start.y;\n\t\tvar z1 = line.start.z;\n\n\t\tvar x2 = line.start.x + direction.x;\n\t\tvar y2 = line.start.y + direction.y;\n\t\tvar z2 = line.start.z + direction.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tdirection.MultiplyScalar (u);\n\t\treturn JSM.CoordAdd (line.start, direction);\n\t};\n\n\t/**\n\t* Function: Plane.Clone\n\t* Description: Clones the plane.\n\t* Returns:\n\t*\t{Plane} a cloned instance\n\t*/\n\tJSM.Plane.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Plane (this.a, this.b, this.c, this.d);\n\t};\n\n\t/**\n\t* Function: GetPlaneFromCoordAndDirection\n\t* Description: Generates a plane from a coordinate and a direction.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t* Returns:\n\t*\t{Plane} the result\n\t*/\n\tJSM.GetPlaneFromCoordAndDirection = function (coord, direction)\n\t{\n\t\tvar plane = new JSM.Plane ();\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tvar pa = normal.x;\n\t\tvar pb = normal.y;\n\t\tvar pc = normal.z;\n\t\tvar pd = -(pa * coord.x + pb * coord.y + pc * coord.z);\n\t\tplane.Set (pa, pb, pc, pd);\n\t\treturn plane;\n\t};\n\n\t/**\n\t* Function: GetPlaneFromThreeCoords\n\t* Description: Generates a plane from three coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t*\tc {Coord} the third coordinate\n\t* Returns:\n\t*\t{Plane} the result\n\t*/\n\tJSM.GetPlaneFromThreeCoords = function (a, b, c)\n\t{\n\t\tvar plane = new JSM.Plane ();\n\t\tvar pa = (b.y - a.y) * (c.z - a.z) - (c.y - a.y) * (b.z - a.z);\n\t\tvar pb = (b.z - a.z) * (c.x - a.x) - (c.z - a.z) * (b.x - a.x);\n\t\tvar pc = (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);\n\t\tvar pd = -(pa * a.x + pb * a.y + pc * a.z);\n\t\tplane.Set (pa, pb, pc, pd);\n\t\treturn plane;\n\t};\n\n\t/**\n\t* Function: CoordPlaneSignedDirectionalDistance\n\t* Description: Calculates the signed distance of a coordinate and a plane along a direction vector.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordPlaneSignedDirectionalDistance = function (coord, direction, plane)\n\t{\n\t\tvar\tnormal = direction.Clone ().Normalize ();\n\n\t\tvar x1 = coord.x;\n\t\tvar y1 = coord.y;\n\t\tvar z1 = coord.z;\n\n\t\tvar x2 = coord.x + normal.x;\n\t\tvar y2 = coord.y + normal.y;\n\t\tvar z2 = coord.z + normal.z;\n\n\t\tvar a = plane.a;\n\t\tvar b = plane.b;\n\t\tvar c = plane.c;\n\t\tvar d = plane.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tnormal.MultiplyScalar (u);\n\t\tvar intersection = JSM.CoordAdd (coord, normal);\n\t\tvar distance = coord.DistanceTo (intersection);\n\t\tvar s = a * x1 + b * y1 + c * z1 + d;\n\t\tif (JSM.IsNegative (s)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: CoordPlaneDirectionalDistance\n\t* Description: Calculates the distance of a coordinate and a plane along a direction vector.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordPlaneDirectionalDistance = function (coord, direction, plane)\n\t{\n\t\treturn Math.abs (JSM.CoordPlaneSignedDirectionalDistance (coord, direction, plane));\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/projection',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixView\n\t* Description: Creates a view matrix.\n\t* Parameters:\n\t*\teye {Coord} eye position\n\t*\tcenter {Coord} center position\n\t*\tup {Vector} up vector\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixView = function (eye, center, up)\n\t{\n\t\tif (eye.IsEqual (center)) {\n\t\t\treturn JSM.MatrixIdentity ();\n\t\t}\n\t\t\n\t\tvar result = [];\n\n\t\tvar d = JSM.CoordSub (eye, center).Normalize ();\n\t\tvar v = JSM.VectorCross (up, d).Normalize ();\n\t\tvar u = JSM.VectorCross (d, v).Normalize ();\n\n\t\tresult[0] = v.x;\n\t\tresult[1] = u.x;\n\t\tresult[2] = d.x;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = v.y;\n\t\tresult[5] = u.y;\n\t\tresult[6] = d.y;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = v.z;\n\t\tresult[9] = u.z;\n\t\tresult[10] = d.z;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = -JSM.VectorDot (v, eye);\n\t\tresult[13] = -JSM.VectorDot (u, eye);\n\t\tresult[14] = -JSM.VectorDot (d, eye);\n\t\tresult[15] = 1.0;\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixPerspective\n\t* Description: Creates a perspective matrix.\n\t* Parameters:\n\t*\tfieldOfView {number} field of view\n\t*\taspectRatio {number} aspect ratio\n\t*\tnearPlane {number} near clipping plane\n\t*\tfarPlane {number} far clipping plane\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixPerspective = function (fieldOfView, aspectRatio, nearPlane, farPlane)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar f = 1.0 / Math.tan (fieldOfView / 2.0);\n\t\tvar nf = 1.0 / (nearPlane - farPlane);\n\t\t\n\t\tresult[0] = f / aspectRatio;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = f;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = (farPlane + nearPlane) * nf;\n\t\tresult[11] = -1.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = (2.0 * farPlane * nearPlane) * nf;\n\t\tresult[15] = 0.0;\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Project\n\t* Description: Projects a 3D coordinate to 2D.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\teye {Coord} the eye of the camera\n\t*\tcenter {Coord} the center of the camera\n\t*\tup {Vector} the up vector of the camera\n\t*\tfieldOfView {number} camera field of view\n\t*\taspectRatio {number} aspect ratio of the desired image\n\t*\tnearPlane {number} near cutting plane distance\n\t*\tfarPlane {number} far cutting plane distance\n\t*\tviewPort {number[4]} view port coordinates in pixels\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Project = function (coord, eye, center, up, fieldOfView, aspectRatio, nearPlane, farPlane, viewPort)\n\t{\n\t\tvar input = [\n\t\t\tcoord.x,\n\t\t\tcoord.y,\n\t\t\tcoord.z,\n\t\t\t1.0\n\t\t];\n\n\t\tvar viewMatrix = JSM.MatrixView (eye, center, up);\n\t\tvar perspectiveMatrix = JSM.MatrixPerspective (fieldOfView, aspectRatio, nearPlane, farPlane);\n\t\tvar projectionMatrix = JSM.MatrixMultiply (viewMatrix, perspectiveMatrix);\n\t\tvar output = JSM.MatrixVectorMultiply (projectionMatrix, input);\n\t\tvar denom = output[3];\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = (output[0] / denom * 0.5 + 0.5) * viewPort[2] + viewPort[0];\n\t\tresult.y = (output[1] / denom * 0.5 + 0.5) * viewPort[3] + viewPort[1];\n\t\tresult.z = (output[2] / denom * 0.5 + 0.5);\n\t\treturn result;\t\n\t};\n\n\t/**\n\t* Function: Unproject\n\t* Description: Projects a 2D coordinate to 3D.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate (the z component can be zero)\n\t*\teye {Coord} the eye of the camera\n\t*\tcenter {Coord} the center of the camera\n\t*\tup {Vector} the up vector of the camera\n\t*\tfieldOfView {number} camera field of view\n\t*\taspectRatio {number} aspect ratio of the desired image\n\t*\tnearPlane {number} near cutting plane distance\n\t*\tfarPlane {number} far cutting plane distance\n\t*\tviewPort {number[4]} view port coordinates in pixels\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Unproject = function (coord, eye, center, up, fieldOfView, aspectRatio, nearPlane, farPlane, viewPort)\n\t{\n\t\tvar input = [\n\t\t\t(coord.x - viewPort[0]) / viewPort[2] * 2.0 - 1.0,\n\t\t\t(coord.y - viewPort[1]) / viewPort[3] * 2.0 - 1.0,\n\t\t\t2.0 * coord.z - 1,\n\t\t\t1.0\n\t\t];\n\t\t\n\t\tvar viewMatrix = JSM.MatrixView (eye, center, up);\n\t\tvar perspectiveMatrix = JSM.MatrixPerspective (fieldOfView, aspectRatio, nearPlane, farPlane);\n\t\tvar projectionMatrix = JSM.MatrixMultiply (viewMatrix, perspectiveMatrix);\n\t\tvar inverseMatrix = JSM.MatrixInvert (projectionMatrix);\n\t\tvar output = JSM.MatrixVectorMultiply (inverseMatrix, input);\n\t\tvar denom = output[3];\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = (output[0] / output[3]);\n\t\tresult.y = (output[1] / output[3]);\n\t\tresult.z = (output[2] / output[3]);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/convexhull',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ConvexHull2D\n\t* Description: Calculates the 2D convex hull from the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord2D[*]} the coordinate array\n\t* Returns:\n\t*\t{Coord2D[*]} coordinate array of the convex hull\n\t*/\n\tJSM.ConvexHull2D = function (coords)\n\t{\n\t\tfunction FindLeftMostCoord (coords)\n\t\t{\n\t\t\tvar count = coords.length;\n\t\t\tvar minValue = JSM.Inf;\n\t\t\tvar minIndex = -1;\n\t\t\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = coords[i].x;\n\t\t\t\tif (JSM.IsLower (current, minValue)) {\n\t\t\t\t\tminValue = current;\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn minIndex;\n\t\t}\n\t\t\n\t\tfunction FindNextCoord (coords, current)\n\t\t{\n\t\t\tvar count = coords.length;\n\t\t\tvar next = 0;\n\t\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 1; i < count; i++) {\n\t\t\t\tif (current == next) {\n\t\t\t\t\tnext = i;\n\t\t\t\t} else {\n\t\t\t\t\tif (JSM.CoordOrientation2D (coords[current], coords[next], coords[i]) == JSM.Orientation.Clockwise) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn next;\n\t\t}\n\n\t\tvar result = [];\n\t\tvar count = coords.length;\n\t\tif (count < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar first = FindLeftMostCoord (coords);\n\t\tvar current = first;\n\t\tvar next;\n\t\t\n\t\tdo {\n\t\t\tresult.push (current);\n\t\t\tnext = FindNextCoord (coords, current);\n\t\t\tcurrent = next;\n\t\t} while (next != first);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvexHull3D\n\t* Description:\n\t*\tCalculates the 3D convex hull from the given coordinates. The result defines\n\t*\tconvex hull triangles as an array of arrays with three coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the coordinate array\n\t* Returns:\n\t*\t{Coord[3][*]} the result\n\t*/\n\tJSM.ConvexHull3D = function (coords)\n\t{\n\t\tfunction Vertex ()\n\t\t{\n\t\t\tthis.position = null;\n\t\t}\n\t\t\n\t\tfunction Edge ()\n\t\t{\n\t\t\tthis.vert1 = null;\n\t\t\tthis.vert2 = null;\n\t\t\tthis.tri1 = null;\n\t\t\tthis.tri2 = null;\n\t\t}\n\n\t\tfunction Triangle ()\n\t\t{\n\t\t\tthis.vertices = null;\n\t\t\tthis.edges = null;\n\t\t\tthis.valid = null;\n\t\t}\n\n\t\tfunction Body ()\n\t\t{\n\t\t\tthis.vertices = [];\n\t\t\tthis.edges = [];\n\t\t\tthis.triangles = [];\n\t\t}\n\n\t\tfunction AddVertex (body, coord)\n\t\t{\n\t\t\tvar vertex = new Vertex ();\n\t\t\tvertex.position = coord;\n\t\t\tbody.vertices.push (vertex);\n\t\t\treturn body.vertices.length - 1;\n\t\t}\n\n\t\tfunction AddEdge (body, triangleIndex, a, b)\n\t\t{\n\t\t\tvar edgeIndex = -1;\n\t\t\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < body.edges.length; i++) {\n\t\t\t\tcurrent = body.edges[i];\n\t\t\t\tif (current.vert1 == a && current.vert2 == b || current.vert1 == b && current.vert2 == a) {\n\t\t\t\t\tedgeIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (edgeIndex == -1) {\n\t\t\t\tvar newEdge = new Edge ();\n\t\t\t\tnewEdge.vert1 = a;\n\t\t\t\tnewEdge.vert2 = b;\n\t\t\t\tnewEdge.tri1 = -1;\n\t\t\t\tnewEdge.tri2 = -1;\n\t\t\t\tbody.edges.push (newEdge);\n\t\t\t\tedgeIndex = body.edges.length - 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar edge = body.edges[edgeIndex];\n\t\t\tif (edge.tri1 != triangleIndex && edge.tri2 != triangleIndex) {\n\t\t\t\tif (edge.tri1 == -1) {\n\t\t\t\t\tedge.tri1 = triangleIndex;\n\t\t\t\t} else if (edge.tri2 == -1) {\n\t\t\t\t\tedge.tri2 = triangleIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn edgeIndex;\n\t\t}\n\n\t\tfunction AddTriangle (body, a, b, c)\n\t\t{\n\t\t\tvar triangleIndex = body.triangles.length;\n\t\t\tvar edge1 = AddEdge (body, triangleIndex, a, b);\n\t\t\tvar edge2 = AddEdge (body, triangleIndex, b, c);\n\t\t\tvar edge3 = AddEdge (body, triangleIndex, c, a);\n\t\t\t\n\t\t\tvar triangle = new Triangle ();\n\t\t\ttriangle.vertices = [a, b, c];\n\t\t\ttriangle.edges = [edge1, edge2, edge3];\n\t\t\ttriangle.valid = true;\n\t\t\tbody.triangles.push (triangle);\n\t\t\treturn body.triangles.length - 1;\n\t\t}\n\n\t\tfunction RemoveTriangleFromEdge (body, triangleIndex, edgeIndex)\n\t\t{\n\t\t\tvar edge = body.edges[edgeIndex];\n\t\t\tif (edge.tri1 == triangleIndex) {\n\t\t\t\tedge.tri1 = -1;\n\t\t\t} else if (edge.tri2 == triangleIndex) {\n\t\t\t\tedge.tri2 = -1;\n\t\t\t}\n\t\t}\n\n\t\tfunction RemoveTriangle (body, triangleIndex)\n\t\t{\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tif (!triangle.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[0]);\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[1]);\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[2]);\n\t\t\ttriangle.valid = false;\n\t\t}\n\n\t\tfunction GetTetrahedronVolume (body, a, b, c, d)\n\t\t{\n\t\t\tvar aCoord = body.vertices[a].position;\n\t\t\tvar bCoord = body.vertices[b].position;\n\t\t\tvar cCoord = body.vertices[c].position;\n\t\t\tvar dCoord = body.vertices[d].position;\n\t\t\t\n\t\t\tvar adSub = JSM.CoordSub (aCoord, dCoord);\n\t\t\tvar bdSub = JSM.CoordSub (bCoord, dCoord);\n\t\t\tvar cdSub = JSM.CoordSub (cCoord, dCoord);\n\t\t\t\n\t\t\treturn (JSM.VectorDot (adSub, JSM.VectorCross (bdSub, cdSub))) / 6.0;\n\t\t}\n\t\t\n\t\tfunction CheckTetrahedronOrientation (body, a, b, c, d)\n\t\t{\n\t\t\tif (JSM.IsLower (GetTetrahedronVolume (body, a, b, c, d), 0.0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddInitialTetrahedron (body)\n\t\t{\n\t\t\tvar triangleIndex = -1;\n\t\t\tif (CheckTetrahedronOrientation (body, 0, 1, 2, 3)) {\n\t\t\t\ttriangleIndex = AddTriangle (body, 0, 1, 2);\n\t\t\t} else {\n\t\t\t\ttriangleIndex = AddTriangle (body, 0, 2, 1);\n\t\t\t}\n\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tAddTriangle (body, triangle.vertices[0], triangle.vertices[2], 3);\n\t\t\tAddTriangle (body, triangle.vertices[2], triangle.vertices[1], 3);\n\t\t\tAddTriangle (body, triangle.vertices[1], triangle.vertices[0], 3);\n\t\t}\n\n\t\tfunction AddCoordToHull (body, index)\n\t\t{\n\t\t\tvar visibleTriangles = [];\n\t\t\t\n\t\t\tvar i, triangle;\n\t\t\tfor (i = 0; i < body.triangles.length; i++) {\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tvisibleTriangles.push (false);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (CheckTetrahedronOrientation (body, triangle.vertices[0], triangle.vertices[2], triangle.vertices[1], index)) {\n\t\t\t\t\tvisibleTriangles.push (true);\n\t\t\t\t} else {\n\t\t\t\t\tvisibleTriangles.push (false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar edge1, edge2, edge3, edge1Vis, edge2Vis, edge3Vis;\n\t\t\tvar newTriangles = [];\n\t\t\tfor (i = 0; i < visibleTriangles.length; i++) {\n\t\t\t\tif (!visibleTriangles[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tedge1 = body.edges[triangle.edges[0]];\n\t\t\t\tedge2 = body.edges[triangle.edges[1]];\n\t\t\t\tedge3 = body.edges[triangle.edges[2]];\n\n\t\t\t\tedge1Vis = (edge1.tri1 == -1 || edge1.tri2 == -1 || visibleTriangles[edge1.tri1] != visibleTriangles[edge1.tri2]);\n\t\t\t\tedge2Vis = (edge2.tri1 == -1 || edge2.tri2 == -1 || visibleTriangles[edge2.tri1] != visibleTriangles[edge2.tri2]);\n\t\t\t\tedge3Vis = (edge3.tri1 == -1 || edge3.tri2 == -1 || visibleTriangles[edge3.tri1] != visibleTriangles[edge3.tri2]);\n\t\t\t\t\n\t\t\t\tif (edge1Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[0], triangle.vertices[1], index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (edge2Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[1], triangle.vertices[2], index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (edge3Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[2], triangle.vertices[0], index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < visibleTriangles.length; i++) {\n\t\t\t\tif (!visibleTriangles[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRemoveTriangle (body, i);\n\t\t\t}\n\t\t\t\n\t\t\tvar newTriangle;\n\t\t\tfor (i = 0; i < newTriangles.length; i++) {\n\t\t\t\tnewTriangle = newTriangles[i];\n\t\t\t\tAddTriangle (body, newTriangle[0], newTriangle[1], newTriangle[2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\tvar count = coords.length;\n\t\tif (count < 4) {\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = new Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tAddVertex (body, coords[i]);\n\t\t}\n\t\t\n\t\tAddInitialTetrahedron (body);\n\t\tfor (i = 4; i < count; i++) {\n\t\t\tAddCoordToHull (body, i);\n\t\t}\n\t\t\n\t\tvar triangle;\n\t\tfor (i = 0; i < body.triangles.length; i++) {\n\t\t\ttriangle = body.triangles[i];\n\t\t\tif (triangle.valid) {\n\t\t\t\tresult.push (triangle.vertices);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/polygon2d',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Complexity\n\t* Description: Complexity of a polygon.\n\t* Values:\n\t*\t{Invalid} invalid polygon\n\t*\t{Convex} convex polygon\n\t*\t{Concave} concave polygon\n\t*\t{Complex} complex polygon (contains holes)\n\t*/\n\tJSM.Complexity = {\n\t\tInvalid : 0,\n\t\tConvex : 1,\n\t\tConcave : 2,\n\t\tComplex : 3\n\t};\n\n\t/**\n\t* Enum: CoordPolygonPosition2D\n\t* Description: Position of a coordinate and a polygon.\n\t* Values:\n\t*\t{OnVertex} coordinate lies on a vertex of the polygon\n\t*\t{OnEdge} coordinate lies on an edge of the polygon\n\t*\t{Inside} coordinate lies inside the polygon\n\t*\t{Outside} coordinate lies outside of the polygon\n\t*/\n\tJSM.CoordPolygonPosition2D = {\n\t\tOnVertex : 0,\n\t\tOnEdge : 1,\n\t\tInside : 2,\n\t\tOutside : 3\n\t};\n\n\t/**\n\t* Enum: SectorPolygonPosition2D\n\t* Description: Position of a sector and a polygon.\n\t* Values:\n\t*\t{IntersectionOnePoint} sector intersects polygon\n\t*\t{IntersectionCoincident} sector lies on an edge of the polygon\n\t*\t{IntersectionOnVertex} sector intersects polygon on a vertex\n\t*\t{NoIntersection} sector does not intersect polygon\n\t*/\n\tJSM.SectorPolygonPosition2D = {\n\t\tIntersectionOnePoint : 0,\n\t\tIntersectionCoincident : 1,\n\t\tIntersectionOnVertex : 2,\n\t\tNoIntersection : 3\n\t};\n\n\t/**\n\t* Class: Polygon2D\n\t* Description: Represents a 2D polygon.\n\t*/\n\tJSM.Polygon2D = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord2D (x, y));\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.Polygon2D.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon2D.RemoveVertex\n\t* Description: Removes a vertex from the polygon.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.RemoveVertex = function (index)\n\t{\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Polygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon2D.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon2D.EnumerateVertices\n\t* Description:\n\t*\tEnumerates the vertices of the polygon, and calls\n\t*\ta function for each vertex.\n\t* Parameters:\n\t*\tfrom {integer} the start vertex index\n\t*\tto {integer} the end vertex index\n\t*\tcallback {function} the callback function\n\t*/\n\tJSM.Polygon2D.prototype.EnumerateVertices = function (from, to, callback)\n\t{\n\t\tvar count = this.vertices.length;\n\t\tvar index = from;\n\t\tcallback (index);\n\t\twhile (index != to) {\n\t\t\tindex = (index + 1) % count;\n\t\t\tcallback (index);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.ShiftVertices\n\t* Description: Shifts polygon vertices.\n\t* Parameters:\n\t*\tcount {integer} the number of shifts\n\t*/\n\tJSM.Polygon2D.prototype.ShiftVertices = function (count)\n\t{\n\t\tJSM.ShiftArray (this.vertices, count);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub2D (prev, curr);\n\t\tvar nextDir = JSM.CoordSub2D (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tif (this.cache.signedArea !== null) {\n\t\t\treturn this.cache.signedArea;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tvar result = 0.0;\n\t\tif (count >= 3) {\n\t\t\tvar i, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = this.vertices[i];\n\t\t\t\tnext = this.vertices[(i + 1) % count];\n\t\t\t\tresult += current.x * next.y - next.x * current.y;\n\t\t\t}\n\t\t\tresult *= 0.5;\n\t\t}\n\t\t\n\t\tthis.cache.signedArea = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.cache.orientation !== null) {\n\t\t\treturn this.cache.orientation;\n\t\t}\n\n\t\tvar result = JSM.Orientation.Invalid;\n\t\tif (this.vertices.length >= 3) {\n\t\t\tvar signedArea = this.GetSignedArea ();\n\t\t\tif (JSM.IsPositive (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.CounterClockwise;\n\t\t\t} else if (JSM.IsNegative (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.Clockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.orientation = result;\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Polygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.cache.complexity !== null) {\n\t\t\treturn this.cache.complexity;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tif (count < 3) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\t\n\t\tvar result = JSM.Complexity.Invalid;\n\t\tvar polygonOrientain = this.GetOrientation ();\n\t\tif (polygonOrientain != JSM.Orientation.Invalid) {\n\t\t\tresult = JSM.Complexity.Convex;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (this.IsConcaveVertex (i)) {\n\t\t\t\t\tresult = JSM.Complexity.Concave;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.complexity = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexOrientation\n\t* Description: Calculates the orientation of the given vertex of the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexOrientation = function (index)\n\t{\n\t\tif (this.cache.vertexOrientations[index] !== undefined) {\n\t\t\treturn this.cache.vertexOrientations[index];\n\t\t}\n\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\t\n\t\tvar result = JSM.CoordOrientation2D (prev, curr, next);\n\t\tthis.cache.vertexOrientations[index] = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConvexVertex\n\t* Description: Returns if the given vertex is convex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConvexVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation == orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConcaveVertex\n\t* Description: Returns if the given vertex is concave.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConcaveVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation != orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.CoordPosition\n\t* Description: Calculates the position of a coordinate and the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordPolygonPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tfunction IntersectionCount (coord, beg, end)\n\t\t{\n\t\t\tfunction GetIntersection (coord, beg, end)\n\t\t\t{\n\t\t\t\tvar result = new JSM.Coord2D (beg.x, coord.y);\n\t\t\t\tif (!JSM.IsEqual (beg.y, coord.y)) {\n\t\t\t\t\tvar yMoveRatio = Math.abs ((beg.y - coord.y) / (end.y - beg.y));\n\t\t\t\t\tresult.x = beg.x + (end.x - beg.x) * yMoveRatio;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tvar begYDist = beg.y - coord.y;\n\t\t\tvar endYDist = end.y - coord.y;\n\t\t\t\n\t\t\tvar begBelow = JSM.IsNegative (begYDist);\n\t\t\tvar begAbove = JSM.IsPositive (begYDist);\n\t\t\tvar endBelow = JSM.IsNegative (endYDist);\n\t\t\tvar endAbove = JSM.IsPositive (endYDist);\n\t\t\tif ((begBelow && endBelow) || (begAbove && endAbove)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar begOnLine = !begBelow && !begAbove;\n\t\t\tvar endOnLine = !endBelow && !endAbove;\n\t\t\tif (begOnLine && endOnLine) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar intersection = GetIntersection (coord, beg, end);\n\t\t\tif (JSM.IsLower (intersection.x, coord.x)) {\n\t\t\t\treturn 0;\n\t\t\t} else if (JSM.IsGreater (intersection.x, coord.x)) {\n\t\t\t\tif (begOnLine || endOnLine) {\n\t\t\t\t\tvar upwardEdge = JSM.IsGreater (end.y, beg.y);\n\t\t\t\t\tif (begOnLine && upwardEdge || endOnLine && !upwardEdge) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tvar vertexCount = this.vertices.length;\n\t\tvar intersections = 0;\n\t\tvar i, edgeFrom, edgeTo, sector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeFrom = this.vertices[i];\n\t\t\tedgeTo = this.vertices[(i + 1) % vertexCount];\n\t\t\tsector = new JSM.Sector2D (edgeFrom, edgeTo);\n\t\t\tposition = sector.CoordPosition (coord);\n\t\t\tif (position == JSM.CoordSectorPosition2D.CoordInsideOfSector) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnEdge;\n\t\t\t} else if (position == JSM.CoordSectorPosition2D.CoordOnSectorEndCoord) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnVertex;\n\t\t\t}\n\t\t\tintersections += IntersectionCount (coord, edgeFrom, edgeTo);\n\t\t}\n\t\t\n\t\tif (intersections % 2 !== 0) {\n\t\t\treturn JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\treturn JSM.CoordPolygonPosition2D.Outside;\n\t};\n\n\t/**\n\t* Function: Polygon2D.SectorPosition\n\t* Description:\n\t*\tCalculates the position of a sector and the polygon. The given begin and end\n\t*\tvertex indices are omitted form intersection checking.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tbegIndex {integer} begin vertex index\n\t*\tendIndex {integer} end vertex index\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.SectorPosition = function (sector, begIndex, endIndex)\n\t{\n\t\tvar result = JSM.SectorPolygonPosition2D.NoIntersection;\n\t\tvar vertexCount = this.vertices.length;\n\t\tif (vertexCount < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar i, edgeBegIndex, edgeEndIndex, edgeBeg, edgeEnd;\n\t\tvar currentSector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeBegIndex = i;\n\t\t\tedgeEndIndex = (i + 1) % vertexCount;\n\t\t\tedgeBeg = this.vertices[edgeBegIndex];\n\t\t\tedgeEnd = this.vertices[edgeEndIndex];\n\t\t\tif (edgeBegIndex == begIndex || edgeEndIndex == begIndex || edgeBegIndex == endIndex || edgeEndIndex == endIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentSector = new JSM.Sector2D (edgeBeg, edgeEnd);\n\t\t\tposition = sector.SectorPosition (currentSector);\n\t\t\tif (position == JSM.SectorSectorPosition2D.SectorsIntersectOnePoint) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionOnePoint;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectCoincident) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionCoincident;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectEndPoint) {\n\t\t\t\tresult = JSM.SectorPolygonPosition2D.IntersectionOnVertex;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsDiagonal\n\t* Description: Returns if the sector between two vertices is diagonal.\n\t* Parameters:\n\t*\tfrom {integer} begin vertex index\n\t*\tto {integer} end vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsDiagonal = function (from, to)\n\t{\n\t\tfunction DiagonalIntersectsAnyEdges (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar sector = new JSM.Sector2D (fromVertex, toVertex);\n\t\t\tvar position = polygon.SectorPosition (sector, from, to);\n\t\t\tif (position != JSM.SectorPolygonPosition2D.NoIntersection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction DiagonalInsideOfPolygon (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar midCoord = new JSM.Coord2D (\n\t\t\t\t(fromVertex.x + toVertex.x) / 2.0,\n\t\t\t\t(fromVertex.y + toVertex.y) / 2.0\n\t\t\t);\n\t\t\tvar position = polygon.CoordPosition (midCoord);\n\t\t\treturn position == JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\t\n\t\tif (from == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.GetPrevVertex (from) == to || this.GetNextVertex (from) == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar fromVertex = this.vertices[from];\n\t\tvar toVertex = this.vertices[to];\n\t\tif (fromVertex.IsEqual (toVertex)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (DiagonalIntersectsAnyEdges (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!DiagonalInsideOfPolygon (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Polygon2D.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.Polygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon2D.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.Polygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t};\n\n\t/**\n\t * Function: Polygon2D.GetBoundingBox\n\t * Description: Calculates the bounding box of the polygon.\n\t * Returns:\n\t *\t{Box2D} the result\n\t */\n\tJSM.Polygon2D.prototype.GetBoundingBox = function ()\n\t{\n\t\tif (this.cache.boundingBox !== null) {\n\t\t\treturn this.cache.boundingBox;\n\t\t}\n\n\t\tvar result = new JSM.Box2D (\n\t\t\tnew JSM.Coord2D (JSM.Inf, JSM.Inf),\n\t\t\tnew JSM.Coord2D (-JSM.Inf, -JSM.Inf)\n\t\t);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tresult.min.x = JSM.Minimum (result.min.x, coord.x);\n\t\t\tresult.min.y = JSM.Minimum (result.min.y, coord.y);\n\t\t\tresult.max.x = JSM.Maximum (result.max.x, coord.x);\n\t\t\tresult.max.y = JSM.Maximum (result.max.y, coord.y);\n\t\t}\n\n\t\tthis.cache.boundingBox = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon2D.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tsignedArea : null,\n\t\t\torientation : null,\n\t\t\tvertexOrientations : {},\n\t\t\tcomplexity : null,\n\t\t\tboundingBox : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon2D} a cloned instance\n\t*/\n\tJSM.Polygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon2D\n\t* Description: Represents a 2D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon2D = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.lastContour.AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertex = function (contourIndex, x, y)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.ContourPolygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tthis.contours[i].ReverseVertices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon2D} the new contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon2D ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon2D} the contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContour = function (index)\n\t{\n\t\treturn this.contours[index];\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tvar area = 0.0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tarea += this.contours[i].GetSignedArea ();\n\t\t}\n\t\treturn area;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar orientation = this.contours[0].GetOrientation ();\n\t\tif (this.contours.length == 1) {\n\t\t\treturn orientation;\n\t\t}\n\t\tif (orientation == JSM.Orientation.Invalid) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar i, contourOrientation;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourOrientation = this.contours[i].GetOrientation ();\n\t\t\tif (contourOrientation == JSM.Orientation.Invalid) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t\tif (orientation == contourOrientation) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\tif (this.contours.length == 1) {\n\t\t\treturn this.contours[0].GetComplexity ();\n\t\t}\n\t\tvar i, contourComplexity;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourComplexity = this.contours[i].GetComplexity ();\n\t\t\tif (contourComplexity == JSM.Complexity.Invalid) {\n\t\t\t\treturn JSM.Complexity.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn JSM.Complexity.Complex;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} a cloned instance\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/polygon',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Polygon\n\t* Description: Represents a 3D polygon.\n\t*/\n\tJSM.Polygon = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.Polygon.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord (x, y, z));\n\t};\n\n\t/**\n\t* Function: Polygon.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord} the vertex\n\t*/\n\tJSM.Polygon.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub (prev, curr);\n\t\tvar nextDir = JSM.CoordSub (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon.GetNormal\n\t* Description: Calculates the normal vector of the polygon.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Polygon.prototype.GetNormal = function ()\n\t{\n\t\tif (this.cache.normal !== null) {\n\t\t\treturn this.cache.normal;\n\t\t}\n\t\tvar result = JSM.CalculateNormal (this.vertices);\n\t\tthis.cache.normal = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon.ToPolygon2D\n\t* Description: Converts the polygon to a 2D polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.Polygon.prototype.ToPolygon2D = function ()\n\t{\n\t\tvar normal = this.GetNormal ();\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i].ToCoord2D (normal);\n\t\t\tresult.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.Polygon.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord[*]} the array of vertices\n\t*/\n\tJSM.Polygon.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tnormal : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon} a cloned instance\n\t*/\n\tJSM.Polygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon\n\t* Description: Represents a 3D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.lastContour.AddVertex (x, y, z);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.ContourPolygon.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.AddContourVertex = function (contourIndex, x, y, z)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y, z);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.ContourPolygon.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon} the new contour\n\t*/\n\tJSM.ContourPolygon.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon} the result\n\t*/\n\tJSM.ContourPolygon.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord} the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon} the contour\n\t*/\n\tJSM.ContourPolygon.prototype.GetContour = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex];\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ToContourPolygon2D\n\t* Description: Converts the polygon to a 2D polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} the result\n\t*/\n\tJSM.ContourPolygon.prototype.ToContourPolygon2D = function ()\n\t{\n\t\tvar normal = this.contours[0].GetNormal ();\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tresult.AddContour ();\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tresult.AddVertexCoord (vertex.ToCoord2D (normal));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.ContourPolygon.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon} a cloned instance\n\t*/\n\tJSM.ContourPolygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\n\t};\n\n\t/**\n\t* Function: OffsetPolygonContour\n\t* Description: Offsets all vertices of a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\twidth {number} the width of the offset\n\t* Returns:\n\t*\t{Polygon} the result\n\t*/\n\tJSM.OffsetPolygonContour = function (polygon, width)\n\t{\n\t\tvar count = polygon.VertexCount ();\n\t\tvar normal = polygon.GetNormal ();\n\n\t\tvar prev, curr, next;\n\t\tvar prevVertex, currVertex, nextVertex;\n\t\tvar prevDir, nextDir;\n\t\tvar distance, offsetedCoord;\n\t\t\n\t\tvar result = new JSM.Polygon ();\n\t\t\n\t\tvar i, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = polygon.GetPrevVertex (i);\n\t\t\tcurr = i;\n\t\t\tnext = polygon.GetNextVertex (i);\n\t\t\t\n\t\t\tprevVertex = polygon.GetVertex (prev);\n\t\t\tcurrVertex = polygon.GetVertex (curr);\n\t\t\tnextVertex = polygon.GetVertex (next);\n\n\t\t\tprevDir = JSM.CoordSub (prevVertex, currVertex);\n\t\t\tnextDir = JSM.CoordSub (nextVertex, currVertex);\n\t\t\tangle = prevDir.AngleTo (nextDir) / 2.0;\n\t\t\tif (JSM.CoordOrientation (prevVertex, currVertex, nextVertex, normal) == JSM.Orientation.Clockwise) {\n\t\t\t\tangle = Math.PI - angle;\n\t\t\t}\n\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\toffsetedCoord = currVertex.Clone ();\n\t\t\toffsetedCoord.Offset (nextDir, distance);\n\t\t\toffsetedCoord.Rotate (normal, angle, currVertex);\n\t\t\tresult.AddVertex (offsetedCoord.x, offsetedCoord.y, offsetedCoord.z);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/cutpolygon',[\"../core/jsm\"],function(JSM){\n\tJSM.CutVertexType = {\n\t\tLeft : 1,\n\t\tRight : 2,\n\t\tCut : 3\n\t};\n\n\tJSM.PolygonCutter = function (geometryInterface)\n\t{\n\t\tthis.geometryInterface = geometryInterface;\n\t\tthis.Reset ();\n\t};\n\n\tJSM.PolygonCutter.prototype.Cut = function (polygon, aSidePolygons, bSidePolygons, cutPolygons)\n\t{\n\t\tthis.Reset ();\n\t\t\n\t\tvar allVertexType = this.CalculateOriginalPolygonData (polygon);\n\t\tif (allVertexType !== null) {\n\t\t\tvar cloned = polygon.Clone ();\n\t\t\tif (allVertexType == JSM.CutVertexType.Left) {\n\t\t\t\taSidePolygons.push (cloned);\n\t\t\t} else if (allVertexType == JSM.CutVertexType.Right) {\n\t\t\t\tbSidePolygons.push (cloned);\n\t\t\t} else {\n\t\t\t\tcutPolygons.push (cloned);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCutPolygonData ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateEntryVertices ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCuttedPolygons (aSidePolygons, bSidePolygons)) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.Reset = function ()\n\t{\n\t\tthis.originalPolygon = null;\n\t\tthis.originalPolygonVertexTypes = null;\n\t\tthis.cutPolygon = null;\n\t\tthis.cutPolygonVertexTypes = null;\n\t\tthis.cutPolygonVertexDistances = null;\n\t\tthis.cutVertexIndices = null;\n\t\tthis.entryVertices = null;\n\t\tthis.entryVertexTypes = null;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateOriginalPolygonData = function (polygon)\n\t{\n\t\tthis.originalPolygon = polygon;\n\t\tthis.originalPolygonVertexTypes = [];\n\t\tvar aSideFound = false;\n\t\tvar bSideFound = false;\n\t\t\n\t\tvar i, vertex, type;\n\t\tfor (i = 0; i < this.originalPolygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\ttype = this.geometryInterface.getVertexSide (vertex);\n\t\t\tif (type == JSM.CutVertexType.Left) {\n\t\t\t\taSideFound = true;\n\t\t\t} else if (type == JSM.CutVertexType.Right) {\n\t\t\t\tbSideFound = true;\n\t\t\t}\n\t\t\tthis.originalPolygonVertexTypes.push (type);\n\t\t}\n\t\t\n\t\tif (aSideFound && bSideFound) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (aSideFound) {\n\t\t\treturn JSM.CutVertexType.Left;\n\t\t} else if (bSideFound) {\n\t\t\treturn JSM.CutVertexType.Right;\n\t\t}\n\t\t\n\t\treturn JSM.CutVertexType.Cut;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCutPolygonData = function ()\n\t{\n\t\tfunction IsIntersectionVertex (cutPolygonVertexTypes, originalType)\n\t\t{\n\t\t\tif (cutPolygonVertexTypes.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar prevType = cutPolygonVertexTypes[cutPolygonVertexTypes.length - 1];\n\t\t\tif (prevType == JSM.CutVertexType.Cut || originalType == JSM.CutVertexType.Cut) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn prevType != originalType;\n\t\t}\n\t\t\n\t\tfunction AddCutVertexToPolygon (polygonCutter, vertex, type)\n\t\t{\n\t\t\tpolygonCutter.cutPolygon.AddVertexCoord (vertex);\n\t\t\tpolygonCutter.cutPolygonVertexTypes.push (type);\n\t\t\tif (type == JSM.CutVertexType.Cut) {\n\t\t\t\tpolygonCutter.cutVertexIndices.push (polygonCutter.cutPolygonVertexTypes.length - 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddIntersectionVertex (polygonCutter, originalIndex)\n\t\t{\n\t\t\tvar prevIndex = polygonCutter.originalPolygon.GetPrevVertex (originalIndex);\n\t\t\tvar prevVertex = polygonCutter.originalPolygon.GetVertex (prevIndex);\n\t\t\tvar currVertex = polygonCutter.originalPolygon.GetVertex (originalIndex);\n\t\t\tvar intersection = polygonCutter.geometryInterface.getIntersectionVertex (prevVertex, currVertex);\n\t\t\tif (intersection === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tAddCutVertexToPolygon (polygonCutter, intersection, JSM.CutVertexType.Cut);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddOriginalVertex (polygonCutter, originalIndex, originalType)\n\t\t{\n\t\t\tvar vertex = polygonCutter.originalPolygon.GetVertex (originalIndex).Clone ();\n\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\n\t\t\tvar vertexCount = polygonCutter.originalPolygon.VertexCount ();\n\t\t\tvar prevType = polygonCutter.originalPolygonVertexTypes[JSM.PrevIndex (originalIndex, vertexCount)];\n\t\t\tvar nextType = polygonCutter.originalPolygonVertexTypes[JSM.NextIndex (originalIndex, vertexCount)];\n\t\t\tif (originalType == JSM.CutVertexType.Cut && prevType == nextType) {\n\t\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction SortCutVertices (cutPolygon, cutVertexIndices, cutPolygonVertexDistances)\n\t\t{\n\t\t\tif (cutVertexIndices.length < 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tJSM.BubbleSort (cutVertexIndices,\n\t\t\t\tfunction (a, b) {\n\t\t\t\t\tvar aDist = cutPolygonVertexDistances[a];\n\t\t\t\t\tvar bDist = cutPolygonVertexDistances[b];\n\t\t\t\t\treturn JSM.IsLower (aDist, bDist);\n\t\t\t\t},\n\t\t\t\tfunction (i, j) {\n\t\t\t\t\tJSM.SwapArrayValues (cutVertexIndices, i, j);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\treturn true;\n\t\t}\t\n\n\t\tthis.cutPolygon = this.geometryInterface.createPolygon ();\n\t\tthis.cutPolygonVertexTypes = [];\n\t\tthis.cutVertexIndices = [];\n\t\t\n\t\tvar vertexCount = this.originalPolygon.VertexCount ();\n\t\tvar i, lastVertex, originalIndex, originalType;\n\t\tfor (i = 0; i <= vertexCount; i++) {\n\t\t\tlastVertex = (i === vertexCount);\n\t\t\toriginalIndex = i;\n\t\t\tif (lastVertex) {\n\t\t\t\toriginalIndex = 0;\n\t\t\t}\n\t\t\t\n\t\t\toriginalType = this.originalPolygonVertexTypes[originalIndex];\n\t\t\tif (IsIntersectionVertex (this.cutPolygonVertexTypes, originalType)) {\n\t\t\t\tAddIntersectionVertex (this, originalIndex);\n\t\t\t}\n\t\t\t\n\t\t\tif (!lastVertex) {\n\t\t\t\tAddOriginalVertex (this, originalIndex, originalType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cutPolygonVertexDistances = this.geometryInterface.getVertexDistances (this.cutPolygon);\n\t\tif (!SortCutVertices (this.cutPolygon, this.cutVertexIndices, this.cutPolygonVertexDistances)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateEntryVertices = function ()\n\t{\n\t\tfunction GetEntryVertexType (cutPolygonVertexTypes, cutPolygonVertexDistances, currIndex)\n\t\t{\n\t\t\tvar currSideType = cutPolygonVertexTypes[currIndex];\n\t\t\tif (currSideType != JSM.CutVertexType.Cut) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tvar prevIndex = JSM.PrevIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar nextIndex = JSM.NextIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar prevSideType = cutPolygonVertexTypes[prevIndex];\n\t\t\tvar nextSideType = cutPolygonVertexTypes[nextIndex];\n\n\t\t\tvar currVertexDistance = cutPolygonVertexDistances[currIndex];\n\t\t\tvar prevVertexDistance = cutPolygonVertexDistances[prevIndex];\n\t\t\tvar nextVertexDistance = cutPolygonVertexDistances[nextIndex];\n\t\t\t\n\t\t\tif (prevSideType == JSM.CutVertexType.Right) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Left) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Cut) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\n\t\tthis.entryVertices = [];\n\t\tthis.entryVertexTypes = [];\n\t\tvar i, vertexIndex, vertexType;\n\t\tfor (i = 0; i < this.cutVertexIndices.length; i++) {\n\t\t\tvertexIndex = this.cutVertexIndices[i];\n\t\t\tvertexType = GetEntryVertexType (this.cutPolygonVertexTypes, this.cutPolygonVertexDistances, vertexIndex);\n\t\t\tif (vertexType !== 0) {\n\t\t\t\tthis.entryVertices.push (vertexIndex);\n\t\t\t\tthis.entryVertexTypes.push (vertexType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.entryVertices.length === 0 || this.entryVertices.length % 2 !== 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCuttedPolygons = function (aSidePolygons, bSidePolygons)\n\t{\n\t\tfunction AddOneSideCuttedPolygons (polygonCutter, aSidePolygons, bSidePolygons, reversed)\n\t\t{\n\t\t\tfunction AddEntryPairToArray (entryPairs, entryVertices, fromIndex, toIndex)\n\t\t\t{\n\t\t\t\tentryPairs[entryVertices[fromIndex]] = entryVertices[toIndex];\n\t\t\t\tentryPairs[entryVertices[toIndex]] = entryVertices[fromIndex];\n\t\t\t}\n\n\t\t\tfunction RemoveEntryPairFromArray (entryPairs, index)\n\t\t\t{\n\t\t\t\tentryPairs[entryPairs[index]] = -1;\n\t\t\t\tentryPairs[index] = -1;\n\t\t\t}\n\n\t\t\tfunction CreateEntryPairsArray (cutPolygon, entryVertices, entryVertexTypes)\n\t\t\t{\n\t\t\t\tfunction FindPairIndex (entryPairs, entryVertices, entryVertexTypes, startIndex)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = startIndex + 1; i < entryVertices.length; i++) {\n\t\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entryVertexTypes[startIndex] != entryVertexTypes[i]) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tvar entryPairs = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < cutPolygon.VertexCount (); i++) {\n\t\t\t\t\tentryPairs.push (-1);\n\t\t\t\t}\n\n\t\t\t\tvar pairIndex;\n\t\t\t\tfor (i = 0; i < entryVertices.length; i++) {\n\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpairIndex = FindPairIndex (entryPairs, entryVertices, entryVertexTypes, i);\n\t\t\t\t\tif (pairIndex == -1) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tAddEntryPairToArray (entryPairs, entryVertices, i, pairIndex);\n\t\t\t\t}\n\t\t\t\treturn entryPairs;\n\t\t\t}\n\t\t\t\n\t\t\tfunction GetNextVertex (currVertexIndex, cutPolygon, entryPairs)\n\t\t\t{\n\t\t\t\tif (entryPairs[currVertexIndex] != -1) {\n\t\t\t\t\tvar nextVertex = entryPairs[currVertexIndex];\n\t\t\t\t\tRemoveEntryPairFromArray (entryPairs, currVertexIndex);\n\t\t\t\t\treturn nextVertex;\n\t\t\t\t} else {\n\t\t\t\t\treturn JSM.NextIndex (currVertexIndex, cutPolygon.VertexCount ());\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tfunction AddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons)\n\t\t\t{\n\t\t\t\tfunction AddVertexIfNotDuplicated (polygon, vertex)\n\t\t\t\t{\n\t\t\t\t\tvar vertexCount = polygon.VertexCount ();\n\t\t\t\t\tif (vertexCount > 0 && polygon.GetVertex (vertexCount - 1).IsEqual (vertex)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpolygon.AddVertexCoord (vertex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar startVertexIndex = polygonCutter.entryVertices[currEntryVertex];\n\t\t\t\tif (entryPairs[startVertexIndex] !== -1) {\n\t\t\t\t\tvar currPolygon = polygonCutter.geometryInterface.createPolygon ();\n\t\t\t\t\tcurrPolygon.AddVertexCoord (polygonCutter.cutPolygon.GetVertex (startVertexIndex).Clone ());\n\t\t\t\t\tvar currVertexIndex = GetNextVertex (startVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\tvar polygonSide = null;\n\t\t\t\t\twhile (currVertexIndex != startVertexIndex) {\n\t\t\t\t\t\tif (polygonSide === null) {\n\t\t\t\t\t\t\tif (polygonCutter.cutPolygonVertexTypes[currVertexIndex] !== JSM.CutVertexType.Cut) {\n\t\t\t\t\t\t\t\tpolygonSide = polygonCutter.cutPolygonVertexTypes[currVertexIndex];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAddVertexIfNotDuplicated (currPolygon, polygonCutter.cutPolygon.GetVertex (currVertexIndex).Clone ());\n\t\t\t\t\t\tcurrVertexIndex = GetNextVertex (currVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\t}\n\t\t\t\t\tif (currPolygon.VertexCount () > 2) {\n\t\t\t\t\t\tif (polygonSide == JSM.CutVertexType.Left) {\n\t\t\t\t\t\t\taSidePolygons.push (currPolygon);\n\t\t\t\t\t\t} else if (polygonSide == JSM.CutVertexType.Right) {\n\t\t\t\t\t\t\tbSidePolygons.push (currPolygon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPairs = CreateEntryPairsArray (polygonCutter.cutPolygon, polygonCutter.entryVertices, polygonCutter.entryVertexTypes);\n\t\t\tif (entryPairs === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currEntryVertex = reversed ? polygonCutter.entryVertices.length - 1 : 0;\n\t\t\twhile (currEntryVertex >= 0 && currEntryVertex < polygonCutter.entryVertices.length) {\n\t\t\t\tAddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons);\n\t\t\t\tcurrEntryVertex = reversed ? currEntryVertex - 1 : currEntryVertex + 1;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, false)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, true)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CutPolygon2DWithLine\n\t* Description:\n\t*\tCuts a polygon with a line. The result array contains cutted\n\t*\tpolygons grouped by their position to the line.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tline {Line2D} the line\n\t*\tleftPolygons {Polygon2D[*]} (out) polygons on the left of the line\n\t*\trightPolygons {Polygon2D[*]} (out) polygons on the right of the line\n\t*\tcutPolygons {Polygon2D[*]} (out) polygons on the line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygon2DWithLine = function (polygon, line, leftPolygons, rightPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon2D ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = line.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordLinePosition2D.CoordAtLineLeft) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordLinePosition2D.CoordAtLineRight) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar edgeLine = new JSM.Line2D (currVertex, JSM.CoordSub2D (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lineLinePosition = line.LinePosition (edgeLine, intersection);\n\t\t\t\tif (lineLinePosition != JSM.LineLinePosition2D.LinesIntersectsOnePoint) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar origo = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar refLineStart = line.start.Clone ();\n\t\t\t\tvar refLineDir = line.direction.Clone ().Rotate (-Math.PI / 2.0, origo);\n\t\t\t\tvar refLine = new JSM.Line2D (refLineStart, refLineDir);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refLine.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, leftPolygons, rightPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: CutPolygonWithPlane\n\t* Description:\n\t*\tCuts a polygon with a plane. The result array contains cutted\n\t*\tpolygons grouped by their position to the plane.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tplane {Plane} the plane\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the plane\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the plane\n\t*\tcutPolygons {Polygon[*]} (out) polygons on the plane\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygonWithPlane = function (polygon, plane, frontPolygons, backPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = plane.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar line = new JSM.Line (currVertex, JSM.CoordSub (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tvar linePlanePosition = plane.LinePosition (line, intersection);\n\t\t\t\tif (linePlanePosition != JSM.LinePlanePosition.LineIntersectsPlane) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar polygonNormal = polygon.GetNormal ();\n\t\t\t\tvar planeNormal = new JSM.Vector (plane.a, plane.b, plane.c);\n\t\t\t\tvar refPlaneNormal = JSM.VectorCross (planeNormal, polygonNormal);\n\t\t\t\tvar refPlaneOrigin = polygon.GetVertex (0);\n\t\t\t\tvar refPlane = JSM.GetPlaneFromCoordAndDirection (refPlaneOrigin, refPlaneNormal);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refPlane.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, frontPolygons, backPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: SegmentPolygon2D\n\t* Description: Segments up a polygon along x and y axis.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\txSegments {integer} x segment number\n\t*\tySegments {integer} y segment number\n\t* Returns:\n\t*\t{Polygon[*]} result polygons\n\t*/\n\tJSM.SegmentPolygon2D = function (polygon, xSegments, ySegments)\n\t{\n\t\tfunction CutPolygonsOneDirection (inputPolygons, resultPolygons, segmentCount, segmentSize, startCoordinate, segmentDir, cutDir)\n\t\t{\n\t\t\tfunction CutPolygon (polygon, line, leftPolygons, rightPolygons)\n\t\t\t{\n\t\t\t\tvar left = [];\n\t\t\t\tvar right = [];\n\t\t\t\tvar cut = [];\n\t\t\t\tif (!JSM.CutPolygon2DWithLine (polygon, line, left, right, cut)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < left.length; i++) {\n\t\t\t\t\tleftPolygons.push (left[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < right.length; i++) {\n\t\t\t\t\trightPolygons.push (right[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar polygonsToProcess = inputPolygons;\n\t\t\tvar startCoord = startCoordinate.Clone ();\n\t\t\tvar i, j, line, newPolygonsToProcess;\n\t\t\tfor (i = 1; i < segmentCount; i++) {\n\t\t\t\tstartCoord.Offset (segmentDir, segmentSize);\n\t\t\t\tline = new JSM.Line2D (startCoord, cutDir);\n\t\t\t\tnewPolygonsToProcess = [];\n\t\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\t\tCutPolygon (polygonsToProcess[j], line, resultPolygons, newPolygonsToProcess);\n\t\t\t\t}\n\t\t\t\tpolygonsToProcess = newPolygonsToProcess;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\tresultPolygons.push (polygonsToProcess[j]);\n\t\t\t}\n\t\t}\n\n\t\tvar boundingBox = polygon.GetBoundingBox ();\n\t\tvar xSize = boundingBox.max.x - boundingBox.min.x;\n\t\tvar ySize = boundingBox.max.y - boundingBox.min.y;\n\t\tvar xSegmentSize = xSize / xSegments;\n\t\tvar ySegmentSize = ySize / ySegments;\n\n\t\tvar originalPolygons = [polygon];\n\t\tvar bottomLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.min.y);\n\t\tvar topLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.max.y);\n\n\t\tvar xCuttedPolygons = [];\n\t\tvar yCuttedPolygons = [];\n\t\tCutPolygonsOneDirection (originalPolygons, xCuttedPolygons, xSegments, xSegmentSize, bottomLeft, new JSM.Vector2D (1.0, 0.0), new JSM.Vector2D (0.0, 1.0));\n\t\tCutPolygonsOneDirection (xCuttedPolygons, yCuttedPolygons, ySegments, ySegmentSize, topLeft, new JSM.Vector2D (0.0, -1.0), new JSM.Vector2D (1.0, 0.0));\n\t\treturn yCuttedPolygons;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/triangulation',[\"../core/jsm\"],function(JSM){\n\tJSM.ConvertContourPolygonToPolygon2D = function (inputPolygon, vertexMap)\n\t{\n\t\tfunction AddResultVertex (resultPolygon, vertex, vertexMap, originalContour, originalVertex)\n\t\t{\n\t\t\tresultPolygon.AddVertexCoord (vertex);\n\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\tvertexMap.push ([originalContour, originalVertex]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)\n\t\t{\n\t\t\tfunction GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData)\n\t\t\t{\n\t\t\t\tfunction IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)\n\t\t\t\t{\n\t\t\t\t\tfunction SegmentIntersectsPolygon (polygon, segmentBeg, segmentEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sector = new JSM.Sector2D (segmentBeg, segmentEnd);\n\t\t\t\t\t\tvar position = polygon.SectorPosition (sector, -1, -1);\n\t\t\t\t\t\tif (position == JSM.SectorPolygonPosition2D.IntersectionOnePoint || position == JSM.SectorPolygonPosition2D.IntersectionCoincident) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SegmentIntersectsPolygon (resultPolygon, resultVertex, holeVertex)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i, hole;\n\t\t\t\t\tfor (i = 1; i < inputPolygon.ContourCount (); i++) {\n\t\t\t\t\t\tif (conversionData.addedHoles[i] !== undefined) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thole = inputPolygon.GetContour (i);\n\t\t\t\t\t\tif (SegmentIntersectsPolygon (hole, resultVertex, holeVertex)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction IsExistingEntryPosition (coord, conversionData)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < conversionData.entryPositions.length; i++) {\n\t\t\t\t\t\tif (coord.IsEqual (conversionData.entryPositions[i])) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar resultVertexIndex, holeVertexIndex, resultVertex, holeVertex;\n\t\t\t\tfor (resultVertexIndex = 0; resultVertexIndex < resultPolygon.VertexCount (); resultVertexIndex++) {\n\t\t\t\t\tfor (holeVertexIndex = 0; holeVertexIndex < holePolygon.VertexCount (); holeVertexIndex++) {\n\t\t\t\t\t\tresultVertex = resultPolygon.GetVertex (resultVertexIndex);\n\t\t\t\t\t\tholeVertex = holePolygon.GetVertex (holeVertexIndex);\n\t\t\t\t\t\tif (IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)) {\n\t\t\t\t\t\t\tif (IsExistingEntryPosition (resultVertex, conversionData) || IsExistingEntryPosition (holeVertex, conversionData)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconversionData.entryPositions.push (resultVertex.Clone ());\n\t\t\t\t\t\t\tconversionData.entryPositions.push (holeVertex.Clone ());\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tbeg : resultVertexIndex,\n\t\t\t\t\t\t\t\tend : holeVertexIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tfunction AddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap)\n\t\t\t{\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar mainContourBeg = entryPoint.beg;\n\t\t\t\tvar mainEntryVertex = resultPolygon.GetVertex (mainContourBeg).Clone ();\n\t\t\t\tresultPolygon.ShiftVertices (mainContourBeg + 1);\n\n\t\t\t\tvar mainEntryContourIndex = 0;\n\t\t\t\tvar mainEntryVertexIndex = 0;\n\t\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\t\tmainEntryContourIndex = vertexMap[mainContourBeg][0];\n\t\t\t\t\tmainEntryVertexIndex = vertexMap[mainContourBeg][1];\n\t\t\t\t\tJSM.ShiftArray (vertexMap, mainContourBeg + 1);\n\t\t\t\t}\n\n\t\t\t\tvar contourBeg = entryPoint.end;\n\t\t\t\tvar contourEnd = holePolygon.GetPrevVertex (contourBeg);\n\t\t\t\tholePolygon.EnumerateVertices (contourBeg, contourEnd, function (index) {\n\t\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (index).Clone (), vertexMap, holeIndex, index);\n\t\t\t\t});\n\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (contourBeg).Clone (), vertexMap, holeIndex, contourBeg);\n\t\t\t\tAddResultVertex (resultPolygon, mainEntryVertex, vertexMap, mainEntryContourIndex, mainEntryVertexIndex);\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPoint = GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData);\n\t\t\tif (entryPoint === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tvar contourCount = inputPolygon.ContourCount ();\n\t\tvar mainContour = inputPolygon.GetContour (0);\n\t\tvar resultPolygon = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < mainContour.VertexCount (); i++) {\n\t\t\tvertex = mainContour.GetVertex (i);\n\t\t\tAddResultVertex (resultPolygon, vertex.Clone (), vertexMap, 0, i);\n\t\t}\n\t\tif (contourCount == 1) {\n\t\t\treturn resultPolygon;\n\t\t}\n\t\t\n\t\tvar holeQueue = [];\n\t\tvar holeIndex;\n\t\tfor (holeIndex = 1; holeIndex < contourCount; holeIndex++) {\n\t\t\tholeQueue.push (holeIndex);\n\t\t}\n\t\t\n\t\tvar conversionData = {\n\t\t\taddedHoles : {},\n\t\t\tholeTryouts : {},\n\t\t\tentryPositions : []\n\t\t};\n\t\t\n\t\twhile (holeQueue.length > 0) {\n\t\t\tholeIndex = holeQueue.shift ();\n\t\t\tif (AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)) {\n\t\t\t\tconversionData.addedHoles[holeIndex] = true;\n\t\t\t} else {\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] === undefined) {\n\t\t\t\t\tconversionData.holeTryouts[holeIndex] = 0;\n\t\t\t\t}\n\t\t\t\tconversionData.holeTryouts[holeIndex] += 1;\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] > 10) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tholeQueue.push (holeIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn resultPolygon;\n\t};\n\n\tJSM.TriangulateConvexPolygon = function (polygon)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 1; i < polygon.VertexCount () - 1; i++) {\n\t\t\tresult.push ([0, i, i + 1]);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulateConcavePolygon2D = function (inputPolygon)\n\t{\n\t\tfunction GetInitialVertexMap (count)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tresult[i] = i;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction FindSplitDiagonal (polygon)\n\t\t{\n\t\t\tvar count = polygon.VertexCount ();\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (polygon.IsDiagonal (i, j)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tbeg : i,\n\t\t\t\t\t\t\tend : j\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction SplitPolygon (polygonData, diagonal)\n\t\t{\n\t\t\tfunction AddVertex (polygonData, resultData, index)\n\t\t\t{\n\t\t\t\tresultData.polygon.AddVertexCoord (polygonData.polygon.GetVertex (index));\n\t\t\t\tresultData.map.push (polygonData.map[index]);\n\t\t\t}\n\t\t\t\n\t\t\tvar resultData1 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\t\t\tvar resultData2 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\n\t\t\tvar beg, end;\n\t\t\t\n\t\t\tbeg = diagonal.beg;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.end);\n\t\t\tAddVertex (polygonData, resultData1, diagonal.end);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData1, index);\n\t\t\t});\n\n\t\t\tbeg = diagonal.end;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.beg);\n\t\t\tAddVertex (polygonData, resultData2, diagonal.beg);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData2, index);\n\t\t\t});\n\t\t\t\n\t\t\treturn {\n\t\t\t\tresultData1 : resultData1,\n\t\t\t\tresultData2 : resultData2\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar polygonStack = [];\n\t\tvar count = inputPolygon.VertexCount ();\n\t\tvar inputMap = GetInitialVertexMap (count);\n\t\tpolygonStack.push ({\n\t\t\tpolygon : inputPolygon,\n\t\t\tmap : inputMap\n\t\t});\n\t\t\n\t\tvar result = [];\n\t\tvar polygonData, vertexCount, diagonal, resultData;\n\t\twhile (polygonStack.length > 0) {\n\t\t\tpolygonData = polygonStack.pop ();\n\t\t\tvertexCount = polygonData.polygon.VertexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tresult.push (polygonData.map);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiagonal = FindSplitDiagonal (polygonData.polygon);\n\t\t\tif (diagonal === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresultData = SplitPolygon (polygonData, diagonal);\n\t\t\tpolygonStack.push (resultData.resultData1);\n\t\t\tpolygonStack.push (resultData.resultData2);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulatePolygon2D = function (polygon)\n\t{\n\t\tif (polygon === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar vertexCount = polygon.VertexCount ();\n\t\tif (vertexCount < 3) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (vertexCount == 3) {\n\t\t\treturn [[0, 1, 2]];\n\t\t}\n\t\t\n\t\tvar complexity = polygon.GetComplexity ();\n\t\tif (complexity === JSM.Complexity.Invalid) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (complexity == JSM.Complexity.Convex) {\n\t\t\treturn JSM.TriangulateConvexPolygon (polygon);\n\t\t}\n\t\t\n\t\treturn JSM.TriangulateConcavePolygon2D (polygon);\n\t};\n\n\t/**\n\t* Function: TriangulatePolygon\n\t* Description:\n\t*\tTriangulates a polygon. The result defines triangles as an\n\t*\tarray of arrays with three original vertex indices.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t* Returns:\n\t*\t{integer[3][*]} the result\n\t*/\n\tJSM.TriangulatePolygon = function (polygon)\n\t{\n\t\tvar polygon2D = polygon.ToPolygon2D ();\n\t\treturn JSM.TriangulatePolygon2D (polygon2D);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/octree',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: TraverseOctreeNodes\n\t* Description:\n\t*\tTraverses the nodes of the tree, and calls the given callback when a node found. The return value\n\t*\tof the callback determines if we need to continue traverse along that given node.\n\t* Parameters:\n\t*\toctree {Octree} the octree\n\t*\tnodeFound {function} the callback\n\t*/\n\tJSM.TraverseOctreeNodes = function (octree, nodeFound)\n\t{\n\t\tfunction TraverseNode (node, nodeFound)\n\t\t{\n\t\t\tif (!nodeFound (node)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (node.children === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, child;\n\t\t\tfor (i = 0; i < node.children.length; i++) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tTraverseNode (child, nodeFound);\n\t\t\t}\n\t\t}\n\n\t\tTraverseNode (octree.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: CreateOctreeChildNodes\n\t* Description:\n\t*\tCreate child nodes for an octree node. It calls a callback function\n\t*\twhich should create a new node element for the octree.\n\t* Parameters:\n\t*\toriginalBox {Box} the box of the original node\n\t*\tcreateNodeCallback {function} the callback function\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.CreateOctreeChildNodes = function (originalBox, createNodeCallback)\n\t{\n\t\tfunction CreateNode (originalBox, createNodeCallback, dirX, dirY, dirZ)\n\t\t{\n\t\t\tvar size = originalBox.GetSize ().Clone ();\n\t\t\tsize.MultiplyScalar (0.5);\n\t\t\tvar min = new JSM.Coord (\n\t\t\t\toriginalBox.min.x + dirX * size.x,\n\t\t\t\toriginalBox.min.y + dirY * size.y,\n\t\t\t\toriginalBox.min.z + dirZ * size.z\n\t\t\t);\n\t\t\tvar max = JSM.CoordAdd (min, size);\n\t\t\tvar box = new JSM.Box (min, max);\n\t\t\treturn createNodeCallback (box);\n\t\t}\n\n\t\tvar size = originalBox.GetSize ();\n\t\tif (JSM.IsZero (size.x) && JSM.IsZero (size.y) && JSM.IsZero (size.z)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar result = [\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 0.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 0.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 1.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 1.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 0.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 0.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 1.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 1.0, 1.0),\n\t\t];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: Octree\n\t* Description: Defines an octree. The octree contains each coordinate only once.\n\t* Parameters:\n\t*\tbox {Box} bounding box\n\t*\tmaxCoordNumInNodes {integer} maximum number of coordinates in a node\n\t*/\n\tJSM.Octree = function (box, maxCoordNumInNodes)\n\t{\n\t\tthis.coords = [];\n\t\tthis.root = this.CreateNewNode (null, box);\n\t\tthis.maxCoordNumInNodes = maxCoordNumInNodes;\n\t\tif (this.maxCoordNumInNodes === undefined || this.maxCoordNumInNodes === null || this.maxCoordNumInNodes === 0) {\n\t\t\tthis.maxCoordNumInNodes = 50;\n\t\t}\n\t};\n\n\t/**\n\t* Function: Octree.AddCoord\n\t* Description:\n\t*\tAdds a coordinate to the octree. The return value is the stored index of the coordinate.\n\t*\tIf the coordinate was already in the octree, it returns the existing index.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.AddCoord = function (coord)\n\t{\n\t\treturn this.AddCoordToNode (coord, this.root);\n\t};\n\n\t/**\n\t* Function: Octree.FindCoord\n\t* Description:\n\t*\tFinds a coordinate in the octree, and returns the stored index of it.\n\t*\tThe return value is -1 if the coordinate does not exist.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.FindCoord = function (coord)\n\t{\n\t\tvar node = this.FindNodeForCoord (coord, this.root);\n\t\tif (node === null) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this.FindCoordInNode (coord, node);\n\t};\n\n\t/**\n\t* Function: Octree.FindCoordInNode\n\t* Description: Finds a coordinate in a node.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnode {object} the node\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.FindCoordInNode = function (coord, node)\n\t{\n\t\tvar i, current;\n\t\tfor (i = 0; i < node.coords.length; i++) {\n\t\t\tcurrent = node.coords[i];\n\t\t\tif (coord.IsEqual (this.coords[current])) {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: Octree.AddCoordToNode\n\t* Description: Adds a coordinate to a node.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\troot {object} the root node\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.AddCoordToNode = function (coord, root)\n\t{\n\t\tvar node = this.FindNodeForCoord (coord, root);\n\t\tif (node === null) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tvar found = this.FindCoordInNode (coord, node);\n\t\tif (found != -1) {\t\n\t\t\treturn found;\n\t\t}\n\t\t\n\t\tif (node.coords.length >= this.maxCoordNumInNodes) {\n\t\t\tif (this.SplitNode (node)) {\n\t\t\t\treturn this.AddCoordToNode (coord, node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar index = this.coords.length;\n\t\tthis.coords.push (coord);\n\t\tnode.coords.push (index);\n\t\treturn index;\n\t};\n\n\t/**\n\t* Function: Octree.FindNodeForCoord\n\t* Description: Finds a node for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnode {object} the starting node\n\t* Returns:\n\t*\t{object} the found node\n\t*/\n\tJSM.Octree.prototype.FindNodeForCoord = function (coord, node)\n\t{\n\t\tif (node.children === null) {\n\t\t\treturn node;\n\t\t}\n\t\t\n\t\tvar center = node.box.GetCenter ();\n\t\tvar xGreater = coord.x > center.x;\n\t\tvar yGreater = coord.y > center.y;\n\t\tvar zGreater = coord.z > center.z;\n\t\t\n\t\tif (!xGreater && !yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[0]);\n\t\t} else if (xGreater && !yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[1]);\n\t\t} else if (xGreater && yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[2]);\n\t\t} else if (!xGreater && yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[3]);\n\t\t} else if (!xGreater && !yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[4]);\n\t\t} else if (xGreater && !yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[5]);\n\t\t} else if (xGreater && yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[6]);\n\t\t} else if (!xGreater && yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[7]);\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\n\t/**\n\t* Function: Octree.SplitNode\n\t* Description: Splits a node to subnodes.\n\t* Parameters:\n\t*\tnode {object} the node\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.Octree.prototype.SplitNode = function (node)\n\t{\n\t\tvar myThis = this;\n\t\tvar children = JSM.CreateOctreeChildNodes (node.box, function (nodeBox) {\n\t\t\treturn myThis.CreateNewNode (node, nodeBox);\n\t\t});\n\t\t\n\t\tif (children === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tnode.children = children;\n\t\tvar nodeCoords = node.coords;\n\t\tnode.coords = [];\n\t\t\n\t\tvar i, newNode;\n\t\tfor (i = 0; i < nodeCoords.length; i++) {\n\t\t\tnewNode = this.FindNodeForCoord (this.coords[nodeCoords[i]], node);\n\t\t\tnewNode.coords.push (nodeCoords[i]);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Octree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Parameters:\n\t*\tparent {object} the parent node\n\t*\tbox {Box} the box of the node\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.Octree.prototype.CreateNewNode = function (parent, box)\n\t{\n\t\tvar newNode = {\n\t\t\tparent : parent,\n\t\t\tbox : box,\n\t\t\tcoords : [],\n\t\t\tchildren : null\n\t\t};\n\t\treturn newNode;\t\n\t};\n\n\t/**\n\t* Class: TriangleOctree\n\t* Description:\n\t*\tDefines an octree which stores triangles. Every triangle is placed in\n\t*\tthe smallest possible node which contains all of its vertices.\n\t* Parameters:\n\t*\tbox {Box} bounding box\n\t*/\n\tJSM.TriangleOctree = function (box)\n\t{\n\t\tthis.root = this.CreateNewNode (null, box);\n\t};\n\n\t/**\n\t* Function: TriangleOctree.AddTriangle\n\t* Description: Adds a triangle to the octree.\n\t* Parameters:\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t*\tuserData {anything} user data for the triangle\n\t*/\n\tJSM.TriangleOctree.prototype.AddTriangle = function (v0, v1, v2, userData)\n\t{\n\t\treturn this.AddTriangleToNode (v0, v1, v2, this.root, userData);\n\t};\n\n\t/**\n\t* Function: TriangleOctree.AddTriangleToNode\n\t* Description: Adds a coordinate to a node.\n\t* Parameters:\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t*\troot {object} the root node\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.TriangleOctree.prototype.AddTriangleToNode = function (v0, v1, v2, root, userData)\n\t{\n\t\tfunction IsTriangleInNode (v0, v1, v2, node)\n\t\t{\n\t\t\treturn node.box.IsCoordInside (v0) && node.box.IsCoordInside (v1) && node.box.IsCoordInside (v2);\n\t\t}\n\t\t\n\t\tif (!IsTriangleInNode (v0, v1, v2, root)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (root.children === null) {\n\t\t\tvar myThis = this;\n\t\t\troot.children = JSM.CreateOctreeChildNodes (root.box, function (nodeBox) {\n\t\t\t\treturn myThis.CreateNewNode (root, nodeBox);\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (root.children !== null) {\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < root.children.length; i++) {\n\t\t\t\tnode = root.children[i];\n\t\t\t\tif (this.AddTriangleToNode (v0, v1, v2, node, userData)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\troot.triangles.push ({\n\t\t\tv0 : v0,\n\t\t\tv1 : v1,\n\t\t\tv2 : v2,\n\t\t\tuserData : userData\n\t\t});\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TriangleOctree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Parameters:\n\t*\tparent {object} the parent node\n\t*\tbox {Box} the box of the node\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleOctree.prototype.CreateNewNode = function (parent, box)\n\t{\n\t\tvar newNode = {\n\t\t\tparent : parent,\n\t\t\tbox : box,\n\t\t\ttriangles : [],\n\t\t\tchildren : null\n\t\t};\n\t\treturn newNode;\t\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/bsptree',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: BSPTree\n\t* Description: Defines a BSP tree.\n\t*/\n\tJSM.BSPTree = function ()\n\t{\n\t\tthis.root = null;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygon\n\t* Description: Adds a polygon to the tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygon = function (polygon, userData)\n\t{\n\t\tif (this.root === null) {\n\t\t\tthis.root = this.CreateNewNode ();\n\t\t}\n\t\t\n\t\treturn this.AddPolygonToNode (this.root, polygon, userData);\n\t};\n\n\t/**\n\t* Function: BSPTree.Traverse\n\t* Description: Traverses the tree and calls a function on node found.\n\t* Parameters:\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.Traverse = function (nodeFound)\n\t{\n\t\tthis.TraverseNode (this.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: BSPTree.TraverseNode\n\t* Description: Traverses a node and its children and calls a function on node found.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.TraverseNode = function (node, nodeFound)\n\t{\n\t\tif (node !== null) {\n\t\t\tnodeFound (node);\n\t\t\tthis.TraverseNode (node.inside, nodeFound);\n\t\t\tthis.TraverseNode (node.outside, nodeFound);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Returns the nodes as an array.\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.BSPTree.prototype.GetNodes = function ()\n\t{\n\t\tvar result = [];\n\t\tthis.Traverse (function (node) {\n\t\t\tresult.push (node);\n\t\t});\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Count nodes.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BSPTree.prototype.NodeCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tthis.Traverse (function () {\n\t\t\tcount = count + 1;\n\t\t});\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygonToNode\n\t* Description: Adds a polygon to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygonToNode = function (node, polygon, userData)\n\t{\n\t\tif (polygon.VertexCount () < 3) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar normal;\n\t\tif (node.polygon === null) {\n\t\t\tnormal = polygon.GetNormal ();\n\t\t\tvar plane = JSM.GetPlaneFromCoordAndDirection (polygon.GetVertex (0), normal);\n\t\t\tnode.polygon = polygon;\n\t\t\tif (userData !== undefined) {\n\t\t\t\tnode.userData = userData;\n\t\t\t}\n\t\t\tnode.plane = plane;\n\t\t} else {\n\t\t\tvar backPolygons = [];\n\t\t\tvar frontPolygons = [];\n\t\t\tvar planePolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, frontPolygons, backPolygons, planePolygons);\n\t\t\tif (cutSucceeded) {\n\t\t\t\tif (backPolygons.length > 0) {\n\t\t\t\t\tthis.AddInsidePolygonsToNode (node, backPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (frontPolygons.length > 0) {\n\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, frontPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (planePolygons.length > 0) {\n\t\t\t\t\tnormal = polygon.GetNormal ();\n\t\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\t\tthis.AddInsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddInsidePolygonsToNode\n\t* Description: Adds inside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddInsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.inside === null) {\n\t\t\tnode.inside = this.CreateNewNode ();\n\t\t\tnode.inside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.inside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.AddOutsidePolygonsToNode\n\t* Description: Adds outside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddOutsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.outside === null) {\n\t\t\tnode.outside = this.CreateNewNode ();\n\t\t\tnode.outside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.outside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.BSPTree.prototype.CreateNewNode = function ()\n\t{\n\t\tvar node = {\n\t\t\tpolygon : null,\n\t\t\tuserData : null,\n\t\t\tplane : null,\n\t\t\tparent : null,\n\t\t\tinside : null,\n\t\t\toutside : null\n\t\t};\n\t\treturn node;\n\t};\n\n\t/**\n\t* Function: ClipPolygonWithBSPTree\n\t* Description: Clips a polygon with a created BSP tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the tree\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the tree\n\t*\tplanarFrontPolygons {Polygon[*]} (out) polygons on the tree looks front\n\t*\tplanarBackPolygons {Polygon[*]} (out) polygons on the tree looks back\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ClipPolygonWithBSPTree = function (polygon, bspTree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t{\n\t\tfunction CutPolygonWithNode (polygon, node, isPlanar)\n\t\t{\n\t\t\tif (node === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar cutBackPolygons = [];\n\t\t\tvar cutFrontPolygons = [];\n\t\t\tvar cutPlanarPolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, cutFrontPolygons, cutBackPolygons, cutPlanarPolygons);\n\t\t\tif (!cutSucceeded) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cutBackPolygons.length > 0) {\n\t\t\t\tAddInsidePolygons (node, cutBackPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutFrontPolygons.length > 0) {\n\t\t\t\tAddOutsidePolygons (node, cutFrontPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutPlanarPolygons.length > 0) {\n\t\t\t\tvar normal = polygon.GetNormal ();\n\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\tAddInsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t} else {\n\t\t\t\t\tAddOutsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction CutPolygonsWithNode (polygons, node, isPlanar)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tCutPolygonWithNode (polygons[i], node, isPlanar);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonsToArray (polygons, polygonArray)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tpolygonArray.push (polygons[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddInsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.inside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.inside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarBackPolygons : backPolygons);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddOutsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.outside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.outside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarFrontPolygons : frontPolygons);\n\t\t\t}\n\t\t}\n\n\t\tCutPolygonWithNode (polygon, bspTree.root, false);\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraverseBSPTreeForEyePosition\n\t* Description: Traverses a BSP tree for a given eye position.\n\t* Parameters:\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\teyePosition {Coord} the eye position\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.TraverseBSPTreeForEyePosition = function (bspTree, eyePosition, nodeFound)\n\t{\n\t\tfunction TraverseNode (node)\n\t\t{\n\t\t\tif (node !== null) {\n\t\t\t\tvar coordPlanePosition = node.plane.CoordPosition (eyePosition);\n\t\t\t\tif (coordPlanePosition == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t} else if (coordPlanePosition == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t} else {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTraverseNode (bspTree.root);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/curves',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateCubicBezierCurve\n\t* Description: Generates a bezier curve from the given points.\n\t* Parameters:\n\t*\tp0 {Coord2D} point 1\n\t*\tp1 {Coord2D} point 2\n\t*\tp2 {Coord2D} point 3\n\t*\tp3 {Coord2D} point 4\n\t*\tsegmentation {integer} the segmentation of the result curve\n\t* Returns:\n\t*\t{Coord2D[]} the result\n\t*/\n\tJSM.GenerateCubicBezierCurve = function (p0, p1, p2, p3, segmentation)\n\t{\n\t\tfunction GetCubicBezierPoint (p0, p1, p2, p3, t)\n\t\t{\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\tvar invT = 1.0 - t;\n\t\t\tvar invT2 = invT * invT;\n\t\t\tvar invT3 = invT2 * invT;\n\t\t\tvar x = invT3 * p0.x + 3.0 * invT2 * t * p1.x  + 3.0 * invT * t2 * p2.x + t3 * p3.x;\n\t\t\tvar y = invT3 * p0.y + 3.0 * invT2 * t * p1.y  + 3.0 * invT * t2 * p2.y + t3 * p3.y;\n\t\t\treturn new JSM.Coord2D (x, y);\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\tvar s = 1.0 / segmentation;\n\t\tvar i, coord;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tcoord = GetCubicBezierPoint (p0, p1, p2, p3, i * s);\n\t\t\tresult.push (coord);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BernsteinPolynomial\n\t* Description: Calculates the value of the Bernstein polynomial.\n\t* Parameters:\n\t*\tk {integer} the start index\n\t*\tn {integer} the end index\n\t*\tx {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.BernsteinPolynomial = function (k, n, x)\n\t{\n\t\tfunction BinomialCoefficient (n, k)\n\t\t{\n\t\t\tvar result = 1.0;\n\t\t\tvar min = JSM.Minimum (k, n - k);\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < min; i++) {\n\t\t\t\tresult = result * (n - i);\n\t\t\t\tresult = result / (i + 1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar coefficient = BinomialCoefficient (n, k);\n\t\treturn coefficient * Math.pow (x, k) * Math.pow (1.0 - x, n - k);\n\t};\n\n\t/**\n\t* Function: GenerateBezierCurve\n\t* Description: Generates a bezier curve from the given points.\n\t* Parameters:\n\t*\tpoints {Coord2D[]} the points\n\t*\tsegmentation {integer} the segmentation of the result curve\n\t* Returns:\n\t*\t{Coord2D[]} the result\n\t*/\n\tJSM.GenerateBezierCurve = function (points, segmentation)\n\t{\n\t\tvar result = [];\n\t\tvar n = points.length - 1;\n\t\tvar s = 1.0 / segmentation;\n\t\t\n\t\tvar i, j, t, point, bernstein, coord;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tt = i * s;\n\t\t\tcoord = new JSM.Coord2D (0.0, 0.0);\n\t\t\tfor (j = 0; j <= n; j++) {\n\t\t\t\tpoint = points[j];\n\t\t\t\tbernstein = JSM.BernsteinPolynomial (j, n, t);\n\t\t\t\tcoord.x += point.x * bernstein;\n\t\t\t\tcoord.y += point.y * bernstein;\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/utilities',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GetGaussianCParameter\n\t* Description:\n\t*\tCalculates the gaussian functions c parameter which can be used\n\t*\tfor the gaussian function to reach epsilon at a given value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tepsilon {number} the epsilon value\n\t* Returns:\n\t*\t{number} the c parameter of the function\n\t*/\n\tJSM.GetGaussianCParameter = function (x, a, b, epsilon)\n\t{\n\t\treturn Math.sqrt (-(Math.pow (x - b, 2.0) / (2.0 * Math.log (epsilon / Math.abs (a)))));\n\t};\n\n\t/**\n\t* Function: GetGaussianValue\n\t* Description: Calculates the gaussian functions value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tc {number} the c parameter of the function\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetGaussianValue = function (x, a, b, c)\n\t{\n\t\treturn a * Math.exp (-(Math.pow (x - b, 2.0) / (2.0 * Math.pow (c, 2.0))));\n\t};\n\n\t/**\n\t* Function: GenerateCirclePoints\n\t* Description: Generates coordinates on circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {number} the segmentation of the circle\n\t*\torigo {Coord} the origo of the circle\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.GenerateCirclePoints = function (radius, segmentation, origo)\n\t{\n\t\tvar result = [];\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcoord = JSM.CylindricalToCartesian (radius, 0.0, theta);\n\t\t\tif (origo !== undefined && origo !== null) {\n\t\t\t\tcoord = JSM.CoordAdd (coord, origo);\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetRuledMesh\n\t* Description:\n\t*\tGenerates ruled mesh coordinates and polygons between two coordinate array.\n\t*\tThe two arrays should have the same length. The result is a coordinate array\n\t*\tand a polygon array which contains indices for vertices.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tsegmentation {number} the segmentation of the mesh\n\t*\tvertices {Coord[*]} (out) the vertices of the mesh\n\t*\tpolygons {integer[*][4]} (out) the polygons of the mesh\n\t*/\n\tJSM.GetRuledMesh = function (aCoords, bCoords, segmentation, vertices, polygons)\n\t{\n\t\tif (aCoords.length !== bCoords.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lineSegmentation = aCoords.length - 1;\n\t\tvar meshSegmentation = segmentation;\n\t\tvar directions = [];\n\t\tvar lengths = [];\n\n\t\tvar i, j;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tdirections.push (JSM.CoordSub (bCoords[i], aCoords[i]));\n\t\t\tlengths.push (aCoords[i].DistanceTo (bCoords[i]));\n\t\t}\n\n\t\tvar step, coord;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tstep = lengths[i] / meshSegmentation;\n\t\t\tfor (j = 0; j <= meshSegmentation; j++) {\n\t\t\t\tcoord = aCoords[i].Clone ().Offset (directions[i], step * j);\n\t\t\t\tvertices.push (coord);\n\t\t\t}\n\t\t}\n\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tfor (j = 0; j < meshSegmentation; j++) {\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + meshSegmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + 1;\n\t\t\t\tnext = current + meshSegmentation + 1;\n\t\t\t\tntop = next + 1;\n\n\t\t\t\tpolygon = [current, next, ntop, top];\n\t\t\t\tpolygons.push (polygon);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/ray',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Ray\n\t* Description: Represents a Ray.\n\t* Parameters:\n\t*\torigin {Coord} the starting point of the ray\n\t*\tdirection {Vector} the direction of the ray\n\t*\tlength {number} the length of the ray, null means infinite ray\n\t*/\n\tJSM.Ray = function (origin, direction, length)\n\t{\n\t\tthis.origin = origin;\n\t\tthis.direction = direction.Normalize ();\n\t\tthis.length = length;\n\t};\n\n\t/**\n\t* Function: Ray.Set\n\t* Description: Sets the ray.\n\t* Parameters:\n\t*\torigin {Coord} the starting point of the ray\n\t*\tdirection {Vector} the direction of the ray\n\t*\tlength {number} the length of the ray, null means infinite ray\n\t*/\n\tJSM.Ray.prototype.Set = function (origin, direction, length)\n\t{\n\t\tthis.origin = origin;\n\t\tthis.direction = direction.Normalize ();\n\t\tthis.length = length;\n\t};\n\n\t/**\n\t* Function: Ray.GetOrigin\n\t* Description: Returns the origin of the ray.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Ray.prototype.GetOrigin = function ()\n\t{\n\t\treturn this.origin;\n\t};\n\n\t/**\n\t* Function: Ray.GetDirection\n\t* Description: Returns the direction of the ray.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Ray.prototype.GetDirection = function ()\n\t{\n\t\treturn this.direction;\n\t};\n\n\t/**\n\t* Function: Ray.IsLengthReached\n\t* Description:\n\t*\tReturns if the given length is greater than the length of the ray.\n\t*\tAlways return false in case of infinite ray.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Ray.prototype.IsLengthReached = function (length)\n\t{\n\t\tif (this.length === undefined || this.length === null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn JSM.IsGreater (length, this.length);\n\t};\n\n\t/**\n\t* Function: Ray.Clone\n\t* Description: Clones the ray.\n\t* Returns:\n\t*\t{Ray} a cloned instance\n\t*/\n\tJSM.Ray.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Ray (this.origin.Clone (), this.direction.Clone (), this.length);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/path',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Path2D\n\t* Description: Helper class for building polygons\n\t* Parameters:\n\t*\tsettings {object} path settings\n\t*/\n\tJSM.Path2D = function (settings)\n\t{\n\t\tthis.settings = {\n\t\t\tsegmentation : 10,\n\t\t\toffset : new JSM.Vector2D (0.0, 0.0),\n\t\t\tscale : new JSM.Coord2D (1.0, 1.0)\n\t\t};\n\t\tJSM.CopyObjectProperties (settings, this.settings, true);\n\t\t\n\t\tthis.position = new JSM.Coord2D (0.0, 0.0);\n\t\tthis.positionAdded = false;\n\t\tthis.polygons = [];\n\t\tthis.currentPolygon = null;\n\t};\n\n\t/**\n\t* Function: Path2D.MoveTo\n\t* Description: Moves the current position to the given position.\n\t* Parameters:\n\t*\tx {number} new x position\n\t*\ty {number} new y position\n\t*/\n\tJSM.Path2D.prototype.MoveTo = function (x, y)\n\t{\n\t\tthis.Close ();\n\t\tthis.position.Set (x, y);\n\t\tthis.positionAdded = false;\n\t};\n\n\t/**\n\t* Function: Path2D.LineTo\n\t* Description: Draws a line from current position to the given position.\n\t* Parameters:\n\t*\tx {number} line end x position\n\t*\ty {number} line end y position\n\t*/\n\tJSM.Path2D.prototype.LineTo = function (x, y)\n\t{\n\t\tif (!this.positionAdded) {\n\t\t\tthis.AddPolygonPoint (this.position.x, this.position.y);\n\t\t}\n\t\tthis.AddPolygonPoint (x, y);\n\t};\n\n\t/**\n\t* Function: Path2D.CubicBezierTo\n\t* Description: Draws a cubic bezier curve from the current position to the given position.\n\t* Parameters:\n\t*\tx {number} curve end x position\n\t*\ty {number} curve end y position\n\t*\tcp1x {number} first control point x position\n\t*\tcp1y {number} first control point y position\n\t*\tcp2x {number} second control point x position\n\t*\tcp2y {number} second control point y position\n\t*/\n\tJSM.Path2D.prototype.CubicBezierTo = function (x, y, cp1x, cp1y, cp2x, cp2y)\n\t{\n\t\tvar bezierPoints = JSM.GenerateCubicBezierCurve (\n\t\t\tnew JSM.Coord2D (this.position.x, this.position.y),\n\t\t\tnew JSM.Coord2D (cp1x, cp1y),\n\t\t\tnew JSM.Coord2D (cp2x, cp2y),\n\t\t\tnew JSM.Coord2D (x, y),\n\t\t\tthis.settings.segmentation\n\t\t);\n\t\tvar i;\n\t\tfor (i = 1; i < bezierPoints.length; i++) {\n\t\t\tthis.LineTo (bezierPoints[i].x, bezierPoints[i].y);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Path2D.Close\n\t* Description: Closes the current polygon.\n\t*/\n\tJSM.Path2D.prototype.Close = function ()\n\t{\n\t\tfunction CheckAndCorrectPolygon (polygon)\n\t\t{\n\t\t\tif (polygon.VertexCount () === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (polygon.GetVertex (0).IsEqual (polygon.GetVertex (polygon.VertexCount () - 1))) {\n\t\t\t\tpolygon.RemoveVertex (polygon.VertexCount () - 1);\n\t\t\t}\n\t\t\tif (polygon.VertexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction FindBasePolygon (polygons, polygon)\n\t\t{\n\t\t\tfunction IsBasePolygon (basePolygon, polygon)\n\t\t\t{\n\t\t\t\tbaseOrientation = baseContour.GetOrientation ();\n\t\t\t\tpolygonOrientation = polygon.GetOrientation ();\n\t\t\t\tif (baseOrientation !== polygonOrientation) {\n\t\t\t\t\tvar firstVertex = polygon.GetVertex (0);\n\t\t\t\t\tvar firstVertexPosition = baseContour.CoordPosition (firstVertex);\n\t\t\t\t\tif (firstVertexPosition == JSM.CoordPolygonPosition2D.Inside) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, baseContour, baseOrientation, polygonOrientation;\n\t\t\tfor (i = polygons.length - 1; i >= 0; i--) {\n\t\t\t\tbaseContour = polygons[i].GetContour (0);\n\t\t\t\tif (IsBasePolygon (baseContour, polygon)) {\n\t\t\t\t\treturn polygons[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.currentPolygon !== null) {\n\t\t\tif (CheckAndCorrectPolygon (this.currentPolygon)) {\n\t\t\t\tvar basePolygon = FindBasePolygon (this.polygons, this.currentPolygon);\n\t\t\t\tif (basePolygon === null) {\n\t\t\t\t\tvar contourPolygon = new JSM.ContourPolygon2D ();\n\t\t\t\t\tcontourPolygon.AddContour (this.currentPolygon);\n\t\t\t\t\tthis.polygons.push (contourPolygon);\n\t\t\t\t} else {\n\t\t\t\t\tbasePolygon.AddContour (this.currentPolygon);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.currentPolygon = null;\n\t\t}\n\t};\t\t\t\n\n\t/**\n\t* Function: Path2D.PolygonCount\n\t* Description: Returns the polygon count of the path.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Path2D.prototype.PolygonCount = function ()\n\t{\n\t\treturn this.polygons.length;\n\t};\n\n\t/**\n\t* Function: Path2D.GetPolygon\n\t* Description: Returns the polygons from the path at the given index.\n\t* Parameters:\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{ContourPolygon2D} the result\n\t*/\n\tJSM.Path2D.prototype.GetPolygon = function (index)\n\t{\n\t\treturn this.polygons[index];\n\t};\n\n\t/**\n\t* Function: Path2D.GetPolygons\n\t* Description: Returns the polygons from the path.\n\t* Returns:\n\t*\t{ContourPolygon2D[*]} the result\n\t*/\n\tJSM.Path2D.prototype.GetPolygons = function ()\n\t{\n\t\treturn this.polygons;\n\t};\n\n\t/**\n\t* Function: Path2D.GetCurrentPolygon\n\t* Description: Returns the current polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.Path2D.prototype.GetCurrentPolygon = function ()\n\t{\n\t\tif (this.currentPolygon === null) {\n\t\t\tthis.currentPolygon = new JSM.Polygon2D ();\n\t\t}\n\t\treturn this.currentPolygon;\n\t};\t\t\n\n\t/**\n\t* Function: Path2D.AddPolygonPoint\n\t* Description: Adds a point to the current polygon.\n\t* Parameters:\n\t*\tx {number} the x position of the point\n\t*\ty {number} the y position of the point\n\t*/\n\tJSM.Path2D.prototype.AddPolygonPoint = function (x, y)\n\t{\n\t\tvar polygon = this.GetCurrentPolygon ();\n\t\tvar polygonX = this.settings.offset.x + x * this.settings.scale.x;\n\t\tvar polygonY = this.settings.offset.y + y * this.settings.scale.y;\n\t\tpolygon.AddVertex (polygonX, polygonY);\n\t\tthis.position.Set (x, y);\n\t\tthis.positionAdded = true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/color',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: HexColorToRGBComponents\n\t* Description: Converts hex color strings to RGB components.\n\t* Parameters:\n\t*\thexColor {string} the hex color\n\t* Returns:\n\t*\t{integer[3]} the RGB components\n\t*/\n\tJSM.HexColorToRGBComponents = function (hexColor)\n\t{\n\t\tvar hexString = hexColor.toString (16);\n\t\twhile (hexString.length < 6) {\n\t\t\thexString = '0' + hexString;\n\t\t}\n\t\tvar r = parseInt (hexString.substr (0, 2), 16);\n\t\tvar g = parseInt (hexString.substr (2, 2), 16);\n\t\tvar b = parseInt (hexString.substr (4, 2), 16);\n\t\treturn [r, g, b];\n\t};\n\n\t/**\n\t* Function: HexColorToNormalizedRGBComponents\n\t* Description: Converts hex color strings to normalized (between 0.0 and 1.0) RGB components.\n\t* Parameters:\n\t*\thexColor {string} the hex color\n\t* Returns:\n\t*\t{number[3]} the RGB components\n\t*/\n\tJSM.HexColorToNormalizedRGBComponents = function (hexColor)\n\t{\n\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\treturn [rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0];\n\t};\n\n\t/**\n\t* Function: HexColorToRGBColor\n\t* Description: Converts hex color strings to RGB color.\n\t* Parameters:\n\t*\thexColor {string} the hex color string\n\t* Returns:\n\t*\t{integer} the RGB value\n\t*/\n\tJSM.HexColorToRGBColor = function (hexColor)\n\t{\n\t\tvar hexString = '0x' + hexColor;\n\t\treturn parseInt (hexString, 16);\n\t};\n\n\t/**\n\t* Function: RGBComponentsToHexColor\n\t* Description: Converts RGB components to hex color.\n\t* Parameters:\n\t*\tred {integer} the red component\n\t*\tgreen {integer} the green component\n\t*\tblue {integer} the blue component\n\t* Returns:\n\t*\t{integer} the hex value\n\t*/\n\tJSM.RGBComponentsToHexColor = function (red, green, blue)\n\t{\n\t\tfunction IntegerToHex (intString)\n\t\t{\n\t\t\tvar result = parseInt (intString, 10).toString (16);\n\t\t\twhile (result.length < 2) {\n\t\t\t\tresult = '0' + result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvar r = IntegerToHex (red);\n\t\tvar g = IntegerToHex (green);\n\t\tvar b = IntegerToHex (blue);\n\t\tvar hexString = '0x' + r + g + b;\n\t\treturn parseInt (hexString, 16);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/material',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Material\n\t* Description:\n\t*\tDefines a material. The parameter structure can contain the following values:\n\t*\tambient, diffuse, specular, shininess, opacity, texture, textureWidth, textureHeight.\n\t* Parameters:\n\t*\tparameters {object} parameters of the material\n\t*/\n\tJSM.Material = function (parameters)\n\t{\n\t\tthis.ambient = 0x00cc00;\n\t\tthis.diffuse = 0x00cc00;\n\t\tthis.specular = 0x000000;\n\t\tthis.shininess = 0.0;\n\t\tthis.opacity = 1.0;\n\t\tthis.reflection = 0.0;\n\t\tthis.singleSided = false;\n\t\tthis.pointSize = 0.1;\n\t\tthis.texture = null;\n\t\tthis.textureWidth = 1.0;\n\t\tthis.textureHeight = 1.0;\n\t\tJSM.CopyObjectProperties (parameters, this, true);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/materialset',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: MaterialSet\n\t* Description: Defines a material container.\n\t*/\n\tJSM.MaterialSet = function ()\n\t{\n\t\tthis.materials = [];\n\t\tthis.defaultMaterial = new JSM.Material ();\n\t};\n\n\t/**\n\t* Function: MaterialSet.AddMaterial\n\t* Description: Adds a material to the container.\n\t* Parameters:\n\t*\tmaterial {Material} the material\n\t* Returns:\n\t*\t{integer} the index of the newly added material\n\t*/\n\tJSM.MaterialSet.prototype.AddMaterial = function (material)\n\t{\n\t\tthis.materials.push (material);\n\t\treturn this.materials.length - 1;\n\t};\n\n\t/**\n\t* Function: MaterialSet.GetMaterial\n\t* Description: Returns a material from the container.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.MaterialSet.prototype.GetMaterial = function (index)\n\t{\n\t\tif (index < 0 || index >= this.materials.length) {\n\t\t\treturn this.defaultMaterial;\n\t\t}\n\t\treturn this.materials[index];\n\t};\n\n\t/**\n\t* Function: MaterialSet.GetDefaultMaterial\n\t* Description: Returns the default material from the container. It is always exists.\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.MaterialSet.prototype.GetDefaultMaterial = function ()\n\t{\n\t\treturn this.defaultMaterial;\n\t};\n\n\t/**\n\t* Function: MaterialSet.Count\n\t* Description: Returns the material count of the container.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.MaterialSet.prototype.Count = function ()\n\t{\n\t\treturn this.materials.length;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/body',[\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: BodyVertex\n\t* Description:\n\t*\tRepresents a vertex of a 3D body. The vertex contains\n\t*\tonly its position as a 3D coordinate.\n\t* Parameters:\n\t*\tposition {Coord} the position\n\t*/\n\tJSM.BodyVertex = function (position)\n\t{\n\t\tthis.position = position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.GetPosition\n\t* Description: Returns the position of the vertex.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.BodyVertex.prototype.GetPosition = function ()\n\t{\n\t\treturn this.position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.SetPosition\n\t* Description: Sets the position of the vertex.\n\t* Parameters:\n\t*\tposition {Coord} the position\n\t*/\n\tJSM.BodyVertex.prototype.SetPosition = function (position)\n\t{\n\t\tthis.position = position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.Clone\n\t* Description: Clones the vertex.\n\t* Returns:\n\t*\t{BodyVertex} the cloned instance\n\t*/\n\tJSM.BodyVertex.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.BodyVertex (this.position.Clone ());\n\t};\n\n\t/**\n\t* Class: BodyPoint\n\t* Description:\n\t*\tRepresents a point in a 3D body. The point contains the vertex index stored in its 3D body,\n\t*\tand a material index of a material defined outside of the body.\n\t* Parameters:\n\t*\tindex {integer} the vertex index stored in the body\n\t*/\n\tJSM.BodyPoint = function (index)\n\t{\n\t\tthis.vertex = index;\n\t\tthis.material = -1;\n\t};\n\n\t/**\n\t* Function: BodyPoint.GetVertexIndex\n\t* Description: Returns the body vertex index of the point.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyPoint.prototype.GetVertexIndex = function ()\n\t{\n\t\treturn this.vertex;\n\t};\n\n\t/**\n\t* Function: BodyPoint.SetVertexIndex\n\t* Description: Sets the vertex index of the point.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyPoint.prototype.SetVertexIndex = function (index)\n\t{\n\t\tthis.vertex = index;\n\t};\n\n\t/**\n\t* Function: BodyPoint.HasMaterialIndex\n\t* Description: Returns if the point has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPoint.prototype.HasMaterialIndex = function ()\n\t{\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPoint.GetMaterialIndex\n\t* Description: Returns the point material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPoint.prototype.GetMaterialIndex = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.SetMaterialIndex\n\t* Description: Sets the point material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyPoint.prototype.SetMaterialIndex = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.InheritAttributes\n\t* Description: Inherits attributes (material) from an another point.\n\t* Parameters:\n\t*\tsource {BodyPoint} the source point\n\t*/\n\tJSM.BodyPoint.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.Clone\n\t* Description: Clones the point.\n\t* Returns:\n\t*\t{BodyPoint} the cloned instance\n\t*/\n\tJSM.BodyPoint.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyPoint (this.vertex);\n\t\tresult.material = this.material;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: BodyLine\n\t* Description:\n\t*\tRepresents a line in a 3D body. The line contains begin and end indices of vertices\n\t*\tstored in its 3D body, and a material index of a material defined outside of the body.\n\t* Parameters:\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.BodyLine = function (beg, end)\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t\tthis.material = -1;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetBegVertexIndex\n\t* Description: Returns the body vertex index at the beginning of the line.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyLine.prototype.GetBegVertexIndex = function ()\t{\n\t\treturn this.beg;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetBegVertexIndex\n\t* Description: Sets the begin vertex index of the line.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyLine.prototype.SetBegVertexIndex = function (index)\t{\n\t\tthis.beg = index;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetEndVertexIndex\n\t* Description: Returns the body vertex index at the end of the line.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyLine.prototype.GetEndVertexIndex = function ()\t{\n\t\treturn this.end;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetEndVertexIndex\n\t* Description: Sets the end vertex index of the line.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyLine.prototype.SetEndVertexIndex = function (index)\t{\n\t\tthis.end = index;\n\t};\n\n\t/**\n\t* Function: BodyLine.HasMaterialIndex\n\t* Description: Returns if the line has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyLine.prototype.HasMaterialIndex = function (){\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetMaterialIndex\n\t* Description: Returns the line material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyLine.prototype.GetMaterialIndex = function (){\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetMaterialIndex\n\t* Description: Sets the line material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyLine.prototype.SetMaterialIndex = function (material){\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyLine.InheritAttributes\n\t* Description: Inherits attributes (material) from an another line.\n\t* Parameters:\n\t*\tsource {BodyLine} the source line\n\t*/\n\tJSM.BodyLine.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t};\n\n\t/**\n\t* Function: BodyLine.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{BodyLine} the cloned instance\n\t*/\n\tJSM.BodyLine.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyLine (this.beg, this.end);\n\t\tresult.material = this.material;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: BodyPolygon\n\t* Description:\n\t*\tRepresents a polygon in a 3D body. The polygon contains indices of vertices stored in its body.\n\t*\tIt also contains a material index of a material defined outside of the body, and a curve\n\t*\tgroup index which defines its normal vector calculation in case of smooth surfaces.\n\t* Parameters:\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.BodyPolygon = function (vertices)\n\t{\n\t\tthis.vertices = vertices;\n\t\tthis.material = -1;\n\t\tthis.curved = -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.AddVertexIndex\n\t* Description: Adds a vertex index to the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.AddVertexIndex = function (index)\n\t{\n\t\tthis.vertices.push (index);\n\t};\n\n\t/**\n\t* Function: BodyPolygon.InsertVertexIndex\n\t* Description: Inserts a vertex index to given index in the polygon.\n\t* Parameters:\n\t*\tvertexIndex {integer} the vertex index\n\t*\tpolygonIndex {integer} the index in the polygon\n\t*/\n\tJSM.BodyPolygon.prototype.InsertVertexIndex = function (vertexIndex, polygonIndex)\n\t{\n\t\tthis.vertices.splice (polygonIndex, 0, vertexIndex);\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetVertexIndex\n\t* Description: Returns the body vertex index at the given polygon vertex index.\n\t* Parameters:\n\t*\tindex {integer} the polygon vertex index\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.GetVertexIndex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetVertexIndex\n\t* Description: Sets the body vertex index at the given polygon vertex index.\n\t* Parameters:\n\t*\tindex {integer} the polygon vertex index\n\t*\tvertIndex {integer} the body vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.SetVertexIndex = function (index, vertIndex)\n\t{\n\t\tthis.vertices[index] = vertIndex;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetVertexIndices\n\t* Description: Returns an array of the body vertex indices in the polygon.\n\t* Returns:\n\t*\t{integer[]} the stored vertex indices\n\t*/\n\tJSM.BodyPolygon.prototype.GetVertexIndices = function ()\n\t{\n\t\treturn this.vertices;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetVertexIndices\n\t* Description: Sets the vertex indices in the polygon.\n\t* Parameters:\n\t*\tvertices {integer[]} the new vertex indices\n\t*/\n\tJSM.BodyPolygon.prototype.SetVertexIndices = function (vertices)\n\t{\n\t\tthis.vertices = vertices;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.VertexIndexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.VertexIndexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.HasMaterialIndex\n\t* Description: Returns if the polygon has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPolygon.prototype.HasMaterialIndex = function ()\n\t{\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetMaterialIndex\n\t* Description: Returns the polygons material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.GetMaterialIndex = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetMaterialIndex\n\t* Description: Sets the polygons material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyPolygon.prototype.SetMaterialIndex = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.HasCurveGroup\n\t* Description: Returns if the polygon has a curve group index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPolygon.prototype.HasCurveGroup = function ()\n\t{\n\t\treturn this.curved !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetCurveGroup\n\t* Description: Returns the polygons curve group index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.GetCurveGroup = function ()\n\t{\n\t\treturn this.curved;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetCurveGroup\n\t* Description: Sets the polygons curve group index.\n\t* Parameters:\n\t*\tgroup {integer} the curve group index\n\t*/\n\tJSM.BodyPolygon.prototype.SetCurveGroup = function (group)\n\t{\n\t\tthis.curved = group;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.ReverseVertexIndices\n\t* Description: Reverses the order of vertex indices in the polygon.\n\t*/\n\tJSM.BodyPolygon.prototype.ReverseVertexIndices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t};\n\n\t/**\n\t* Function: BodyPolygon.InheritAttributes\n\t* Description: Inherits attributes (material and curve group index) from an another polygon.\n\t* Parameters:\n\t*\tsource {BodyPolygon} the source polygon\n\t*/\n\tJSM.BodyPolygon.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t\tthis.curved = source.curved;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{BodyPolygon} the cloned instance\n\t*/\n\tJSM.BodyPolygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyPolygon ([]);\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.vertices.push (this.vertices[i]);\n\t\t}\n\t\tresult.material = this.material;\n\t\tresult.curved = this.curved;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Enum: TextureProjectionType\n\t* Description: Texture projection type.\n\t* Values:\n\t*\t{Planar} planar projection\n\t*\t{Cubic} cubic projection\n\t*\t{Cylindrical} cylindrical projection\n\t*/\n\tJSM.TextureProjectionType = {\n\t\tPlanar : 0,\n\t\tCubic : 1,\n\t\tCylindrical : 2\n\t};\n\n\t/**\n\t* Class: BodyTextureProjection\n\t* Description:\n\t*\tRepresents the texture projection of the body. It contains a projection type,\n\t*\tand a coordinate system for projection.\n\t*/\n\tJSM.BodyTextureProjection = function ()\n\t{\n\t\tthis.type = null;\n\t\tthis.coords = null;\n\t\tthis.SetCubic (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.GetType\n\t* Description: Returns the texture projection type.\n\t* Returns:\n\t*\t{TextureProjectionType} the result\n\t*/\n\tJSM.BodyTextureProjection.prototype.GetType = function ()\n\t{\n\t\treturn this.type;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.GetCoords\n\t* Description: Returns the texture projection coordinate system.\n\t* Returns:\n\t*\t{CoordSystem} the result\n\t*/\n\tJSM.BodyTextureProjection.prototype.GetCoords = function ()\n\t{\n\t\treturn this.coords;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetType\n\t* Description: Sets the texture projection type.\n\t* Parameters:\n\t*\ttype {TextureProjectionType} the type\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetType = function (type)\n\t{\n\t\tthis.type = type;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCoords\n\t* Description: Sets the texture projection coordinates.\n\t* Parameters:\n\t*\tcoords {CoordSystem} the coordinates\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCoords = function (coords)\n\t{\n\t\tthis.coords = coords;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetPlanar\n\t* Description: Sets the texture projection to planar with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction of the projection plane\n\t*\tyDirection {Vector} y direction of the projection plane\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetPlanar = function (origo, xDirection, yDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Planar;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection,\n\t\t\tyDirection,\n\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCubic\n\t* Description: Sets the texture projection to cubic with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction (edge of the cube) of the projection\n\t*\tyDirection {Vector} y direction (edge of the cube) of the projection\n\t*\tzDirection {Vector} z direction (edge of the cube) of the projection\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCubic = function (origo, xDirection, yDirection, zDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Cubic;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection,\n\t\t\tyDirection,\n\t\t\tzDirection\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCylindrical\n\t* Description: Sets the texture projection to cylindrical with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\tradius {number} radius of the cylinder\n\t*\txDirection {Vector} x direction (start point along perimeter) of the projection\n\t*\tzDirection {Vector} z direction (normal vector) of the projection\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCylindrical = function (origo, radius, xDirection, zDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Cylindrical;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection.Clone ().SetLength (radius),\n\t\t\tJSM.VectorCross (zDirection, xDirection).SetLength (radius),\n\t\t\tzDirection\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.Transform\n\t* Description: Transforms the texture projection coordinate system.\n\t* Parameters:\n\t*\ttransformation {Transformation} the transformation\n\t*/\n\tJSM.BodyTextureProjection.prototype.Transform = function (transformation)\n\t{\n\t\tthis.coords.ToAbsoluteCoords ();\n\t\tthis.coords.origo = transformation.Apply (this.coords.origo);\n\t\tthis.coords.e1 = transformation.Apply (this.coords.e1);\n\t\tthis.coords.e2 = transformation.Apply (this.coords.e2);\n\t\tthis.coords.e3 = transformation.Apply (this.coords.e3);\n\t\tthis.coords.ToDirectionVectors ();\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.Clone\n\t* Description: Clones the texture projection.\n\t* Returns:\n\t*\t{BodyTextureProjection} the cloned instance\n\t*/\n\tJSM.BodyTextureProjection.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyTextureProjection ();\n\t\tresult.SetType (this.type);\n\t\tresult.SetCoords (this.coords.Clone ());\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: Body\n\t* Description:\n\t*\tRepresents a 3D body. The body contains vertices, polygons,\n\t*\tand a texture coordinate system.\n\t*/\n\tJSM.Body = function ()\n\t{\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Body.AddVertex\n\t* Description: Adds a vertex to the body.\n\t* Parameters:\n\t*\tvertex {BodyVertex} the vertex\n\t* Returns:\n\t*\t{integer} the index of the newly added vertex\n\t*/\n\tJSM.Body.prototype.AddVertex = function (vertex)\n\t{\n\t\tthis.vertices.push (vertex);\n\t\treturn this.vertices.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddPoint\n\t* Description: Adds a point to the body.\n\t* Parameters:\n\t*\tpoint {BodyPoint} the point\n\t* Returns:\n\t*\t{integer} the index of the newly added point\n\t*/\n\tJSM.Body.prototype.AddPoint = function (point)\n\t{\n\t\tthis.points.push (point);\n\t\treturn this.points.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddLine\n\t* Description: Adds a line to the body.\n\t* Parameters:\n\t*\tline {BodyLine} the line\n\t* Returns:\n\t*\t{integer} the index of the newly added line\n\t*/\n\tJSM.Body.prototype.AddLine = function (line)\n\t{\n\t\tthis.lines.push (line);\n\t\treturn this.lines.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddPolygon\n\t* Description: Adds a polygon to the body.\n\t* Parameters:\n\t*\tpolygon {BodyPolygon} the polygon\n\t* Returns:\n\t*\t{integer} the index of the newly added polygon\n\t*/\n\tJSM.Body.prototype.AddPolygon = function (polygon)\n\t{\n\t\tthis.polygons.push (polygon);\n\t\treturn this.polygons.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.GetVertex\n\t* Description: Returns the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{BodyVertex} the result\n\t*/\n\tJSM.Body.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Body.GetVertexPosition\n\t* Description: Returns the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Body.prototype.GetVertexPosition = function (index)\n\t{\n\t\treturn this.vertices[index].position;\n\t};\n\n\t/**\n\t* Function: Body.SetVertexPosition\n\t* Description: Sets the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*\tposition {Coord} the new position\n\t*/\n\tJSM.Body.prototype.SetVertexPosition = function (index, position)\n\t{\n\t\tthis.vertices[index].position = position;\n\t};\n\n\t/**\n\t* Function: Body.GetPoint\n\t* Description: Returns the point at the given index.\n\t* Parameters:\n\t*\tindex {integer} the point index\n\t* Returns:\n\t*\t{BodyPoint} the result\n\t*/\n\tJSM.Body.prototype.GetPoint = function (index)\n\t{\n\t\treturn this.points[index];\n\t};\n\n\t/**\n\t* Function: Body.GetLine\n\t* Description: Returns the line at the given index.\n\t* Parameters:\n\t*\tindex {integer} the line index\n\t* Returns:\n\t*\t{BodyLine} the result\n\t*/\n\tJSM.Body.prototype.GetLine = function (index)\n\t{\n\t\treturn this.lines[index];\n\t};\n\n\t/**\n\t* Function: Body.GetPolygon\n\t* Description: Returns the polygon at the given index.\n\t* Parameters:\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{BodyPolygon} the result\n\t*/\n\tJSM.Body.prototype.GetPolygon = function (index)\n\t{\n\t\treturn this.polygons[index];\n\t};\n\n\t/**\n\t* Function: Body.SetPointsMaterialIndex\n\t* Description: Sets the material index for all points in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetPointsMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tthis.points[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetLinesMaterialIndex\n\t* Description: Sets the material index for all lines in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetLinesMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tthis.lines[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetPolygonsMaterialIndex\n\t* Description: Sets the material index for all polygons in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetPolygonsMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tthis.polygons[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetPolygonsCurveGroup\n\t* Description: Sets the curve group index for all polygons in the body.\n\t* Parameters:\n\t*\tgroup {integer} the curve group index\n\t*/\n\tJSM.Body.prototype.SetPolygonsCurveGroup = function (group)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tthis.polygons[i].SetCurveGroup (group);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.RemoveVertex\n\t* Description: Removes a vertex from the body. It also removes connected polygons.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Body.prototype.RemoveVertex = function (index)\n\t{\n\t\tvar pointsToDelete = [];\n\t\tvar linesToDelete = [];\n\t\tvar polygonsToDelete = [];\n\t\tvar i, j, point, line, polygon, bodyVertIndex;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tpoint = this.points[i];\n\t\t\tif (point.GetVertexIndex () == index) {\n\t\t\t\tpointsToDelete.push (i);\n\t\t\t} else if (point.GetVertexIndex () >= index) {\n\t\t\t\tpoint.SetVertexIndex (point.GetVertexIndex () - 1);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tline = this.lines[i];\n\t\t\tif (line.GetBegVertexIndex () == index || line.GetEndVertexIndex () == index) {\n\t\t\t\tlinesToDelete.push (i);\n\t\t\t} else {\n\t\t\t\tif (line.GetBegVertexIndex () >= index) {\n\t\t\t\t\tline.SetBegVertexIndex (line.GetBegVertexIndex () - 1);\n\t\t\t\t}\n\t\t\t\tif (line.GetEndVertexIndex () >= index) {\n\t\t\t\t\tline.SetEndVertexIndex (line.GetEndVertexIndex () - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tpolygon = this.polygons[i];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tbodyVertIndex = polygon.GetVertexIndex (j);\n\t\t\t\tif (polygon.GetVertexIndex (j) == index) {\n\t\t\t\t\tpolygonsToDelete.push (i);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (bodyVertIndex >= index) {\n\t\t\t\t\tpolygon.SetVertexIndex (j, bodyVertIndex - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < pointsToDelete.length; i++) {\n\t\t\tthis.RemovePoint (pointsToDelete[i] - i);\n\t\t}\n\t\tfor (i = 0; i < linesToDelete.length; i++) {\n\t\t\tthis.RemoveLine (linesToDelete[i] - i);\n\t\t}\n\t\tfor (i = 0; i < polygonsToDelete.length; i++) {\n\t\t\tthis.RemovePolygon (polygonsToDelete[i] - i);\n\t\t}\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemovePoint\n\t* Description: Removes a point from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the point\n\t*/\n\tJSM.Body.prototype.RemovePoint = function (index)\n\t{\n\t\tthis.points.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemoveLine\n\t* Description: Removes a line from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the line\n\t*/\n\tJSM.Body.prototype.RemoveLine = function (index)\n\t{\n\t\tthis.lines.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemovePolygon\n\t* Description: Removes a polygon from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the polygon\n\t*/\n\tJSM.Body.prototype.RemovePolygon = function (index)\n\t{\n\t\tthis.polygons.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.VertexCount\n\t* Description: Returns the vertex count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Body.PointCount\n\t* Description: Returns the point count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.PointCount = function ()\n\t{\n\t\treturn this.points.length;\n\t};\n\n\t/**\n\t* Function: Body.LineCount\n\t* Description: Returns the line count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.LineCount = function ()\n\t{\n\t\treturn this.lines.length;\n\t};\n\n\t/**\n\t* Function: Body.PolygonCount\n\t* Description: Returns the polygon count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.PolygonCount = function ()\n\t{\n\t\treturn this.polygons.length;\n\t};\n\n\t/**\n\t* Function: Body.GetTextureProjection\n\t* Description: Returns the texture projection of the body.\n\t* Returns:\n\t*\t{BodyTextureProjection} the result\n\t*/\n\tJSM.Body.prototype.GetTextureProjection = function ()\n\t{\n\t\treturn this.projection;\n\t};\n\n\t/**\n\t* Function: Body.SetTextureProjection\n\t* Description: Sets the texture projection of the body.\n\t* Parameters:\n\t*\tprojection {BodyTextureProjection} the new texture projection\n\t*/\n\tJSM.Body.prototype.SetTextureProjection = function (projection)\n\t{\n\t\tthis.projection = projection;\n\t};\n\n\t/**\n\t* Function: Body.SetPlanarTextureProjection\n\t* Description: Sets the texture projection to planar with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction of the projection plane\n\t*\tyDirection {Vector} y direction of the projection plane\n\t*/\n\tJSM.Body.prototype.SetPlanarTextureProjection = function (origo, xDirection, yDirection)\n\t{\n\t\tthis.projection.SetPlanar (origo, xDirection, yDirection);\n\t};\n\n\t/**\n\t* Function: Body.SetCubicTextureProjection\n\t* Description: Sets the texture projection to cubic with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction (edge of the cube) of the projection\n\t*\tyDirection {Vector} y direction (edge of the cube) of the projection\n\t*\tzDirection {Vector} z direction (edge of the cube) of the projection\n\t*/\n\tJSM.Body.prototype.SetCubicTextureProjection = function (origo, xDirection, yDirection, zDirection)\n\t{\n\t\tthis.projection.SetCubic (origo, xDirection, yDirection, zDirection);\n\t};\n\n\t/**\n\t* Function: Body.SetCylindricalTextureProjection\n\t* Description: Sets the texture projection to cylindrical with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\tradius {number} radius of the cylinder\n\t*\txDirection {Vector} x direction (start point along perimeter) of the projection\n\t*\tzDirection {Vector} z direction (normal vector) of the projection\n\t*/\n\tJSM.Body.prototype.SetCylindricalTextureProjection = function (origo, radius, xDirection, zDirection)\n\t{\n\t\tthis.projection.SetCylindrical (origo, radius, xDirection, zDirection);\n\t};\n\n\t/**\n\t* Function: Body.Transform\n\t* Description: Transforms the body.\n\t* Parameters:\n\t*\ttransformation {Transformation} the transformation\n\t*/\n\tJSM.Body.prototype.Transform = function (transformation)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tthis.vertices[i].position = transformation.Apply (this.vertices[i].position);\n\t\t}\n\t\tthis.projection.Transform (transformation);\n\t};\n\n\t/**\n\t* Function: Body.GetBoundingBox\n\t* Description: Returns the bounding box of the body.\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.Body.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i].position;\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\t\t\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\t/**\n\t* Function: Body.GetCenter\n\t* Description: Returns the center of the bounding box of the body.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Body.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\t/**\n\t* Function: Body.GetBoundingSphere\n\t* Description: Returns the bounding sphere of the body.\n\t* Returns:\n\t*\t{Sphere} the result\n\t*/\n\tJSM.Body.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\t\t\n\t\tvar i, current;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcurrent = center.DistanceTo (this.vertices[i].position);\n\t\t\tif (JSM.IsGreater (current, radius)) {\n\t\t\t\tradius = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.Sphere (center, radius);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Body.OffsetToOrigo\n\t* Description: Offsets the body to the origo.\n\t*/\n\tJSM.Body.prototype.OffsetToOrigo = function ()\n\t{\n\t\tvar center = this.GetCenter ().Clone ();\n\t\tcenter.MultiplyScalar (-1.0);\n\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tthis.vertices[i].position = JSM.CoordAdd (this.vertices[i].position, center);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.Merge\n\t* Description: Merges an existing body to the body.\n\t* Parameters:\n\t*\tbody {Body} the body to merge\n\t*/\n\tJSM.Body.prototype.Merge = function (body)\n\t{\n\t\tvar oldVertexCount = this.vertices.length;\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tthis.vertices.push (body.GetVertex (i).Clone ());\n\t\t}\n\t\t\n\t\tvar newPoint;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tnewPoint = body.GetPoint (i).Clone ();\n\t\t\tnewPoint.SetVertexIndex (newPoint.GetVertexIndex () + oldVertexCount);\n\t\t\tthis.points.push (newPoint);\n\t\t}\t\n\t\t\n\t\tvar newLine;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tnewLine = body.GetLine (i).Clone ();\n\t\t\tnewLine.SetBegVertexIndex (newLine.GetBegVertexIndex () + oldVertexCount);\n\t\t\tnewLine.SetEndVertexIndex (newLine.GetEndVertexIndex () + oldVertexCount);\n\t\t\tthis.lines.push (newLine);\n\t\t}\n\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnewPolygon = body.GetPolygon (i).Clone ();\n\t\t\tfor (j = 0; j < newPolygon.VertexIndexCount (); j++) {\n\t\t\t\tnewPolygon.vertices[j] += oldVertexCount;\n\t\t\t}\n\t\t\tthis.polygons.push (newPolygon);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.Clear\n\t* Description: Makes the body empty.\n\t*/\n\tJSM.Body.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.points = [];\n\t\tthis.lines = [];\n\t\tthis.polygons = [];\n\t\tthis.projection = new JSM.BodyTextureProjection ();\n\t};\n\n\t/**\n\t* Function: Body.Clone\n\t* Description: Clones the body.\n\t* Returns:\n\t*\t{Body} the cloned instance\n\t*/\n\tJSM.Body.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.AddVertex (this.vertices[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tresult.AddPoint (this.points[i].Clone ());\n\t\t}\n\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tresult.AddLine (this.lines[i].Clone ());\n\t\t}\n\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tresult.AddPolygon (this.polygons[i].Clone ());\n\t\t}\n\n\t\tresult.SetTextureProjection (this.projection.Clone ());\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/model',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Model\n\t* Description: Represents a 3D model. The model contains bodies.\n\t*/\n\tJSM.Model = function ()\n\t{\n\t\tthis.bodies = [];\n\t\tthis.materials = new JSM.MaterialSet ();\n\t};\n\n\t/**\n\t* Function: Model.AddBody\n\t* Description: Adds a body to the model.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer} the index of the newly added body\n\t*/\n\tJSM.Model.prototype.AddBody = function (body)\n\t{\n\t\tthis.bodies.push (body);\n\t\treturn this.bodies.length - 1;\n\t};\n\n\t/**\n\t* Function: Model.AddBodies\n\t* Description: Adds bodies to the model.\n\t* Parameters:\n\t*\tbodies {Body[*]} the body\n\t*/\n\tJSM.Model.prototype.AddBodies = function (bodies)\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < bodies.length; i++) {\n\t\t\tbody = bodies[i];\n\t\t\tthis.AddBody (body);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Model.GetBody\n\t* Description: Returns the stored body with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.Model.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\t/**\n\t* Function: Model.BodyCount\n\t* Description: Returns the body count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.BodyCount = function ()\n\t{\n\t\treturn this.bodies.length;\n\t};\n\n\t/**\n\t* Function: Model.AddMaterial\n\t* Description: Adds a material to the mode.\n\t* Parameters:\n\t*\tmaterial {Material} the material\n\t* Returns:\n\t*\t{integer} the index of the newly added material\n\t*/\n\tJSM.Model.prototype.AddMaterial = function (material)\n\t{\n\t\treturn this.materials.AddMaterial (material);\n\t};\n\n\t/**\n\t* Function: Model.GetMaterial\n\t* Description: Returns a material from the model.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.Model.prototype.GetMaterial = function (index)\n\t{\n\t\treturn this.materials.GetMaterial (index);\n\t};\n\n\t/**\n\t* Function: Model.GetDefaultMaterial\n\t* Description: Returns the default material from the model. It is always exists.\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.Model.prototype.GetDefaultMaterial = function ()\n\t{\n\t\treturn this.materials.GetDefaultMaterial ();\n\t};\n\n\t/**\n\t* Function: Model.GetMaterialSet\n\t* Description: Returns the material set of the model.\n\t* Returns:\n\t*\t{MaterialSet} the result\n\t*/\n\tJSM.Model.prototype.GetMaterialSet = function ()\n\t{\n\t\treturn this.materials;\n\t};\n\n\t/**\n\t* Function: Model.Count\n\t* Description: Returns the material count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.MaterialCount = function ()\n\t{\n\t\treturn this.materials.Count ();\n\t};\n\n\t/**\n\t* Function: Model.VertexCount\n\t* Description: Returns the vertex count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.VertexCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tcount += this.bodies[i].VertexCount ();\n\t\t}\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: Model.PolygonCount\n\t* Description: Returns the polygon count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.PolygonCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tcount += this.bodies[i].PolygonCount ();\n\t\t}\n\t\treturn count;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/adjacencyinfo',[\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: VertInfo\n\t* Description:\n\t*\tContains adjacency information for a body vertex. Contains arrays\n\t*\twith indices of connected edge and polygon info.\n\t*/\n\tJSM.VertInfo = function ()\n\t{\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\n\t};\n\n\t/**\n\t* Class: EdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body edge. Contains indices\n\t*\tof connected vertex and polygon info.\n\t*/\n\tJSM.EdgeInfo = function ()\n\t{\n\t\tthis.vert1 = -1;\n\t\tthis.vert2 = -1;\n\t\tthis.pgon1 = -1;\n\t\tthis.pgon2 = -1;\n\t};\n\n\t/**\n\t* Class: PolyEdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon edge. Contains an index\n\t*\tof an existing edge, and a flag which defines its direction.\n\t*/\n\tJSM.PolyEdgeInfo = function ()\n\t{\n\t\tthis.index = -1;\n\t\tthis.reverse = false;\n\t};\n\n\t/**\n\t* Class: PgonInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon. Contains arrays\n\t*\twith indices of connected vertex and poly edge info.\n\t*/\n\tJSM.PgonInfo = function ()\n\t{\n\t\tthis.verts = [];\n\t\tthis.pedges = [];\n\t};\n\n\t/**\n\t* Class: AdjacencyInfo\n\t* Description:\n\t*\tContains adjacency information for a body. Contains arrays\n\t*\twith vertex, edge and polygon info.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo = function (body)\n\t{\n\t\tthis.verts = null;\n\t\tthis.edges = null;\n\t\tthis.pgons = null;\n\t\tthis.Calculate (body);\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.Reset\n\t* Description: Calculates the adjacency information for a body.\n\t* Returns:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo.prototype.Calculate = function (body)\n\t{\n\t\tfunction AddVertex (adjacencyInfo)\n\t\t{\n\t\t\tvar vert = new JSM.VertInfo ();\n\t\t\tadjacencyInfo.verts.push (vert);\n\t\t}\n\t\t\n\t\tfunction AddPolygon (adjacencyInfo, body, polygonIndex)\n\t\t{\n\t\t\tfunction AddEdge (adjacencyInfo, pgonInfo, fromVertexIndex, toVertexIndex, polygonIndex)\n\t\t\t{\n\t\t\t\tfunction ConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo)\n\t\t\t\t{\n\t\t\t\t\tfunction ConnectPgonAndEdgeToVert (vert, pgonIndex, edgeIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (vert.edges.indexOf (edgeIndex) == -1) {\n\t\t\t\t\t\t\tvert.edges.push (edgeIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vert.pgons.indexOf (pgonIndex) == -1) {\n\t\t\t\t\t\t\tvert.pgons.push (pgonIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpgonInfo.verts.push (fromVertexIndex);\n\t\t\t\t\tpgonInfo.pedges.push (pedge);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[fromVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[toVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar pedge = new JSM.PolyEdgeInfo ();\n\t\t\t\n\t\t\t\tvar i, edge;\n\t\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\t\tif (edge.vert1 === fromVertexIndex && edge.vert2 === toVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t\t} else if (edge.vert1 === toVertexIndex && edge.vert2 === fromVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pedge.index === -1) {\n\t\t\t\t\tvar newEdge = new JSM.EdgeInfo ();\n\t\t\t\t\tnewEdge.vert1 = fromVertexIndex;\n\t\t\t\t\tnewEdge.vert2 = toVertexIndex;\n\t\t\t\t\tnewEdge.pgon1 = polygonIndex;\n\t\t\t\t\tnewEdge.pgon2 = -1;\n\t\t\t\t\tadjacencyInfo.edges.push (newEdge);\n\t\t\t\t\t\n\t\t\t\t\tpedge.index = adjacencyInfo.edges.length - 1;\n\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t} else {\n\t\t\t\t\tvar currEdge = adjacencyInfo.edges[pedge.index];\n\t\t\t\t\tif (currEdge.pgon1 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon1 = polygonIndex;\n\t\t\t\t\t} else if (currEdge.pgon1 !== polygonIndex && currEdge.pgon2 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon2 = polygonIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo);\n\t\t\t}\n\n\t\t\tvar polygon = body.GetPolygon (polygonIndex);\n\t\t\tvar pgon = new JSM.PgonInfo ();\n\t\t\t\n\t\t\tvar i, curr, next;\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = polygon.GetVertexIndex (i);\n\t\t\t\tnext = polygon.GetVertexIndex (i < count - 1 ? i + 1 : 0);\n\t\t\t\tAddEdge (adjacencyInfo, pgon, curr, next, polygonIndex);\n\t\t\t}\n\t\t\tadjacencyInfo.pgons.push (pgon);\n\t\t}\n\n\t\tthis.verts = [];\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\t\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (this);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (this, body, i);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourVertex\n\t* Description: Returns if the vertex has contour edge.\n\t* Parameters:\n\t*\tvert {VertInfo} the vertex info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourVertex = function (vert)\n\t{\n\t\tvar i, edge;\n\t\tfor (i = 0; i < vert.edges.length; i++) {\n\t\t\tedge = vert.edges[i];\n\t\t\tif (this.IsContourEdge (this.edges[edge])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourEdge\n\t* Description: Returns if the edge has only one polygon neighbour.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourEdge = function (edge)\n\t{\n\t\tvar pgonCount = this.GetEdgePolygonCount (edge);\n\t\treturn pgonCount == 1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetEdgePolygonCount\n\t* Description: Returns the neighbour polygon count of the edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetEdgePolygonCount = function (edge)\n\t{\n\t\tvar pgonCount = 0;\n\t\tif (edge.pgon1 != -1) {\n\t\t\tpgonCount += 1;\n\t\t}\n\t\tif (edge.pgon2 != -1) {\n\t\t\tpgonCount += 2;\n\t\t}\n\t\treturn pgonCount;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetAnotherPgonOfEdge\n\t* Description: Returns the polygon index which is next to the given polygon along an edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t*\tcurrentPgon {integer} the polygon index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetAnotherPgonOfEdge = function (edge, pgon)\n\t{\n\t\tif (edge.pgon1 != -1 && edge.pgon1 != pgon) {\n\t\t\treturn edge.pgon1;\n\t\t} else if (edge.pgon2 != -1 && edge.pgon2 != pgon) {\n\t\t\treturn edge.pgon2;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeStartVertex\n\t* Description: Returns the start vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeStartVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeEndVertex\n\t* Description: Returns the end vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeEndVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t}\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexToPolygon\n\t* Description:\n\t*\tCalculates an array which contains array of the connected polygon\n\t*\tindices for all vertex indices in the body. The result is an\n\t*\tarray of array of polygon indices.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexToPolygon = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.push ([]);\n\t\t}\n\t\t\n\t\tvar polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tresult[polygon.GetVertexIndex (j)].push (i);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IsSolidBody\n\t* Description:\n\t*\tReturns if a given body is solid. It means that every\n\t*\tedges of the body has two polygon neighbours.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tif (adjacencyInfo.edges.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar i, edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CheckSolidBody\n\t* Description:\n\t*\tReturns if a given body solid body is correct. It means that every\n\t*\tedges of the body has two polygon neighbours, and there are no edge\n\t*\tin the body which appears twice with the same direction.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar i, j, edge, pedge, found, pgon1, pgon2, pgon1Reverse, pgon2Reverse;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon1 = adjacencyInfo.pgons[edge.pgon1];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon1.pedges.length; j++) {\n\t\t\t\tpedge = pgon1.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon1Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon2 = adjacencyInfo.pgons[edge.pgon2];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon2.pedges.length; j++) {\n\t\t\t\tpedge = pgon2.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon2Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (pgon1Reverse == pgon2Reverse) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraversePgonsAlongEdges\n\t* Description:\n\t*\tTraverses polygons along edges. The given callback function called on every\n\t*\tfound polygon. The return value of the callback means if the traverse should\n\t*\tcontinue along the edges of the current polygon.\n\t* Parameters:\n\t*\tpgonIndex {integer} the polygon index to start from\n\t*\tadjacencyInfo {AdjacencyInfo} the adjacency info\n\t*\tonPgonFound {function} the callback\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.TraversePgonsAlongEdges = function (pgonIndex, adjacencyInfo, onPgonFound)\n\t{\n\t\tfunction AddNeighboursToStack (pgonIndex, adjacencyInfo, pgonStack)\n\t\t{\n\t\t\tvar pgon = adjacencyInfo.pgons[pgonIndex];\n\t\t\tvar i, edge, anotherPgon;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[pgon.pedges[i].index];\n\t\t\t\tanotherPgon = adjacencyInfo.GetAnotherPgonOfEdge (edge, pgonIndex);\n\t\t\t\tif (anotherPgon != -1) {\n\t\t\t\t\tpgonStack.push (anotherPgon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar pgonIsProcessed = {};\n\t\tvar pgonStack = [pgonIndex];\n\t\tvar currentPgonIndex;\n\t\twhile (pgonStack.length > 0) {\n\t\t\tcurrentPgonIndex = pgonStack.pop ();\n\t\t\tif (pgonIsProcessed[currentPgonIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpgonIsProcessed[currentPgonIndex] = true;\n\t\t\tif (onPgonFound (currentPgonIndex)) {\n\t\t\t\tAddNeighboursToStack (currentPgonIndex, adjacencyInfo, pgonStack);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/bodyutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: AddVertexToBody\n\t* Description: Adds a vertex to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.AddVertexToBody = function (body, x, y, z)\n\t{\n\t\treturn body.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t};\n\n\t/**\n\t* Function: AddPointToBody\n\t* Description: Adds a point to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertex {integer} the vertex index stored in the body\n\t*/\n\tJSM.AddPointToBody = function (body, vertex)\n\t{\n\t\treturn body.AddPoint (new JSM.BodyPoint (vertex));\n\t};\n\n\t/**\n\t* Function: AddLineToBody\n\t* Description: Adds a line to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.AddLineToBody = function (body, beg, end)\n\t{\n\t\treturn body.AddLine (new JSM.BodyLine (beg, end));\n\t};\n\n\t/**\n\t* Function: AddPolygonToBody\n\t* Description: Adds a polygon to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.AddPolygonToBody = function (body, vertices)\n\t{\n\t\treturn body.AddPolygon (new JSM.BodyPolygon (vertices));\n\t};\n\n\t/**\n\t* Function: CheckBody\n\t* Description:\n\t*\tChecks if the body is correct. It means that every polygon has at least three\n\t*\tvertices, and every point, line and polygon vertex index is valid.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckBody = function (body)\n\t{\n\t\tvar vertexCount = body.VertexCount ();\n\t\tvar i, j, point, line, polygon;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tpoint = body.GetPoint (i);\n\t\t\tif (point.GetVertexIndex () < 0 || point.GetVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tline = body.GetLine (i);\n\t\t\tif (line.GetBegVertexIndex () < 0 || line.GetBegVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (line.GetEndVertexIndex () < 0 || line.GetEndVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tif (polygon.VertexIndexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tif (polygon.GetVertexIndex (j) < 0 || polygon.GetVertexIndex (j) >= vertexCount) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormal\n\t* Description: Calculates a normal vector for a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormal = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = body.GetVertexPosition (polygon.GetVertexIndex (currentIndex));\n\t\t\t\tnext = body.GetVertexPosition (polygon.GetVertexIndex (nextIndex));\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormals\n\t* Description: Calculates polygon normal vectors for all polygons stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*]} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculateBodyPolygonNormal (body, i));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexNormals\n\t* Description:\n\t*\tCalculates vertex normal vectors for all vertices stored in the body.\n\t*\tThe result is an array of array with vertex normal vectors.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar vertexToPolygon = null;\n\t\t\n\t\tvar i, j, k, polygon, normal;\n\t\tvar average, count, neighbourPolygons, neighbourPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tresult[i] = [];\n\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\tif (vertexToPolygon === null) {\n\t\t\t\t\tvertexToPolygon = JSM.CalculateBodyVertexToPolygon (body);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\taverage = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\t\tcount = 0;\n\t\t\t\t\t\n\t\t\t\t\tneighbourPolygons = vertexToPolygon[polygon.GetVertexIndex (j)];\n\t\t\t\t\tfor (k = 0; k < neighbourPolygons.length; k++) {\n\t\t\t\t\t\tneighbourPolygon = body.GetPolygon (neighbourPolygons[k]);\n\t\t\t\t\t\tif (neighbourPolygon.GetCurveGroup () === polygon.GetCurveGroup ()) {\n\t\t\t\t\t\t\taverage = JSM.CoordAdd (average, polygonNormals[neighbourPolygons[k]]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\taverage.MultiplyScalar (1.0 / count);\n\t\t\t\t\taverage.Normalize ();\n\t\t\t\t\tresult[i].push (average);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnormal = polygonNormals[i];\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tresult[i].push (new JSM.Vector (normal.x, normal.y, normal.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCurveGroups\n\t* Description: Calculates the curve groups for a given polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon|Polygon2D} the polygon\n\t*\tcurveAngle {number} the curve angle\n\t* Returns:\n\t*\t{integer[*]} the curve groups\n\t*/\n\tJSM.CalculatePolygonCurveGroups = function (polygon, curveAngle)\n\t{\n\t\tvar curveGroups = [];\n\t\tvar count = polygon.VertexCount ();\n\n\t\tvar i, prev;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurveGroups.push (0);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = curveGroups[polygon.GetPrevVertex (i)];\n\t\t\tif (polygon.GetVertexAngle (i) > curveAngle) {\n\t\t\t\tcurveGroups[i] = prev;\n\t\t\t} else {\n\t\t\t\tcurveGroups[i] = prev + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar firstGroup = curveGroups[0];\n\t\tvar lastGroup = curveGroups[count - 1];\n\t\tif (firstGroup === 0 && firstGroup != lastGroup) {\n\t\t\tfor (i = 0; curveGroups[i] == firstGroup; i++) {\n\t\t\t\tcurveGroups[i] = lastGroup;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curveGroups;\n\t};\n\n\n\t/**\n\t* Function: CalculatePolygonCentroid\n\t* Description: Calculates the centroid of a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculatePolygonCentroid = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\t\t\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult = JSM.CoordAdd (result, body.GetVertexPosition (polygon.GetVertexIndex (i)));\n\t\t}\n\t\t\n\t\tresult.MultiplyScalar (1.0 / count);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MakeBodyInsideOut\n\t* Description: Reverses all polygons orientation in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.MakeBodyInsideOut = function (body)\n\t{\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tpolygon.ReverseVertexIndices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: SoftMoveBodyVertex\n\t* Description: Moves a vertex and its nearby vertices depending on gaussian function.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the vertex index to move\n\t*\tradius {number} the radius of the movement\n\t*\tdirection {Vector} the direction of the movement\n\t*\tdistance {number} the distance of the movement\n\t*/\n\tJSM.SoftMoveBodyVertex = function (body, index, radius, direction, distance)\n\t{\n\t\tvar referenceCoord = body.GetVertexPosition (index).Clone ();\n\n\t\tvar eps = 0.00001;\n\t\tvar a = distance;\n\t\tvar b = 0.0;\n\t\tvar c = JSM.GetGaussianCParameter (radius, a, b, eps);\n\n\t\tvar i, currentDistance, newDistance;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tcurrentDistance = referenceCoord.DistanceTo (body.GetVertex (i).position);\n\t\t\tif (JSM.IsGreater (currentDistance, radius)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewDistance = JSM.GetGaussianValue (currentDistance, distance, b, c);\n\t\t\tbody.GetVertexPosition (i).Offset (direction, newDistance);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateWireBody\n\t* Description: Generates a body which contains only the lines from the given body.\n\t* Parameters:\n\t*\tbody {Body} the original body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateWireBody = function (body)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.AddVertex (body.GetVertex (i).Clone ());\n\t\t}\n\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tJSM.AddLineToBody (result, edge.vert1, edge.vert2);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangulateWithCentroids\n\t* Description:\n\t*\tTriangulates all polygons of the body by connecting all polygon\n\t*\tvertices with the centroid vertex of the polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulateWithCentroids = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, centroidCoord, centroidIndex, oldPolygon, oldVertexCount, polygon, curr, next;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tcentroidCoord = JSM.CalculatePolygonCentroid (body, i);\n\t\t\tcentroidIndex = body.AddVertex (new JSM.BodyVertex (centroidCoord));\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\toldVertexCount = oldPolygon.VertexIndexCount ();\n\t\t\tfor (j = 0; j < oldVertexCount; j++) {\n\t\t\t\tcurr = oldPolygon.GetVertexIndex (j);\n\t\t\t\tnext = oldPolygon.GetVertexIndex (j < oldVertexCount - 1 ? j + 1 : 0);\n\t\t\t\tpolygon = new JSM.BodyPolygon ([curr, next, centroidIndex]);\n\t\t\t\tpolygon.InheritAttributes (oldPolygon);\n\t\t\t\tbody.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangulatePolygons\n\t* Description: Triangulates all polygons of the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulatePolygons = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, oldPolygon, polygon, coord, triangleIndices, triangle, bodyTriangle;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\tpolygon = new JSM.Polygon ();\n\t\t\tfor (j = 0; j < oldPolygon.VertexIndexCount (); j++) {\n\t\t\t\tcoord = body.GetVertexPosition (oldPolygon.GetVertexIndex (j));\n\t\t\t\tpolygon.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\ttriangleIndices = JSM.TriangulatePolygon (polygon);\n\t\t\tif (triangleIndices !== null) {\n\t\t\t\tfor (j = 0; j < triangleIndices.length; j++) {\n\t\t\t\t\ttriangle = triangleIndices[j];\n\t\t\t\t\tbodyTriangle = new JSM.BodyPolygon ([\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[0]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[1]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[2])\n\t\t\t\t\t]);\n\t\t\t\t\tbodyTriangle.InheritAttributes (oldPolygon);\n\t\t\t\t\tbody.AddPolygon (bodyTriangle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateRandomMaterials\n\t* Description: Generates random materials for a body. A seed number can be specified.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\tseeded {boolean} seeded random generation\n\t*/\n\tJSM.GenerateRandomMaterials = function (body, materials, seeded)\n\t{\n\t\tfunction GetRandomInt (seeded, seed)\n\t\t{\n\t\t\tvar minColor = 0;\n\t\t\tvar maxColor = 16777215;\n\t\t\tvar color = 0;\n\t\t\tif (seeded !== undefined && seeded) {\n\t\t\t\tcolor = JSM.SeededRandomInt (minColor, maxColor, seed + 1);\n\t\t\t} else {\n\t\t\t\tcolor = JSM.RandomInt (minColor, maxColor);\n\t\t\t}\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tvar i, color, material;\n\t\tvar seed = 0;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetLine (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPoint (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPolygon (i).SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AddBodyToBSPTree\n\t* Description: Adds a body to a BSP tree.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tid {anything} the id for added polygons\n\t*/\n\tJSM.AddBodyToBSPTree = function (body, bspTree, id)\n\t{\n\t\tfunction ConvertBodyPolygonToPolygon (body, index, userData)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tuserData.material = polygon.GetMaterialIndex ();\n\t\t\tvar result = new JSM.Polygon ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar i, polygon, userData;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tuserData = {\n\t\t\t\tid : id,\n\t\t\t\toriginalPolygon : i,\n\t\t\t\tmaterial : -1\n\t\t\t};\n\t\t\tpolygon = ConvertBodyPolygonToPolygon (body, i, userData);\n\t\t\tbspTree.AddPolygon (polygon, userData);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/textureutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CalculatePlanarTextureCoord\n\t* Description: Calculates the planar texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculatePlanarTextureCoord = function (coord, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e1 = system.e1.Clone ().Normalize ();\n\t\tvar e2 = system.e2.Clone ().Normalize ();\n\t\tvar e3 = JSM.VectorCross (system.e1, system.e2);\n\n\t\tvar xyPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e3);\n\t\tvar xzPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e2);\n\t\tvar yzPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e1);\n\t\t\n\t\tvar projected = xyPlane.ProjectCoord (coord);\n\t\tresult.x = yzPlane.CoordSignedDistance (projected);\n\t\tresult.y = xzPlane.CoordSignedDistance (projected);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateCubicTextureCoord\n\t* Description: Calculates the cubic texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnormal {Vector} the normal vector for calculation\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculateCubicTextureCoord = function (coord, normal, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e1 = system.e1.Clone ().Normalize ();\n\t\tvar e2 = system.e2.Clone ().Normalize ();\n\t\tvar e3 = system.e3.Clone ().Normalize ();\n\n\t\tvar correctPlane = -1;\n\t\tvar maxProduct = 0.0;\n\t\t\n\t\tvar i, currentDirection, product;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (i === 0) {\n\t\t\t\tcurrentDirection = e1;\n\t\t\t} else if (i === 1) {\n\t\t\t\tcurrentDirection = e2;\n\t\t\t} else if (i === 2) {\n\t\t\t\tcurrentDirection = e3;\n\t\t\t}\n\n\t\t\tproduct = Math.abs (JSM.VectorDot (normal, currentDirection));\n\t\t\tif (JSM.IsGreater (product, maxProduct)) {\n\t\t\t\tcorrectPlane = i;\n\t\t\t\tmaxProduct = product;\n\t\t\t}\n\t\t}\n\n\t\tif (correctPlane === -1) {\n\t\t\treturn result;\n\t\t}\n\n\t\tvar planeSystem = null;\n\t\tif (correctPlane === 0) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te2,\n\t\t\t\te3,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t} else if (correctPlane === 1) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te1,\n\t\t\t\te3,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t} else if (correctPlane === 2) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te1,\n\t\t\t\te2,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t}\n\t\t\n\t\tif (planeSystem === null) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn JSM.CalculatePlanarTextureCoord (coord, planeSystem);\n\t};\n\n\t/**\n\t* Function: CalculateCylindricalTextureCoord\n\t* Description: Calculates the cylindrical texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnormal {Vector} the normal vector for calculation\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculateCylindricalTextureCoord = function (coord, normal, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e3Direction = system.e3.Clone ().Normalize ();\n\t\tif (e3Direction.IsCollinearWith (normal)) {\n\t\t\tresult = JSM.CalculateCubicTextureCoord (coord, normal, system);\n\t\t\treturn [result, 0.0];\n\t\t}\n\n\t\tvar baseLine = new JSM.Line (system.origo, e3Direction);\n\t\tvar projectedCoord = baseLine.ProjectCoord (coord);\n\t\tvar projectedDistance = JSM.CoordSignedDistance (system.origo, projectedCoord, e3Direction);\n\n\t\tvar e1Direction = system.e1.Clone ().Normalize ();\n\t\tvar coordDirection = JSM.CoordSub (coord, projectedCoord);\n\t\tvar angle = JSM.GetVectorsFullAngle (coordDirection, e1Direction, e3Direction);\n\t\tvar radius = system.e1.Length ();\n\n\t\tresult.x = angle * radius;\n\t\tresult.y = projectedDistance;\n\t\treturn [result, angle];\n\t};\n\n\t/**\n\t* Function: CalculatePolygonPlanarTextureCoords\n\t* Description: Calculates the planar texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonPlanarTextureCoords = function (body, index)\n\t{\n\t\tvar result = [];\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\tresult.push (JSM.CalculatePlanarTextureCoord (coord, system));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCubicTextureCoords\n\t* Description: Calculates the cubic texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t*\tnormal {Vector} the normal vector for calculation\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonCubicTextureCoords = function (body, index, normal)\n\t{\n\t\tvar result = [];\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\tresult.push (JSM.CalculateCubicTextureCoord (coord, normal, system));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCylindricalTextureCoords\n\t* Description: Calculates the cylindrical texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t*\tnormal {Vector} the normal vector for calculation\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonCylindricalTextureCoords = function (body, index, normal)\n\t{\n\t\tvar result = [];\n\t\tvar angles = [];\n\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, j, coord, textureValues;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\ttextureValues = JSM.CalculateCylindricalTextureCoord (coord, normal, system);\n\t\t\tresult.push (textureValues[0]);\n\t\t\tangles.push (textureValues[1]);\n\t\t}\n\n\t\tvar e3Direction = system.e3.Clone ().Normalize ();\n\t\tif (e3Direction.IsCollinearWith (normal)) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar needRepair = false;\n\t\tfor (i = 0; i < angles.length; i++) {\n\t\t\tfor (j = i + 1; j < angles.length; j++) {\n\t\t\t\tif (JSM.IsGreater (Math.abs (angles[i] - angles[j]), Math.PI)) {\n\t\t\t\t\tneedRepair = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needRepair) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (needRepair) {\n\t\t\tvar radius = system.e1.Length ();\n\t\t\tfor (i = 0; i < angles.length; i++) {\n\t\t\t\tif (JSM.IsLower (angles[i], Math.PI)) {\n\t\t\t\t\tresult[i].x = radius * (angles[i] + 2.0 * Math.PI);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPlanarTextureCoords\n\t* Description: Calculates the planar texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyPlanarTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculatePolygonPlanarTextureCoords (body, i));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyCubicTextureCoords\n\t* Description: Calculates the cubic texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyCubicTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar i, normal;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnormal = polygonNormals[i];\n\t\t\tresult.push (JSM.CalculatePolygonCubicTextureCoords (body, i, normal));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyCylindricalTextureCoords\n\t* Description: Calculates the cylindrical texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyCylindricalTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar i, normal;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnormal = polygonNormals[i];\n\t\t\tresult.push (JSM.CalculatePolygonCylindricalTextureCoords (body, i, normal));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyTextureCoords\n\t* Description:\n\t*\tCalculates the texture coordinates for a body. The result\n\t*\tis an array of arrays of texture coordinates.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar projection = body.GetTextureProjection ().GetType ();\n\t\tif (projection === JSM.TextureProjectionType.Planar) {\n\t\t\tresult = JSM.CalculateBodyPlanarTextureCoords (body);\n\t\t} else if (projection === JSM.TextureProjectionType.Cubic) {\n\t\t\tresult = JSM.CalculateBodyCubicTextureCoords (body);\n\t\t} else if (projection === JSM.TextureProjectionType.Cylindrical) {\n\t\t\tresult = JSM.CalculateBodyCylindricalTextureCoords (body);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/cututils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CutBodyByPlane\n\t* Description: Cuts a body by a plane.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CutBodyByPlane = function (body, plane)\n\t{\n\t\tfunction CutBodyPolygonByPlane (polygon, plane, indexTable)\n\t\t{\n\t\t\tfunction AddOriginalVertex (index, vertex, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\trawResult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\trawIndexTable.push (index);\n\t\t\t}\n\n\t\t\tfunction AddIntersectionVertex (from, to, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\tvar direction = JSM.CoordSub (polygon[to], polygon[from]).Normalize ();\n\t\t\t\tvar line = new JSM.Line (polygon[from], direction);\n\t\t\t\tvar intersection = plane.LineIntersection (line);\n\t\t\t\trawResult.push (new JSM.Coord (intersection.x, intersection.y, intersection.z));\n\t\t\t\trawIndexTable.push (-1);\n\t\t\t}\n\n\t\t\tvar hasIndexTable = (indexTable !== undefined && indexTable !== null);\n\t\t\tvar count = polygon.length;\n\t\t\tvar result = [];\n\t\t\tvar front = [];\n\t\t\t\n\t\t\tvar needCut = false;\n\t\t\tvar i, position, vertex;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tvertex = polygon[i];\n\t\t\t\tposition = plane.CoordPosition (vertex);\n\t\t\t\tfront.push (position !== JSM.CoordPlanePosition.CoordAtBackOfPlane);\n\t\t\t\tif (i > 0 && front[i - 1] !== front[i]) {\n\t\t\t\t\tneedCut = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!needCut) {\n\t\t\t\tif (front[0] === false) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\tvertex = polygon[i];\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tindexTable.push (i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tvar rawResult = [];\n\t\t\tvar rawIndexTable = [];\n\n\t\t\tvar from, to;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfrom = i - 1;\n\t\t\t\tto = i;\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tfrom = count - 1;\n\t\t\t\t}\n\n\t\t\t\tvertex = polygon[to];\n\t\t\t\tif (front[to]) {\n\t\t\t\t\tif (!front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t\tAddOriginalVertex (to, vertex, rawResult, rawIndexTable);\n\t\t\t\t} else {\n\t\t\t\t\tif (front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar currentVertex;\n\t\t\tvar currentIndex;\n\t\t\tvar lastVertex;\n\t\t\tvar lastIndex;\n\t\t\tfor (i = 0; i < rawResult.length; i++) {\n\t\t\t\tcurrentVertex = rawResult[i];\n\t\t\t\tlastVertex = result[result.length - 1];\n\t\t\t\tif (i === 0 || !lastVertex.IsEqual (currentVertex)) {\n\t\t\t\t\tresult.push (new JSM.Coord (currentVertex.x, currentVertex.y, currentVertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tindexTable.push (currentIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tlastIndex = rawIndexTable[i - 1];\n\t\t\t\t\t\tif (currentIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = currentIndex;\n\t\t\t\t\t\t} else if (lastIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = lastIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction GetInsertedVertexIndex (result, vertex, originalVertexCount)\n\t\t{\n\t\t\tvar index = -1;\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = originalVertexCount; i < result.VertexCount (); i++) {\n\t\t\t\tif (vertex.IsEqual (result.GetVertexPosition (i))) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (index === -1) {\n\t\t\t\tindex = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t\t\n\t\t\treturn index;\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar cuttedPolygons = [];\n\t\tvar cuttedIndexTables = [];\n\t\t\n\t\tvar remainsVertex = [];\n\t\tvar originalOldToNewIndex = [];\n\t\t\n\t\tvar i, j, polygon, polygon3D, vertexPosition;\n\t\tvar cuttedPolygon, indexTable;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\n\t\t\tpolygon3D = [];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tvertexPosition = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\tpolygon3D.push (new JSM.Coord (vertexPosition.x, vertexPosition.y, vertexPosition.z));\n\t\t\t}\n\t\t\t\n\t\t\tindexTable = [];\n\t\t\tcuttedPolygon = CutBodyPolygonByPlane (polygon3D, plane, indexTable);\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tremainsVertex[polygon.GetVertexIndex (indexTable[j])] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcuttedPolygons.push (cuttedPolygon);\n\t\t\tcuttedIndexTables.push (indexTable);\n\t\t}\n\n\t\tvar vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tif (remainsVertex[i]) {\n\t\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\t\toriginalOldToNewIndex[i] = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t}\n\n\t\tvar originalVertexCount = result.VertexCount ();\n\n\t\tvar newPolygon, newPolygonVertices;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tcuttedPolygon = cuttedPolygons[i];\n\t\t\tindexTable = cuttedIndexTables[i];\n\t\t\tif (indexTable.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewPolygonVertices = [];\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tnewPolygonVertices.push (originalOldToNewIndex[polygon.GetVertexIndex (indexTable[j])]);\n\t\t\t\t} else {\n\t\t\t\t\tvertex = cuttedPolygon[j];\n\t\t\t\t\tnewPolygonVertices.push (GetInsertedVertexIndex (result, vertex, originalVertexCount));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnewPolygon = new JSM.BodyPolygon (newPolygonVertices);\n\t\t\tnewPolygon.InheritAttributes (polygon);\n\t\t\tresult.AddPolygon (newPolygon);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/generator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateRectangle\n\t* Description: Generates a rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRectangle = function (xSize, ySize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, 0.0)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboid\n\t* Description: Generates a cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboid = function (xSize, ySize, zSize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboidSides\n\t* Description:\n\t*\tGenerates the specified sides of a cuboid. The last parameter is\n\t*\ta boolean array which defines sides visibility.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsides {boolean[]} sides visibility\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboidSides = function (xSize, ySize, zSize, sides)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tif (sides[0]) { result.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3])); }\n\t\tif (sides[1]) { result.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2])); }\n\t\tif (sides[2]) { result.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6])); }\n\t\tif (sides[3]) { result.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7])); }\n\t\tif (sides[4]) { result.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1])); }\n\t\tif (sides[5]) { result.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7])); }\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedRectangle\n\t* Description:\tGenerates a segmented rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\txSegmentation {integer} segmentation along x side\n\t*\tySegmentation {integer} segmentation along y side\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedRectangle = function (xSize, ySize, xSegmentation, ySegmentation)\n\t{\n\t\tfunction AddVertices ()\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, 0.0);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons ()\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar xSegment = xSize / xSegmentation;\n\t\tvar ySegment = ySize / ySegmentation;\n\t\t\n\t\tAddVertices ();\n\t\tAddPolygons ();\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedCuboid\n\t* Description:\tGenerates a segmented cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsegmentation {integer} segmentation of the sides\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedCuboid = function (xSize, ySize, zSize, segmentation)\n\t{\n\t\tfunction GetLevelOffset (level)\n\t\t{\n\t\t\tvar offset = 0;\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\toffset = (segmentation + 1) * (segmentation + 1) + (level - 1) * (segmentation * 4);\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction GetLevelSideVertices (level)\n\t\t{\n\t\t\tvar i;\n\t\t\t\n\t\t\tvar vertices = [];\n\t\t\tvar offset = GetLevelOffset (level);\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + (i + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (segmentation + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + i * (segmentation + 1));\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (3 * segmentation) + i - 1);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn vertices;\n\t\t}\n\n\t\tfunction AddVertices (level)\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tvar zCoord = level * zSegment;\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tif (i === 0 || i === segmentation || j === 0 || j === segmentation) {\n\t\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (level)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tvar offset = GetLevelOffset (level);\n\t\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\t\t\tcurrent = offset + i * (segmentation + 1) + j;\n\t\t\t\t\t\tnext = current + 1;\n\t\t\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, top, ntop, next]));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\tvar prevSideVertices = levelSideVertices [level - 1];\n\t\t\t\tvar currSideVertices = levelSideVertices [level];\n\t\t\t\tfor (i = 0; i < segmentation * 4; i++) {\n\t\t\t\t\tcurrent = prevSideVertices[i];\n\t\t\t\t\ttop = currSideVertices[i];\n\t\t\t\t\tif (i < segmentation * 4 - 1) {\n\t\t\t\t\t\tnext = prevSideVertices[i + 1];\n\t\t\t\t\t\tntop = currSideVertices[i + 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = prevSideVertices[0];\n\t\t\t\t\t\tntop = currSideVertices[0];\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar zStart = zSize / 2.0;\n\t\t\n\t\tvar xSegment = xSize / segmentation;\n\t\tvar ySegment = ySize / segmentation;\n\t\tvar zSegment = zSize / segmentation;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddVertices (i);\n\t\t}\n\t\t\n\t\tvar levelSideVertices = [];\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tlevelSideVertices.push (GetLevelSideVertices (i));\n\t\t}\n\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddPolygons (i);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCircle\n\t* Description:\tGenerates a circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {integer} the segmentation of the circle\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCircle = function (radius, segmentation)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar circlePoints = JSM.GenerateCirclePoints (radius, segmentation);\n\t\tvar i;\n\t\tfor (i = 0; i < circlePoints.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (circlePoints[i]));\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\ttopPolygon.AddVertexIndex (i);\n\t\t}\n\t\tresult.AddPolygon (topPolygon);\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSphere\n\t* Description: Generates a sphere.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\tsegmentation {integer} the segmentation of the sphere\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSphere = function (radius, segmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar segments = segmentation;\n\t\tvar circle = segments * 2;\n\n\t\tvar topIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, 0.0, 0.0)));\n\t\tvar step = Math.PI / segments;\n\t\tvar theta = step;\n\t\t\n\t\tvar i, j, phi;\n\t\tfor (i = 1; i < segments; i++) {\n\t\t\tphi = 0;\n\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, theta, phi)));\n\t\t\t\tphi += step;\n\t\t\t}\n\t\t\ttheta += step;\n\t\t}\n\t\tvar bottomIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (-radius, 0.0, 0.0)));\n\n\t\tvar offset, current, next, top, ntop, polygon;\n\t\tfor (i = 1; i <= segments; i++) {\n\t\t\tif (i === 1) {\n\t\t\t\toffset = 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, topIndex]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i < segments) {\n\t\t\t\toffset = (i - 1) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current - circle;\n\t\t\t\t\tntop = top + 1;\n\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t\tntop = offset - circle;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i === segments) {\n\t\t\t\toffset = (i - 2) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, bottomIndex, next]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTriangulatedSphere\n\t* Description: Generates a sphere from triangles.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\titerations {integer} the iteration number\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriangulatedSphere = function (radius, iterations, isCurved)\n\t{\n\t\tfunction GenerateIcosahedron () {\n\t\t\tvar result = new JSM.Body ();\n\n\t\t\tvar a = 1.0;\n\t\t\tvar b = 0.0;\n\t\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 9, 2]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 10, 3]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 9, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 10, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [4, 8, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [6, 11, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [5, 10, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [7, 9, 11]);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tvar result = GenerateIcosahedron ();\n\t\t\n\t\tvar currentRadius = result.GetVertexPosition (0).Length ();\n\t\tvar scale = radius / currentRadius;\n\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t}\n\t\t\n\t\tvar iteration, oldVertexCoord, oldBody, adjacencyInfo;\n\t\tvar currentEdge, edgeVertexIndices;\n\t\tvar currentPgon, polygonVertexIndices;\n\t\tvar edgeCoord, currentPolyEdge;\n\t\tfor (iteration = 0; iteration < iterations; iteration++) {\n\t\t\toldBody = result;\n\t\t\t\n\t\t\tresult = new JSM.Body ();\n\t\t\tadjacencyInfo = new JSM.AdjacencyInfo (oldBody);\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\toldVertexCoord = oldBody.GetVertexPosition (i);\n\t\t\t\tJSM.AddVertexToBody (result, oldVertexCoord.x, oldVertexCoord.y, oldVertexCoord.z);\n\t\t\t}\n\t\t\t\n\t\t\tedgeVertexIndices = [];\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tcurrentEdge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (oldBody.GetVertexPosition (currentEdge.vert1), oldBody.GetVertexPosition (currentEdge.vert2));\n\t\t\t\tedgeVertexIndices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord.SetLength (radius))));\n\t\t\t}\n\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tcurrentPgon = adjacencyInfo.pgons[i];\n\t\t\t\tpolygonVertexIndices = [];\n\t\t\t\tfor (j = 0; j < currentPgon.pedges.length; j++) {\n\t\t\t\t\tcurrentPolyEdge = currentPgon.pedges[j];\n\t\t\t\t\tpolygonVertexIndices.push (adjacencyInfo.GetPolyEdgeStartVertex (currentPolyEdge));\n\t\t\t\t\tpolygonVertexIndices.push (edgeVertexIndices[currentPolyEdge.index]);\n\t\t\t\t}\n\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[0], polygonVertexIndices[1], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[2], polygonVertexIndices[3]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[3], polygonVertexIndices[4], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[3], polygonVertexIndices[5]]);\n\t\t\t}\n\t\t}\n\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < result.PolygonCount (); i++) {\n\t\t\t\tresult.GetPolygon (i).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinder\n\t* Description: Generates a cylinder.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinder = function (radius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePie\n\t* Description: Generates a pie.\n\t* Parameters:\n\t*\tradius {number} the radius of the pie\n\t*\theight {number} the height of the pie\n\t*\tangle {number} the angle of the pie\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePie = function (radius, height, angle, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = angle;\n\t\tvar step = angle / (segments - 1);\n\t\t\n\t\tvar i;\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i <= segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved && i > 0 && i < segments) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i <= segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCone\n\t* Description: Generates a cone.\n\t* Parameters:\n\t*\ttopRadius {number} the top radius of the cone\n\t*\tbottomRadius {number} the bottom radius of the cone\n\t*\theight {number} the height of the cone\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCone = function (topRadius, bottomRadius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar topDegenerated = (JSM.IsZero (topRadius));\n\t\tvar bottomDegenerated = (JSM.IsZero (bottomRadius));\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\n\t\tif (topDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\t}\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (!topDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (topRadius, height / 2.0, theta)));\n\t\t\t}\n\t\t\tif (!bottomDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (bottomRadius, -height / 2.0, theta)));\n\t\t\t}\n\t\t\ttheta -= step;\n\t\t}\n\t\tif (bottomDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tcurrent = i + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 1;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([0, next, current]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\tcurrent = i;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, segments]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else {\n\t\t\t\tcurrent = 2 * i;\n\t\t\t\tnext = current + 2;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tvar topPolygon, bottomPolygon;\n\t\tif (withTopAndBottom) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\tbottomPolygon.AddVertexIndex (i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (segments - i - 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t} else {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t}\n\t\t}\n\n\t\tvar avgRadius = (topRadius + bottomRadius) / 2.0;\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), avgRadius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismGeometry\n\t* Description: Generates a prism defined by bottom and top vertices polygon.\n\t* Parameters:\n\t*\tbottomVertices {Coord[*]} bottom vertices\n\t*\ttopVertices {Coord[*]} top vertices\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismGeometry = function (bottomVertices, topVertices, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = bottomVertices.length;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (bottomVertices[i].Clone ()));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (topVertices[i].Clone ()));\n\t\t}\n\n\t\tvar current, next, bodyPolygon;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * (count - i - 1));\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismFromPolygon\n\t* Description: Generates a prism defined by a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the base polygon\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismFromPolygon = function (polygon, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i, vertex;\n\t\tvar count = polygon.VertexCount ();\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tbottomVertices.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\ttopVertices.push (new JSM.Coord (vertex.x, vertex.y, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = bottomVertices[0].Clone ();\n\t\tvar firtVertex = bottomVertices[1].Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrism\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The base polygon is an array\n\t*\tof coordinates which will be offseted in the given direction.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrism = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.FromArray (basePolygon);\n\t\tvar count = polygon.VertexCount ();\n\n\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tbottomVertices.push (polygon.GetVertex (i).Clone ());\n\t\t\ttopVertices.push (polygon.GetVertex (i).Clone ().Offset (direction, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\t\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = polygon.GetVertex (0).Clone ();\n\t\tvar firtVertex = polygon.GetVertex (1).Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismWithHole\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The polygon can contain null\n\t*\tvalues which defines the end of the current contour. The holes have\n\t*\tto be in reversed orientation than the main contour.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon which can contain null values\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismWithHole = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction AddVertices (contourPolygon, direction, height, result)\n\t\t{\n\t\t\tvar i, j, contour, vertex1, vertex2;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex1 = contour.GetVertex (j).Clone ();\n\t\t\t\t\tvertex2 = contour.GetVertex (j).Clone ().Offset (direction, height);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex1));\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddContours (contourPolygon, contourOffsets, curveAngle, result)\n\t\t{\n\t\t\tvar offset = 0;\n\n\t\t\tvar i, j, contour, vertexCount, current, next, bodyPolygon, curveGroups;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tcurveGroups = null;\n\t\t\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\t\t\tcurveGroups = JSM.CalculatePolygonCurveGroups (contour, curveAngle);\n\t\t\t\t}\t\t\n\t\t\t\tvertexCount = contour.VertexCount ();\n\t\t\t\tcontourOffsets.push (offset);\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tcurrent = 2 * offset + 2 * j;\n\t\t\t\t\tnext = current + 2;\n\t\t\t\t\tif (j == vertexCount - 1) {\n\t\t\t\t\t\tnext = 2 *  offset;\n\t\t\t\t\t}\n\t\t\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\t\tif (curveGroups !== null) {\n\t\t\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t\t\t}\n\t\t\t\toffset += vertexCount;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddTopBottomPolygons (contourPolygon, contourOffsets)\n\t\t{\n\t\t\tvar vertexMap = [];\n\t\t\tvar contourPolygon2D = contourPolygon.ToContourPolygon2D ();\n\t\t\tvar simplePolygon = JSM.ConvertContourPolygonToPolygon2D (contourPolygon2D, vertexMap);\n\t\t\tif (simplePolygon === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar triangles = JSM.TriangulatePolygon2D (simplePolygon);\n\t\t\tif (triangles === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, j, triangle, mapValue;\n\t\t\tvar topTriangle, bottomTriangle;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\ttriangle = triangles[i];\n\t\t\t\ttopTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\tmapValue = vertexMap[triangle[j]];\n\t\t\t\t\ttopTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1] + 1);\n\t\t\t\t\tmapValue = vertexMap[triangle[2 - j]];\n\t\t\t\t\tbottomTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1]);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topTriangle);\n\t\t\t\tresult.AddPolygon (bottomTriangle);\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar contourOffsets = [];\n\t\tvar contourPolygon = new JSM.ContourPolygon ();\n\t\tcontourPolygon.FromArray (basePolygon);\n\t\tAddVertices (contourPolygon, direction, height, result);\n\t\tAddContours (contourPolygon, contourOffsets, curveAngle, result);\n\n\t\tif (withTopAndBottom) {\n\t\t\tAddTopBottomPolygons (contourPolygon, contourOffsets);\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismsFromPath2D\n\t* Description: Generates a prism from the given path.\n\t* Parameters:\n\t*\tpath {Path2D} the path\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body[*]} the result\n\t*/\n\tJSM.GeneratePrismsFromPath2D = function (path, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction GetPrismPolygon (polygon)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i, j, contour, vertex;\n\t\t\tfor (i = 0; i < polygon.ContourCount (); i++) {\n\t\t\t\tcontour = polygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\t\t}\n\t\t\t\tif (i < polygon.ContourCount () - 1) {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar bodies = [];\n\t\tvar polygons = path.GetPolygons ();\n\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygon = polygons[i];\n\t\t\tif (polygon.ContourCount () === 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrism (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t} else if (polygon.ContourCount () > 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrismWithHole (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t}\n\t\t}\n\t\treturn bodies;\n\t};\n\n\t/**\n\t* Function: GeneratePrismShell\n\t* Description: Generates a prism with the given width of sides.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismShell = function (basePolygon, direction, height, width, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolygon.length;\n\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygon[i]));\n\t\t}\n\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.vertices = basePolygon;\n\t\tvar offsetedPolygon = JSM.OffsetPolygonContour (polygon, width);\n\t\tvar innerBasePolygon = offsetedPolygon.vertices;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolygon[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar curr, next, top, ntop;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t\tntop = 2 * count;\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t\tntop = count;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinderShell\n\t* Description: Generates a cylinder with the given width of sides.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\twidth {number} the width of the cylinder sides\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinderShell = function (radius, height, width, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tfunction GenerateCircle (radius, segmentation, bottom)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar step = 2.0 * Math.PI / segmentation;\n\t\t\tvar theta, cartesian;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttheta = i * step;\n\t\t\t\tcartesian = JSM.PolarToCartesian (radius, theta);\n\t\t\t\tresult.push (new JSM.Coord (cartesian.x, cartesian.y, bottom));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar circle = GenerateCircle (radius, segmentation, -height / 2.0);\n\t\tvar result = JSM.GeneratePrismShell (circle, normal, height, width, withTopAndBottom);\n\t\t\n\t\tvar i;\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\tresult.GetPolygon (2 * i).SetCurveGroup (0);\n\t\t\t\tresult.GetPolygon (2 * i + 1).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateLineShell\n\t* Description: Generates a polyline with width and height.\n\t* Parameters:\n\t*\tbasePolyLine {Coord[*]} the base polyline\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the shell\n\t*\twidth {number} the width of the shell\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLineShell = function (basePolyLine, direction, height, width, withStartAndEnd, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolyLine.length;\n\n\t\tvar angles = [];\n\t\t\n\t\tvar i, prev, curr, next;\n\t\tvar prevDir, nextDir, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (i === 0 || i === count - 1) {\n\t\t\t\tangle = Math.PI / 2.0;\n\t\t\t} else {\n\t\t\t\tprev = i - 1;\n\t\t\t\tcurr = i;\n\t\t\t\tnext = i + 1;\n\n\t\t\t\tnextDir = JSM.CoordSub (basePolyLine[next], basePolyLine[curr]);\n\t\t\t\tprevDir = JSM.CoordSub (basePolyLine[prev], basePolyLine[curr]);\n\t\t\t\tangle = nextDir.AngleTo (prevDir) / 2.0;\n\t\t\t\tif (JSM.CoordOrientation (basePolyLine[prev], basePolyLine[curr], basePolyLine[next], direction) == JSM.Orientation.Clockwise) {\n\t\t\t\t\tangle = Math.PI - angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tangles.push (angle);\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0, 0, 1);\n\t\tvar innerBasePolyLine = [];\n\t\tvar distance, innerCoord, offsetDirection;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tif (i === count - 1) {\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr - 1], basePolyLine[curr]);\n\t\t\t} else {\n\t\t\t\tnext = (i + 1) % count;\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr], basePolyLine[next]);\n\t\t\t}\n\n\t\t\tangle = angles[curr];\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\tinnerCoord = basePolyLine[curr].Clone ();\n\t\t\tinnerCoord.Offset (offsetDirection, distance);\n\t\t\tinnerCoord.Rotate (normal, -(Math.PI - angle), basePolyLine[curr]);\n\t\t\tinnerBasePolyLine.push (innerCoord);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolyLine[i]));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolyLine[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar top, ntop;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tcurr = 0;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\n\t\t\tcurr = count - 1;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolyLine[1], basePolyLine[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolyLine[0].x, basePolyLine[0].y, basePolyLine[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTorus\n\t* Description: Generates a torus.\n\t* Parameters:\n\t*\touterRadius {number} the outer radius of the torus\n\t*\tinnerRadius {number} the inner radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tinnerSegmentation {integer} the inner segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTorus = function (outerRadius, innerRadius, outerSegmentation, innerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar theta = 0.0;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = JSM.PolarToCartesian (innerRadius, theta);\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePolyTorus\n\t* Description: Generates a torus with a polygon cross section.\n\t* Parameters:\n\t*\tbasePolygon {Coord2D[*]} the cross section polygon of the torus\n\t*\touterRadius {number} the outer radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePolyTorus = function (basePolygon, outerRadius, outerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar innerSegmentation = basePolygon.length;\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = basePolygon[i];\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (j);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectors\n\t* Description: Generates a ruled surface between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectors = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateGrid\n\t* Description: Generates a planar grid.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\tySize {number} the y size\n\t*\txSegmentation {integer} the segmentation along x axis\n\t*\tySegmentation {integer} the segmentation along y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGrid = function (xSize, ySize, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tvar xSector = new JSM.Sector (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (xSize, 0.0, 0.0));\n\t\tvar ySector = new JSM.Sector (new JSM.Coord (0.0, ySize, 0.0), new JSM.Coord (xSize, ySize, 0.0));\n\t\treturn JSM.GenerateRuledFromSectors (xSector, ySector, xSegmentation, ySegmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateSquareGrid\n\t* Description: Generates a planar square grid.\n\t* Parameters:\n\t*\tsize {number} the size\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSquareGrid = function (size, segmentation, isCurved)\n\t{\n\t\treturn JSM.GenerateGrid (size, size, segmentation, segmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectorsWithHeight\n\t* Description: Generates a ruled surface with height between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\theight {height} the height\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectorsWithHeight = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved, height)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\t\t\n\t\tvar topVertexCount = result.VertexCount ();\n\n\t\tvar newVertex, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tnewVertex = new JSM.Coord (vertex.x, vertex.y, vertex.z);\n\t\t\tnewVertex.z -= height;\n\t\t\tresult.AddVertex (new JSM.BodyVertex (newVertex));\n\t\t}\n\n\t\tvar j, newpolygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tnewpolygonVertexIndices = [];\n\t\t\tfor (j = polygonVertexIndices.length - 1; j >= 0; j--) {\n\t\t\t\tnewpolygonVertexIndices.push (polygonVertexIndices[j] + topVertexCount);\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon (newpolygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tvar current, next, top, ntop;\n\t\t\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + (lineSegmentation * (meshSegmentation + 1)) + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = i * (meshSegmentation + 1) + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = (i + 1) * meshSegmentation + i + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromCoords\n\t* Description:\n\t*\tGenerates a ruled surface between two coordinate arrays.\n\t*\tThe two arrays should have the same length.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromCoords = function (aCoords, bCoords, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tvertices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (vertices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRevolved\n\t* Description:\n\t*\tGenerates a revolved surface by rotating a polyline around a given axis.\n\t*\tIf the angle is 360 degree, it can generate top and bottom polygons.\n\t* Parameters:\n\t*\tpolyLine {Coord[*]} the polyline\n\t*\taxis {Sector} the axis\n\t*\tangle {number} the angle\n\t*\tsegmentation {integer} the segmentation\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveMode {string} 'None', 'CurveSegments', or 'CurveAll'\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRevolved = function (polyLine, axis, angle, segmentation, withTopAndBottom, curveMode)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar circular = JSM.IsEqual (angle, 2.0 * Math.PI);\n\n\t\tvar count = polyLine.length;\n\t\tvar step = angle / segmentation;\n\t\tvar axisDir = JSM.CoordSub (axis.end, axis.beg);\n\t\t\n\t\tvar i, j, rotated;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\tif (circular && j === segmentation) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trotated = polyLine[i].Clone ().Rotate (axisDir, j * step, axis.beg);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar curveModeFlag = 0;\n\t\tif (curveMode == 'CurveSegments') {\n\t\t\tcurveModeFlag = 1;\n\t\t} else if (curveMode == 'CurveAll') {\n\t\t\tcurveModeFlag = 2;\n\t\t}\n\t\t\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\tcurrent = i * (segmentation + 1) + j;\n\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tif (circular) {\n\t\t\t\t\tcurrent = i * segmentation + j;\n\t\t\t\t\ttop = current + segmentation;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tif (j === segmentation - 1) {\n\t\t\t\t\t\tnext = i * segmentation;\n\t\t\t\t\t\tntop = (i + 1) * segmentation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (curveModeFlag == 1) {\n\t\t\t\t\tpolygon.SetCurveGroup (i);\n\t\t\t\t} else if (curveModeFlag == 2) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tif (circular && withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (segmentation * (count - 1) + i);\n\t\t\t\tbottomPolygon.AddVertexIndex (segmentation - i - 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tvar axisNormalDir = axisDir.Clone ().Normalize ();\n\t\tvar axisLine = new JSM.Line (axis.beg, axisNormalDir);\n\t\tvar avgRadius = 0.0;\n\t\tvar projected;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprojected = axisLine.ProjectCoord (polyLine[i]);\n\t\t\tavgRadius = avgRadius + projected.DistanceTo (polyLine[i]);\n\t\t}\n\t\tavgRadius = avgRadius / count;\n\t\t\n\t\tvar origo = new JSM.Coord (axis.beg.x, axis.beg.y, axis.beg.z);\n\t\tvar baseLine = new JSM.Line (origo, axisDir);\n\t\tvar projectedToBaseLine = baseLine.ProjectCoord (polyLine[0]);\n\t\tvar xDirection = JSM.CoordSub (polyLine[0], projectedToBaseLine).Normalize ();\n\t\t\n\t\tresult.SetCylindricalTextureProjection (origo, avgRadius, xDirection, axisNormalDir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTube\n\t* Description:\n\t*\tGenerates a tube from a given array of polygons. All of the\n\t*\tpolygons should have same number of vertices.\n\t* Parameters:\n\t*\tbasePolygons {Coord[*][*]} the array of polygons\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTube = function (basePolygons, withStartAndEnd)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar contourCount = basePolygons.length;\n\t\tvar count = basePolygons[0].length;\n\n\t\tvar i, j;\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tfor (i = 0; i < contourCount; i++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygons[i][j]));\n\t\t\t}\n\t\t}\n\n\t\tvar current, next;\n\t\tfor (j = 0; j < contourCount - 1; j++) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = j + contourCount * i;\n\t\t\t\tnext = current + contourCount;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, next + 1, current + 1]));\n\t\t\t}\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (contourCount * i + contourCount - 1);\n\t\t\t}\n\t\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\t\tbottomPolygon.AddVertexIndex (contourCount * i);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurface\n\t* Description: Generates the surface of a given function.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurface = function (function3D, intervalMin, intervalMax, segmentation, isCurved)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMin.y, 0.0), new JSM.Coord (intervalMax.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMax.y, 0.0), new JSM.Coord (intervalMax.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectors (aSector, bSector, segmentation, segmentation, isCurved);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurfaceSolid\n\t* Description: Generates the surface of a given function with a solid body.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tbottomZ {number} the bottom z coordinate of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurfaceSolid = function (function3D, intervalMin, intervalMax, segmentation, isCurved, bottomZ)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMin.y, 0.0), new JSM.Coord (intervalMin.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMax.y, 0.0), new JSM.Coord (intervalMin.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectorsWithHeight (aSector, bSector, segmentation, segmentation, isCurved, bottomZ);\n\n\t\tvar i, coord;\n\t\tvar topVertexCount = (segmentation + 1) * (segmentation + 1);\n\t\tfor (i = 0; i < topVertexCount; i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/camera',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Camera\n\t* Description: Represents a camera.\n\t* Parameters:\n\t*\teye {Coord} the eye position\n\t*\tcenter {Coord} the center position\n\t*\tup {Vector} the up vector\n\t*\tfieldOfView {number} field of view in degree\n\t*\tnearClippingPlane {number} near clipping plane distance\n\t*\tfarClippingPlane {number} far clipping plane distance\n\t*/\n\tJSM.Camera = function (eye, center, up, fieldOfView, nearClippingPlane, farClippingPlane)\n\t{\n\t\tthis.eye = JSM.ValueOrDefault (eye, new JSM.Coord (1.0, 1.0, 1.0));\n\t\tthis.center = JSM.ValueOrDefault (center, new JSM.Coord (0.0, 0.0, 0.0));\n\t\tthis.up = JSM.ValueOrDefault (up, new JSM.Vector (0.0, 0.0, 1.0));\n\t\tthis.fieldOfView = JSM.ValueOrDefault (fieldOfView, 45.0);\n\t\tthis.nearClippingPlane = JSM.ValueOrDefault (nearClippingPlane, 0.1);\n\t\tthis.farClippingPlane = JSM.ValueOrDefault (farClippingPlane, 1000.0);\n\t};\n\n\t/**\n\t* Function: Camera.Set\n\t* Description: Sets the camera.\n\t* Parameters:\n\t*\teye {Coord} the eye position\n\t*\tcenter {Coord} the center position\n\t*\tup {Vector} the up vector\n\t*\tfieldOfView {number} field of view in degree\n\t*\tnearClippingPlane {number} near clipping plane distance\n\t*\tfarClippingPlane {number} far clipping plane distance\n\t*/\n\tJSM.Camera.prototype.Set = function (eye, center, up, fieldOfView, nearClippingPlane, farClippingPlane)\n\t{\n\t\tthis.eye = eye;\n\t\tthis.center = center;\n\t\tthis.up = up;\n\t\tthis.fieldOfView = JSM.ValueOrDefault (fieldOfView, 45.0);\n\t\tthis.nearClippingPlane = JSM.ValueOrDefault (nearClippingPlane, 0.1);\n\t\tthis.farClippingPlane = JSM.ValueOrDefault (farClippingPlane, 1000.0);\n\t};\n\n\t/**\n\t* Function: Camera.Clone\n\t* Description: Clones the camera.\n\t* Returns:\n\t*\t{Camera} a cloned instance\n\t*/\n\tJSM.Camera.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Camera ();\n\t\tresult.eye = this.eye;\n\t\tresult.center = this.center;\n\t\tresult.up = this.up;\n\t\tresult.fieldOfView = this.fieldOfView;\n\t\tresult.nearClippingPlane = this.nearClippingPlane;\n\t\tresult.farClippingPlane = this.farClippingPlane;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/explode',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ExplodeBody\n\t* Description:\n\t*\tExplodes a body to primitives. The function calls callback functions\n\t*\ton geometry start and end, and when a triangle or a line is created.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\texplodeData {object} the parameters and callback functions of explode\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ExplodeBody = function (body, materials, explodeData)\n\t{\n\t\tfunction SeparateByMaterial (materials, itemsByMaterial, itemsWithNoMaterial, callbacks)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\titemsByMaterial.push ([]);\n\t\t\t}\n\n\t\t\tvar itemCount = callbacks.itemCount ();\n\t\t\tvar material;\n\t\t\tfor (i = 0; i < itemCount; i++) {\n\t\t\t\tmaterial = callbacks.getMaterial (i);\n\t\t\t\tif (material !== -1) {\n\t\t\t\t\titemsByMaterial[material].push (i);\n\t\t\t\t} else {\n\t\t\t\t\titemsWithNoMaterial.push (i);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\tfunction ExplodePoints (body, materials, explodeData)\n\t\t{\n\t\t\tfunction ExplodePointsByMaterial (pointIndices, materialIndex, explodeData)\n\t\t\t{\n\t\t\t\tif (pointIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onPointGeometryStart !== undefined && explodeData.onPointGeometryStart !== null) {\n\t\t\t\t\texplodeData.onPointGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onPoint !== undefined && explodeData.onPoint !== null) {\n\t\t\t\t\tvar i, point, vertex;\n\t\t\t\t\tfor (i = 0; i < pointIndices.length; i++) {\n\t\t\t\t\t\tpoint = body.GetPoint (pointIndices[i]);\n\t\t\t\t\t\tvertex = body.GetVertexPosition (point.GetVertexIndex ());\n\t\t\t\t\t\texplodeData.onPoint (vertex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onPointGeometryEnd !== undefined && explodeData.onPointGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onPointGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.PointCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pointsByMaterial = [];\n\t\t\tvar pointsWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, pointsByMaterial, pointsWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.PointCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar point = body.GetPoint (index);\n\t\t\t\t\treturn point.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar i;\t\t\n\t\t\tfor (i = 0; i < pointsByMaterial.length; i++) {\n\t\t\t\tExplodePointsByMaterial (pointsByMaterial[i], i, explodeData);\n\t\t\t}\n\t\t\tExplodePointsByMaterial (pointsWithNoMaterial, -1, explodeData);\n\t\t}\n\n\t\tfunction ExplodeLines (body, materials, explodeData)\n\t\t{\n\t\t\tfunction ExplodeLinesByMaterial (lineIndices, materialIndex, explodeData)\n\t\t\t{\n\t\t\t\tif (lineIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onLineGeometryStart !== undefined && explodeData.onLineGeometryStart !== null) {\n\t\t\t\t\texplodeData.onLineGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onLine !== undefined && explodeData.onLine !== null) {\n\t\t\t\t\tvar i, line, beg, end;\n\t\t\t\t\tfor (i = 0; i < lineIndices.length; i++) {\n\t\t\t\t\t\tline = body.GetLine (lineIndices[i]);\n\t\t\t\t\t\tbeg = body.GetVertexPosition (line.GetBegVertexIndex ());\n\t\t\t\t\t\tend = body.GetVertexPosition (line.GetEndVertexIndex ());\n\t\t\t\t\t\texplodeData.onLine (beg, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onLineGeometryEnd !== undefined && explodeData.onLineGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onLineGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.LineCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar linesByMaterial = [];\n\t\t\tvar linesWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, linesByMaterial, linesWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.LineCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar line = body.GetLine (index);\n\t\t\t\t\treturn line.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar i;\t\t\n\t\t\tfor (i = 0; i < linesByMaterial.length; i++) {\n\t\t\t\tExplodeLinesByMaterial (linesByMaterial[i], i, explodeData);\n\t\t\t}\n\t\t\tExplodeLinesByMaterial (linesWithNoMaterial, -1, explodeData);\n\t\t}\n\n\t\tfunction ExplodePolygons (body, materials, explodeData)\n\t\t{\n\t\t\tfunction CalculatePolygonsDerivedData (body, materials)\n\t\t\t{\n\t\t\t\tvar vertexNormals = JSM.CalculateBodyVertexNormals (body);\n\n\t\t\t\tvar i, j;\n\t\t\t\tvar hasTextureCoords = false;\n\t\t\t\tif (materials !== undefined && materials !== null) {\n\t\t\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\t\t\tif (materials.GetMaterial (i).texture !== null) {\n\t\t\t\t\t\t\thasTextureCoords = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar textureCoords = null;\n\t\t\t\tvar polygon, material;\n\t\t\t\tif (hasTextureCoords) {\n\t\t\t\t\ttextureCoords = JSM.CalculateBodyTextureCoords (body);\n\t\t\t\t\tfor (i = 0; i < textureCoords.length; i++) {\n\t\t\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\t\t\tif (polygon.HasMaterialIndex ()) {\n\t\t\t\t\t\t\tmaterial = materials.GetMaterial (polygon.GetMaterialIndex ());\n\t\t\t\t\t\t\tfor (j = 0; j < textureCoords[i].length; j++) {\n\t\t\t\t\t\t\t\ttextureCoords[i][j].x /= material.textureWidth;\n\t\t\t\t\t\t\t\ttextureCoords[i][j].y /= -material.textureHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tvertexNormals : vertexNormals,\n\t\t\t\t\ttextureCoords : textureCoords\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tfunction ExplodePolygonsByMaterial (polygonIndices, materialIndex, derivedData, explodeData)\n\t\t\t{\n\t\t\t\tfunction ExplodePolygon (index, derivedData, explodeData)\n\t\t\t\t{\n\t\t\t\t\tfunction CreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (explodeData.onTriangle !== undefined && explodeData.onTriangle !== null) {\n\t\t\t\t\t\t\texplodeData.onTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\t\t\tif (count < 3) {\n\t\t\t\t\t\tJSM.Message ('Invalid polygon found.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar vertex1, vertex2, vertex3;\n\t\t\t\t\tvar normal1, normal2, normal3;\n\t\t\t\t\tvar uv1, uv2, uv3;\n\n\t\t\t\t\tvar convexPolygon = false;\n\t\t\t\t\tif (explodeData.hasConvexPolygons !== undefined && explodeData.hasConvexPolygons !== null) {\n\t\t\t\t\t\tconvexPolygon = explodeData.hasConvexPolygons;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i;\n\t\t\t\t\tif (count == 3 || convexPolygon) {\n\t\t\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\t\t\tvertex1 = body.GetVertexPosition (polygon.GetVertexIndex (0));\n\t\t\t\t\t\t\tvertex2 = body.GetVertexPosition (polygon.GetVertexIndex ((i + 1) % count));\n\t\t\t\t\t\t\tvertex3 = body.GetVertexPosition (polygon.GetVertexIndex ((i + 2) % count));\n\t\t\t\t\t\t\tnormal1 = derivedData.vertexNormals[index][0];\n\t\t\t\t\t\t\tnormal2 = derivedData.vertexNormals[index][(i + 1) % count];\n\t\t\t\t\t\t\tnormal3 = derivedData.vertexNormals[index][(i + 2) % count];\n\t\t\t\t\t\t\tuv1 = null;\n\t\t\t\t\t\t\tuv2 = null;\n\t\t\t\t\t\t\tuv3 = null;\n\t\t\t\t\t\t\tif (derivedData.textureCoords !== null) {\n\t\t\t\t\t\t\t\tuv1 = derivedData.textureCoords[index][0];\n\t\t\t\t\t\t\t\tuv2 = derivedData.textureCoords[index][(i + 1) % count];\n\t\t\t\t\t\t\t\tuv3 = derivedData.textureCoords[index][(i + 2) % count];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar polygon3D = new JSM.Polygon ();\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar vertex;\n\t\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\t\tvertex = body.GetVertexPosition (polygon.vertices[i]);\n\t\t\t\t\t\t\tpolygon3D.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar normal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\t\t\tvar triangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\t\t\tif (triangles !== null) {\n\t\t\t\t\t\t\tvar triangle;\n\t\t\t\t\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\t\t\t\t\ttriangle = triangles[i];\n\t\t\t\t\t\t\t\tvertex1 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[0]));\n\t\t\t\t\t\t\t\tvertex2 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[1]));\n\t\t\t\t\t\t\t\tvertex3 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[2]));\n\t\t\t\t\t\t\t\tnormal1 = derivedData.vertexNormals[index][triangle[0]];\n\t\t\t\t\t\t\t\tnormal2 = derivedData.vertexNormals[index][triangle[1]];\n\t\t\t\t\t\t\t\tnormal3 = derivedData.vertexNormals[index][triangle[2]];\n\t\t\t\t\t\t\t\tuv1 = null;\n\t\t\t\t\t\t\t\tuv2 = null;\n\t\t\t\t\t\t\t\tuv3 = null;\n\t\t\t\t\t\t\t\tif (derivedData.textureCoords !== null) {\n\t\t\t\t\t\t\t\t\tuv1 = derivedData.textureCoords[index][triangle[0]];\n\t\t\t\t\t\t\t\t\tuv2 = derivedData.textureCoords[index][triangle[1]];\n\t\t\t\t\t\t\t\t\tuv3 = derivedData.textureCoords[index][triangle[2]];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tCreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tJSM.Message ('Triangulation failed.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (polygonIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onGeometryStart !== undefined && explodeData.onGeometryStart !== null) {\n\t\t\t\t\texplodeData.onGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < polygonIndices.length; i++) {\n\t\t\t\t\tExplodePolygon (polygonIndices[i], derivedData, explodeData);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onGeometryEnd !== undefined && explodeData.onGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.PolygonCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar polygonsByMaterial = [];\n\t\t\tvar polygonsWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, polygonsByMaterial, polygonsWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.PolygonCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\t\t\treturn polygon.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar derivedData = CalculatePolygonsDerivedData (body, materials);\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygonsByMaterial.length; i++) {\n\t\t\t\tExplodePolygonsByMaterial (polygonsByMaterial[i], i, derivedData, explodeData);\n\t\t\t}\n\t\t\tExplodePolygonsByMaterial (polygonsWithNoMaterial, -1, derivedData, explodeData);\n\t\t}\n\n\t\tif (explodeData === undefined || explodeData === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (materials === undefined || materials === null) {\n\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t}\t\n\t\t\n\t\tExplodePoints (body, materials, explodeData);\n\t\tExplodeLines (body, materials, explodeData);\n\t\tExplodePolygons (body, materials, explodeData);\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/exporter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ExportBodyContentToStl\n\t* Description: Exports a body content to stl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tname {string} name the body\n\t*\thasConvexPolygons {boolean} the body has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyContentToStl = function (body, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddTriangleToContent (normal, vertex1, vertex2, vertex3)\n\t\t{\n\t\t\tAddLineToContent ('\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z);\n\t\t\tAddLineToContent ('\\t\\touter loop');\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex1.x + ' ' + vertex1.y + ' ' + vertex1.z);\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex2.x + ' ' + vertex2.y + ' ' + vertex2.z);\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex3.x + ' ' + vertex3.y + ' ' + vertex3.z);\n\t\t\tAddLineToContent ('\\t\\tendloop');\n\t\t\tAddLineToContent ('\\tendfacet');\n\t\t}\n\t\t\n\t\tfunction AddPolygon (index)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tif (count < 3) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar vertex1, vertex2, vertex3;\n\t\t\tvar normal = null;\n\t\t\tif (count === 3) {\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (0)).position;\n\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex (1)).position;\n\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex (2)).position;\n\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t} else {\n\t\t\t\tvar useTriangulation = true;\n\t\t\t\tif (hasConvexPolygons !== undefined && hasConvexPolygons) {\n\t\t\t\t\tuseTriangulation = false;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar i;\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\tif (useTriangulation) {\n\t\t\t\t\tvar polygon3D = new JSM.Polygon ();\n\t\t\t\t\t\n\t\t\t\t\tvar vertex;\n\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\tvertex = body.GetVertex (polygon.vertices[i]);\n\t\t\t\t\t\tpolygon3D.AddVertex (vertex.position.x, vertex.position.y, vertex.position.z);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar triangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\t\tif (triangles !== null) {\n\t\t\t\t\t\tvar triangle;\n\t\t\t\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\t\t\t\ttriangle = triangles[i];\n\t\t\t\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (triangle[0])).position;\n\t\t\t\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex (triangle[1])).position;\n\t\t\t\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex (triangle[2])).position;\n\t\t\t\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (0)).position;\n\t\t\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex ((i + 1) % count)).position;\n\t\t\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex ((i + 2) % count)).position;\n\t\t\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar stlContent = '';\n\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (i);\n\t\t}\n\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToStl\n\t* Description: Exports a body to stl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tname {string} name the body\n\t*\thasConvexPolygons {boolean} the body has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToStl = function (body, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tvar stlContent = '';\n\t\t\n\t\tAddLineToContent ('solid ' + name);\n\t\tstlContent += JSM.ExportBodyContentToStl (body, name, hasConvexPolygons);\n\t\tAddLineToContent ('endsolid ' + name);\n\t\t\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportModelToStl\n\t* Description: Exports a model to stl.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t*\tname {string} name the model\n\t*\thasConvexPolygons {boolean} the model has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToStl = function (model, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tvar stlContent = '';\n\n\t\tAddLineToContent ('solid ' + name);\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tstlContent += JSM.ExportBodyContentToStl (body, name + (i + 1).toString (), hasConvexPolygons);\n\t\t}\n\t\tAddLineToContent ('endsolid ' + name);\n\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyContentToObj\n\t* Description: Exports a body content to obj.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertexOffset {integer} vertex index offset\n\t*\tnormalOffset {integer} normal index offset\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyContentToObj = function (body, vertexOffset, normalOffset)\n\t{\n\t\tfunction AddToContent (line)\n\t\t{\n\t\t\tobjContent += line;\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tobjContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddVertex (index)\n\t\t{\n\t\t\tvar vertCoord = body.GetVertex (index).position;\n\t\t\tAddLineToContent ('v ' + vertCoord.x + ' ' + vertCoord.y + ' ' + vertCoord.z);\n\t\t}\n\n\t\tfunction AddNormal (index)\n\t\t{\n\t\t\tvar normalVector = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\tAddLineToContent ('vn ' + normalVector.x + ' ' + normalVector.y + ' ' + normalVector.z);\n\t\t}\n\n\t\tfunction AddPolygon (index)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\n\t\t\tAddToContent ('f ');\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tAddToContent ((vertexOffset + polygon.GetVertexIndex (i) + 1) + '//' + (normalOffset + index + 1) + ' ');\n\t\t\t}\n\t\t\t\n\t\t\tAddLineToContent ('');\n\t\t}\n\n\t\tvar objContent = '';\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (i);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddNormal (i);\n\t\t}\n\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (i);\n\t\t}\n\t\t\n\t\treturn objContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToObj\n\t* Description: Exports a body to obj.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToObj = function (body)\n\t{\n\t\treturn JSM.ExportBodyContentToObj (body, 0, 0);\n\t};\n\n\t/**\n\t* Function: ExportModelToObj\n\t* Description: Exports a model to obj.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToObj = function (model)\n\t{\n\t\tvar objContent = '';\n\t\t\n\t\tvar vertexOffset = 0;\n\t\tvar normalOffset = 0;\n\t\t\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tobjContent += JSM.ExportBodyContentToObj (body, vertexOffset, normalOffset);\n\t\t\tvertexOffset += body.VertexCount ();\n\t\t\tnormalOffset += body.PolygonCount ();\n\t\t}\n\n\t\treturn objContent;\n\t};\n\n\t/**\n\t* Function: ExportMaterialsToGdl\n\t* Description: Exports a material container to gdl.\n\t* Parameters:\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportMaterialsToGdl = function (materials)\n\t{\n\t\tfunction HexColorToRGBColorString (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = rgb[0] / 255.0 + ',' + rgb[1] / 255.0 + ',' + rgb[2] / 255.0;\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tgdlContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddMaterial (material, index)\n\t\t{\n\t\t\tvar rgbString = HexColorToRGBColorString (material.diffuse);\n\t\t\tAddLineToContent ('define material \"material' + index + '\" 2, ' + rgbString + ' ! ' + index);\n\t\t}\n\t\t\n\t\tvar gdlContent = '';\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\twriteMaterials = true;\n\t\t}\n\n\t\tvar i;\n\t\tif (writeMaterials) {\n\t\t\tAddMaterial (materials.GetDefaultMaterial (), 1);\n\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\tAddMaterial (materials.GetMaterial (i), i + 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyGeometryToGdl\n\t* Description: Exports a body geometry to gdl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\twriteMaterials {boolean} write materials\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyGeometryToGdl = function (body, writeMaterials)\n\t{\n\t\tfunction AddToContent (line)\n\t\t{\n\t\t\tvar lineLengthLimit = 200;\n\t\t\tif (line.length > lineLengthLimit) {\n\t\t\t\tvar current = 0;\n\t\t\t\tvar i, character;\n\t\t\t\tfor (i = 0; i < line.length; i++) {\n\t\t\t\t\tcharacter = line[i];\n\t\t\t\t\tgdlContent += character;\n\t\t\t\t\tcurrent++;\n\t\t\t\t\tif (current > lineLengthLimit && character == ',') {\n\t\t\t\t\t\tgdlContent += '\\n';\n\t\t\t\t\t\tcurrent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgdlContent += line;\n\t\t\t}\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tAddToContent (line + '\\n');\n\t\t}\n\n\t\tfunction AddVertex (index)\n\t\t{\n\t\t\tvar vertCoord = body.GetVertex (index).position;\n\t\t\tAddLineToContent ('vert ' + vertCoord.x + ', ' + vertCoord.y + ', ' + vertCoord.z + ' ! ' + (index + 1));\n\t\t}\n\n\t\tfunction AddEdge (adjacencyInfo, index)\n\t\t{\n\t\t\tvar edge = adjacencyInfo.edges[index];\n\t\t\tvar status = 0;\n\t\t\tif (edge.pgon1 != -1 && edge.pgon2 != -1) {\n\t\t\t\tif (body.GetPolygon (edge.pgon1).HasCurveGroup () && body.GetPolygon (edge.pgon2).HasCurveGroup ()) {\n\t\t\t\t\tif (body.GetPolygon (edge.pgon1).GetCurveGroup () == body.GetPolygon (edge.pgon2).GetCurveGroup ()) {\n\t\t\t\t\t\tstatus = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tAddLineToContent ('edge ' + (edge.vert1 + 1) + ', ' + (edge.vert2 + 1) + ', -1, -1, ' + status + ' ! ' + (index + 1));\n\t\t}\n\n\t\tfunction AddPolygon (adjacencyInfo, index, lastMaterialIndex)\n\t\t{\n\t\t\tvar materialIndex = -1;\n\t\t\tif (writeMaterials) {\n\t\t\t\tmaterialIndex = body.GetPolygon (index).GetMaterialIndex () + 2;\n\t\t\t\tif (materialIndex != lastMaterialIndex) {\n\t\t\t\t\tAddLineToContent ('set material \"material' + materialIndex + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar pgon = adjacencyInfo.pgons[index];\n\t\t\tvar status = 0;\n\t\t\tif (body.GetPolygon (index).HasCurveGroup ()) {\n\t\t\t\tstatus = 2;\n\t\t\t}\n\t\t\tAddToContent ('pgon ' + pgon.pedges.length + ', 0, ' + status + ', ');\n\t\t\tvar pedgeList = '';\n\t\t\tvar i, pedge;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tpedge = pgon.pedges[i];\n\t\t\t\tif (!pedge.reverse) {\n\t\t\t\t\tpedgeList += (pedge.index + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpedgeList += (-(pedge.index + 1));\n\t\t\t\t}\n\t\t\t\tif (i < pgon.pedges.length - 1) {\n\t\t\t\t\tpedgeList += ', ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tAddToContent (pedgeList);\n\t\t\tAddToContent (' ! ' + (index + 1));\n\t\t\tAddLineToContent ('');\n\t\t\t\n\t\t\treturn materialIndex;\n\t\t}\n\n\t\tvar gdlContent = '';\n\n\t\tAddLineToContent ('base');\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\tAddVertex (i);\n\t\t}\n\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tAddEdge (adjacencyInfo, i);\n\t\t}\n\t\t\n\t\tvar lastMaterialIndex = -1;\n\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\tlastMaterialIndex = AddPolygon (adjacencyInfo, i, lastMaterialIndex);\n\t\t}\n\n\t\tAddLineToContent ('body -1');\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToGdl\n\t* Description: Exports a body to gdl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToGdl = function (body, materials)\n\t{\n\t\tvar gdlContent = '';\n\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\tgdlContent += JSM.ExportMaterialsToGdl (materials);\n\t\t\twriteMaterials = true;\n\t\t}\n\n\t\tgdlContent += JSM.ExportBodyGeometryToGdl (body, writeMaterials);\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportModelToGdl\n\t* Description: Exports a model to gdl.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToGdl = function (model, materials)\n\t{\n\t\tvar gdlContent = '';\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\tgdlContent += JSM.ExportMaterialsToGdl (materials);\n\t\t\twriteMaterials = true;\n\t\t}\n\t\t\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tgdlContent += JSM.ExportBodyGeometryToGdl (body, writeMaterials);\n\t\t}\n\n\t\treturn gdlContent;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/trianglebody',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: TriangleBody\n\t* Description: Represents a 3D body which contains only triangles.\n\t*/\n\tJSM.TriangleBody = function (name)\n\t{\n\t\tthis.name = name;\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.uvs = [];\n\t\tthis.triangles = [];\n\t\tthis.defaultUVIndex = -1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.SetName\n\t* Description: Sets the name of the body.\n\t* Parameters:\n\t*\tname {string} the name\n\t*/\n\tJSM.TriangleBody.prototype.SetName = function (name)\n\t{\n\t\tthis.name = name;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetName\n\t* Description: Returns the name of the body.\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetName = function ()\n\t{\n\t\treturn this.name;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddVertex\n\t* Description: Adds a vertex to the body.\n\t* Parameters:\n\t*\tx, y, z {number} the coordinates of the vertex\n\t* Returns:\n\t*\t{integer} the index of the added vertex\n\t*/\n\tJSM.TriangleBody.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.vertices.push (new JSM.Coord (x, y, z));\n\t\treturn this.vertices.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetVertex\n\t* Description: Returns the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.SetVertex\n\t* Description: Sets the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*\tx, y, z {number} the new coordinates of the vertex\n\t*/\n\tJSM.TriangleBody.prototype.SetVertex = function (index, x, y, z)\n\t{\n\t\tthis.vertices[index] = new JSM.Coord (x, y, z);\n\t};\n\n\t/**\n\t* Function: TriangleBody.VertexCount\n\t* Description: Returns the vertex count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddNormal\n\t* Description: Adds a normal vector to the body.\n\t* Parameters:\n\t*\tx, y, z {number} the coordinates of the normal vector\n\t* Returns:\n\t*\t{integer} the index of the added normal vector\n\t*/\n\tJSM.TriangleBody.prototype.AddNormal = function (x, y, z)\n\t{\n\t\tthis.normals.push (new JSM.Vector (x, y, z));\n\t\treturn this.normals.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetNormal\n\t* Description: Returns the normal vector at the given index.\n\t* Parameters:\n\t*\tindex {integer} the normal vector index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetNormal = function (index)\n\t{\n\t\treturn this.normals[index];\n\t};\n\n\n\t/**\n\t* Function: TriangleBody.GetTriangleNormal\n\t* Description: Returns the normal vector of a triangle at the given position.\n\t* Parameters:\n\t*\ttriangleIndex {integer} the triangle index\n\t*\tnormalPosition {Coord} the position of the normal inside the triangle\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetTriangleNormal = function (triangleIndex, normalPosition)\n\t{\n\t\tvar normal = null;\n\t\tvar triangle = this.triangles[triangleIndex];\n\t\tif (triangle.curve == -1) {\n\t\t\tnormal = this.GetNormal (triangle.n0);\n\t\t} else {\n\t\t\tvar v0 = this.GetVertex (triangle.v0);\n\t\t\tvar v1 = this.GetVertex (triangle.v1);\n\t\t\tvar v2 = this.GetVertex (triangle.v2);\n\t\t\tvar n0 = this.GetNormal (triangle.n0);\n\t\t\tvar n1 = this.GetNormal (triangle.n1);\n\t\t\tvar n2 = this.GetNormal (triangle.n2);\n\t\t\tnormal = JSM.BarycentricInterpolation (v0, v1, v2, n0, n1, n2, normalPosition);\n\t\t}\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: TriangleBody.NormalCount\n\t* Description: Returns the normal vector count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.NormalCount = function ()\n\t{\n\t\treturn this.normals.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddUV\n\t* Description: Adds a texture coordinate to the body.\n\t* Parameters:\n\t*\tx, y {number} the coordinates of the texture coordinate\n\t* Returns:\n\t*\t{integer} the index of the added texture coordinate\n\t*/\n\tJSM.TriangleBody.prototype.AddUV = function (x, y)\n\t{\n\t\tthis.uvs.push (new JSM.Coord2D (x, y));\n\t\treturn this.uvs.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddDefaultUV\n\t* Description:\n\t*\tAdds a default texture coordinate to the body.\n\t*\tThe default texture coordinate is stored only once.\n\t* Returns:\n\t*\t{integer} the index of the default texture coordinate\n\t*/\n\tJSM.TriangleBody.prototype.AddDefaultUV = function ()\n\t{\n\t\tif (this.defaultUVIndex != -1) {\n\t\t\treturn this.defaultUVIndex;\n\t\t}\n\t\t\n\t\tthis.defaultUVIndex = this.AddUV (0.0, 0.0);\n\t\treturn this.defaultUVIndex;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetUV\n\t* Description: Returns the texture coordinate at the given index.\n\t* Parameters:\n\t*\tindex {integer} the texture coordinate index\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetUV = function (index)\n\t{\n\t\treturn this.uvs[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.UVCount\n\t* Description: Returns the texture coordinate count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.UVCount = function ()\n\t{\n\t\treturn this.uvs.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddTriangle\n\t* Description: Adds a triangle to the body.\n\t* Parameters:\n\t*\tv0, v1, v2 {integer} the vertex indices of the triangle\n\t*\tn0, n1, n2 {integer} the normal vector indices of the triangle\n\t*\tu0, u1, u2 {integer} the texture coordinate indices of the triangle\n\t*\tmat {integer} the material index of the triangle\n\t*\tcurve {integer} the curve group index of the triangle\n\t* Returns:\n\t*\t{integer} the index of the added triangle\n\t*/\n\tJSM.TriangleBody.prototype.AddTriangle = function (v0, v1, v2, n0, n1, n2, u0, u1, u2, mat, curve)\n\t{\n\t\tthis.triangles.push ({\n\t\t\tv0 : v0,\n\t\t\tv1 : v1,\n\t\t\tv2 : v2,\n\t\t\tn0 : n0,\n\t\t\tn1 : n1,\n\t\t\tn2 : n2,\n\t\t\tu0 : u0,\n\t\t\tu1 : u1,\n\t\t\tu2 : u2,\n\t\t\tmat : mat,\n\t\t\tcurve : curve\n\t\t});\n\t\treturn this.triangles.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetTriangle\n\t* Description: Returns the triangle at the given index.\n\t* Parameters:\n\t*\tindex {integer} the triangle index\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetTriangle = function (index)\n\t{\n\t\treturn this.triangles[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.TriangleCount\n\t* Description: Returns the triangle count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.TriangleCount = function ()\n\t{\n\t\treturn this.triangles.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetBoundingBox\n\t* Description: Returns the bounding box of the body.\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\t\t\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetCenter\n\t* Description: Returns the center of the bounding box of the body.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetBoundingSphere\n\t* Description: Returns the bounding sphere of the body.\n\t* Returns:\n\t*\t{Sphere} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\t\t\n\t\tvar i, current;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcurrent = center.DistanceTo (this.vertices[i]);\n\t\t\tif (JSM.IsGreater (current, radius)) {\n\t\t\t\tradius = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.Sphere (center, radius);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleBody.Finalize\n\t* Description:\n\t*\tFinalizes the body. This operation calculates normal vectors\n\t*\tand fixes the body if some data is missing from it.\n\t* Parameters:\n\t*\tmodel {TriangleModel} the triangle index\n\t*/\n\tJSM.TriangleBody.prototype.Finalize = function (model)\n\t{\n\t\tfunction FinalizeTriangle (body, triangleIndex, triangleNormals, vertexToTriangles)\n\t\t{\n\t\t\tfunction AddAverageNormal (body, vertexIndex, triangleIndex, triangleNormals, vertexToTriangles)\n\t\t\t{\n\t\t\t\tvar averageNormal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\tvar averageCount = 0;\n\t\t\t\t\n\t\t\t\tvar triangle = body.GetTriangle (triangleIndex);\n\t\t\t\tvar neighbourTriangles = vertexToTriangles[vertexIndex];\n\t\t\t\tvar i, neighbourTriangleIndex, neighbourTriangle;\n\t\t\t\tfor (i = 0; i < neighbourTriangles.length; i++) {\n\t\t\t\t\tneighbourTriangleIndex = neighbourTriangles[i];\n\t\t\t\t\tneighbourTriangle = body.GetTriangle (neighbourTriangleIndex);\n\t\t\t\t\tif (triangle.curve == neighbourTriangle.curve) {\n\t\t\t\t\t\taverageNormal = JSM.CoordAdd (averageNormal, triangleNormals[neighbourTriangleIndex]);\n\t\t\t\t\t\taverageCount = averageCount + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\taverageNormal.MultiplyScalar (1.0 / averageCount);\n\t\t\t\taverageNormal.Normalize ();\n\t\t\t\treturn body.AddNormal (averageNormal.x, averageNormal.y, averageNormal.z);\n\t\t\t}\n\t\t\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tif (triangle.mat === undefined || triangle.mat < 0) {\n\t\t\t\ttriangle.mat = model.GetDefaultMaterialIndex ();\n\t\t\t}\n\t\t\t\n\t\t\tvar normal, normalIndex;\n\t\t\tif (triangle.n0 === undefined || triangle.n1 === undefined || triangle.n2 === undefined) {\n\t\t\t\tif (triangle.curve === undefined || triangle.curve < 0) {\n\t\t\t\t\tnormal = triangleNormals[triangleIndex];\n\t\t\t\t\tnormalIndex = body.AddNormal (normal.x, normal.y, normal.z);\n\t\t\t\t\ttriangle.n0 = normalIndex;\n\t\t\t\t\ttriangle.n1 = normalIndex;\n\t\t\t\t\ttriangle.n2 = normalIndex;\n\t\t\t\t\ttriangle.curve = -1;\n\t\t\t\t} else {\n\t\t\t\t\ttriangle.n0 = AddAverageNormal (body, triangle.v0, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t\ttriangle.n1 = AddAverageNormal (body, triangle.v1, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t\ttriangle.n2 = AddAverageNormal (body, triangle.v2, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (triangle.u0 === undefined || triangle.u1 === undefined || triangle.u2 === undefined) {\n\t\t\t\ttriangle.u0 = body.AddDefaultUV ();\n\t\t\t\ttriangle.u1 = body.AddDefaultUV ();\n\t\t\t\ttriangle.u2 = body.AddDefaultUV ();\n\t\t\t}\n\t\t}\n\n\t\tvar triangleNormals = [];\n\t\tvar vertexToTriangles = {};\n\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertexToTriangles[i] = [];\n\t\t}\n\t\t\n\t\tvar triangle, normal;\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\ttriangle = this.triangles[i];\n\t\t\tnormal = JSM.CalculateTriangleNormal (this.vertices[triangle.v0], this.vertices[triangle.v1], this.vertices[triangle.v2]);\n\t\t\ttriangleNormals.push (normal);\n\t\t\tvertexToTriangles[triangle.v0].push (i);\n\t\t\tvertexToTriangles[triangle.v1].push (i);\n\t\t\tvertexToTriangles[triangle.v2].push (i);\n\t\t}\n\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\tFinalizeTriangle (this, i, triangleNormals, vertexToTriangles);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleBody.Clone\n\t* Description: Clones the body.\n\t* Returns:\n\t*\t{TriangleBody} a cloned instance\n\t*/\n\tJSM.TriangleBody.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.TriangleBody (this.name);\n\t\t\n\t\tvar i, triangle;\n\t\t\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.vertices.push (this.vertices[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.normals.length; i++) {\n\t\t\tresult.normals.push (this.normals[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.uvs.length; i++) {\n\t\t\tresult.uvs.push (this.uvs[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\ttriangle = this.triangles[i];\n\t\t\tresult.triangles.push ({\n\t\t\t\tv0 : triangle.v0,\n\t\t\t\tv1 : triangle.v1,\n\t\t\t\tv2 : triangle.v2,\n\t\t\t\tn0 : triangle.n0,\n\t\t\t\tn1 : triangle.n1,\n\t\t\t\tn2 : triangle.n2,\n\t\t\t\tu0 : triangle.u0,\n\t\t\t\tu1 : triangle.u1,\n\t\t\t\tu2 : triangle.u2,\n\t\t\t\tmat : triangle.mat,\n\t\t\t\tcurve : triangle.curve\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertTriangleBodyToOctree\n\t* Description: Converts a triangle body to triangle octree.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t* Returns:\n\t*\t{TriangleOctree} the result\n\t*/\n\tJSM.ConvertTriangleBodyToOctree = function (body)\n\t{\n\t\tvar result = new JSM.TriangleOctree (body.GetBoundingBox ());\n\t\tvar i, triangle, v0, v1, v2;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tresult.AddTriangle (v0, v1, v2, {\n\t\t\t\ttriangleIndex : i\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/trianglemodel',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: TriangleModel\n\t* Description: Represents a 3D model which contains only triangles.\n\t*/\n\tJSM.TriangleModel = function ()\n\t{\n\t\tthis.materials = [];\n\t\tthis.bodies = [];\n\t\tthis.defaultMaterial = -1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddMaterial\n\t* Description: Adds a material to the model.\n\t* Parameters:\n\t*\tmaterial {material} the parameters of the material\n\t* Returns:\n\t*\t{integer} the index of the added material\n\t*/\n\tJSM.TriangleModel.prototype.AddMaterial = function (material)\n\t{\n\t\tthis.materials.push (material);\n\t\treturn this.materials.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetMaterial\n\t* Description: Returns the material at the given index.\n\t* Parameters:\n\t*\tindex {integer} the material index\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetMaterial = function (index)\n\t{\n\t\treturn this.materials[index];\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddDefaultMaterial\n\t* Description: Adds a default material to the model. The default material is stored only once.\n\t* Returns:\n\t*\t{integer} the index of the default material\n\t*/\n\tJSM.TriangleModel.prototype.AddDefaultMaterial = function ()\n\t{\n\t\tif (this.defaultMaterial == -1) {\n\t\t\tthis.defaultMaterial = this.AddMaterial ({});\n\t\t}\n\t\treturn this.defaultMaterial;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetDefaultMaterialIndex\n\t* Description: Adds a default material, and returns the index of it.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetDefaultMaterialIndex = function ()\n\t{\n\t\treturn this.AddDefaultMaterial ();\n\t};\n\n\t/**\n\t* Function: TriangleModel.MaterialCount\n\t* Description: Returns the material count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.MaterialCount = function ()\n\t{\n\t\treturn this.materials.length;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddBody\n\t* Description: Adds a body to the model.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t* Returns:\n\t*\t{integer} the index of the added body\n\t*/\n\tJSM.TriangleModel.prototype.AddBody = function (body)\n\t{\n\t\tthis.bodies.push (body);\n\t\treturn this.bodies.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddBodyToIndex\n\t* Description: Adds a body to the model to the given index.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{integer} the index of the added body\n\t*/\n\tJSM.TriangleModel.prototype.AddBodyToIndex = function (body, index)\n\t{\n\t\tthis.bodies.splice (index, 0, body);\n\t\treturn index;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetBody\n\t* Description: Returns the body at the given index.\n\t* Parameters:\n\t*\tindex {integer} the body index\n\t* Returns:\n\t*\t{TriangleBody} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\t/**\n\t* Function: TriangleModel.VertexCount\n\t* Description: Returns the vertex count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.VertexCount = function ()\n\t{\n\t\tvar result = 0;\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tresult += body.VertexCount ();\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleModel.TriangleCount\n\t* Description: Returns the triangle count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.TriangleCount = function ()\n\t{\n\t\tvar result = 0;\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tresult += body.TriangleCount ();\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleModel.BodyCount\n\t* Description: Returns the body count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.BodyCount = function ()\n\t{\n\t\treturn this.bodies.length;\n\t};\n\n\t/**\n\t* Function: TriangleModel.FinalizeMaterials\n\t* Description:\n\t*\tFinalizes the materials in the model. This fill every not\n\t*\tspecified material parameter with default values.\n\t*/\n\tJSM.TriangleModel.prototype.FinalizeMaterials = function ()\n\t{\n\t\tvar defaultMaterialData = {\n\t\t\tname : 'Default',\n\t\t\tambient : [0.5, 0.5, 0.5],\n\t\t\tdiffuse : [0.5, 0.5, 0.5],\n\t\t\tspecular : [0.1, 0.1, 0.1],\n\t\t\tshininess : 0.0,\n\t\t\topacity : 1.0,\n\t\t\treflection : 0.0,\n\t\t\ttexture : null,\n\t\t\toffset : null,\n\t\t\tscale : null,\n\t\t\trotation : null\n\t\t};\n\t\t\n\t\tvar i, material;\n\t\tfor (i = 0; i < this.materials.length; i++) {\n\t\t\tmaterial = this.materials[i];\n\t\t\tJSM.CopyObjectProperties (defaultMaterialData, material, false);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleModel.FinalizeBodies\n\t* Description: Finalizes all body in the model.\n\t*/\n\tJSM.TriangleModel.prototype.FinalizeBodies = function ()\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tbody.Finalize (this);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleModel.Finalize\n\t* Description: Finalizes the model. It finalizes materials and bodies.\n\t*/\n\tJSM.TriangleModel.prototype.Finalize = function ()\n\t{\n\t\tthis.FinalizeBodies ();\n\t\tthis.FinalizeMaterials ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/converter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ConvertBodyToTriangleBody\n\t* Description: Converts a body to triangle body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{TriangleBody} the result\n\t*/\n\tJSM.ConvertBodyToTriangleBody = function (body)\n\t{\n\t\tfunction AddTriangle (result, polygon, v0, v1, v2)\n\t\t{\n\t\t\tvar triangleIndex = result.AddTriangle (v0, v1, v2);\n\t\t\tvar triangle = result.GetTriangle (triangleIndex);\n\t\t\tif (polygon.HasMaterialIndex ()) {\n\t\t\t\ttriangle.mat = polygon.GetMaterialIndex ();\n\t\t\t}\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\ttriangle.curve = polygon.GetCurveGroup ();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.TriangleBody ();\n\t\t\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\tresult.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t}\n\t\t\n\t\tvar polygon, vertexCount;\n\t\tvar polygon3D, normal, triangle, triangles;\n\t\tvar v0, v1, v2;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tvertexCount = polygon.VertexIndexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tv0 = polygon.GetVertexIndex (0);\n\t\t\t\tv1 = polygon.GetVertexIndex (1);\n\t\t\t\tv2 = polygon.GetVertexIndex (2);\n\t\t\t\tAddTriangle (result, polygon, v0, v1, v2);\n\t\t\t} else {\n\t\t\t\tpolygon3D = new JSM.Polygon ();\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tvertex = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\t\tpolygon3D.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, i);\n\t\t\t\ttriangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\tif (triangles !== null) {\n\t\t\t\t\tfor (j = 0; j < triangles.length; j++) {\n\t\t\t\t\t\ttriangle = triangles[j];\n\t\t\t\t\t\tv0 = polygon.GetVertexIndex (triangle[0]);\n\t\t\t\t\t\tv1 = polygon.GetVertexIndex (triangle[1]);\n\t\t\t\t\t\tv2 = polygon.GetVertexIndex (triangle[2]);\n\t\t\t\t\t\tAddTriangle (result, polygon, v0, v1, v2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertModelToTriangleModel\n\t* Description: Converts a model to triangle model.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t* Returns:\n\t*\t{TriangleModel} the result\n\t*/\n\tJSM.ConvertModelToTriangleModel = function (model)\n\t{\n\t\tvar result = new JSM.TriangleModel ();\n\t\tvar materials = model.GetMaterialSet ();\n\t\tvar i, material;\n\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\tmaterial = materials.GetMaterial (i);\n\t\t\tresult.AddMaterial ({\n\t\t\t\tname : 'Material' + i,\n\t\t\t\tambient : JSM.HexColorToNormalizedRGBComponents (material.ambient),\n\t\t\t\tdiffuse : JSM.HexColorToNormalizedRGBComponents (material.diffuse),\n\t\t\t\tspecular : JSM.HexColorToNormalizedRGBComponents (material.specular),\n\t\t\t\tshininess : material.shininess,\n\t\t\t\topacity : material.opacity,\n\t\t\t\treflection : material.reflection\n\t\t\t});\n\t\t}\n\t\t\n\t\tvar body, triangleBody;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\ttriangleBody = JSM.ConvertBodyToTriangleBody (body);\n\t\t\tresult.AddBody (triangleBody);\n\t\t}\n\t\tresult.Finalize ();\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertTriangleModelToJsonData\n\t* Description: Converts a triangle model to json data.\n\t* Parameters:\n\t*\tmodel {TriangleModel} the model\n\t* Returns:\n\t*\t{object} the result data\n\t*/\n\tJSM.ConvertTriangleModelToJsonData = function (model)\n\t{\n\t\tfunction ConvertMaterials (model, materials)\n\t\t{\n\t\t\tvar i, material, jsonMaterial;\n\t\t\tfor (i = 0; i < model.MaterialCount (); i++) {\n\t\t\t\tmaterial = model.GetMaterial (i);\n\t\t\t\tjsonMaterial = {\n\t\t\t\t\tname : JSM.ValueOrDefault (material.name, ''),\n\t\t\t\t\tambient : material.ambient,\n\t\t\t\t\tdiffuse : material.diffuse,\n\t\t\t\t\tspecular : material.specular,\n\t\t\t\t\tshininess : material.shininess,\n\t\t\t\t\topacity : material.opacity\n\t\t\t\t};\n\t\t\t\tif (material.texture !== undefined && material.texture !== null) {\n\t\t\t\t\tjsonMaterial.texture = JSM.ValueOrDefault (material.texture, null);\n\t\t\t\t\tjsonMaterial.offset = material.offset;\n\t\t\t\t\tjsonMaterial.scale = material.scale;\n\t\t\t\t\tjsonMaterial.rotation = material.rotation;\n\t\t\t\t}\n\t\t\t\tmaterials.push (jsonMaterial);\n\t\t\t}\n\t\t}\n\n\t\tfunction ConvertBody (model, body, mesh)\n\t\t{\n\t\t\tvar trianglesByMaterial = [];\n\t\t\tvar materialCount = model.MaterialCount ();\n\t\t\t\n\t\t\tvar i, j, coord;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tcoord = body.GetVertex (i);\n\t\t\t\tmesh.vertices.push (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < body.NormalCount (); i++) {\n\t\t\t\tcoord = body.GetNormal (i);\n\t\t\t\tmesh.normals.push (coord.x, coord.y, coord.z);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < body.UVCount (); i++) {\n\t\t\t\tcoord = body.GetUV (i);\n\t\t\t\tmesh.uvs.push (coord.x, coord.y);\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < materialCount; i++) {\n\t\t\t\ttrianglesByMaterial.push ([]);\n\t\t\t}\n\n\t\t\tvar triangle;\n\t\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\t\ttriangle = body.GetTriangle (i);\n\t\t\t\tif (triangle.mat === undefined || triangle.mat < 0 || triangle.mat >= materialCount) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrianglesByMaterial[triangle.mat].push (i);\n\t\t\t}\n\n\t\t\tvar triangleCount = 0;\n\t\t\tvar triangles, jsonTriangles;\n\t\t\tfor (i = 0; i < trianglesByMaterial.length; i++) {\n\t\t\t\ttriangles = trianglesByMaterial[i];\n\t\t\t\tif (triangles.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjsonTriangles =  {\n\t\t\t\t\tmaterial : i,\n\t\t\t\t\tparameters : []\n\t\t\t\t};\n\t\t\t\tfor (j = 0; j < triangles.length; j++) {\n\t\t\t\t\ttriangle = body.GetTriangle (triangles[j]);\n\t\t\t\t\tjsonTriangles.parameters.push (\n\t\t\t\t\t\ttriangle.v0, triangle.v1, triangle.v2,\n\t\t\t\t\t\ttriangle.n0, triangle.n1, triangle.n2,\n\t\t\t\t\t\ttriangle.u0, triangle.u1, triangle.u2\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\ttriangleCount = triangleCount + triangles.length;\n\t\t\t\tmesh.triangles.push (jsonTriangles);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tversion : 1,\n\t\t\tmaterials : [],\n\t\t\tmeshes : []\n\t\t};\n\t\t\n\t\tConvertMaterials (model, result.materials);\n\t\t\n\t\tvar i, body, mesh;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tif (body.TriangleCount () === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmesh = {\n\t\t\t\tname : body.GetName (),\n\t\t\t\tvertices : [],\n\t\t\t\tnormals : [],\n\t\t\t\tuvs : [],\n\t\t\t\ttriangles : []\n\t\t\t};\n\t\t\tConvertBody (model, body, mesh);\n\t\t\tresult.meshes.push (mesh);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MergeJsonDataMeshes\n\t* Description: Merges meshes in json data.\n\t* Parameters:\n\t*\tjsonData {object} the original data\n\t* Returns:\n\t*\t{object} the result data\n\t*/\n\tJSM.MergeJsonDataMeshes = function (jsonData)\n\t{\n\t\tfunction MergeMesh (mesh, currentMesh, materialToTriangles)\n\t\t{\n\t\t\tfunction MergeAttributes (mesh, currentMesh)\n\t\t\t{\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < currentMesh.vertices.length; i++) {\n\t\t\t\t\tmesh.vertices.push (currentMesh.vertices[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < currentMesh.normals.length; i++) {\n\t\t\t\t\tmesh.normals.push (currentMesh.normals[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < currentMesh.uvs.length; i++) {\n\t\t\t\t\tmesh.uvs.push (currentMesh.uvs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction MergeTriangles (mesh, currentTriangles, materialToTriangles, vertexOffset, normalOffset, uvOffset)\n\t\t\t{\n\t\t\t\tvar material = currentTriangles.material;\n\t\t\t\tvar trianglesIndex = materialToTriangles[material];\n\t\t\t\tif (trianglesIndex === undefined) {\n\t\t\t\t\tmesh.triangles.push ({\n\t\t\t\t\t\tmaterial : material,\n\t\t\t\t\t\tparameters : []\n\t\t\t\t\t});\n\t\t\t\t\ttrianglesIndex = mesh.triangles.length - 1;\n\t\t\t\t\tmaterialToTriangles[material] = trianglesIndex;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar triangles = mesh.triangles[trianglesIndex];\n\t\t\t\tvar triangleParameters = triangles.parameters;\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < currentTriangles.parameters.length; i = i + 9) {\n\t\t\t\t\ttriangleParameters.push (\n\t\t\t\t\t\tcurrentTriangles.parameters[i] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 1] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 2] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 3] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 4] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 5] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 6] + uvOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 7] + uvOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 8] + uvOffset\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar vertexOffset = mesh.vertices.length / 3;\n\t\t\tvar normalOffset = mesh.normals.length / 3;\n\t\t\tvar uvOffset = mesh.uvs.length / 2;\n\t\t\tMergeAttributes (mesh, currentMesh);\n\n\t\t\tvar i, currentTriangles;\n\t\t\tfor (i = 0; i < currentMesh.triangles.length; i++) {\n\t\t\t\tcurrentTriangles = currentMesh.triangles[i];\n\t\t\t\tMergeTriangles (mesh, currentTriangles, materialToTriangles, vertexOffset, normalOffset, uvOffset);\n\t\t\t}\n\t\t}\n\n\t\tvar result = {\n\t\t\tversion : jsonData.version,\n\t\t\tmaterials : jsonData.materials,\n\t\t\tmeshes : []\n\t\t};\n\t\t\n\t\tvar mesh = {\n\t\t\tname : 'Merged',\n\t\t\tvertices : [],\n\t\t\tnormals : [],\n\t\t\tuvs : [],\n\t\t\ttriangles : []\n\t\t};\n\t\t\n\t\tvar materialToTriangles = {};\n\t\tvar i, currentMesh;\n\t\tfor (i = 0; i < jsonData.meshes.length; i++) {\n\t\t\tcurrentMesh = jsonData.meshes[i];\n\t\t\tMergeMesh (mesh, currentMesh, materialToTriangles);\n\t\t}\n\t\t\n\t\tresult.meshes.push (mesh);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/rayutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: RayTriangleIntersection\n\t* Description: Calculates intersection between a ray and a triangle.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayTriangleIntersection = function (ray, v0, v1, v2)\n\t{\n\t\tvar rayOrigin = ray.GetOrigin ();\n\t\tvar rayDirection = ray.GetDirection ();\n\n\t\tvar edgeDir1 = JSM.CoordSub (v1, v0);\n\t\tvar edgeDir2 = JSM.CoordSub (v2, v0);\n\t\tvar pVector = JSM.VectorCross (rayDirection, edgeDir2);\n\n\t\tvar determinant = JSM.VectorDot (edgeDir1, pVector);\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar isFrontFacing = JSM.IsPositive (determinant);\n\t\tif (!isFrontFacing) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar invDeterminant = 1.0 / determinant;\n\n\t\tvar tVector = JSM.CoordSub (rayOrigin, v0);\n\t\tvar u = JSM.VectorDot (tVector, pVector) * invDeterminant;\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar qVector = JSM.VectorCross (tVector, edgeDir1);\n\t\tvar v = JSM.VectorDot (rayDirection, qVector) * invDeterminant;\n\t\tif (JSM.IsLower (v, 0.0) || JSM.IsGreater (u + v, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\t \n\t\tvar distance = JSM.VectorDot (edgeDir2, qVector) * invDeterminant;\n\t\tif (!JSM.IsPositive (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar scaledDirection = rayDirection.Clone ().MultiplyScalar (distance);\n\t\tvar intersection = {\n\t\t\tposition : JSM.CoordAdd (rayOrigin, scaledDirection),\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayBoxIntersection\n\t* Description: Calculates intersection between a ray and a box.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmin, max {Coord} the minimum and maximum points of the box\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayBoxIntersection = function (ray, min, max)\n\t{\n\t\tvar rayOriginVec = ray.GetOrigin ();\n\t\tvar rayDirectionVec = ray.GetDirection ();\n\n\t\tvar rayOrigin = JSM.CoordToArray (rayOriginVec);\n\t\tvar rayDirection = JSM.CoordToArray (rayDirectionVec);\n\t\tvar minB = JSM.CoordToArray (min);\n\t\tvar maxB = JSM.CoordToArray (max);\n\t\tvar quadrant = [0, 0, 0];\n\t\tvar candidatePlane = [0.0, 0.0, 0.0];\n\n\t\tvar originInBox = true;\n\t\tvar i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (JSM.IsLower (rayOrigin[i], minB[i])) {\n\t\t\t\tquadrant[i] = -1; // left\n\t\t\t\tcandidatePlane[i] = minB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else if (JSM.IsGreater (rayOrigin[i], maxB[i])) {\n\t\t\t\tquadrant[i] = 1; // right\n\t\t\t\tcandidatePlane[i] = maxB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else {\n\t\t\t\tquadrant[i] = 0; // middle\n\t\t\t}\n\t\t}\n\n\t\tvar intersection = null;\n\t\tif (originInBox) {\n\t\t\tintersection = {\n\t\t\t\tposition : rayOriginVec,\n\t\t\t\tdistance : 0.0\n\t\t\t};\n\t\t\treturn intersection;\n\t\t}\n\n\t\tvar maxT = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (quadrant[i] !== 0 && !JSM.IsZero (rayDirection[i])) {\n\t\t\t\tmaxT[i] = (candidatePlane[i] - rayOrigin[i]) / rayDirection[i];\n\t\t\t} else {\n\t\t\t\tmaxT[i] = -1.0;\n\t\t\t}\n\t\t}\n\n\t\tvar whichPlane = 0;\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (JSM.IsLower (maxT[whichPlane], maxT[i])) {\n\t\t\t\twhichPlane = i;\n\t\t\t}\n\t\t}\n\n\t\tif (JSM.IsNegative (maxT[whichPlane])) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar xCoord = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (whichPlane != i) {\n\t\t\t\txCoord[i] = rayOrigin[i] + maxT[whichPlane] * rayDirection[i];\n\t\t\t\tif (JSM.IsLower (xCoord[i], minB[i]) || JSM.IsGreater (xCoord[i], maxB[i])) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txCoord[i] = candidatePlane[i];\n\t\t\t}\n\t\t}\n\n\t\tvar intersectionCoord = JSM.CoordFromArray (xCoord);\n\t\tvar distance = rayOriginVec.DistanceTo (intersectionCoord);\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tintersection = {\n\t\t\tposition : intersectionCoord,\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayOctreeIntersection\n\t* Description: Calculates the nearest intersection between a ray and an octree.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\toctree {Octree} the octree\n\t*\tintersection {object} the result data (position, distance, userData)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayOctreeIntersection = function (ray, octree, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\n\t\tJSM.TraverseOctreeNodes (octree, function (node) {\n\t\t\tif (!calcMinIntersection && foundIntersection) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!JSM.RayBoxIntersection (ray, node.box.min, node.box.max)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < node.triangles.length; i++) {\n\t\t\t\tvar triangle = node.triangles[i];\n\t\t\t\tvar v0 = triangle.v0;\n\t\t\t\tvar v1 = triangle.v1;\n\t\t\t\tvar v2 = triangle.v2;\n\t\t\t\tvar currentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\tif (currentIntersection !== null) {\n\t\t\t\t\tfoundIntersection = true;\n\t\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\t\tminIntersection.userData = triangle.userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\t\n\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.userData = minIntersection.userData;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleBodyIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle body.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tbody {TriangleBody} the triangle body\n\t*\tintersection {object} the result data (position, distance, triangleIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleBodyIntersection = function (ray, body, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\t\n\t\tvar i, triangle, v0, v1, v2, currentIntersection;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tcurrentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\tif (currentIntersection !== null) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.triangleIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersection = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (JSM.RayTriangleBodyIntersection (ray, body, currentIntersection)) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersectionWithOctree\n\t* Description:\n\t*\tCalculates the nearest intersection between a ray and a triangle model.\n\t*\tCaches the octrees for all bodies in the model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersectionWithOctree = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, hasIntersection, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\thasIntersection = false;\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (body.TriangleCount () > 20) {\n\t\t\t\tif (body.octree === undefined) {\n\t\t\t\t\tbody.octree = JSM.ConvertTriangleBodyToOctree (body);\n\t\t\t\t}\n\t\t\t\thasIntersection = JSM.RayOctreeIntersection (ray, body.octree, currentIntersection);\n\t\t\t} else {\n\t\t\t\thasIntersection = JSM.RayTriangleBodyIntersection (ray, body, currentIntersection);\n\t\t\t}\n\t\t\t\n\t\t\tif (hasIntersection) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tif (currentIntersection.userData !== undefined) {\n\t\t\t\t\t\tminIntersection.triangleIndex = currentIntersection.userData.triangleIndex;\n\t\t\t\t\t}\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/binaryreader',[\"../core/jsm\"],function(JSM){\n\tJSM.BinaryReader = function (arrayBuffer, isLittleEndian)\n\t{\n\t\tthis.arrayBuffer = arrayBuffer;\n\t\tthis.dataView = new DataView (arrayBuffer);\n\t\tthis.isLittleEndian = isLittleEndian;\n\t\tthis.position = 0;\n\t};\n\n\tJSM.BinaryReader.prototype.GetPosition = function ()\n\t{\n\t\treturn this.position;\n\t};\n\n\tJSM.BinaryReader.prototype.GetByteLength = function ()\n\t{\n\t\treturn this.arrayBuffer.byteLength;\n\t};\n\n\tJSM.BinaryReader.prototype.Skip = function (bytes)\n\t{\n\t\tthis.position = this.position + bytes;\n\t};\n\n\tJSM.BinaryReader.prototype.End = function ()\n\t{\n\t\treturn this.position >= this.arrayBuffer.byteLength;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadBoolean = function ()\n\t{\n\t\tvar result = this.dataView.getInt8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result ? true : false;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadCharacter = function ()\n\t{\n\t\tvar result = this.dataView.getInt8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedCharacter = function ()\n\t{\n\t\tvar result = this.dataView.getUint8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadInteger16 = function ()\n\t{\n\t\tvar result = this.dataView.getInt16 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 2;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedInteger16 = function ()\n\t{\n\t\tvar result = this.dataView.getUint16 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 2;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadInteger32 = function ()\n\t{\n\t\tvar result = this.dataView.getInt32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedInteger32 = function ()\n\t{\n\t\tvar result = this.dataView.getUint32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadFloat32 = function ()\n\t{\n\t\tvar result = this.dataView.getFloat32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadDouble64 = function ()\n\t{\n\t\tvar result = this.dataView.getFloat64 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 8;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerutils',[\"../core/jsm\"],function(JSM){\n\tJSM.GetArrayBufferFromURL = function (url, callbacks)\n\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.open ('GET', url, true);\n\t\trequest.responseType = 'arraybuffer';\n\n\t\trequest.onload = function () {\n\t\t\tvar arrayBuffer = request.response;\n\t\t\tif (arrayBuffer && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (arrayBuffer);\n\t\t\t}\n\t\t};\n\t\t\n\t\trequest.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\trequest.send (null);\n\t};\n\n\tJSM.GetArrayBufferFromFile = function (file, callbacks)\n\t{\n\t\tvar reader = new FileReader ();\n\n\t\treader.onloadend = function (event) {\n\t\t\tif (event.target.readyState == FileReader.DONE && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (event.target.result);\n\t\t\t}\n\t\t};\n\t\t\n\t\treader.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\treader.readAsArrayBuffer (file);\n\t};\n\n\tJSM.GetStringBufferFromURL = function (url, callbacks)\n\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.open ('GET', url, true);\n\t\trequest.responseType = 'text';\n\n\t\trequest.onload = function () {\n\t\t\tvar stringBuffer = request.response;\n\t\t\tif (stringBuffer && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (stringBuffer);\n\t\t\t}\n\t\t};\n\t\t\n\t\trequest.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\trequest.send (null);\n\t};\n\n\tJSM.GetStringBufferFromFile = function (file, callbacks)\n\t{\n\t\tvar reader = new FileReader ();\n\n\t\treader.onloadend = function (event) {\n\t\t\tif (event.target.readyState == FileReader.DONE && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (event.target.result);\n\t\t\t}\n\t\t};\n\n\t\treader.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\t\n\t\t\n\t\treader.readAsText (file);\n\t};\n\n\tJSM.LoadMultipleBuffers = function (inputList, onReady)\n\t{\n\t\tfunction LoadMultipleBuffersInternal (inputList, index, result, onReady)\n\t\t{\n\t\t\tif (index >= inputList.length) {\n\t\t\t\tonReady (result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar currentInput = inputList[index];\n\t\t\tvar loaderFunction = null;\n\t\t\tif (currentInput.isFile) {\n\t\t\t\tif (currentInput.isArrayBuffer) {\n\t\t\t\t\tloaderFunction = JSM.GetArrayBufferFromFile;\n\t\t\t\t} else {\n\t\t\t\t\tloaderFunction = JSM.GetStringBufferFromFile;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentInput.isArrayBuffer) {\n\t\t\t\t\tloaderFunction = JSM.GetArrayBufferFromURL;\n\t\t\t\t} else {\n\t\t\t\t\tloaderFunction = JSM.GetStringBufferFromURL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tloaderFunction (currentInput.originalObject, {\n\t\t\t\tonReady : function (resultBuffer) {\n\t\t\t\t\tresult.push (resultBuffer);\n\t\t\t\t\tLoadMultipleBuffersInternal (inputList, index + 1, result, onReady);\n\t\t\t\t},\n\t\t\t\tonError : function () {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t\tLoadMultipleBuffersInternal (inputList, index + 1, result, onReady);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar result = [];\n\t\tLoadMultipleBuffersInternal (inputList, 0, result, function (result) {\n\t\t\tonReady (result);\n\t\t});\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importer3ds',[\"../core/jsm\"],function(JSM){\n\tJSM.Read3dsFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnLog (logText, logLevel)\n\t\t{\n\t\t\tif (callbacks.onLog !== undefined && callbacks.onLog !== null) {\n\t\t\t\tcallbacks.onLog (logText, logLevel);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterial (material)\n\t\t{\n\t\t\tif (callbacks.onMaterial !== undefined && callbacks.onMaterial !== null) {\n\t\t\t\tcallbacks.onMaterial (material);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMesh (objectName)\n\t\t{\n\t\t\tif (callbacks.onMesh !== undefined && callbacks.onMesh !== null) {\n\t\t\t\tcallbacks.onMesh (objectName);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTransformation (matrix)\n\t\t{\n\t\t\tif (callbacks.onTransformation !== undefined && callbacks.onTransformation !== null) {\n\t\t\t\tcallbacks.onTransformation (matrix);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnObjectNode (objectNode)\n\t\t{\n\t\t\tif (callbacks.onObjectNode !== undefined && callbacks.onObjectNode !== null) {\n\t\t\t\tcallbacks.onObjectNode (objectNode);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTextureVertex (x, y)\n\t\t{\n\t\t\tif (callbacks.onTextureVertex !== undefined && callbacks.onTextureVertex !== null) {\n\t\t\t\tcallbacks.onTextureVertex (x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (v0, v1, v2, flags)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, flags);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFaceMaterial (faceIndex, materialName)\n\t\t{\n\t\t\tif (callbacks.onFaceMaterial !== undefined && callbacks.onFaceMaterial !== null) {\n\t\t\t\tcallbacks.onFaceMaterial (faceIndex, materialName);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFaceSmoothingGroup (faceIndex, smoothingGroup)\n\t\t{\n\t\t\tif (callbacks.onFaceSmoothingGroup !== undefined && callbacks.onFaceSmoothingGroup !== null) {\n\t\t\t\tcallbacks.onFaceSmoothingGroup (faceIndex, smoothingGroup);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadChunk (reader, onReady)\n\t\t{\n\t\t\tvar chunkId = reader.ReadUnsignedInteger16 ();\n\t\t\tvar chunkLength = reader.ReadUnsignedInteger32 ();\n\t\t\tonReady (chunkId, chunkLength);\n\t\t}\n\t\t\n\t\tfunction SkipChunk (reader, length)\n\t\t{\n\t\t\treader.Skip (length - 6);\n\t\t}\n\t\t\n\t\tfunction GetChunkEnd (reader, length)\n\t\t{\n\t\t\treturn reader.GetPosition () + length - 6;\n\t\t}\n\t\t\n\t\tfunction ReadName (reader)\n\t\t{\n\t\t\tvar name = '';\n\t\t\tvar letter = 0;\n\t\t\tvar count = 0;\n\t\t\twhile (count < 64) {\n\t\t\t\tletter = reader.ReadCharacter ();\n\t\t\t\tif (letter === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname = name + String.fromCharCode (letter);\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction ReadChunks (reader, endByte, onReady)\n\t\t{\n\t\t\twhile (reader.GetPosition () <= endByte - 6) {\n\t\t\t\tReadChunk (reader, onReady);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadFile (reader, chunks)\n\t\t{\n\t\t\tfunction ReadColorChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tvar color = [0.0, 0.0, 0.0];\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar hasLinColor = false;\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_COLOR) {\n\t\t\t\t\t\tif (!hasLinColor) {\n\t\t\t\t\t\t\tcolor[0] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t\tcolor[1] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t\tcolor[2] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (chunkId == chunks.MAT_LIN_COLOR) {\n\t\t\t\t\t\tcolor[0] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\tcolor[1] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\tcolor[2] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\thasLinColor = true;\n\t\t\t\t\t} else if (chunkId == chunks.MAT_COLOR_F) {\n\t\t\t\t\t\tif (!hasLinColor) {\n\t\t\t\t\t\t\tcolor[0] = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcolor[1] = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcolor[2] = reader.ReadFloat32 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (chunkId == chunks.MAT_LIN_COLOR_F) {\n\t\t\t\t\t\tcolor[0] = reader.ReadFloat32 ();\n\t\t\t\t\t\tcolor[1] = reader.ReadFloat32 ();\n\t\t\t\t\t\tcolor[2] = reader.ReadFloat32 ();\n\t\t\t\t\t\thasLinColor = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn color;\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadPercentageChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tvar percentage = 0.0;\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.PERCENTAGE) {\n\t\t\t\t\t\tpercentage = reader.ReadUnsignedInteger16 () / 100.0;\n\t\t\t\t\t} else if (chunkId == chunks.PERCENTAGE_F) {\n\t\t\t\t\t\tpercentage = reader.ReadFloat32 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn percentage;\n\t\t\t}\n\n\t\t\tfunction ReadTextureMapChunk (reader, id, length, material)\n\t\t\t{\n\t\t\t\tmaterial.texture = null;\n\t\t\t\tmaterial.offset = [0.0, 0.0];\n\t\t\t\tmaterial.scale = [1.0, 1.0];\n\t\t\t\tmaterial.rotation = 0.0;\n\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_TEXMAP_NAME) {\n\t\t\t\t\t\tmaterial.texture = ReadName (reader);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_UOFFSET) {\n\t\t\t\t\t\tmaterial.offset[0] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_VOFFSET) {\n\t\t\t\t\t\tmaterial.offset[1] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_USCALE) {\n\t\t\t\t\t\tmaterial.scale[0] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_VSCALE) {\n\t\t\t\t\t\tmaterial.scale[1] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_ROTATION) {\n\t\t\t\t\t\tmaterial.rotation = reader.ReadFloat32 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadMaterialChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read material chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar material = {};\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_NAME) {\n\t\t\t\t\t\tOnLog ('Read material name chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.name = ReadName (reader);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_AMBIENT) {\n\t\t\t\t\t\tOnLog ('Read material ambient chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.ambient = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_DIFFUSE) {\n\t\t\t\t\t\tOnLog ('Read material diffuse chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.diffuse = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SPECULAR) {\n\t\t\t\t\t\tOnLog ('Read material specular chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.specular = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SHININESS) {\n\t\t\t\t\t\tOnLog ('Read material shininess chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.shininess = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SHININESS_STRENGTH) {\n\t\t\t\t\t\tOnLog ('Read material shininess strength chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.shininessStrength = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TRANSPARENCY) {\n\t\t\t\t\t\tOnLog ('Read material transparency chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.transparency = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP) {\n\t\t\t\t\t\tOnLog ('Read material texture map chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tReadTextureMapChunk (reader, chunkId, chunkLength, material);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tOnMaterial (material);\n\t\t\t}\n\n\t\t\tfunction ReadVerticesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read vertices chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar vertexCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, x, y, z;\n\t\t\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\t\t\tx = reader.ReadFloat32 ();\n\t\t\t\t\ty = reader.ReadFloat32 ();\n\t\t\t\t\tz = reader.ReadFloat32 ();\n\t\t\t\t\tOnVertex (x, y, z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadTextureVerticesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read texture vertices chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar texVertexCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, x, y;\n\t\t\t\tfor (i = 0; i < texVertexCount; i++) {\n\t\t\t\t\tx = reader.ReadFloat32 ();\n\t\t\t\t\ty = reader.ReadFloat32 ();\n\t\t\t\t\tOnTextureVertex (x, y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadFaceMaterialsChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read face materials chunk (' + id.toString (16) + ', ' + length + ')', 5);\n\t\t\t\t\n\t\t\t\tvar materialName = ReadName (reader);\n\t\t\t\tvar faceCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, faceIndex;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tfaceIndex = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tOnFaceMaterial (faceIndex, materialName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadFaceSmoothingGroupsChunk (reader, faceCount, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read face smoothing groups chunk (' + id.toString (16) + ', ' + length + ')', 5);\n\t\t\t\t\n\t\t\t\tvar i, smoothingGroup;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tsmoothingGroup = reader.ReadUnsignedInteger32 ();\n\t\t\t\t\tOnFaceSmoothingGroup (i, smoothingGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadFacesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read faces chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar faceCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, v0, v1, v2, flags;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tv0 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tv1 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tv2 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tflags = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tOnFace (v0, v1, v2, flags);\n\t\t\t\t}\n\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.TRI_MATERIAL) {\n\t\t\t\t\t\tReadFaceMaterialsChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_SMOOTH) {\n\t\t\t\t\t\tReadFaceSmoothingGroupsChunk (reader, faceCount,  chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 5);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadTransformationChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read transformation chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\tvar matrix = [];\n\t\t\t\tvar i, j;\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\tmatrix.push (reader.ReadFloat32 ());\n\t\t\t\t\t}\n\t\t\t\t\tif (i < 3) {\n\t\t\t\t\t\tmatrix.push (0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatrix.push (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tOnTransformation (matrix);\n\t\t\t}\n\n\t\t\tfunction ReadMeshChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read mesh chunk (' + objectName + ', ' +  id.toString (16) + ', ' + length + ')', 3);\n\n\t\t\t\tOnMesh (objectName);\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.TRI_VERTEX) {\n\t\t\t\t\t\tReadVerticesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_TEXVERTEX) {\n\t\t\t\t\t\tReadTextureVerticesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_FACE) {\n\t\t\t\t\t\tReadFacesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_TRANSFORMATION) {\n\t\t\t\t\t\tReadTransformationChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 4);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadLightChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Skip light chunk (' + objectName + ', ' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\tSkipChunk (reader, length);\n\t\t\t}\n\n\t\t\tfunction ReadCameraChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Skip camera chunk (' + objectName + ', ' +  id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\tSkipChunk (reader, length);\n\t\t\t}\n\n\t\t\tfunction ReadObjectChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read object chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar objectName = ReadName (reader);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJ_TRIMESH) {\n\t\t\t\t\t\tReadMeshChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.OBJ_LIGHT) {\n\t\t\t\t\t\tReadLightChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.OBJ_CAMERA) {\n\t\t\t\t\t\tReadCameraChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadEditorChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read editor chunk (' + id.toString (16) + ', ' + length + ')', 1);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.EDIT_MATERIAL) {\n\t\t\t\t\t\tReadMaterialChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.EDIT_OBJECT) {\n\t\t\t\t\t\tReadObjectChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 2);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadObjectNodeChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tfunction ReadTrackVector (reader, type)\n\t\t\t\t{\n\t\t\t\t\tvar result = [];\n\t\t\t\t\treader.Skip (10);\n\t\t\t\t\t\n\t\t\t\t\tvar i, flags, current, tmp;\n\t\t\t\t\tvar keyNum = reader.ReadInteger32 ();\n\t\t\t\t\tfor (i = 0; i < keyNum; i++) {\n\t\t\t\t\t\treader.ReadInteger32 ();\n\t\t\t\t\t\tflags = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t\tif (flags !== 0) {\n\t\t\t\t\t\t\treader.ReadFloat32 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurrent = null;\n\t\t\t\t\t\tif (type == chunks.OBJECT_ROTATION) {\n\t\t\t\t\t\t\ttmp = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcurrent = ReadVector (reader);\n\t\t\t\t\t\t\tcurrent[3] = tmp;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent = ReadVector (reader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push (current);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tOnLog ('Read object node chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar objectNode = {\n\t\t\t\t\tname : '',\n\t\t\t\t\tnodeId : -1,\n\t\t\t\t\tflags : -1,\n\t\t\t\t\tuserId : -1,\n\t\t\t\t\tpivot : [0.0, 0.0, 0.0],\n\t\t\t\t\tpositions : [],\n\t\t\t\t\trotations : [],\n\t\t\t\t\tscales : []\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJECT_HIERARCHY) {\n\t\t\t\t\t\tobjectNode.name = ReadName (reader);\n\t\t\t\t\t\tobjectNode.flags = reader.ReadUnsignedInteger32 ();\n\t\t\t\t\t\tobjectNode.userId = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_PIVOT) {\n\t\t\t\t\t\tobjectNode.pivot = ReadVector (reader);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_POSITION) {\n\t\t\t\t\t\tobjectNode.positions = ReadTrackVector (reader, chunks.OBJECT_POSITION);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_ROTATION) {\n\t\t\t\t\t\tobjectNode.rotations = ReadTrackVector (reader, chunks.OBJECT_ROTATION);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_SCALE) {\n\t\t\t\t\t\tobjectNode.scales = ReadTrackVector (reader, chunks.OBJECT_SCALE);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_ID) {\n\t\t\t\t\t\tobjectNode.nodeId = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tOnObjectNode (objectNode);\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadKeyFrameChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read keyframe chunk (' + id.toString (16) + ', ' + length + ')', 1);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJECT_NODE) {\n\t\t\t\t\t\tReadObjectNodeChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 2);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadMainChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read main chunk (' + id.toString (16) + ', ' + length + ')', 0);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.EDIT3DS) {\n\t\t\t\t\t\tReadEditorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.KF3DS) {\n\t\t\t\t\t\tReadKeyFrameChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 1);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\n\t\t\tvar endByte = reader.GetByteLength ();\n\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\tif (chunkId == chunks.MAIN3DS) {\n\t\t\t\t\tReadMainChunk (reader, chunkId, chunkLength);\n\t\t\t\t} else {\n\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 0);\n\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar chunks = {\n\t\t\tMAIN3DS : 0x4D4D,\n\t\t\tEDIT3DS : 0x3D3D,\n\t\t\tEDIT_MATERIAL : 0xAFFF,\n\t\t\tMAT_NAME : 0xA000,\n\t\t\tMAT_AMBIENT : 0xA010,\n\t\t\tMAT_DIFFUSE : 0xA020,\n\t\t\tMAT_SPECULAR : 0xA030,\n\t\t\tMAT_SHININESS : 0xA040,\n\t\t\tMAT_SHININESS_STRENGTH : 0xA041,\n\t\t\tMAT_TRANSPARENCY : 0xA050,\n\t\t\tMAT_COLOR_F : 0x0010,\n\t\t\tMAT_COLOR : 0x0011,\n\t\t\tMAT_LIN_COLOR : 0x0012,\n\t\t\tMAT_LIN_COLOR_F : 0x0013,\n\t\t\tMAT_TEXMAP : 0xA200,\n\t\t\tMAT_TEXMAP_NAME : 0xA300,\n\t\t\tMAT_TEXMAP_UOFFSET : 0xA358,\n\t\t\tMAT_TEXMAP_VOFFSET : 0xA35A,\n\t\t\tMAT_TEXMAP_USCALE : 0xA354,\n\t\t\tMAT_TEXMAP_VSCALE : 0xA356,\n\t\t\tMAT_TEXMAP_ROTATION : 0xA35C,\n\t\t\tPERCENTAGE : 0x0030,\n\t\t\tPERCENTAGE_F : 0x0031,\n\t\t\tEDIT_OBJECT : 0x4000,\n\t\t\tOBJ_TRIMESH : 0x4100,\n\t\t\tOBJ_LIGHT : 0x4600,\n\t\t\tOBJ_CAMERA : 0x4700,\n\t\t\tTRI_VERTEX : 0x4110,\n\t\t\tTRI_TEXVERTEX : 0x4140,\n\t\t\tTRI_FACE : 0x4120,\n\t\t\tTRI_TRANSFORMATION : 0x4160,\n\t\t\tTRI_MATERIAL : 0x4130,\n\t\t\tTRI_SMOOTH : 0x4150,\n\t\t\tKF3DS : 0xB000,\n\t\t\tOBJECT_NODE : 0xB002,\n\t\t\tOBJECT_HIERARCHY : 0xB010,\n\t\t\tOBJECT_PIVOT : 0xB013,\n\t\t\tOBJECT_POSITION : 0xB020,\n\t\t\tOBJECT_ROTATION : 0xB021,\n\t\t\tOBJECT_SCALE : 0xB022,\n\t\t\tOBJECT_ID : 0xB030\n\t\t};\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\tReadFile (reader, chunks);\n\t};\n\n\tJSM.Convert3dsToJsonData = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction FinalizeMeshes (nodeHierarcy, triangleModel, materialNameToIndex)\n\t\t{\n\t\t\tfunction ApplyTransformation (body, node, nodeHierarcy)\n\t\t\t{\n\t\t\t\tfunction MatrixScale (matrix, scale)\n\t\t\t\t{\n\t\t\t\t\tvar x = scale[0];\n\t\t\t\t\tvar y = scale[1];\n\t\t\t\t\tvar z = scale[2];\n\t\t\t\t\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\t\tmatrix[0 * 4 + i] *= x;\n\t\t\t\t\t\tmatrix[1 * 4 + i] *= y;\n\t\t\t\t\t\tmatrix[2 * 4 + i] *= z;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn matrix;\n\t\t\t\t}\n\n\t\t\t\tfunction MatrixTranslate (matrix, translation)\n\t\t\t\t{\n\t\t\t\t\tvar x = translation[0];\n\t\t\t\t\tvar y = translation[1];\n\t\t\t\t\tvar z = translation[2];\n\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tmatrix[3 * 4 + i] += matrix[0 * 4 + i] * x + matrix[1 * 4 + i] * y + matrix[2 * 4 + i] * z;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn matrix;\n\t\t\t\t}\n\n\t\t\t\tfunction MatrixRotate (matrix, quaternion)\n\t\t\t\t{\n\t\t\t\t\tvar rotation = JSM.MatrixRotationQuaternion (quaternion);\n\t\t\t\t\treturn JSM.MatrixMultiply (rotation, matrix);\n\t\t\t\t}\n\n\t\t\t\tfunction TransformBodyVertices (body, matrix)\n\t\t\t\t{\n\t\t\t\t\tvar i, vertex, transformedVertex;\n\t\t\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\t\t\ttransformedVertex = JSM.ApplyTransformation (matrix, vertex);\n\t\t\t\t\t\tbody.SetVertex (i, transformedVertex.x, transformedVertex.y, transformedVertex.z);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction FlipByXCoordinates (body, matrix, invMatrix)\t\n\t\t\t\t{\n\t\t\t\t\tvar determinant = JSM.MatrixDeterminant (matrix);\n\t\t\t\t\tif (!JSM.IsNegative (determinant)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar flippedMatrix = JSM.MatrixClone (matrix);\n\t\t\t\t\tMatrixScale (flippedMatrix, [-1.0, 1.0, 1.0]);\n\t\t\t\t\t\n\t\t\t\t\tvar finalMatrix = JSM.MatrixMultiply (invMatrix, flippedMatrix);\n\t\t\t\t\tTransformBodyVertices (body, finalMatrix);\n\t\t\t\t}\n\n\t\t\t\tfunction GetNodeTransformation (node, nodeHierarcy)\n\t\t\t\t{\n\t\t\t\t\tfunction GetNodePosition (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.positions.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node.positions[0];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tfunction GetNodeRotation (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tfunction GetQuatFromAxisAndAngle (quat)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar result = [0.0, 0.0, 0.0, 1.0];\n\t\t\t\t\t\t\tvar length = Math.sqrt (quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2]);\n\t\t\t\t\t\t\tif (JSM.IsPositive (length)) {\n\t\t\t\t\t\t\t\tvar omega = quat[3] * -0.5;\n\t\t\t\t\t\t\t\tvar si = Math.sin (omega) / length;\n\t\t\t\t\t\t\t\tresult = [si * quat[0], si * quat[1], si * quat[2], Math.cos (omega)];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (node.rotations.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar quat = node.rotations[0];\n\t\t\t\t\t\treturn GetQuatFromAxisAndAngle (quat);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction GetNodeScale (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.scales.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node.scales[0];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (node.matrix !== undefined) {\n\t\t\t\t\t\treturn node.matrix;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar result = JSM.MatrixIdentity ();\n\t\t\t\t\tresult = MatrixTranslate (result, GetNodePosition (node));\n\t\t\t\t\tresult = MatrixRotate (result, GetNodeRotation (node));\n\t\t\t\t\tresult = MatrixScale (result, GetNodeScale (node));\n\t\t\t\t\t\n\t\t\t\t\tif (node.userId != 65535) {\n\t\t\t\t\t\tvar parentIndex = nodeHierarcy.nodeIdToIndex[node.userId];\n\t\t\t\t\t\tif (parentIndex !== undefined) {\n\t\t\t\t\t\t\tvar parentNode = nodeHierarcy.nodes[parentIndex];\n\t\t\t\t\t\t\tvar parentTransformation = GetNodeTransformation (parentNode, nodeHierarcy);\n\t\t\t\t\t\t\tresult = JSM.MatrixMultiply (result, parentTransformation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode.matrix = result;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tfunction GetNodePivotPoint (node)\n\t\t\t\t{\n\t\t\t\t\tif (node === undefined || node === null) {\n\t\t\t\t\t\treturn [0.0, 0.0, 0.0];\n\t\t\t\t\t}\n\t\t\t\t\treturn node.pivot;\n\t\t\t\t}\n\n\t\t\t\tfunction GetMeshTransformation (mesh)\n\t\t\t\t{\n\t\t\t\t\tif (mesh === undefined || mesh === null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn mesh.transformation;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar currentMeshData = body.meshData;\n\t\t\t\tvar meshTransformation = GetMeshTransformation (currentMeshData);\n\t\t\t\tif (meshTransformation === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar nodeTransformation = null;\n\t\t\t\tif (node !== null) {\n\t\t\t\t\tnodeTransformation = GetNodeTransformation (node, nodeHierarcy);\n\t\t\t\t} else {\n\t\t\t\t\tnodeTransformation = meshTransformation;\n\t\t\t\t}\n\n\t\t\t\tvar matrix = JSM.MatrixClone (nodeTransformation);\n\t\t\t\tvar meshMatrix = JSM.MatrixClone (meshTransformation);\n\t\t\t\tvar invMeshMatrix = JSM.MatrixInvert (meshMatrix);\n\t\t\t\tif (invMeshMatrix === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tFlipByXCoordinates (body, meshMatrix, invMeshMatrix);\n\n\t\t\t\tvar nodePivotPoint = GetNodePivotPoint (node);\n\t\t\t\tMatrixTranslate (matrix, [-nodePivotPoint[0], -nodePivotPoint[1], -nodePivotPoint[2]]);\n\t\t\t\tvar finalMatrix = JSM.MatrixMultiply (invMeshMatrix, matrix);\n\t\t\t\tTransformBodyVertices (body, finalMatrix);\n\t\t\t}\n\n\t\t\tfunction FinalizeMaterials (body, materialNameToIndex)\n\t\t\t{\n\t\t\t\tvar hasTextureCoordinates = (body.UVCount () == body.VertexCount ());\n\t\t\t\tvar currentMeshData = body.meshData;\n\t\t\t\tvar i, triangle, materialName, materialIndex, smoothingGroup;\n\t\t\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\t\t\ttriangle = body.GetTriangle (i);\n\t\t\t\t\tif (hasTextureCoordinates) {\n\t\t\t\t\t\ttriangle.u0 = triangle.v0;\n\t\t\t\t\t\ttriangle.u1 = triangle.v1;\n\t\t\t\t\t\ttriangle.u2 = triangle.v2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmaterialName = currentMeshData.faceToMaterial[i];\n\t\t\t\t\tif (materialName !== undefined) {\n\t\t\t\t\t\tmaterialIndex = materialNameToIndex[materialName];\n\t\t\t\t\t\tif (materialIndex !== undefined) {\n\t\t\t\t\t\t\ttriangle.mat = materialIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsmoothingGroup = currentMeshData.faceToSmoothingGroup[i];\n\t\t\t\t\tif (smoothingGroup !== undefined && smoothingGroup > 0) {\n\t\t\t\t\t\ttriangle.curve = smoothingGroup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction FinalizeMesh (body, node, materialNameToIndex, nodeHierarcy)\n\t\t\t{\n\t\t\t\tApplyTransformation (body, node, nodeHierarcy);\n\t\t\t\tFinalizeMaterials (body, materialNameToIndex);\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfunction DuplicateBody (model, body, bodyIndex, instanceIndex)\n\t\t\t{\n\t\t\t\tvar clonedBody = body.Clone ();\n\t\t\t\tclonedBody.SetName (clonedBody.GetName () + ' (' + instanceIndex + ')');\n\t\t\t\tif (bodyIndex < model.BodyCount ()) {\n\t\t\t\t\tmodel.AddBodyToIndex (clonedBody, bodyIndex);\n\t\t\t\t} else {\n\t\t\t\t\tmodel.AddBody (clonedBody);\n\t\t\t\t}\n\t\t\t\treturn clonedBody;\n\t\t\t}\n\n\t\t\tvar i, j, currentBody, currentMeshData, currentNode;\n\t\t\tvar firstNode, addedBody;\n\t\t\tfor (i = 0; i < triangleModel.BodyCount (); i++) {\n\t\t\t\tcurrentBody = triangleModel.GetBody (i);\n\t\t\t\tcurrentMeshData = currentBody.meshData;\n\t\t\t\tif (currentMeshData.objectNodes.length === 0) {\n\t\t\t\t\tFinalizeMesh (currentBody, null, materialNameToIndex, nodeHierarcy);\n\t\t\t\t} else {\n\t\t\t\t\tfirstNode = nodeHierarcy.nodes[currentMeshData.objectNodes[0]];\n\t\t\t\t\tfor (j = 1; j < currentMeshData.objectNodes.length; j++) {\n\t\t\t\t\t\tcurrentNode = nodeHierarcy.nodes[currentMeshData.objectNodes[j]];\n\t\t\t\t\t\taddedBody = DuplicateBody (triangleModel, currentBody, i + 1, j + 1);\n\t\t\t\t\t\taddedBody.meshData = currentBody.meshData;\n\t\t\t\t\t\tFinalizeMesh (addedBody, currentNode, materialNameToIndex, nodeHierarcy);\n\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tFinalizeMesh (currentBody, firstNode, materialNameToIndex, nodeHierarcy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar currentBody = null;\n\t\t\n\t\tvar materialNameToIndex = {};\n\t\tvar bodyNameToIndex = {};\n\n\t\tvar nodeHierarcy = {\n\t\t\tnodes : [],\n\t\t\tnodeIdToIndex : {}\n\t\t};\n\t\t\n\t\tJSM.Read3dsFile (arrayBuffer, {\n\t\t\tonMaterial : function (material) {\n\t\t\t\tfunction GetOpacity (transparency)\n\t\t\t\t{\n\t\t\t\t\tif (transparency === undefined || transparency === null) {\n\t\t\t\t\t\treturn 1.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1.0 - transparency;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetShininess (shininess, shininessStrength)\n\t\t\t\t{\n\t\t\t\t\tif (shininess === undefined || shininess === null) {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tif (shininessStrength === undefined || shininessStrength === null) {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn shininess * shininessStrength;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (materialNameToIndex[material.name] !== undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar index = triangleModel.AddMaterial ({\n\t\t\t\t\tname : material.name,\n\t\t\t\t\tambient : material.ambient,\n\t\t\t\t\tdiffuse : material.diffuse,\n\t\t\t\t\tspecular : material.specular,\n\t\t\t\t\tshininess : GetShininess (material.shininess, material.shininessStrength),\n\t\t\t\t\topacity : GetOpacity (material.transparency)\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar currentMaterial = triangleModel.GetMaterial (index);\n\t\t\t\tif (material.texture !== undefined && material.texture !== null) {\n\t\t\t\t\tvar textureBuffer = OnFileRequested (material.texture);\n\t\t\t\t\tif (textureBuffer !== null) {\n\t\t\t\t\t\tvar blob = new window.Blob ([textureBuffer]);\n\t\t\t\t\t\tvar blobURL = window.URL.createObjectURL (blob);\n\t\t\t\t\t\tcurrentMaterial.texture = blobURL;\n\t\t\t\t\t\tcurrentMaterial.offset = material.offset;\n\t\t\t\t\t\tcurrentMaterial.scale = material.scale;\n\t\t\t\t\t\tcurrentMaterial.rotation = -material.rotation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaterialNameToIndex[material.name] = index;\n\t\t\t},\n\t\t\tonMesh : function (meshName) {\n\t\t\t\tif (bodyNameToIndex[meshName] !== undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody (meshName));\n\t\t\t\tcurrentBody = triangleModel.GetBody (index);\n\t\t\t\tcurrentBody.meshData ={\n\t\t\t\t\tfaceToMaterial : {},\n\t\t\t\t\tfaceToSmoothingGroup : {},\n\t\t\t\t\tobjectNodes : [],\n\t\t\t\t\ttransformation : null\n\t\t\t\t};\n\t\t\t\tbodyNameToIndex[meshName] = index;\n\t\t\t},\n\t\t\tonTransformation : function (matrix) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.transformation = matrix;\n\t\t\t},\n\t\t\tonObjectNode : function (objectNode) {\n\t\t\t\tvar nodeIndex = nodeHierarcy.nodes.length;\n\t\t\t\tnodeHierarcy.nodes.push (objectNode);\n\t\t\t\tnodeHierarcy.nodeIdToIndex[objectNode.nodeId] = nodeIndex;\n\n\t\t\t\tvar bodyIndex = bodyNameToIndex[objectNode.name];\n\t\t\t\tif (bodyIndex === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar body = triangleModel.GetBody (bodyIndex);\n\t\t\t\tbody.meshData.objectNodes.push (nodeIndex);\n\t\t\t},\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonTextureVertex : function (x, y) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddUV (x, y);\n\t\t\t},\n\t\t\tonFace : function (v0, v1, v2) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t},\n\t\t\tonFaceMaterial : function (faceIndex, materialName) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.faceToMaterial[faceIndex] = materialName;\n\t\t\t},\n\t\t\tonFaceSmoothingGroup : function (faceIndex, smoothingGroup) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.faceToSmoothingGroup[faceIndex] = smoothingGroup;\n\t\t\t},\n\t\t\tonFileRequested : OnFileRequested\n\t\t});\n\t\t\n\t\tFinalizeMeshes (nodeHierarcy, triangleModel, materialNameToIndex);\n\t\ttriangleModel.Finalize ();\n\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerobj',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadObjFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnNewMaterial (name)\n\t\t{\n\t\t\tif (callbacks.onNewMaterial !== undefined && callbacks.onNewMaterial !== null) {\n\t\t\t\tcallbacks.onNewMaterial (name);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialComponent (name, red, green, blue)\n\t\t{\n\t\t\tif (callbacks.onMaterialComponent !== undefined && callbacks.onMaterialComponent !== null) {\n\t\t\t\tcallbacks.onMaterialComponent (name, red, green, blue);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialParameter (name, value)\n\t\t{\n\t\t\tif (callbacks.onMaterialParameter !== undefined && callbacks.onMaterialParameter !== null) {\n\t\t\t\tcallbacks.onMaterialParameter (name, value);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialTexture (textureName)\n\t\t{\n\t\t\tif (callbacks.onMaterialTexture !== undefined && callbacks.onMaterialTexture !== null) {\n\t\t\t\tcallbacks.onMaterialTexture (textureName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnUseMaterial (name)\n\t\t{\n\t\t\tif (callbacks.onUseMaterial !== undefined && callbacks.onUseMaterial !== null) {\n\t\t\t\tcallbacks.onUseMaterial (name);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMesh (meshName)\n\t\t{\n\t\t\tif (callbacks.onMesh !== undefined && callbacks.onMesh !== null) {\n\t\t\t\tcallbacks.onMesh (meshName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnNormal (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onNormal !== undefined && callbacks.onNormal !== null) {\n\t\t\t\tcallbacks.onNormal (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTexCoord (x, y)\n\t\t{\n\t\t\tif (callbacks.onTexCoord !== undefined && callbacks.onTexCoord !== null) {\n\t\t\t\tcallbacks.onTexCoord (x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices, normals, uvs)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices, normals, uvs);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction ProcessLine (line, objectCounter)\n\t\t{\n\t\t\tfunction GetIndex (index, count)\n\t\t\t{\n\t\t\t\tif (index > 0) {\n\t\t\t\t\treturn index - 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn count + index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction GetFileName (line, keyword)\n\t\t\t{\n\t\t\t\tvar fileNameIndex = line.indexOf (keyword) + keyword.length;\n\t\t\t\tvar fileName = line.substr (fileNameIndex, line.length - fileNameIndex);\n\t\t\t\treturn fileName.trim ();\n\t\t\t}\n\t\t\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar i, fileName;\n\t\t\tif (lineParts[0] == 'g') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar meshName = '';\n\t\t\t\tfor (i = 1; i < lineParts.length; i++) {\n\t\t\t\t\tmeshName += lineParts[i];\n\t\t\t\t\tif (i < lineParts.length - 1) {\n\t\t\t\t\t\tmeshName += ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOnMesh (meshName);\n\t\t\t} else if (lineParts[0] == 'v') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.vertexCount += 1;\n\t\t\t\tOnVertex (parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'vn') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.normalCount += 1;\n\t\t\t\tOnNormal (parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'vt') {\n\t\t\t\tif (lineParts.length < 3) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.uvCount += 1;\n\t\t\t\tOnTexCoord (parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t} else if (lineParts[0] == 'f') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar uvs = [];\n\t\t\t\t\n\t\t\t\tvar partSplitted;\n\t\t\t\tfor (i = 1; i < lineParts.length; i++) {\n\t\t\t\t\tpartSplitted = lineParts[i].split ('/');\n\t\t\t\t\tvertices.push (GetIndex (parseInt (partSplitted[0], 10), objectCounter.vertexCount));\n\t\t\t\t\tif (partSplitted.length > 1 && partSplitted[1].length > 0) {\n\t\t\t\t\t\tuvs.push (GetIndex (parseInt (partSplitted[1], 10), objectCounter.uvCount));\n\t\t\t\t\t}\n\t\t\t\t\tif (partSplitted.length > 2 && partSplitted[2].length > 0) {\n\t\t\t\t\t\tnormals.push (GetIndex (parseInt (partSplitted[2], 10), objectCounter.normalCount));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOnFace (vertices, normals, uvs);\n\t\t\t} else if (lineParts[0] == 'usemtl') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnUseMaterial (lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'newmtl') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnNewMaterial (lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'Ka' || lineParts[0] == 'Kd' || lineParts[0] == 'Ks') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnMaterialComponent (lineParts[0], parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'Ns' || lineParts[0] == 'Tr' || lineParts[0] == 'd') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tOnMaterialParameter (lineParts[0], lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'map_Kd') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfileName = GetFileName (line, 'map_Kd');\n\t\t\t\tOnMaterialTexture (fileName);\n\t\t\t} else if (lineParts[0] == 'mtllib') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileName = GetFileName (line, 'mtllib');\n\t\t\t\tvar fileStringBuffer = OnFileRequested (fileName.trim ());\n\t\t\t\tif (fileStringBuffer === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tProcessFile (fileStringBuffer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer, objectCounter)\n\t\t{\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, objectCounter);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar objectCounter = {\n\t\t\tvertexCount : 0,\n\t\t\tnormalCount : 0,\n\t\t\tuvCount : 0\n\t\t};\n\n\t\tProcessFile (stringBuffer, objectCounter);\n\t};\n\n\tJSM.ConvertObjToJsonData = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tvar materialNameToIndex = {};\n\t\tvar currentMaterial = null;\n\t\tvar currentMaterialIndex = null;\n\t\t\n\t\tvar globalVertices = [];\n\t\tvar globalNormals = [];\n\t\tvar globalUVs = [];\n\t\t\n\t\tvar globalToLocalVertices = {};\n\t\tvar globalToLocalNormals = {};\n\t\tvar globalToLocalUVs = {};\n\t\t\n\t\tJSM.ReadObjFile (stringBuffer, {\n\t\t\tonNewMaterial : function (name) {\n\t\t\t\tvar index = triangleModel.AddMaterial ({\n\t\t\t\t\tname : name\n\t\t\t\t});\n\t\t\t\tcurrentMaterial = triangleModel.GetMaterial (index);\n\t\t\t\tmaterialNameToIndex[name] = index;\n\t\t\t},\n\t\t\tonMaterialComponent : function (name, red, green, blue) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (name == 'Ka') {\n\t\t\t\t\tcurrentMaterial.ambient = [red, green, blue];\n\t\t\t\t} else if (name == 'Kd') {\n\t\t\t\t\tcurrentMaterial.diffuse = [red, green, blue];\n\t\t\t\t} else if (name == 'Ks') {\n\t\t\t\t\tcurrentMaterial.specular = [red, green, blue];\n\t\t\t\t}\n\t\t\t},\n\t\t\tonMaterialParameter : function (name, value) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (name == 'Ns') {\n\t\t\t\t\tcurrentMaterial.shininess = 0.0;\n\t\t\t\t\tif (JSM.IsPositive (value)) {\n\t\t\t\t\t\tcurrentMaterial.shininess = (Math.log2 (parseFloat (value)) - 1) / 10.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (name == 'Tr') {\n\t\t\t\t\tcurrentMaterial.opacity = 1.0 - parseFloat (value);\n\t\t\t\t} else if (name == 'd') {\n\t\t\t\t\tcurrentMaterial.opacity = parseFloat (value);\n\t\t\t\t}\t\t\t\n\t\t\t},\n\t\t\tonMaterialTexture : function (textureName) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar textureBuffer = OnFileRequested (textureName);\n\t\t\t\tif (textureBuffer === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar blob = new window.Blob ([textureBuffer]);\n\t\t\t\tvar blobURL = window.URL.createObjectURL (blob);\n\t\t\t\tcurrentMaterial.texture = blobURL;\n\t\t\t},\n\t\t\tonUseMaterial : function (name) {\n\t\t\t\tvar materialIndex = materialNameToIndex[name];\n\t\t\t\tif (materialIndex !== undefined) {\n\t\t\t\t\tcurrentMaterialIndex = materialIndex;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonMesh : function (meshName) {\n\t\t\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody (meshName));\n\t\t\t\tcurrentBody = triangleModel.GetBody (index);\n\t\t\t\tglobalToLocalVertices = {};\n\t\t\t\tglobalToLocalNormals = {};\n\t\t\t\tglobalToLocalUVs = {};\n\t\t\t},\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tglobalVertices.push (new JSM.Coord (x, y, z));\n\t\t\t},\n\t\t\tonNormal : function (x, y, z) {\n\t\t\t\tglobalNormals.push (new JSM.Coord (x, y, z));\n\t\t\t},\n\t\t\tonTexCoord : function (x, y) {\n\t\t\t\tglobalUVs.push (new JSM.Coord2D (x, y));\n\t\t\t},\n\t\t\tonFace : function (vertices, normals, uvs) {\n\t\t\t\tfunction GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, valueAdderFunc)\n\t\t\t\t{\n\t\t\t\t\tif (globalIndex < 0 || globalIndex >= globalValueArray.length) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\tvar result = globalToLocalIndices[globalIndex];\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tvar globalValue = globalValueArray[globalIndex];\n\t\t\t\t\t\tresult = valueAdderFunc (globalValue);\n\t\t\t\t\t\tglobalToLocalIndices[globalIndex] = result;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalVertexIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddVertex (val.x, val.y, val.z);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalNormalIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddNormal (val.x, val.y, val.z);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalUVIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddUV (val.x, val.y);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar i, v0, v1, v2, triangle, triangleIndex;\n\t\t\t\tvar hasNormals = (normals.length == vertices.length);\n\t\t\t\tvar hasUVs = (uvs.length == vertices.length);\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[0]);\n\t\t\t\t\tv1 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[(i + 1) % count]);\n\t\t\t\t\tv2 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[(i + 2) % count]);\n\t\t\t\t\ttriangleIndex = currentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t\ttriangle = currentBody.GetTriangle (triangleIndex);\n\t\t\t\t\tif (hasNormals) {\n\t\t\t\t\t\ttriangle.n0 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[0]);\n\t\t\t\t\t\ttriangle.n1 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[(i + 1) % count]);\n\t\t\t\t\t\ttriangle.n2 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[(i + 2) % count]);\n\t\t\t\t\t}\n\t\t\t\t\tif (hasUVs) {\n\t\t\t\t\t\ttriangle.u0 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[0]);\n\t\t\t\t\t\ttriangle.u1 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[(i + 1) % count]);\n\t\t\t\t\t\ttriangle.u2 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[(i + 2) % count]);\n\t\t\t\t\t}\n\t\t\t\t\tif (currentMaterialIndex !== null) {\n\t\t\t\t\t\ttriangle.mat = currentMaterialIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonFileRequested : OnFileRequested\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerstl',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadBinaryStlFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tvar i, v0, v1, v2, normal;\n\t\tfor (i = 0; i < triangleCount; i++) {\n\t\t\tnormal = ReadVector (reader);\n\t\t\tv0 = ReadVector (reader);\n\t\t\tv1 = ReadVector (reader);\n\t\t\tv2 = ReadVector (reader);\n\t\t\treader.Skip (2);\n\t\t\tOnFace (v0, v1, v2, normal);\n\t\t}\n\t};\n\n\tJSM.ReadAsciiStlFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (lines, lineIndex)\n\t\t{\n\t\t\tfunction GetLine (lines, lineIndex)\n\t\t\t{\n\t\t\t\treturn lines[lineIndex].trim ();\n\t\t\t}\n\t\t\n\t\t\tfunction GetVertices (lines, lineIndex, vertices)\n\t\t\t{\n\t\t\t\tvar currentLineIndex, currentLine, lineParts, vertex;\n\t\t\t\tfor (currentLineIndex = lineIndex; currentLineIndex < lines.length && vertices.length < 3; currentLineIndex++) {\n\t\t\t\t\tcurrentLine = GetLine (lines, currentLineIndex);\n\t\t\t\t\tif (currentLine.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlineParts = currentLine.split (/\\s+/);\n\t\t\t\t\tif (lineParts.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (lineParts[0] == 'vertex') {\n\t\t\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvertex = [parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3])];\n\t\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn currentLineIndex + 1;\n\t\t\t}\n\t\t\n\t\t\tvar line = GetLine (lines, lineIndex);\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\n\t\t\tif (lineParts[0] == 'solid') {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t} else if (lineParts[0] == 'facet' && lineParts[1] == 'normal') {\n\t\t\t\tif (lineParts.length < 5) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar normal = [parseFloat (lineParts[2]), parseFloat (lineParts[3]), parseFloat (lineParts[4])];\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar nextLineIndex = GetVertices (lines, lineIndex + 1, vertices);\n\t\t\t\tif (vertices.length != 3) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnFace (vertices[0], vertices[1], vertices[2], normal);\n\t\t\t\treturn nextLineIndex;\n\t\t\t}\n\n\t\t\treturn lineIndex + 1;\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar lineIndex = 0;\n\t\tvar lines = stringBuffer.split ('\\n');\n\t\twhile (lineIndex < lines.length && lineIndex != -1) {\n\t\t\tlineIndex = ProcessLine (lines, lineIndex);\n\t\t}\n\t};\n\n\tJSM.IsBinaryStlFile = function (arrayBuffer)\n\t{\n\t\tvar byteLength = arrayBuffer.byteLength;\n\t\tif (byteLength < 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tif (byteLength != triangleCount * 50 + 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.ConvertStlToJsonData = function (arrayBuffer, stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\n\t\tif (arrayBuffer !== null) {\n\t\t\tJSM.ReadBinaryStlFile (arrayBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (stringBuffer !== null) {\n\t\t\tJSM.ReadAsciiStlFile (stringBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importeroff',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadOffFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (line, readState)\n\t\t{\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!readState.offHeaderFound) {\n\t\t\t\tif (lineParts.length == 1 && lineParts[0] == 'OFF') {\n\t\t\t\t\treadState.offHeaderFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (!readState.infoFound) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\treadState.vertexCount = parseInt (lineParts[0]);\n\t\t\t\t\treadState.faceCount = parseInt (lineParts[1]);\n\t\t\t\t\treadState.infoFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readVertices < readState.vertexCount) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\tOnVertex (parseFloat (lineParts[0]), parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t\t\treadState.readVertices += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readFaces < readState.faceCount) {\n\t\t\t\tvar vertexCount = parseInt (lineParts[0]);\n\t\t\t\tif (lineParts.length >= vertexCount + 1) {\n\t\t\t\t\tvar vertices = [];\n\t\t\t\t\tvar i, vertex;\n\t\t\t\t\tfor (i = 1; i < vertexCount + 1; i++) {\n\t\t\t\t\t\tvertex = parseInt (lineParts[i]);\n\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t}\n\t\t\t\t\tOnFace (vertices);\n\t\t\t\t\treadState.readFaces += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer)\n\t\t{\n\t\t\tvar readState = {\n\t\t\t\toffHeaderFound : false,\n\t\t\t\tinfoFound : false,\n\t\t\t\tvertexCount : 0,\n\t\t\t\tfaceCount : 0,\n\t\t\t\treadVertices : 0,\n\t\t\t\treadFaces : 0\n\t\t\t};\n\t\t\t\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, readState);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tProcessFile (stringBuffer);\n\t};\n\n\tJSM.ConvertOffToJsonData = function (stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tJSM.ReadOffFile (stringBuffer, {\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonFace : function (vertices) {\n\t\t\t\tvar i, v0, v1, v2;\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = vertices[0];\n\t\t\t\t\tv1 = vertices[i + 1];\n\t\t\t\t\tv2 = vertices[i + 2];\n\t\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importercommon',[\"../core/jsm\"],function(JSM){\n\tJSM.ImportFileList = function ()\n\t{\n\t\tthis.descriptors = null;\n\t\tthis.isFile = null;\n\t};\n\n\tJSM.ImportFileList.prototype.InitFromFiles = function (fileList)\n\t{\n\t\tthis.descriptors = [];\n\t\tvar i, file, descriptor;\n\t\tfor (i = 0; i < fileList.length; i++) {\n\t\t\tfile = fileList[i];\n\t\t\tdescriptor = {\n\t\t\t\toriginalObject : file,\n\t\t\t\toriginalFileName : file.name,\n\t\t\t\tfileName : file.name.toUpperCase (),\n\t\t\t\textension : this.GetFileExtension (file.name).toUpperCase ()\n\t\t\t};\n\t\t\tthis.descriptors.push (descriptor);\n\t\t}\n\t\tthis.isFile = true;\n\t};\n\n\tJSM.ImportFileList.prototype.InitFromURLs = function (urlList)\n\t{\n\t\tthis.descriptors = [];\n\t\tvar i, url, fileName, descriptor;\n\t\tfor (i = 0; i < urlList.length; i++) {\n\t\t\turl = urlList[i];\n\t\t\tfileName = this.GetFileName (url);\n\t\t\tdescriptor = {\n\t\t\t\toriginalObject : url,\n\t\t\t\toriginalFileName : fileName,\n\t\t\t\tfileName : fileName.toUpperCase (),\n\t\t\t\textension : this.GetFileExtension (fileName).toUpperCase ()\n\t\t\t};\n\t\t\tthis.descriptors.push (descriptor);\n\t\t}\n\t\tthis.isFile = false;\n\t};\n\n\tJSM.ImportFileList.prototype.GetInputList = function ()\n\t{\n\t\tfunction IsArrayBuffer (descriptor)\n\t\t{\n\t\t\tif (descriptor.extension == '.OBJ' || descriptor.extension == '.MTL' || descriptor.extension == '.OFF') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tvar result = [];\n\t\tvar i, descriptor, inputListElem;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tinputListElem = {\n\t\t\t\toriginalObject : descriptor.originalObject,\n\t\t\t\tisFile : this.isFile,\n\t\t\t\tisArrayBuffer : IsArrayBuffer (descriptor)\n\t\t\t};\n\t\t\tresult.push (inputListElem);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileName = function (fullFileName)\n\t{\n\t\tvar splitted = fullFileName.split ('/');\n\t\tif (splitted.length == 1) {\n\t\t\tsplitted = fullFileName.split ('\\\\');\n\t\t}\n\t\tif (splitted.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tvar fileName = splitted[splitted.length - 1];\n\t\treturn decodeURI (fileName);\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileDescriptor = function (index)\n\t{\n\t\treturn this.descriptors[index];\n\t};\n\n\tJSM.ImportFileList.prototype.GetMainFileIndex = function ()\n\t{\n\t\tvar i, descriptor;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tif (this.IsSupportedExtension (descriptor.extension)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileIndexByName = function (fileName)\n\t{\n\t\tvar i, descriptor, currentFileName;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tcurrentFileName = this.GetFileName (fileName);\n\t\t\tif (descriptor.fileName == currentFileName.toUpperCase ()) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tJSM.ImportFileList.prototype.IsSupportedExtension = function (extension)\n\t{\n\t\tif (extension == '.3DS' || extension == '.OBJ' || extension == '.STL' || extension == '.OFF') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileExtension = function (fileName)\n\t{\n\t\tvar lastPoint = fileName.lastIndexOf ('.');\n\t\tif (lastPoint == -1) {\n\t\t\treturn '';\n\t\t}\n\t\tvar extension = fileName.substr (lastPoint);\n\t\treturn extension;\n\t};\n\n\tJSM.ConvertImportFileListToJsonData = function (importFileList, callbacks)\n\t{\n\t\tfunction OnError ()\n\t\t{\n\t\t\tif (callbacks.onError !== undefined && callbacks.onError !== null) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t}\n\n\t\tfunction OnReady (fileNames, jsonData)\n\t\t{\n\t\t\tif (callbacks.onReady !== undefined && callbacks.onReady !== null) {\n\t\t\t\tcallbacks.onReady (fileNames, jsonData);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction FileRequested (importFileList, resultBuffers, fileName, fileNames)\n\t\t{\n\t\t\tvar requestedFileIndex = importFileList.GetFileIndexByName (fileName);\n\t\t\tvar currentFileName = importFileList.GetFileName (fileName);\n\t\t\tif (requestedFileIndex == -1) {\n\t\t\t\tfileNames.missing.push (currentFileName);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (fileNames.requested.indexOf (currentFileName) == -1) {\n\t\t\t\tfileNames.requested.push (currentFileName);\n\t\t\t}\n\t\t\treturn resultBuffers[requestedFileIndex];\t\n\t\t}\n\t\t\n\t\tvar mainFileIndex = importFileList.GetMainFileIndex ();\n\t\tif (mainFileIndex === -1) {\n\t\t\tOnError ();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar mainFile = importFileList.GetFileDescriptor (mainFileIndex);\n\t\tvar fileNames = {\n\t\t\tmain : mainFile.originalFileName,\n\t\t\trequested : [],\n\t\t\tmissing : []\n\t\t};\n\n\t\tvar inputList = importFileList.GetInputList ();\n\t\ttry {\n\t\t\tif (mainFile.extension == '.3DS') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.Convert3dsToJsonData (mainFileBuffer, {\n\t\t\t\t\t\t\tonFileRequested : function (fileName) {\n\t\t\t\t\t\t\t\treturn FileRequested (importFileList, resultBuffers, fileName, fileNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.OBJ') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.ConvertObjToJsonData (mainFileBuffer, {\n\t\t\t\t\t\t\tonFileRequested : function (fileName) {\n\t\t\t\t\t\t\t\treturn FileRequested (importFileList, resultBuffers, fileName, fileNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.STL') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (JSM.IsBinaryStlFile (mainFileBuffer)) {\n\t\t\t\t\t\t\tvar jsonData = JSM.ConvertStlToJsonData (mainFileBuffer, null);\n\t\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\tfor (i = 0; i < inputList.length; i++) {\n\t\t\t\t\t\t\t\tinputList[i].isArrayBuffer = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\t\t\t\tOnError ();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar jsonData = JSM.ConvertStlToJsonData (null, mainFileBuffer);\n\t\t\t\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.OFF') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.ConvertOffToJsonData (mainFileBuffer);\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (exception) {\n\t\t\tOnError ();\n\t\t\treturn;\n\t\t}\n\t};\n\n\tJSM.ConvertFileListToJsonData = function (fileList, callbacks)\n\t{\n\t\tvar importFileList = new JSM.ImportFileList ();\n\t\timportFileList.InitFromFiles (fileList);\n\t\tJSM.ConvertImportFileListToJsonData (importFileList, callbacks);\n\t};\n\n\tJSM.ConvertURLListToJsonData = function (urlList, callbacks)\n\t{\n\t\tvar importFileList = new JSM.ImportFileList ();\n\t\timportFileList.InitFromURLs (urlList);\n\t\tJSM.ConvertImportFileListToJsonData (importFileList, callbacks);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/webglutils',[\"../core/jsm\"],function(JSM){\n\tJSM.IsPowerOfTwo = function (x)\n\t{\n\t\treturn (x & (x - 1) === 0);\n\t};\n\n\tJSM.NextPowerOfTwo = function (x)\n\t{\n\t\tif (JSM.IsPowerOfTwo (x)) {\n\t\t\treturn x;\n\t\t}\n\n\t\tvar result = 1;\n\t\twhile (result < x) {\n\t\t\tresult *= 2;\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.ResizeImageToPowerOfTwoSides = function (image)\n\t{\n\t\tif (JSM.IsPowerOfTwo (image.width) && !JSM.IsPowerOfTwo (image.height)) {\n\t\t\treturn image;\n\t\t}\n\t\t\n\t\tvar width = JSM.NextPowerOfTwo (image.width);\n\t\tvar height = JSM.NextPowerOfTwo (image.height);\n\n\t\tvar canvas = document.createElement ('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\t\n\t\tvar context = canvas.getContext ('2d');\n\t\tcontext.drawImage (image, 0, 0, width, height);\n\t\treturn context.getImageData (0, 0, width, height);\n\t};\n\n\tJSM.WebGLInitContext = function (canvas)\n\t{\n\t\tif (canvas === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (canvas.getContext === undefined) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar context = canvas.getContext ('webgl') || canvas.getContext ('experimental-webgl');\n\t\tif (context === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tcontext.viewport (0, 0, canvas.width, canvas.height);\n\t\tcontext.clearColor (1.0, 1.0, 1.0, 1.0);\n\t\treturn context;\n\t};\n\n\tJSM.WebGLInitShaderProgram = function (context, vertexShader, fragmentShader, onError)\n\t{\n\t\tfunction CompileShader (context, script, type, onError)\n\t\t{\n\t\t\tvar shader = context.createShader (type);\n\t\t\tcontext.shaderSource (shader, script);\n\t\t\tcontext.compileShader (shader);\n\t\t\tif (!context.getShaderParameter (shader, context.COMPILE_STATUS)) {\n\t\t\t\tif (onError !== undefined && onError !== null) {\n\t\t\t\t\tonError (context.getShaderInfoLog (shader));\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn shader;\n\t\t}\n\t\t\n\t\tfunction CreateShader (context, fragmentShaderScript, vertexShaderScript, onError)\n\t\t{\n\t\t\tvar fragmentShader = CompileShader (context, fragmentShaderScript, context.FRAGMENT_SHADER, onError);\n\t\t\tvar vertexShader = CompileShader (context, vertexShaderScript, context.VERTEX_SHADER, onError);\n\t\t\tif (fragmentShader === null || vertexShader === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar shaderProgram = context.createProgram ();\n\t\t\tcontext.attachShader (shaderProgram, vertexShader);\n\t\t\tcontext.attachShader (shaderProgram, fragmentShader);\n\t\t\tcontext.linkProgram (shaderProgram);\n\t\t\tif (!context.getProgramParameter (shaderProgram, context.LINK_STATUS)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn shaderProgram;\n\t\t}\n\t\t\n\t\tvar shader = CreateShader (context, fragmentShader, vertexShader, onError);\n\t\tif (shader === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tcontext.useProgram (shader);\n\t\treturn shader;\n\t};\n\n\tJSM.WebGLGetFloatTextureBufferSize = function (array)\n\t{\n\t\treturn JSM.NextPowerOfTwo (Math.ceil (Math.sqrt (array.length / 4.0)));\n\t};\n\n\tJSM.WebGLCreateFloatTextureBuffer = function (context, array, size)\n\t{\n\t\tvar floatArray = null;\n\t\tif (array !== null) {\n\t\t\twhile (array.length < size * size * 4) {\n\t\t\t\tarray.push (0.0);\n\t\t\t}\n\t\t\tfloatArray = new Float32Array (array);\n\t\t}\n\t\tvar textureBuffer = context.createTexture ();\n\t\tcontext.bindTexture (context.TEXTURE_2D, textureBuffer);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\n\t\tcontext.texImage2D (context.TEXTURE_2D, 0, context.RGBA, size, size, 0, context.RGBA, context.FLOAT, floatArray);\n\t\tcontext.bindTexture (context.TEXTURE_2D, null);\n\t\treturn textureBuffer;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderlight',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderAmbientLight = function (color)\n\t{\n\t\tthis.color = JSM.HexColorToNormalizedRGBComponents (color);\n\t};\n\n\tJSM.RenderDirectionalLight = function (diffuse, specular, direction)\n\t{\n\t\tthis.diffuse = JSM.HexColorToNormalizedRGBComponents (diffuse);\n\t\tthis.specular = JSM.HexColorToNormalizedRGBComponents (specular);\n\t\tthis.direction = direction.Clone ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/rendermaterial',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderMaterialFlags = {\n\t\tPoint : 1,\n\t\tLine : 2,\n\t\tTriangle : 4,\n\t\tTextured : 8,\n\t\tTransparent : 16\n\t};\n\n\tJSM.RenderMaterial = function (type, parameters)\n\t{\n\t\tthis.type = type;\n\t\tthis.ambient = [0.0, 0.8, 0.0];\n\t\tthis.diffuse = [0.0, 0.8, 0.0];\n\t\tthis.specular = [0.0, 0.0, 0.0];\n\t\tthis.shininess = 0.0;\n\t\tthis.opacity = 1.0;\n\t\tthis.reflection = 0.0;\n\t\tthis.singleSided = false;\n\t\tthis.pointSize = 0.1;\n\t\tthis.texture = null;\n\t\tJSM.CopyObjectProperties (parameters, this, true);\n\t};\n\n\tJSM.RenderMaterial.prototype.SetType = function (type)\n\t{\n\t\tthis.type = type;\n\t};\n\n\tJSM.RenderMaterial.prototype.SetBuffers = function (textureBuffer, textureImage)\n\t{\n\t\tthis.textureBuffer = textureBuffer;\n\t\tthis.textureImage = textureImage;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/rendermesh',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderMesh = function (material)\n\t{\n\t\tthis.material = material;\n\t\t\n\t\tthis.vertexArray = null;\n\t\tthis.normalArray = null;\n\t\tthis.uvArray = null;\n\t\t\n\t\tthis.vertexBuffer = null;\n\t\tthis.normalBuffer = null;\n\t\tthis.uvBuffer = null;\n\t};\n\n\tJSM.RenderMesh.prototype.SetMaterial = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\tJSM.RenderMesh.prototype.GetMaterial = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\tJSM.RenderMesh.prototype.SetVertexArray = function (vertices)\n\t{\n\t\tthis.vertexArray = new Float32Array (vertices);\n\t};\n\n\tJSM.RenderMesh.prototype.SetNormalArray = function (normals)\n\t{\n\t\tthis.normalArray = new Float32Array (normals);\n\t};\n\n\tJSM.RenderMesh.prototype.SetUVArray = function (uvs)\n\t{\n\t\tthis.uvArray = new Float32Array (uvs);\n\t};\n\n\tJSM.RenderMesh.prototype.HasVertexArray = function ()\n\t{\n\t\treturn this.vertexArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.HasNormalArray = function ()\n\t{\n\t\treturn this.normalArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.HasUVArray = function ()\n\t{\n\t\treturn this.uvArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertexArray = function ()\n\t{\n\t\treturn this.vertexArray;\n\t};\n\n\tJSM.RenderMesh.prototype.GetNormalArray = function ()\n\t{\n\t\treturn this.normalArray;\n\t};\n\n\tJSM.RenderMesh.prototype.GetUVArray = function ()\n\t{\n\t\treturn this.uvArray;\n\t};\n\n\tJSM.RenderMesh.prototype.SetBuffers = function (vertexBuffer, normalBuffer, uvBuffer)\n\t{\n\t\tthis.vertexBuffer = vertexBuffer;\n\t\tthis.normalBuffer = normalBuffer;\n\t\tthis.uvBuffer = uvBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertexBuffer = function ()\n\t{\n\t\treturn this.vertexBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetNormalBuffer = function ()\n\t{\n\t\treturn this.normalBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetUVBuffer = function ()\n\t{\n\t\treturn this.uvBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.VertexCount = function ()\n\t{\n\t\treturn parseInt (this.vertexArray.length / 3, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.NormalCount = function ()\n\t{\n\t\treturn parseInt (this.normalArray.length / 3, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.UVCount = function ()\n\t{\n\t\treturn parseInt (this.uvArray.length / 2, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertex = function (index)\n\t{\n\t\treturn new JSM.Coord (this.vertexArray[3 * index], this.vertexArray[3 * index + 1], this.vertexArray[3 * index + 2]);\n\t};\n\n\tJSM.RenderMesh.prototype.GetTransformedVertex = function (index, transformation)\n\t{\n\t\tvar vertex = this.GetVertex (index);\n\t\treturn transformation.Apply (vertex);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderbody',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderBody = function ()\n\t{\n\t\tthis.transformation = new JSM.Transformation ();\n\t\tthis.meshes = {};\n\t};\n\n\tJSM.RenderBody.prototype.AddMesh = function (mesh)\n\t{\n\t\tif (this.meshes[mesh.material.type] === undefined) {\n\t\t\tthis.meshes[mesh.material.type] = [];\n\t\t}\n\t\tthis.meshes[mesh.material.type].push (mesh);\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateMeshes = function (onMeshFound)\n\t{\n\t\tvar meshType;\n\t\tfor (meshType in this.meshes) {\n\t\t\tif (this.meshes.hasOwnProperty (meshType)) {\n\t\t\t\tthis.EnumerateTypedMeshes (meshType, onMeshFound);\n\t\t\t}\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.HasTypedMeshes = function (meshType)\n\t{\n\t\treturn this.meshes[meshType] !== undefined;\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateTypedMeshes = function (meshType, onMeshFound)\n\t{\n\t\tif (!this.HasTypedMeshes (meshType)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar typedMeshes = this.meshes[meshType];\n\t\tvar\ti, typedMesh;\n\t\tfor\t(i = 0; i < typedMeshes.length; i++) {\n\t\t\ttypedMesh = typedMeshes[i];\n\t\t\tonMeshFound (typedMesh);\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateMeshesWithFlag = function (flag, onMeshFound)\n\t{\n\t\tvar meshType;\n\t\tfor (meshType in this.meshes) {\n\t\t\tif (this.meshes.hasOwnProperty (meshType) && (meshType & flag)) {\n\t\t\t\tthis.EnumerateTypedMeshes (meshType, onMeshFound);\n\t\t\t}\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.GetTransformation = function ()\n\t{\n\t\treturn this.transformation;\n\t};\n\n\tJSM.RenderBody.prototype.GetTransformationMatrix = function ()\n\t{\n\t\treturn this.transformation.matrix;\n\t};\n\n\tJSM.RenderBody.prototype.SetTransformation = function (transformation)\n\t{\n\t\tthis.transformation = transformation;\n\t};\n\n\tJSM.RenderBody.prototype.AppendTransformation = function (transformation)\n\t{\n\t\tthis.transformation.Append (transformation);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/shaderprogram',[\"../core/jsm\"],function(JSM){\n\tJSM.ShaderType = {\n\t\tPoint : 0,\n\t\tLine : 1,\n\t\tTriangle : 2,\n\t\tTexturedTriangle : 3\n\t};\n\n\tJSM.ShaderProgram = function (context)\n\t{\n\t\tthis.context = context;\n\t\tthis.globalParams = null;\n\t\tthis.shaders = null;\n\t\tthis.currentShader = null;\n\t\tthis.currentType = null;\n\t\tthis.cullEnabled = null;\n\t};\n\n\tJSM.ShaderProgram.prototype.Init = function ()\n\t{\n\t\tif (!this.InitGlobalParams ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\t\n\t};\n\n\tJSM.ShaderProgram.prototype.GetMaxLightCount = function ()\n\t{\n\t\treturn this.globalParams.maxLightCount;\n\t};\n\n\tJSM.ShaderProgram.prototype.InitGlobalParams = function ()\n\t{\n\t\tvar noDirectionalLight = new JSM.RenderDirectionalLight (0x000000, 0x000000, new JSM.Vector (0.0, 0.0, 0.0));\n\t\tthis.globalParams = {\n\t\t\tnoDirectionalLight : noDirectionalLight,\n\t\t\tmaxLightCount : 4\n\t\t};\n\t\treturn true;\n\t};\n\n\tJSM.ShaderProgram.prototype.InitShaders = function ()\n\t{\n\t\tfunction GetFragmentShaderScript (shaderType, globalParams)\n\t\t{\n\t\t\tvar script = null;\n\t\t\tif (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define MAX_LIGHTS ' + globalParams.maxLightCount,\n\n\t\t\t\t\t'struct Light',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'};',\n\n\t\t\t\t\t'struct Material',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 ambientColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'};',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump vec3 uAmbientLightColor;',\n\t\t\t\t\t'uniform Light uLights[MAX_LIGHTS];',\n\t\t\t\t\t'uniform Material uMaterial;',\n\t\t\t\t\t\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmediump vec3 ambientComponent = uMaterial.ambientColor * uAmbientLightColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tfor (int i = 0; i < MAX_LIGHTS; i++) {',\n\t\t\t\t\t'\t\tdiffuseComponent += uMaterial.diffuseColor * uLights[i].diffuseColor;',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t'\tgl_FragColor = vec4 (ambientComponent + diffuseComponent, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t} else if (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Triangle ? 'NOTEXTURE' : 'USETEXTURE'),\n\t\t\t\t\t'#define MAX_LIGHTS ' + globalParams.maxLightCount,\n\t\t\t\t\t\n\t\t\t\t\t'struct Light',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'\tmediump vec3 specularColor;',\n\t\t\t\t\t'\tmediump vec3 direction;',\n\t\t\t\t\t'};',\n\n\t\t\t\t\t'struct Material',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 ambientColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'\tmediump vec3 specularColor;',\n\t\t\t\t\t'\tmediump float shininess;',\n\t\t\t\t\t'\tmediump float opacity;',\n\t\t\t\t\t'};',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump vec3 uAmbientLightColor;',\n\t\t\t\t\t'uniform Light uLights[MAX_LIGHTS];',\n\t\t\t\t\t'uniform Material uMaterial;',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\t\t\t\t\t'varying mediump vec3 vNormal;',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'varying mediump vec2 vUV;',\n\t\t\t\t\t'uniform sampler2D uSampler;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmediump vec3 N = normalize (vNormal);',\n\t\t\t\t\t'\tif (!gl_FrontFacing) {',\n\t\t\t\t\t'\t\tN = -N;',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t'\tmediump vec3 ambientComponent = uMaterial.ambientColor * uAmbientLightColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tmediump vec3 specularComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tmediump vec3 E = normalize (-vVertex);',\n\n\t\t\t\t\t'\tfor (int i = 0; i < MAX_LIGHTS; i++) {',\n\t\t\t\t\t'\t\tmediump vec3 L = normalize (-uLights[i].direction);',\n\t\t\t\t\t'\t\tmediump vec3 R = normalize (-reflect (L, N));',\n\t\t\t\t\t'\t\tdiffuseComponent += uMaterial.diffuseColor * uLights[i].diffuseColor * max (dot (N, L), 0.0);',\n\t\t\t\t\t'\t\tspecularComponent += uMaterial.specularColor * uLights[i].specularColor * pow (max (dot (R, E), 0.0), uMaterial.shininess);',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'\tmediump vec3 textureColor = texture2D (uSampler, vec2 (vUV.s, vUV.t)).xyz;',\n\t\t\t\t\t'\tambientComponent = ambientComponent * textureColor;',\n\t\t\t\t\t'\tdiffuseComponent = diffuseComponent * textureColor;',\n\t\t\t\t\t'\tspecularComponent = specularComponent * textureColor;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t\n\t\t\t\t\t'\tambientComponent = clamp (ambientComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tdiffuseComponent = clamp (diffuseComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tspecularComponent = clamp (specularComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tgl_FragColor = vec4 (ambientComponent + diffuseComponent + specularComponent, uMaterial.opacity);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n\t\t\n\t\tfunction GetVertexShaderScript (shaderType)\n\t\t{\n\t\t\tvar script = null;\n\t\t\tif (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Triangle ? 'NOTEXTURE' : 'USETEXTURE'),\n\t\t\t\t\t'attribute mediump vec3 aVertexPosition;',\n\t\t\t\t\t'attribute mediump vec3 aVertexNormal;',\n\n\t\t\t\t\t'uniform mediump mat4 uViewMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uProjectionMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uTransformationMatrix;',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\t\t\t\t\t'varying mediump vec3 vNormal;',\n\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'attribute mediump vec2 aVertexUV;',\n\t\t\t\t\t'varying mediump vec2 vUV;',\n\t\t\t\t\t'#endif',\n\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmat4 modelViewMatrix = uViewMatrix * uTransformationMatrix;',\n\t\t\t\t\t'\tvVertex = vec3 (modelViewMatrix * vec4 (aVertexPosition, 1.0));',\n\t\t\t\t\t'\tvNormal = normalize (vec3 (modelViewMatrix * vec4 (aVertexNormal, 0.0)));',\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'\tvUV = aVertexUV;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t} else if (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Point ? 'POINT' : 'LINE'),\n\t\t\t\t\t'attribute mediump vec3 aVertexPosition;',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump mat4 uViewMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uProjectionMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uTransformationMatrix;',\n\t\t\t\t\t'#ifdef POINT',\n\t\t\t\t\t'uniform mediump float uPointSize;',\n\t\t\t\t\t'#endif',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmat4 modelViewMatrix = uViewMatrix * uTransformationMatrix;',\n\t\t\t\t\t'\tvVertex = vec3 (modelViewMatrix * vec4 (aVertexPosition, 1.0));',\n\t\t\t\t\t'#ifdef POINT',\n\t\t\t\t\t'\tconst mediump float scale = 200.0;',\n\t\t\t\t\t'\tgl_PointSize = uPointSize * (scale / length (vVertex));',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n\n\t\tfunction InitShaderParameters (context, shader, globalParams, shaderType)\n\t\t{\n\t\t\tif (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tshader.vertexPositionAttribute = context.getAttribLocation (shader, 'aVertexPosition');\n\t\t\t\tshader.vertexNormalAttribute = context.getAttribLocation (shader, 'aVertexNormal');\n\n\t\t\t\tshader.ambientLightColorUniform = context.getUniformLocation (shader, 'uAmbientLightColor');\n\t\t\t\tshader.lightUniforms = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < globalParams.maxLightCount; i++) {\n\t\t\t\t\tshader.lightUniforms.push ({\n\t\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uLights[' + i + '].diffuseColor'),\n\t\t\t\t\t\tspecularColor : context.getUniformLocation (shader, 'uLights[' + i + '].specularColor'),\n\t\t\t\t\t\tdirection : context.getUniformLocation (shader, 'uLights[' + i + '].direction')\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tshader.materialUniforms = {\n\t\t\t\t\tambientColor : context.getUniformLocation (shader, 'uMaterial.ambientColor'),\n\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uMaterial.diffuseColor'),\n\t\t\t\t\tspecularColor : context.getUniformLocation (shader, 'uMaterial.specularColor'),\n\t\t\t\t\tshininess : context.getUniformLocation (shader, 'uMaterial.shininess'),\n\t\t\t\t\topacity : context.getUniformLocation (shader, 'uMaterial.opacity')\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tshader.vMatrixUniform = context.getUniformLocation (shader, 'uViewMatrix');\n\t\t\t\tshader.pMatrixUniform = context.getUniformLocation (shader, 'uProjectionMatrix');\n\t\t\t\tshader.tMatrixUniform = context.getUniformLocation (shader, 'uTransformationMatrix');\n\n\t\t\t\tif (shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\t\tshader.vertexUVAttribute = context.getAttribLocation (shader, 'aVertexUV');\n\t\t\t\t\tshader.samplerUniform = context.getUniformLocation (shader, 'uSampler');\n\t\t\t\t}\n\t\t\t} else if (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tshader.vertexPositionAttribute = context.getAttribLocation (shader, 'aVertexPosition');\n\n\t\t\t\tshader.ambientLightColorUniform = context.getUniformLocation (shader, 'uAmbientLightColor');\n\t\t\t\tshader.lightUniforms = [];\n\t\t\t\tfor (i = 0; i < globalParams.maxLightCount; i++) {\n\t\t\t\t\tshader.lightUniforms.push ({\n\t\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uLights[' + i + '].diffuseColor')\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tshader.materialUniforms = {\n\t\t\t\t\tambientColor : context.getUniformLocation (shader, 'uMaterial.ambientColor'),\n\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uMaterial.diffuseColor'),\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tshader.vMatrixUniform = context.getUniformLocation (shader, 'uViewMatrix');\n\t\t\t\tshader.pMatrixUniform = context.getUniformLocation (shader, 'uProjectionMatrix');\n\t\t\t\tshader.tMatrixUniform = context.getUniformLocation (shader, 'uTransformationMatrix');\n\n\t\t\t\tif (shaderType == JSM.ShaderType.Point) {\n\t\t\t\t\tshader.pointSizeUniform = context.getUniformLocation (shader, 'uPointSize');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction InitShader (context, shaders, globalParams, shaderType)\n\t\t{\n\t\t\tvar vertexShaderScript = GetVertexShaderScript (shaderType);\n\t\t\tvar fragmentShaderScript = GetFragmentShaderScript (shaderType, globalParams);\n\t\t\tif (vertexShaderScript === null || fragmentShaderScript === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar shader = JSM.WebGLInitShaderProgram (context, vertexShaderScript, fragmentShaderScript, function (message) {\n\t\t\t\tJSM.Message (message);\n\t\t\t});\n\t\t\tif (shader === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tcontext.useProgram (shader);\n\t\t\tInitShaderParameters (context, shader, globalParams, shaderType);\n\t\t\tshaders[shaderType] = shader;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tthis.shaders = {};\n\t\t\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Point)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Line)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Triangle)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.TexturedTriangle)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context.enable (this.context.DEPTH_TEST);\n\t\tthis.context.depthFunc (this.context.LEQUAL);\n\t\t\n\t\tthis.context.enable (this.context.BLEND);\n\t\tthis.context.blendEquation (this.context.FUNC_ADD);\n\t\tthis.context.blendFunc (this.context.SRC_ALPHA, this.context.ONE_MINUS_SRC_ALPHA);\n\n\t\tthis.context.disable (this.context.CULL_FACE);\n\t\tthis.cullEnabled = false;\n\n\t\treturn true;\n\t};\n\n\tJSM.ShaderProgram.prototype.CompileMaterial = function (material, textureLoaded)\n\t{\n\t\tif (material.texture !== null) {\n\t\t\tvar context = this.context;\n\t\t\tvar textureBuffer = context.createTexture ();\n\t\t\tvar textureImage = new Image ();\n\t\t\ttextureImage.src = material.texture;\n\t\t\ttextureImage.onload = function () {\n\t\t\t\tvar resizedImage = JSM.ResizeImageToPowerOfTwoSides (textureImage);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, textureBuffer);\n\t\t\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.LINEAR);\n\t\t\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);\n\t\t\t\tcontext.texImage2D (context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, resizedImage);\n\t\t\t\tcontext.generateMipmap (context.TEXTURE_2D);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, null);\n\t\t\t\tif (textureLoaded !== undefined && textureLoaded !== null) {\n\t\t\t\t\ttextureLoaded ();\n\t\t\t\t}\n\t\t\t};\n\t\t\tmaterial.SetBuffers (textureBuffer, textureImage);\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.CompileMesh = function (mesh)\n\t{\n\t\tvar context = this.context;\n\t\tvar vertexBuffer = context.createBuffer ();\n\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetVertexArray (), context.STATIC_DRAW);\n\t\tvertexBuffer.itemSize = 3;\n\t\tvertexBuffer.numItems = mesh.VertexCount ();\n\n\t\tvar normalBuffer = null;\n\t\tif (mesh.HasNormalArray ()) {\n\t\t\tnormalBuffer = context.createBuffer ();\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, normalBuffer);\n\t\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetNormalArray (), context.STATIC_DRAW);\n\t\t\tnormalBuffer.itemSize = 3;\n\t\t\tnormalBuffer.numItems = mesh.NormalCount ();\n\t\t}\n\n\t\tvar uvBuffer = null;\n\t\tif (mesh.HasUVArray ()) {\n\t\t\tuvBuffer = context.createBuffer ();\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, uvBuffer);\n\t\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetUVArray (), context.STATIC_DRAW);\n\t\t\tuvBuffer.itemSize = 2;\n\t\t\tuvBuffer.numItems = mesh.UVCount ();\n\t\t}\n\t\t\n\t\tmesh.SetBuffers (vertexBuffer, normalBuffer, uvBuffer);\n\t};\n\n\tJSM.ShaderProgram.prototype.GetShader = function (shaderType)\n\t{\n\t\treturn this.shaders[shaderType];\n\t};\n\n\tJSM.ShaderProgram.prototype.UseShader = function (shaderType)\n\t{\n\t\tthis.currentShader = this.GetShader (shaderType);\n\t\tthis.currentType = shaderType;\n\t\tthis.context.useProgram (this.currentShader);\n\t};\n\n\tJSM.ShaderProgram.prototype.SetParameters = function (ambientLight, directionalLights, viewMatrix, projectionMatrix)\n\t{\n\t\tfunction GetLight (directionalLights, index, noDirectionalLight)\n\t\t{\n\t\t\tif (index < directionalLights.length) {\n\t\t\t\treturn directionalLights[index];\n\t\t\t}\n\n\t\t\treturn noDirectionalLight;\n\t\t}\n\t\t\n\t\tvar context = this.context;\n\t\tvar shader = this.currentShader;\n\t\t\n\t\tvar i, light, lightDirection;\n\t\tif (this.currentType == JSM.ShaderType.Triangle || this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\tcontext.uniform3f (shader.ambientLightColorUniform, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);\n\t\t\tfor (i = 0; i < this.globalParams.maxLightCount; i++) {\n\t\t\t\tlight = GetLight (directionalLights, i, this.globalParams.noDirectionalLight);\n\t\t\t\tlightDirection = JSM.ApplyRotation (viewMatrix, light.direction);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].diffuseColor, light.diffuse[0], light.diffuse[1], light.diffuse[2]);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].specularColor, light.specular[0], light.specular[1], light.specular[2]);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].direction, lightDirection.x, lightDirection.y, lightDirection.z);\n\t\t\t}\n\t\t\tcontext.uniformMatrix4fv (shader.pMatrixUniform, false, projectionMatrix);\n\t\t\tcontext.uniformMatrix4fv (shader.vMatrixUniform, false, viewMatrix);\n\t\t} else if (this.currentType == JSM.ShaderType.Point || this.currentType == JSM.ShaderType.Line) {\n\t\t\tcontext.uniform3f (shader.ambientLightColorUniform, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);\n\t\t\tfor (i = 0; i < this.globalParams.maxLightCount; i++) {\n\t\t\t\tlight = GetLight (directionalLights, i, this.globalParams.noDirectionalLight);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].diffuseColor, light.diffuse[0], light.diffuse[1], light.diffuse[2]);\n\t\t\t}\n\t\t\tcontext.uniformMatrix4fv (shader.pMatrixUniform, false, projectionMatrix);\n\t\t\tcontext.uniformMatrix4fv (shader.vMatrixUniform, false, viewMatrix);\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.SetCullEnabled = function (enable)\n\t{\n\t\tif (enable && !this.cullEnabled) {\n\t\t\tthis.context.enable (this.context.CULL_FACE);\n\t\t\tthis.cullEnabled = true;\n\t\t} else if (!enable && this.cullEnabled) {\n\t\t\tthis.context.disable (this.context.CULL_FACE);\n\t\t\tthis.cullEnabled = false;\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.DrawArrays = function (material, matrix, vertexBuffer, normalBuffer, uvBuffer)\n\t{\n\t\tvar context = this.context;\n\t\tvar shader = this.currentShader;\n\t\tthis.SetCullEnabled (material.singleSided);\n\t\t\n\t\tif (this.currentType == JSM.ShaderType.Triangle || this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\tcontext.uniform3f (shader.materialUniforms.ambientColor, material.ambient[0], material.ambient[1], material.ambient[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.diffuseColor, material.diffuse[0], material.diffuse[1], material.diffuse[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.specularColor, material.specular[0], material.specular[1], material.specular[2]);\n\t\t\tcontext.uniform1f (shader.materialUniforms.shininess, material.shininess);\n\t\t\tcontext.uniform1f (shader.materialUniforms.opacity, material.opacity);\n\n\t\t\tcontext.uniformMatrix4fv (shader.tMatrixUniform, false, matrix);\n\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexPositionAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexPositionAttribute, vertexBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, normalBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexNormalAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexNormalAttribute, normalBuffer.itemSize, context.FLOAT, false, 0, 0);\n\n\t\t\tif (this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tcontext.activeTexture (context.TEXTURE0);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, material.textureBuffer);\n\t\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, uvBuffer);\n\t\t\t\tcontext.enableVertexAttribArray (shader.vertexUVAttribute);\n\t\t\t\tcontext.vertexAttribPointer (shader.vertexUVAttribute, uvBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\tcontext.uniform1i (shader.samplerUniform, 0);\n\t\t\t}\n\t\t\t\n\t\t\tcontext.drawArrays (context.TRIANGLES, 0, vertexBuffer.numItems);\n\t\t} else if (this.currentType == JSM.ShaderType.Point || this.currentType == JSM.ShaderType.Line) {\n\t\t\tcontext.uniform3f (shader.materialUniforms.ambientColor, material.ambient[0], material.ambient[1], material.ambient[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.diffuseColor, material.diffuse[0], material.diffuse[1], material.diffuse[2]);\n\t\t\t\n\t\t\tcontext.uniformMatrix4fv (shader.tMatrixUniform, false, matrix);\n\t\t\t\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexPositionAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexPositionAttribute, vertexBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\n\t\t\tif (this.currentType == JSM.ShaderType.Point) {\n\t\t\t\tcontext.uniform1f (shader.pointSizeUniform, material.pointSize);\n\t\t\t\tcontext.drawArrays (context.POINTS, 0, vertexBuffer.numItems);\n\t\t\t} else if (this.currentType == JSM.ShaderType.Line) {\n\t\t\t\tcontext.drawArrays (context.LINES, 0, vertexBuffer.numItems);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderer',[\"../core/jsm\"],function(JSM){\n\tJSM.Renderer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.shader = null;\n\t\t\n\t\tthis.ambientLight = null;\n\t\tthis.directionalLights = null;\n\t\tthis.bodies = null;\n\t};\n\n\tJSM.Renderer.prototype.Init = function (canvas)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitContext (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitView ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\tif (!this.InitBodies ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitContext = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (this.canvas === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas.getContext === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = this.canvas.getContext ('webgl') || this.canvas.getContext ('experimental-webgl');\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = JSM.WebGLInitContext (canvas);\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitShaders = function ()\n\t{\n\t\tthis.shader = new JSM.ShaderProgram (this.context);\n\t\treturn this.shader.Init ();\n\t};\n\n\tJSM.Renderer.prototype.InitLights = function ()\n\t{\n\t\tthis.ambientLight = new JSM.RenderAmbientLight (0x000000);\n\t\tthis.directionalLights = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitView = function ()\n\t{\n\t\tthis.directionalLights = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.context.clearColor (red, green, blue, 1.0);\n\t};\n\n\tJSM.Renderer.prototype.SetAmbientLight = function (light)\n\t{\n\t\tthis.ambientLight = light;\n\t};\n\n\tJSM.Renderer.prototype.AddLight = function (light)\n\t{\n\t\tvar maxLightCount = this.shader.GetMaxLightCount ();\n\t\tif (this.directionalLights.length >= maxLightCount) {\n\t\t\treturn -1;\n\t\t}\n\t\tthis.directionalLights.push (light);\n\t\treturn this.directionalLights.length - 1;\n\t};\n\n\tJSM.Renderer.prototype.RemoveLight = function (light)\n\t{\n\t\tvar index = this.directionalLights.indexOf (light);\n\t\tif (index != -1) {\n\t\t\tthis.directionalLights.splice (index, 1);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveLights = function ()\n\t{\n\t\tthis.directionalLights = [];\n\t};\n\n\tJSM.Renderer.prototype.GetLight = function (index)\n\t{\n\t\treturn this.directionalLights[index];\n\t};\n\n\tJSM.Renderer.prototype.AddBody = function (renderBody, textureLoaded)\n\t{\n\t\tvar shader = this.shader;\n\t\trenderBody.EnumerateMeshes (function (mesh) {\n\t\t\tshader.CompileMaterial (mesh.GetMaterial (), textureLoaded);\n\t\t\tshader.CompileMesh (mesh);\n\t\t});\n\t\tthis.bodies.push (renderBody);\n\t};\n\n\tJSM.Renderer.prototype.AddBodies = function (renderBodies, textureLoaded)\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < renderBodies.length; i++) {\n\t\t\tbody = renderBodies[i];\n\t\t\tthis.AddBody (body, textureLoaded);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.EnumerateBodies = function (onBodyFound)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tonBodyFound (this.bodies[i]);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveBody = function (body)\n\t{\n\t\tvar index = this.bodies.indexOf (body);\n\t\tif (index != -1) {\n\t\t\tthis.bodies.splice (index, 1);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t};\n\n\tJSM.Renderer.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\tJSM.Renderer.prototype.Resize = function ()\n\t{\n\t\tthis.context.viewport (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\tJSM.Renderer.prototype.FindObjects = function (camera, screenX, screenY)\n\t{\n\t\tvar screenCoord = new JSM.Coord (screenX, this.canvas.height - screenY, 0.5);\n\t\tvar aspectRatio = this.canvas.width / this.canvas.height;\n\t\tvar viewPort = [0, 0, this.canvas.width, this.canvas.height];\n\t\tvar unprojected = JSM.Unproject (screenCoord, camera.eye, camera.center, camera.up, camera.fieldOfView * JSM.DegRad, aspectRatio, camera.nearClippingPlane, camera.farClippingPlane, viewPort);\n\t\tvar ray = new JSM.Ray (camera.eye, JSM.CoordSub (unprojected, camera.eye), null);\n\t\t\n\t\tvar result = [];\n\t\tthis.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshesWithFlag (JSM.RenderMaterialFlags.Triangle, function (mesh) {\n\t\t\t\tvar vertexCount = mesh.VertexCount ();\n\t\t\t\tvar i, v0, v1, v2, intersection;\n\t\t\t\tfor (i = 0; i < vertexCount; i += 3) {\n\t\t\t\t\tv0 = mesh.GetTransformedVertex (i + 0, transformation);\n\t\t\t\t\tv1 = mesh.GetTransformedVertex (i + 1, transformation);\n\t\t\t\t\tv2 = mesh.GetTransformedVertex (i + 2, transformation);\n\t\t\t\t\tintersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\t\tif (intersection !== null) {\n\t\t\t\t\t\tresult.push ({\n\t\t\t\t\t\t\trenderBody : body,\n\t\t\t\t\t\t\trenderMesh : mesh,\n\t\t\t\t\t\t\ttriangleIndex : parseInt (i / 3, 10),\n\t\t\t\t\t\t\tintersection : intersection\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tresult.sort (function (a, b) {\n\t\t\treturn a.intersection.distance - b.intersection.distance;\n\t\t});\n\t\treturn result;\n\t};\n\n\tJSM.Renderer.prototype.Render = function (camera)\n\t{\n\t\tfunction DrawMeshes (renderer, materialType, viewMatrix, projectionMatrix)\n\t\t{\n\t\t\tfunction MaterialTypeToShaderType (materialType)\n\t\t\t{\n\t\t\t\tfunction HasFlag (type, flag)\n\t\t\t\t{\n\t\t\t\t\treturn type & flag;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (HasFlag (materialType, JSM.RenderMaterialFlags.Triangle)) {\n\t\t\t\t\tif (HasFlag (materialType, JSM.RenderMaterialFlags.Textured)) {\n\t\t\t\t\t\treturn JSM.ShaderType.TexturedTriangle;\n\t\t\t\t\t} else if (!HasFlag (materialType, JSM.RenderMaterialFlags.Textured)) {\n\t\t\t\t\t\treturn JSM.ShaderType.Triangle;\n\t\t\t\t\t}\n\t\t\t\t} else if (HasFlag (materialType, JSM.RenderMaterialFlags.Line)) {\n\t\t\t\t\treturn JSM.ShaderType.Line;\n\t\t\t\t} else if (HasFlag (materialType, JSM.RenderMaterialFlags.Point)) {\n\t\t\t\t\treturn JSM.ShaderType.Point;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar shaderType = null;\n\t\t\trenderer.EnumerateBodies (function (body) {\n\t\t\t\tif (body.HasTypedMeshes (materialType)) {\n\t\t\t\t\tvar matrix = body.GetTransformationMatrix ();\n\t\t\t\t\tbody.EnumerateTypedMeshes (materialType, function (mesh) {\n\t\t\t\t\t\tif (shaderType === null) {\n\t\t\t\t\t\t\tshaderType = MaterialTypeToShaderType (materialType);\n\t\t\t\t\t\t\trenderer.shader.UseShader (shaderType);\n\t\t\t\t\t\t\trenderer.shader.SetParameters (renderer.ambientLight, renderer.directionalLights, viewMatrix, projectionMatrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar material = mesh.GetMaterial ();\n\t\t\t\t\t\tvar vertexBuffer = mesh.GetVertexBuffer ();\n\t\t\t\t\t\tvar normalBuffer = mesh.GetNormalBuffer ();\n\t\t\t\t\t\tvar uvBuffer = mesh.GetUVBuffer ();\n\t\t\t\t\t\trenderer.shader.DrawArrays (material, matrix, vertexBuffer, normalBuffer, uvBuffer);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.context.clear (this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n\t\t\n\t\tvar viewMatrix = JSM.MatrixView (camera.eye, camera.center, camera.up);\n\t\tvar projectionMatrix = JSM.MatrixPerspective (camera.fieldOfView * JSM.DegRad, this.canvas.width / this.canvas.height, camera.nearClippingPlane, camera.farClippingPlane);\n\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Textured, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Line, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Point, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Transparent, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Transparent + JSM.RenderMaterialFlags.Textured, viewMatrix, projectionMatrix);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/pointcloudrenderer',[\"../core/jsm\"],function(JSM){\n\tJSM.PointCloudRenderer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.shader = null;\n\t\t\n\t\tthis.camera = null;\n\t\tthis.points = null;\n\t\tthis.pointSize = null;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitContext (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitBuffers ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitView (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitContext = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (this.canvas === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas.getContext === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = this.canvas.getContext ('experimental-webgl');\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context.clearColor (1.0, 1.0, 1.0, 1.0);\n\t\tthis.context.enable (this.context.DEPTH_TEST);\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitShaders = function ()\n\t{\n\t\tfunction CreateShaderFromScript (context, script, type)\n\t\t{\n\t\t\tvar shader = context.createShader (type);\n\t\t\tcontext.shaderSource (shader, script);\n\t\t\tcontext.compileShader (shader);\n\t\t\tif (!context.getShaderParameter (shader, context.COMPILE_STATUS)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn shader;\n\t\t}\n\n\t\tvar fragmentShaderScript = [\n\t\t\t'varying highp vec3 vColor;',\n\t\t\t'void main (void) {',\n\t\t\t'\tgl_FragColor = vec4 (vColor, 1.0);',\n\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\n\t\tvar vertexShaderScript = [\n\t\t\t'attribute highp vec3 aVertexPosition;',\n\t\t\t'attribute highp vec3 aVertexColor;',\n\n\t\t\t'uniform highp mat4 uViewMatrix;',\n\t\t\t'uniform highp mat4 uProjectionMatrix;',\n\n\t\t\t'uniform highp float uPointSize;',\n\t\t\t\n\t\t\t'varying highp vec3 vColor;',\n\t\t\t\n\t\t\t'void main (void) {',\n\t\t\t'\tvColor = aVertexColor;',\n\t\t\t'\tgl_PointSize = uPointSize;',\n\t\t\t'\tgl_Position = uProjectionMatrix * uViewMatrix * vec4 (aVertexPosition, 1.0);',\n\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\n\t\tvar fragmentShader = CreateShaderFromScript (this.context, fragmentShaderScript, this.context.FRAGMENT_SHADER);\n\t\tvar vertexShader = CreateShaderFromScript (this.context, vertexShaderScript, this.context.VERTEX_SHADER);\n\t\tif (fragmentShader === null || vertexShader === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.shader = this.context.createProgram ();\n\t\tthis.context.attachShader (this.shader, vertexShader);\n\t\tthis.context.attachShader (this.shader, fragmentShader);\n\t\tthis.context.linkProgram (this.shader);\n\t\tif (!this.context.getProgramParameter (this.shader, this.context.LINK_STATUS)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.context.useProgram (this.shader);\n\n\t\tthis.shader.vertexPositionAttribute = this.context.getAttribLocation (this.shader, 'aVertexPosition');\n\t\tthis.context.enableVertexAttribArray (this.shader.vertexPositionAttribute);\n\n\t\tthis.shader.vertexColorAttribute = this.context.getAttribLocation (this.shader, 'aVertexColor');\n\t\tthis.context.enableVertexAttribArray (this.shader.vertexColorAttribute);\n\n\t\tthis.shader.pMatrixUniform = this.context.getUniformLocation (this.shader, 'uProjectionMatrix');\n\t\tthis.shader.vMatrixUniform = this.context.getUniformLocation (this.shader, 'uViewMatrix');\n\t\t\n\t\tthis.shader.pointSizeUniform = this.context.getUniformLocation (this.shader, 'uPointSize');\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitBuffers = function ()\n\t{\n\t\tthis.points = [];\n\t\tthis.pointSize = 1.0;\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitView = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.context.clearColor (red, green, blue, 1.0);\n\t};\n\n\tJSM.PointCloudRenderer.prototype.SetPointSize = function (pointSize)\n\t{\n\t\tthis.pointSize = pointSize;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.AddPoints = function (points, colors)\n\t{\n\t\tvar pointBuffer = this.context.createBuffer ();\n\t\tvar pointArray = new Float32Array (points);\n\n\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, pointBuffer);\n\t\tthis.context.bufferData (this.context.ARRAY_BUFFER, pointArray, this.context.STATIC_DRAW);\n\t\tpointBuffer.itemSize = 3;\n\t\tpointBuffer.numItems = parseInt (pointArray.length / 3, 10);\n\t\t\n\t\tvar colorBuffer = this.context.createBuffer ();\n\t\tvar colorArray = new Float32Array (colors);\n\n\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, colorBuffer);\n\t\tthis.context.bufferData (this.context.ARRAY_BUFFER, colorArray, this.context.STATIC_DRAW);\n\t\tcolorBuffer.itemSize = 3;\n\t\tcolorBuffer.numItems = parseInt (colorArray.length / 3, 10);\n\n\t\tthis.points.push ({pointArray : pointArray, pointBuffer : pointBuffer, colorBuffer : colorBuffer});\n\t};\n\n\tJSM.PointCloudRenderer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.points = [];\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Resize = function ()\n\t{\n\t\tthis.context.viewport (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Render = function ()\n\t{\n\t\tthis.context.clear (this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n\t\t\n\t\tvar projectionMatrix = JSM.MatrixPerspective (this.camera.fieldOfView * JSM.DegRad, this.canvas.width / this.canvas.height, this.camera.nearClippingPlane, this.camera.farClippingPlane);\n\t\tthis.context.uniformMatrix4fv (this.shader.pMatrixUniform, false, projectionMatrix);\n\n\t\tvar viewMatrix = JSM.MatrixView (this.camera.eye, this.camera.center, this.camera.up);\n\t\tthis.context.uniformMatrix4fv (this.shader.vMatrixUniform, false, viewMatrix);\n\n\t\tthis.context.uniform1f (this.shader.pointSizeUniform, this.pointSize);\n\t\t\n\t\tvar i, pointBuffer, colorBuffer;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tpointBuffer = this.points[i].pointBuffer;\n\t\t\tcolorBuffer = this.points[i].colorBuffer;\n\t\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, pointBuffer);\n\t\t\tthis.context.vertexAttribPointer (this.shader.vertexPositionAttribute, pointBuffer.itemSize, this.context.FLOAT, false, 0, 0);\n\t\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, colorBuffer);\n\t\t\tthis.context.vertexAttribPointer (this.shader.vertexColorAttribute, colorBuffer.itemSize, this.context.FLOAT, false, 0, 0);\n\t\t\tthis.context.drawArrays (this.context.POINTS, 0, pointBuffer.numItems);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderconverter',[\"../core/jsm\"],function(JSM){\n\tJSM.ConvertBodyToRenderBody = function (body, materials, parameters)\n\t{\n\t\tfunction MaterialToRenderMaterial (material, materialType)\n\t\t{\n\t\t\tvar renderAmbient = JSM.HexColorToNormalizedRGBComponents (material.ambient);\n\t\t\tvar renderDiffuse = JSM.HexColorToNormalizedRGBComponents (material.diffuse);\n\t\t\tvar renderSpecular = JSM.HexColorToNormalizedRGBComponents (material.specular);\n\t\t\tvar renderMaterial = new JSM.RenderMaterial (materialType, {\n\t\t\t\tambient : renderAmbient,\n\t\t\t\tdiffuse : renderDiffuse,\n\t\t\t\tspecular : renderSpecular,\n\t\t\t\tshininess : material.shininess,\n\t\t\t\topacity : material.opacity,\n\t\t\t\tsingleSided : material.singleSided,\n\t\t\t\tpointSize : material.pointSize,\n\t\t\t\ttexture : material.texture\n\t\t\t});\n\t\t\treturn renderMaterial;\n\t\t}\n\t\t\n\t\tvar hasConvexPolygons = false;\n\t\tif (parameters !== undefined && parameters !== null) {\n\t\t\tif (parameters.hasConvexPolygons !== undefined && parameters.hasConvexPolygons !== null) {\n\t\t\t\thasConvexPolygons = parameters.hasConvexPolygons;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar renderBody = new JSM.RenderBody ();\n\t\t\n\t\tvar vertices = null;\n\t\tvar normals = null;\n\t\tvar uvs = null;\n\t\t\n\t\tvar explodeData = {\n\t\t\thasConvexPolygons : hasConvexPolygons,\n\t\t\tonPointGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = null;\n\t\t\t\tuvs = null;\n\t\t\t},\t\t\n\t\t\tonPointGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Point;\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonPoint : function (vertex) {\n\t\t\t\tvertices.push (vertex.x, vertex.y, vertex.z);\n\t\t\t},\t\t\n\t\t\tonLineGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = null;\n\t\t\t\tuvs = null;\n\t\t\t},\n\t\t\tonLineGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Line;\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonLine : function (begVertex, endVertex) {\n\t\t\t\tvertices.push (begVertex.x, begVertex.y, begVertex.z);\n\t\t\t\tvertices.push (endVertex.x, endVertex.y, endVertex.z);\n\t\t\t},\t\t\n\t\t\tonGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = [];\n\t\t\t\tuvs = [];\n\t\t\t},\n\t\t\tonGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Triangle;\n\t\t\t\tif (material.texture !== null) {\n\t\t\t\t\tmaterialType += JSM.RenderMaterialFlags.Textured;\n\t\t\t\t}\n\t\t\t\tif (material.opacity < 1.0) {\n\t\t\t\t\tmaterialType += JSM.RenderMaterialFlags.Transparent;\n\t\t\t\t}\n\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\tmesh.SetNormalArray (normals);\n\t\t\t\tif (material.texture !== null) {\n\t\t\t\t\tmesh.SetUVArray (uvs);\n\t\t\t\t}\n\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonTriangle : function (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3) {\n\t\t\t\tvertices.push (vertex1.x, vertex1.y, vertex1.z);\n\t\t\t\tvertices.push (vertex2.x, vertex2.y, vertex2.z);\n\t\t\t\tvertices.push (vertex3.x, vertex3.y, vertex3.z);\n\t\t\t\t\n\t\t\t\tnormals.push (normal1.x, normal1.y, normal1.z);\n\t\t\t\tnormals.push (normal2.x, normal2.y, normal2.z);\n\t\t\t\tnormals.push (normal3.x, normal3.y, normal3.z);\n\t\t\t\t\n\t\t\t\tif (uv1 !== null && uv2 !== null && uv3 !== null) {\n\t\t\t\t\tuvs.push (uv1.x, uv1.y);\n\t\t\t\t\tuvs.push (uv2.x, uv2.y);\n\t\t\t\t\tuvs.push (uv3.x, uv3.y);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tJSM.ExplodeBody (body, materials, explodeData);\n\t\treturn renderBody;\n\t};\n\n\tJSM.ConvertModelToRenderBodies = function (model, parameters)\n\t{\n\t\tvar bodies = [];\n\t\tvar materials = model.GetMaterialSet ();\n\t\tvar i, body, renderBody;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\trenderBody = JSM.ConvertBodyToRenderBody (body, materials, parameters);\n\t\t\tbodies.push (renderBody);\n\t\t}\n\t\treturn bodies;\n\t};\n\n\tJSM.ConvertJSONDataToRenderBodies = function (jsonData, asyncCallbacks)\n\t{\n\t\tfunction ConvertMeshToRenderBody (mesh, materials)\n\t\t{\n\t\t\tfunction ConvertTrianglesToRenderMesh (mesh, triangles, materials)\n\t\t\t{\n\t\t\t\tfunction GetTextureCoordinate (u, v, offset, scale, rotation)\n\t\t\t\t{\n\t\t\t\t\tvar result = new JSM.Vector2D (u, v);\n\t\t\t\t\tif (!JSM.IsZero (rotation)) {\n\t\t\t\t\t\tvar si = Math.sin (rotation * JSM.DegRad);\n\t\t\t\t\t\tvar co = Math.cos (rotation * JSM.DegRad);\n\t\t\t\t\t\tresult.x = co * u - si * v;\n\t\t\t\t\t\tresult.y = si * u + co * v;\n\t\t\t\t\t}\n\t\t\t\t\tresult.x = offset[0] + result.x * scale[0];\n\t\t\t\t\tresult.y = offset[1] + result.y * scale[1];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tfunction AppendTriangleCoords (targetArray, sourceArray, indexArray, startIndex, componentCount)\n\t\t\t\t{\n\t\t\t\t\tvar vertexIndex, sourceVertexIndex, componentIndex;\n\t\t\t\t\tfor (vertexIndex = 0; vertexIndex < 3; vertexIndex++) {\n\t\t\t\t\t\tsourceVertexIndex = indexArray[startIndex + vertexIndex];\n\t\t\t\t\t\tfor (componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n\t\t\t\t\t\t\ttargetArray.push (sourceArray[sourceVertexIndex * componentCount + componentIndex]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials[triangles.material];\n\t\t\t\tvar renderMaterial = new JSM.RenderMaterial (JSM.RenderMaterialFlags.Triangle, {\n\t\t\t\t\tambient : material.ambient || [1.0, 1.0, 1.0],\n\t\t\t\t\tdiffuse : material.diffuse || [1.0, 1.0, 1.0],\n\t\t\t\t\tspecular : material.specular || [1.0, 1.0, 1.0],\n\t\t\t\t\tshininess : material.shininess || 0.0,\n\t\t\t\t\topacity : material.opacity || 1.0,\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar hasTexture = (material.texture !== undefined && material.texture !== null);\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\trenderMaterial.SetType (JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Textured);\n\t\t\t\t\trenderMaterial.texture = material.texture;\n\t\t\t\t\trenderMaterial.ambient = [1.0, 1.0, 1.0];\n\t\t\t\t\trenderMaterial.diffuse = [1.0, 1.0, 1.0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar renderMesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tvar vertexArray = [];\n\t\t\t\tvar normalArray = [];\n\t\t\t\tvar uvArray = [];\n\t\t\t\t\n\t\t\t\tvar i;\n\t\t\t\tfor\t(i = 0; i < triangles.parameters.length; i += 9) {\n\t\t\t\t\tAppendTriangleCoords (vertexArray, mesh.vertices, triangles.parameters, i, 3);\n\t\t\t\t\tAppendTriangleCoords (normalArray, mesh.normals, triangles.parameters, i + 3, 3);\n\t\t\t\t\tAppendTriangleCoords (uvArray, mesh.uvs, triangles.parameters, i + 6, 2);\n\t\t\t\t}\n\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\tvar offset = material.offset || [0.0, 0.0];\n\t\t\t\t\tvar scale = material.scale || [1.0, 1.0];\n\t\t\t\t\tvar rotation = material.rotation || 0.0;\n\t\t\t\t\tvar transformedUV;\n\t\t\t\t\tfor\t(i = 0; i < uvArray.length; i += 2) {\n\t\t\t\t\t\ttransformedUV = GetTextureCoordinate (uvArray[i + 0], uvArray[i + 1], offset, scale, rotation);\n\t\t\t\t\t\tuvArray[i + 0] = transformedUV.x;\n\t\t\t\t\t\tuvArray[i + 1] = -transformedUV.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trenderMesh.SetVertexArray (vertexArray);\n\t\t\t\trenderMesh.SetNormalArray (normalArray);\n\t\t\t\trenderMesh.SetUVArray (uvArray);\n\t\t\t\treturn renderMesh;\n\t\t\t}\n\t\t\t\n\t\t\tvar renderBody = new JSM.RenderBody ();\n\t\t\tvar i, triangles, renderMesh;\n\t\t\tfor (i = 0; i < mesh.triangles.length; i++) {\n\t\t\t\ttriangles = mesh.triangles[i];\n\t\t\t\trenderMesh = ConvertTrianglesToRenderMesh (mesh, triangles, materials);\n\t\t\t\trenderBody.AddMesh (renderMesh);\n\t\t\t}\n\t\t\treturn renderBody;\n\t\t}\n\t\t\n\t\tfunction AddMesh (meshes, materials, meshIndex, resultBodies)\n\t\t{\n\t\t\tvar renderBody = ConvertMeshToRenderBody (meshes[meshIndex], materials);\n\t\t\tresultBodies.push (renderBody);\n\t\t}\n\t\t\n\t\tvar resultBodies = [];\n\n\t\tvar materials = jsonData.materials;\n\t\tif (materials === undefined) {\n\t\t\treturn resultBodies;\n\t\t}\n\t\t\n\t\tvar meshes = jsonData.meshes;\n\t\tif (meshes === undefined) {\n\t\t\treturn resultBodies;\n\t\t}\n\t\t\n\t\tvar meshIndex = 0;\n\t\tJSM.AsyncRunTask (\n\t\t\tfunction () {\n\t\t\t\tAddMesh (meshes, materials, meshIndex, resultBodies);\n\t\t\t\tmeshIndex = meshIndex + 1;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tasyncCallbacks,\n\t\t\tmeshes.length, 0, resultBodies\n\t\t);\n\n\t\treturn resultBodies;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/mouse',[\"../core/jsm\"],function(JSM){\n\tJSM.Mouse = function ()\n\t{\n\t\tthis.down = false;\n\t\tthis.button = 0;\n\t\tthis.shift = false;\n\t\tthis.ctrl = false;\n\t\tthis.alt = false;\n\t\tthis.prev = new JSM.Coord2D (0, 0);\n\t\tthis.curr = new JSM.Coord2D (0, 0);\n\t\tthis.diff = new JSM.Coord2D (0, 0);\n\t};\n\n\tJSM.Mouse.prototype.Down = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\n\t\tthis.down = true;\n\t\tthis.button = event.which;\n\t\tthis.shift = event.shiftKey;\n\t\tthis.ctrl = event.ctrlKey;\n\t\tthis.alt = event.altKey;\n\t\t\n\t\tthis.SetCurrent (eventParameters, div);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Mouse.prototype.Move = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.shift = event.shiftKey;\n\t\tthis.ctrl = event.ctrlKey;\n\t\tthis.alt = event.altKey;\n\t\t\n\t\tthis.SetCurrent (eventParameters, div);\n\t\tthis.diff = JSM.CoordSub2D (this.curr, this.prev);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Mouse.prototype.Up = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.down = false;\n\t\tthis.SetCurrent (eventParameters, div);\n\t};\n\n\tJSM.Mouse.prototype.Out = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.down = false;\n\t\tthis.SetCurrent (eventParameters, div);\n\t};\n\n\tJSM.Mouse.prototype.SetCurrent = function (eventParameters, div)\n\t{\n\t\tvar currX = eventParameters.clientX;\n\t\tvar currY = eventParameters.clientY;\n\t\tif (div.getBoundingClientRect !== undefined) {\n\t\t\tvar clientRect = div.getBoundingClientRect ();\n\t\t\tcurrX -= clientRect.left;\n\t\t\tcurrY -= clientRect.top;\n\t\t}\n\t\tif (window.pageXOffset !== undefined && window.pageYOffset !== undefined) {\n\t\t\tcurrX += window.pageXOffset;\n\t\t\tcurrY += window.pageYOffset;\n\t\t}\n\t\tthis.curr = new JSM.Coord2D (currX, currY);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/touch',[\"../core/jsm\"],function(JSM){\n\tJSM.Touch = function ()\n\t{\n\t\tthis.down = false;\n\t\tthis.fingers = 0;\n\t\tthis.prev = new JSM.Coord2D ();\n\t\tthis.curr = new JSM.Coord2D ();\n\t\tthis.diff = new JSM.Coord2D ();\n\t};\n\n\tJSM.Touch.prototype.Start = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.down = true;\n\t\tthis.fingers = event.touches.length;\n\n\t\tthis.SetCurrent (event, div);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Touch.prototype.Move = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fingers = event.touches.length;\n\n\t\tthis.SetCurrent (event, div);\n\t\tthis.diff = JSM.CoordSub2D (this.curr, this.prev);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Touch.prototype.End = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.down = false;\n\t\tthis.SetCurrent (event, div);\n\t};\n\n\tJSM.Touch.prototype.SetCurrent = function (event, div)\n\t{\n\t\tfunction GetEventCoord (touch, div)\n\t\t{\n\t\t\tvar currX = touch.pageX;\n\t\t\tvar currY = touch.pageY;\n\t\t\tif (div.getBoundingClientRect !== undefined) {\n\t\t\t\tvar clientRect = div.getBoundingClientRect ();\n\t\t\t\tcurrX -= clientRect.left;\n\t\t\t\tcurrY -= clientRect.top;\n\t\t\t}\n\t\t\tif (window.pageXOffset !== undefined && window.pageYOffset !== undefined) {\n\t\t\t\tcurrX += window.pageXOffset;\n\t\t\t\tcurrY += window.pageYOffset;\n\t\t\t}\n\t\t\treturn new JSM.Coord2D (currX, currY);\n\t\t}\n\t\t\n\t\tif (event.touches.length == 1 || event.touches.length == 3) {\n\t\t\tthis.curr = GetEventCoord (event.touches[0], div);\n\t\t} else if (event.touches.length == 2) {\n\t\t\tvar distance = GetEventCoord (event.touches[0], div).DistanceTo (GetEventCoord (event.touches[1], div));\n\t\t\tthis.curr = new JSM.Coord2D (distance, distance);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/painter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: OrderPolygons\n\t* Description: Order body polygons from front to back depending on the eye position.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\teye {Coord} the camera eye position\n\t*\tcenter {Coord} the camera center position\n\t* Returns:\n\t*\t{integer[]} the ordered polygon indices\n\t*/\n\tJSM.OrderPolygons = function (body, eye, center)\n\t{\n\t\tfunction SwapArrayValues (array, from, to)\n\t\t{\n\t\t\tvar temp = array[from];\n\t\t\tarray[from] = array[to];\n\t\t\tarray[to] = temp;\n\t\t}\n\n\t\tfunction GetPolygonCenter (p)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (p);\n\t\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult = JSM.CoordAdd (result, coord);\n\t\t\t}\n\t\t\t\n\t\t\tresult.MultiplyScalar (1.0 / polygon.VertexIndexCount ());\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction CalculatePolygonValues ()\n\t\t{\n\t\t\tvar viewDirection = JSM.CoordSub (center, eye).Normalize ();\n\t\t\tvar cameraPlane = JSM.GetPlaneFromCoordAndDirection (eye, viewDirection);\n\t\t\t\n\t\t\tvar i, j, polygon, coord, distance, minDistance, maxDistance;\n\t\t\tvar polygonCenter, polygonCenterDistance;\n\t\t\tvar polygonNormal, polygonViewVector, polygonDirection, polygonPlane;\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tminDistance = JSM.Inf;\n\t\t\t\tmaxDistance = -JSM.Inf;\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\t\tdistance = cameraPlane.CoordDistance (coord);\n\t\t\t\t\tif (JSM.IsLower (distance, minDistance)) {\n\t\t\t\t\t\tminDistance = distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (JSM.IsGreater (distance, maxDistance)) {\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tminViewDistances.push (minDistance);\n\t\t\t\tmaxViewDistances.push (maxDistance);\n\t\t\t\t\n\t\t\t\tpolygonCenter = GetPolygonCenter (i);\n\t\t\t\tpolygonCenterDistance = cameraPlane.CoordDistance (polygonCenter);\n\t\t\t\tpolygonCenters.push (polygonCenter);\n\t\t\t\tpolygonCenterDistances.push (polygonCenterDistance);\n\n\t\t\t\tpolygonNormal = JSM.CalculateBodyPolygonNormal (body, i);\n\t\t\t\tpolygonViewVector = JSM.CoordSub (polygonCenter, eye).Normalize ();\n\t\t\t\tpolygonDirection = JSM.VectorDot (polygonNormal, polygonViewVector);\n\t\t\t\tif (JSM.IsGreaterOrEqual (polygonDirection, 0.0)) {\n\t\t\t\t\tpolygonNormal.MultiplyScalar (-1);\n\t\t\t\t}\n\n\t\t\t\tpolygonPlane = JSM.GetPlaneFromCoordAndDirection (polygonCenter, polygonNormal);\n\t\t\t\tpolygonPlanes.push (polygonPlane);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction PolygonViewOverlap (s, p)\n\t\t{\n\t\t\treturn JSM.IsLowerOrEqual (minViewDistances[s], maxViewDistances[p]);\n\t\t}\n\n\t\tfunction PolygonIsFrontOfPlane (s, p)\n\t\t{\n\t\t\tvar sPlane = polygonPlanes[s];\n\t\t\tvar pPlane = polygonPlanes[p];\n\n\t\t\tvar i, coord;\n\n\t\t\tvar isSBehindP = true;\n\t\t\tvar sPolygon = body.GetPolygon (s);\n\t\t\tfor (i = 0; i < sPolygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (sPolygon.GetVertexIndex (i));\n\t\t\t\tif (pPlane.CoordPosition (coord) === JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tisSBehindP = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (isSBehindP) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar isPFrontOfS = true;\n\t\t\tvar pPolygon = body.GetPolygon (p);\n\t\t\tfor (i = 0; i < pPolygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (pPolygon.GetVertexIndex (i));\n\t\t\t\tif (sPlane.CoordPosition (coord) === JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tisPFrontOfS = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (isPFrontOfS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction HasLowerDistance (s, p)\n\t\t{\n\t\t\tif (JSM.IsLower (maxViewDistances[s], maxViewDistances[p])) {\n\t\t\t\treturn true;\n\t\t\t} else if (JSM.IsEqual (maxViewDistances[s], maxViewDistances[p])) {\n\t\t\t\tif (JSM.IsLower (polygonCenterDistances[s], polygonCenterDistances[p])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction OrderPolygonsByMaxViewDistance ()\n\t\t{\n\t\t\tvar count = ordered.length;\n\t\t\t\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tfor (j = 0; j < count - i - 1; j++) {\n\t\t\t\t\tif (HasLowerDistance (ordered[j], ordered[j + 1])) {\n\t\t\t\t\t\tSwapArrayValues (ordered, j, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction NeedToChangeOrder (s, p)\n\t\t{\n\t\t\tif (needToChangeOrderCache[s][p] !== null) {\n\t\t\t\treturn needToChangeOrderCache[s][p];\n\t\t\t}\n\n\t\t\tif (PolygonViewOverlap (s, p)) {\n\t\t\t\tif (PolygonIsFrontOfPlane (s, p)) {\n\t\t\t\t\tneedToChangeOrderCache[s][p] = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tneedToChangeOrderCache[s][p] = false;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction ReorderPolygons ()\n\t\t{\n\t\t\tvar count = ordered.length;\n\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tfor (j = 0; j < count - i - 1; j++) {\n\t\t\t\t\tif (NeedToChangeOrder (ordered[j], ordered[j + 1])) {\n\t\t\t\t\t\tSwapArrayValues (ordered, j, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\t\n\t\tvar minViewDistances = [];\n\t\tvar maxViewDistances = [];\n\t\tvar polygonCenters = [];\n\t\tvar polygonCenterDistances = [];\n\t\tvar polygonPlanes = [];\n\t\t\n\t\tvar ordered = [];\n\t\tvar needToChangeOrderCache = [];\n\t\tvar count = body.PolygonCount ();\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tordered.push (i);\n\t\t\tneedToChangeOrderCache.push ([]);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tneedToChangeOrderCache[i].push (null);\n\t\t\t}\n\t\t}\n\n\t\tCalculatePolygonValues ();\n\t\tOrderPolygonsByMaxViewDistance ();\n\t\tReorderPolygons ();\n\t\t\n\t\tresult = ordered;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/drawing',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: CanvasDrawer\n\t* Description: Represents an object which can draw primitives to a canvas.\n\t* Parameters:\n\t*\tcanvas {html canvas element} the destination element\n\t*/\n\tJSM.CanvasDrawer = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tthis.context = this.canvas.getContext ('2d');\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.GetWidth\n\t* Description: Returns the width of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.CanvasDrawer.prototype.GetWidth = function ()\n\t{\n\t\treturn this.canvas.width;\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.GetHeight\n\t* Description: Returns the height of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.CanvasDrawer.prototype.GetHeight = function ()\n\t{\n\t\treturn this.canvas.height;\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.Clear\n\t* Description: Clears the target.\n\t*/\n\tJSM.CanvasDrawer.prototype.Clear = function ()\n\t{\n\t\tthis.context.clearRect (0, 0, this.canvas.width, this.canvas.height);\n\t\tthis.context.fillStyle = '#ffffff';\n\t\tthis.context.fillRect (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.DrawLine\n\t* Description: Draws a line to the target.\n\t* Parameters:\n\t*\tfrom {Coord2D} the start of the line\n\t*\tto {Coord2D} the end of the line\n\t*/\n\tJSM.CanvasDrawer.prototype.DrawLine = function (from, to)\n\t{\n\t\tthis.context.beginPath ();\n\t\tthis.context.moveTo (from.x, this.canvas.height - from.y);\n\t\tthis.context.lineTo (to.x, this.canvas.height - to.y);\n\t\tthis.context.stroke ();\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.DrawPolygon\n\t* Description: Draws a polygon to the target.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tcolor {string} the hex color string\n\t*\tcontour {boolean} need to draw contour\n\t*/\n\tJSM.CanvasDrawer.prototype.DrawPolygon = function (polygon, color, contour)\n\t{\n\t\tfunction HexColorToHTMLColor (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tthis.context.fillStyle = HexColorToHTMLColor (color);\n\t\tthis.context.beginPath ();\n\n\t\tvar i, vertex, nextVertex;\n\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tif (i === 0) {\n\t\t\t\tthis.context.moveTo (vertex.x, this.canvas.height - vertex.y);\n\t\t\t} else {\n\t\t\t\tthis.context.lineTo (vertex.x, this.canvas.height - vertex.y);\n\t\t\t}\n\t\t}\n\n\t\tthis.context.closePath ();\n\t\tthis.context.fill ();\n\n\t\tif (contour) {\n\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\tnextVertex = polygon.GetVertex (i < polygon.VertexCount () - 1 ? i + 1 : 0);\n\t\t\t\tthis.DrawLine (vertex, nextVertex);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Class: SVGDrawer\n\t* Description: Represents an object which can draw primitives to an svg.\n\t* Parameters:\n\t*\tsvgObject {html svg element} the destination element\n\t*/\n\tJSM.SVGDrawer = function (svgObject)\n\t{\n\t\tthis.svgObject = svgObject;\n\t\tthis.svgNameSpace = 'http://www.w3.org/2000/svg';\n\t};\n\n\t/**\n\t* Function: SVGDrawer.GetWidth\n\t* Description: Returns the width of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SVGDrawer.prototype.GetWidth = function ()\n\t{\n\t\treturn this.svgObject.getAttribute ('width');\n\t};\n\n\t/**\n\t* Function: SVGDrawer.GetHeight\n\t* Description: Returns the height of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SVGDrawer.prototype.GetHeight = function ()\n\t{\n\t\treturn this.svgObject.getAttribute ('height');\n\t};\n\n\t/**\n\t* Function: SVGDrawer.Clear\n\t* Description: Clears the target.\n\t*/\n\tJSM.SVGDrawer.prototype.Clear = function ()\n\t{\n\t\twhile (this.svgObject.lastChild) {\n\t\t\tthis.svgObject.removeChild (this.svgObject.lastChild);\n\t\t}\n\t};\n\n\t/**\n\t* Function: SVGDrawer.DrawLine\n\t* Description: Draws a line to the target.\n\t* Parameters:\n\t*\tfrom {Coord2D} the start of the line\n\t*\tto {Coord2D} the end of the line\n\t*/\n\tJSM.SVGDrawer.prototype.DrawLine = function (from, to)\n\t{\n\t\tvar svgLine = document.createElementNS (this.svgNameSpace, 'line');\n\t\tvar height = this.GetHeight ();\n\t\tsvgLine.setAttributeNS (null, 'stroke', 'black');\n\t\tsvgLine.setAttributeNS (null, 'x1', from.x);\n\t\tsvgLine.setAttributeNS (null, 'y1', height - from.y);\n\t\tsvgLine.setAttributeNS (null, 'x2', to.x);\n\t\tsvgLine.setAttributeNS (null, 'y2', height - to.y);\n\t\tthis.svgObject.appendChild (svgLine);\n\t};\n\n\t/**\n\t* Function: SVGDrawer.DrawPolygon\n\t* Description: Draws a polygon to the target.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tcolor {string} the hex color string\n\t*\tcontour {boolean} need to draw contour\n\t*/\n\tJSM.SVGDrawer.prototype.DrawPolygon = function (polygon, color/*, contour*/)\n\t{\n\t\tfunction HexColorToHTMLColor (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';\n\t\t\treturn result;\n\t\t}\n\n\t\tvar pointsString = '';\n\t\tvar height = this.GetHeight ();\n\t\t\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tpointsString = pointsString + vertex.x + ', ' + (height - vertex.y);\n\t\t\tif (i < polygon.VertexCount () - 1) {\n\t\t\t\tpointsString = pointsString + ', ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar svgPolyon = document.createElementNS (this.svgNameSpace, 'polygon');\n\t\tsvgPolyon.setAttributeNS (null, 'points', pointsString);\n\t\tsvgPolyon.setAttributeNS (null, 'fill', HexColorToHTMLColor (color));\n\t\tsvgPolyon.setAttributeNS (null, 'fill-opacity', '1.0');\n\t\tsvgPolyon.setAttributeNS (null, 'stroke', 'black');\n\t\tthis.svgObject.appendChild (svgPolyon);\n\t};\n\n\t/**\n\t* Function: DrawProjectedBody\n\t* Description: Draws a projected body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the material container\n\t*\tcamera {Camera} the camera for projection\n\t*\tdrawMode {string} draw mode ('HiddenLinePainter', 'HiddenLineFrontFacing' or 'Wireframe')\n\t*\tneedClear {boolean} clear the display before draw\n\t*\tdrawer {drawer object} the drawer object\n\t*/\n\tJSM.DrawProjectedBody = function (body, materials, camera, drawMode, needClear, drawer)\n\t{\n\t\tfunction AddProjectedCoord (projectedPolygon, coord)\n\t\t{\n\t\t\tvar projected = JSM.Project (coord, eye, center, up, fieldOfView * JSM.DegRad, aspectRatio, nearPlane, farPlane, viewPort);\n\t\t\tprojectedPolygon.AddVertex (projected.x, projected.y);\n\t\t}\n\n\t\tfunction GetProjectedPolygonFromBody (polygon)\n\t\t{\n\t\t\tvar projectedPolygon = new JSM.Polygon2D ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tAddProjectedCoord (projectedPolygon, coord);\n\t\t\t}\n\t\t\treturn projectedPolygon;\n\t\t}\n\n\t\tfunction GetProjectedPolygonFromPolygon (polygon)\n\t\t{\n\t\t\tvar projectedPolygon = new JSM.Polygon2D ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\tAddProjectedCoord (projectedPolygon, coord);\n\t\t\t}\n\t\t\treturn projectedPolygon;\n\t\t}\n\n\t\tif (needClear) {\n\t\t\tdrawer.Clear ();\n\t\t}\n\n\t\tvar width = drawer.GetWidth ();\n\t\tvar height = drawer.GetHeight ();\n\t\t\n\t\tvar eye = camera.eye;\n\t\tvar center = camera.center;\n\t\tvar up = camera.up;\n\t\tvar fieldOfView = camera.fieldOfView;\n\t\tvar aspectRatio = width / height;\n\t\tvar nearPlane = camera.nearClippingPlane;\n\t\tvar farPlane = camera.farClippingPlane;\n\t\tvar viewPort = [0, 0, width, height];\n\n\t\tvar i, j, polygon, coord, projected, materialIndex, color;\n\t\tif (drawMode == 'HiddenLinePainter') {\n\t\t\tvar orderedPolygons = JSM.OrderPolygons (body, eye, center);\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\t\t\tfor (i = 0; i < orderedPolygons.length; i++) {\n\t\t\t\tpolygon = body.GetPolygon (orderedPolygons[i]);\n\t\t\t\tprojected = GetProjectedPolygonFromBody (polygon);\n\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t}\n\t\t} else if (drawMode == 'HiddenLineBSPTree') {\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\n\t\t\tvar bspTree = new JSM.BSPTree ();\n\t\t\tJSM.AddBodyToBSPTree (body, bspTree);\n\n\t\t\tJSM.TraverseBSPTreeForEyePosition (bspTree, camera.eye, function (node) {\n\t\t\t\tprojected = GetProjectedPolygonFromPolygon (node.polygon);\n\t\t\t\tpolygon = body.GetPolygon (node.userData.originalPolygon);\n\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t});\t\t\n\t\t} else if (drawMode == 'HiddenLineFrontFacing') {\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tprojected = GetProjectedPolygonFromBody (polygon);\n\t\t\t\tif (projected.GetOrientation () == JSM.Orientation.CounterClockwise) {\n\t\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (drawMode == 'Wireframe') {\n\t\t\tvar vertexCount, currentCoord, currentVertex, vertex;\n\t\t\tvar drawedLines = [];\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tcurrentCoord = null;\n\t\t\t\tcurrentVertex = null;\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tvertexCount = polygon.VertexIndexCount ();\n\t\t\t\tfor (j = 0; j <= vertexCount; j++) {\n\t\t\t\t\tvertex = polygon.GetVertexIndex (j % vertexCount);\n\t\t\t\t\tcoord = body.GetVertexPosition (vertex);\n\t\t\t\t\tprojected = JSM.Project (coord, eye, center, up, fieldOfView * JSM.DegRad, aspectRatio, nearPlane, farPlane, viewPort);\n\t\t\t\t\tif (currentCoord !== null && currentVertex !== null && drawedLines[[currentVertex, vertex]] === undefined) {\n\t\t\t\t\t\tdrawer.DrawLine (currentCoord, projected);\n\t\t\t\t\t\tdrawedLines[[currentVertex, vertex]] = true;\n\t\t\t\t\t\tdrawedLines[[vertex, currentVertex]] = true;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentVertex = vertex;\n\t\t\t\t\tcurrentCoord = projected;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/navigation',[\"../core/jsm\"],function(JSM){\n\tJSM.Navigation = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.drawCallback = null;\n\t\tthis.resizeCallback = null;\n\t\t\n\t\tthis.mouse = null;\n\t\tthis.touch = null;\n\t\t\n\t\tthis.cameraFixUp = null;\n\t\tthis.cameraEnableOrbit = null;\n\t\tthis.cameraEnablePan = null;\n\t\tthis.cameraEnableZoom = null;\n\t\tthis.cameraNearDistanceLimit = null;\n\t\tthis.cameraFarDistanceLimit = null;\n\t\t\n\t\tthis.orbitCenter = null;\n\t\tthis.fullscreen = null;\n\t};\n\n\tJSM.Navigation.prototype.Init = function (canvas, camera, drawCallback, resizeCallback)\n\t{\n\t\tthis.canvas = canvas;\n\t\tthis.camera = camera;\n\t\tthis.drawCallback = drawCallback;\n\t\tthis.resizeCallback = resizeCallback;\n\n\t\tthis.mouse = new JSM.Mouse ();\n\t\tthis.touch = new JSM.Touch ();\n\t\t\n\t\tthis.cameraFixUp = true;\n\t\tthis.cameraEnableOrbit = true;\n\t\tthis.cameraEnablePan = true;\n\t\tthis.cameraEnableZoom = true;\n\t\t\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t\tthis.fullscreen = false;\n\n\t\tvar myThis = this;\n\t\tif (document.addEventListener) {\n\t\t\tdocument.addEventListener ('mousemove', function (event) {myThis.OnMouseMove (event);});\n\t\t\tdocument.addEventListener ('mouseup', function (event) {myThis.OnMouseUp (event);});\n\t\t}\n\t\tif (this.canvas.addEventListener) {\n\t\t\tthis.canvas.addEventListener ('mousedown', function (event) {myThis.OnMouseDown (event);}, false);\n\t\t\tthis.canvas.addEventListener ('DOMMouseScroll', function (event) {myThis.OnMouseWheel (event);}, false);\n\t\t\tthis.canvas.addEventListener ('mousewheel', function (event) {myThis.OnMouseWheel (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchstart', function (event) {myThis.OnTouchStart (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchmove', function (event) {myThis.OnTouchMove (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchend', function (event) {myThis.OnTouchEnd (event);}, false);\n\t\t\tthis.canvas.addEventListener ('contextmenu', function (event) {myThis.OnContextMenu (event);}, false);\n\t\t}\n\t\tif (window.addEventListener) {\n\t\t\twindow.addEventListener ('resize', function (event) {myThis.OnResize (event);}, false);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.Navigation.prototype.SetCamera = function (eye, center, up)\n\t{\n\t\tthis.camera.Set (eye, center, up);\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t};\n\n\tJSM.Navigation.prototype.EnableFixUp = function (enable)\n\t{\n\t\tthis.cameraFixUp = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnableOrbit = function (enable)\n\t{\n\t\tthis.cameraEnableOrbit = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnablePan = function (enable)\n\t{\n\t\tthis.cameraEnablePan = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnableZoom = function (enable)\n\t{\n\t\tthis.cameraEnableZoom = enable;\n\t};\n\n\tJSM.Navigation.prototype.SetNearDistanceLimit = function (limit)\n\t{\n\t\tthis.cameraNearDistanceLimit = limit;\n\t};\n\n\tJSM.Navigation.prototype.SetFarDistanceLimit = function (limit)\n\t{\n\t\tthis.cameraFarDistanceLimit = limit;\n\t};\n\n\tJSM.Navigation.prototype.SetOrbitCenter = function (orbitCenter)\n\t{\n\t\tthis.orbitCenter = orbitCenter;\n\t};\n\n\tJSM.Navigation.prototype.FitInWindow = function (center, radius)\n\t{\n\t\tif (JSM.IsZero (radius)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar offsetToOrigo = JSM.CoordSub (this.camera.center, center);\n\t\tthis.camera.center = center;\n\t\tthis.camera.eye = JSM.CoordSub (this.camera.eye, offsetToOrigo);\n\t\t\n\t\tvar centerEyeDirection = JSM.CoordSub (this.camera.eye, this.camera.center).Normalize ();\n\t\tvar fieldOfView = this.camera.fieldOfView / 2.0;\n\t\tif (this.canvas.width < this.canvas.height) {\n\t\t\tfieldOfView = fieldOfView * this.canvas.width / this.canvas.height;\n\t\t}\n\t\tvar distance = radius / Math.sin (fieldOfView * JSM.DegRad);\n\t\t\n\t\tthis.camera.eye = this.camera.center.Clone ().Offset (centerEyeDirection, distance);\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t};\n\n\tJSM.Navigation.prototype.SetFullscreen = function (fullscreen)\n\t{\n\t\tthis.fullscreen = fullscreen;\n\t\tthis.ResizeCallback ();\n\t};\n\n\tJSM.Navigation.prototype.Orbit = function (angleX, angleY)\n\t{\n\t\tvar radAngleX = angleX * JSM.DegRad;\n\t\tvar radAngleY = angleY * JSM.DegRad;\n\t\t\n\t\tvar viewDirection = JSM.CoordSub (this.camera.center, this.camera.eye).Normalize ();\n\t\tvar horizontalDirection = JSM.VectorCross (viewDirection, this.camera.up).Normalize ();\n\t\tvar differentCenter = !this.orbitCenter.IsEqual (this.camera.center);\n\t\t\n\t\tif (this.cameraFixUp) {\n\t\t\tvar originalAngle = viewDirection.AngleTo (this.camera.up);\n\t\t\tvar newAngle = originalAngle + radAngleY;\n\t\t\tif (JSM.IsGreater (newAngle, 0.0) && JSM.IsLower (newAngle, Math.PI)) {\n\t\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\tif (differentCenter) {\n\t\t\t\t\tthis.camera.center.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.camera.eye.Rotate (this.camera.up, -radAngleX, this.orbitCenter);\n\t\t\tif (differentCenter) {\n\t\t\t\tthis.camera.center.Rotate (this.camera.up, -radAngleX, this.orbitCenter);\n\t\t\t}\n\t\t} else {\n\t\t\tvar verticalDirection = JSM.VectorCross (horizontalDirection, viewDirection).Normalize ();\n\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\tthis.camera.eye.Rotate (verticalDirection, -radAngleX, this.orbitCenter);\n\t\t\tif (differentCenter) {\n\t\t\t\tthis.camera.center.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\tthis.camera.center.Rotate (verticalDirection, -radAngleX, this.orbitCenter);\n\t\t\t}\n\t\t\tthis.camera.up = verticalDirection;\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.Pan = function (moveX, moveY)\n\t{\n\t\tvar viewDirection = JSM.CoordSub (this.camera.center, this.camera.eye).Normalize ();\n\t\tvar horizontalDirection = JSM.VectorCross (viewDirection, this.camera.up).Normalize ();\n\t\tvar verticalDirection = JSM.VectorCross (horizontalDirection, viewDirection).Normalize ();\n\t\t\n\t\tthis.camera.eye.Offset (horizontalDirection, -moveX);\n\t\tthis.camera.center.Offset (horizontalDirection, -moveX);\n\n\t\tthis.camera.eye.Offset (verticalDirection, moveY);\n\t\tthis.camera.center.Offset (verticalDirection, moveY);\n\t};\n\n\tJSM.Navigation.prototype.Zoom = function (ratio)\n\t{\n\t\tvar direction = JSM.CoordSub (this.camera.center, this.camera.eye);\n\t\tvar distance = direction.Length ();\n\t\tvar zoomIn = ratio > 0;\n\t\tif (zoomIn && this.cameraNearDistanceLimit !== null && distance < this.cameraNearDistanceLimit) {\n\t\t\treturn 0;\n\t\t} else if (!zoomIn && this.cameraFarDistanceLimit !== null && distance > this.cameraFarDistanceLimit) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar move = distance * ratio;\n\t\tthis.camera.eye.Offset (direction, move);\n\t};\n\n\tJSM.Navigation.prototype.DrawCallback = function ()\n\t{\n\t\tif (this.drawCallback !== undefined && this.drawCallback !== null) {\n\t\t\tthis.drawCallback ();\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.ResizeCallback = function ()\n\t{\n\t\tif (this.resizeCallback !== undefined && this.resizeCallback !== null) {\n\t\t\tif (this.fullscreen) {\n\t\t\t\tthis.canvas.width = window.innerWidth;\n\t\t\t\tthis.canvas.height = window.innerHeight;\n\t\t\t}\n\t\t\tthis.resizeCallback ();\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.OnMouseDown = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Down (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseMove = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Move (event, this.canvas);\n\t\tif (!this.mouse.down) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ratio = 0.0;\n\t\tif (this.mouse.button == 1) {\n\t\t\tif (!this.cameraEnableOrbit) {\n\t\t\t\treturn;\n\t\t\t}\t\t\n\t\t\tratio = 0.5;\n\t\t\tthis.Orbit (this.mouse.diff.x * ratio, this.mouse.diff.y * ratio);\n\t\t} else if (this.mouse.button == 3) {\n\t\t\tif (!this.cameraEnablePan) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar eyeCenterDistance = this.camera.eye.DistanceTo (this.camera.center);\n\t\t\tratio = 0.001 * eyeCenterDistance;\n\t\t\tthis.Pan (this.mouse.diff.x * ratio, this.mouse.diff.y * ratio);\n\t\t}\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnMouseUp = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Up (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseOut = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Out (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseWheel = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tif (!this.cameraEnableZoom) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar eventParameters = event;\n\t\tif (eventParameters === null) {\n\t\t\teventParameters = window.event;\n\t\t}\n\t\t\n\t\tvar delta = 0;\n\t\tif (eventParameters.detail) {\n\t\t\tdelta = -eventParameters.detail;\n\t\t} else if (eventParameters.wheelDelta) {\n\t\t\tdelta = eventParameters.wheelDelta / 40;\n\t\t}\n\n\t\tvar ratio = 0.1;\n\t\tif (delta < 0) {\n\t\t\tratio = ratio * -1.0;\n\t\t}\n\n\t\tthis.Zoom (ratio);\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnTouchStart = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.Start (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnTouchMove = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.Move (event, this.canvas);\n\t\tif (!this.touch.down) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ratio = 0.0;\n\t\tif (this.touch.fingers == 1) {\n\t\t\tif (!this.cameraEnableOrbit) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tratio = 0.5;\n\t\t\tthis.Orbit (this.touch.diff.x * ratio, this.touch.diff.y * ratio);\n\t\t} else if (this.touch.fingers == 2) {\n\t\t\tif (!this.cameraEnableZoom) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tratio = 0.005;\n\t\t\tthis.Zoom (this.touch.diff.x * ratio);\n\t\t} else if (this.touch.fingers == 3) {\n\t\t\tif (!this.cameraEnablePan) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar eyeCenterDistance = this.camera.eye.DistanceTo (this.camera.center);\n\t\t\tratio = 0.001 * eyeCenterDistance;\n\t\t\tthis.Pan (this.touch.diff.x * ratio, this.touch.diff.y * ratio);\n\t\t}\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnTouchEnd = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.End (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnContextMenu = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t};\n\n\tJSM.Navigation.prototype.OnResize = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.ResizeCallback ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/softwareviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.SoftwareViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.bodies = null;\n\t\tthis.drawer = null;\n\t\tthis.drawMode = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.SoftwareViewer.prototype.Start = function (canvas, camera)\n\t{\n\t\tif (!this.InitCanvas (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.InitCanvas = function (canvas)\n\t{\n\t\tthis.bodies = [];\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas instanceof (HTMLCanvasElement)) {\n\t\t\tthis.drawer = new JSM.CanvasDrawer (this.canvas);\n\t\t} else if (this.canvas instanceof (SVGSVGElement)) {\n\t\t\tthis.drawer = new JSM.SVGDrawer (this.canvas);\n\t\t}\n\t\t\n\t\tif (!this.drawer) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.drawMode = 'Wireframe';\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.InitCamera = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.AddBody = function (body, materials)\n\t{\n\t\tthis.bodies.push ([body, materials]);\n\t};\n\n\tJSM.SoftwareViewer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t};\n\n\tJSM.SoftwareViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, j, body, vertex;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i][0];\n\t\t\tfor (j = 0; j < body.VertexCount (); j++) {\n\t\t\t\tvertex = body.GetVertex (j);\n\t\t\t\tmin.x = JSM.Minimum (min.x, vertex.position.x);\n\t\t\t\tmin.y = JSM.Minimum (min.y, vertex.position.y);\n\t\t\t\tmin.z = JSM.Minimum (min.z, vertex.position.z);\n\t\t\t\tmax.x = JSM.Maximum (max.x, vertex.position.x);\n\t\t\t\tmax.y = JSM.Maximum (max.y, vertex.position.y);\n\t\t\t\tmax.z = JSM.Maximum (max.z, vertex.position.z);\n\t\t\t}\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, j, body, vertex, distance;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i][0];\n\t\t\tfor (j = 0; j < body.VertexCount (); j++) {\n\t\t\t\tvertex = body.GetVertex (j);\n\t\t\t\tdistance = center.DistanceTo (vertex.position);\n\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\tradius = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.SoftwareViewer.prototype.Resize = function ()\n\t{\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.Draw = function ()\n\t{\n\t\tvar i, bodyAndMaterials;\n\t\tthis.drawer.Clear ();\n\t\t\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbodyAndMaterials = this.bodies[i];\n\t\t\tJSM.DrawProjectedBody (bodyAndMaterials[0], bodyAndMaterials[1], this.camera, this.drawMode, false, this.drawer);\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/spriteviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.SpriteViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.callbacks = null;\n\t\tthis.points = null;\n\t\tthis.projected = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.SpriteViewer.prototype.Start = function (canvas, camera, callbacks)\n\t{\n\t\tif (!this.InitCanvas (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCallbacks (callbacks)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCanvas = function (canvas)\n\t{\n\t\tthis.points = [];\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCamera = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.camera, this.Draw.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCallbacks = function (callbacks)\n\t{\n\t\tthis.callbacks = {\n\t\t\tonPointDraw : null\n\t\t};\n\n\t\tif (callbacks !== undefined) {\n\t\t\tif (callbacks.onDrawStart !== undefined) { this.callbacks.onDrawStart = callbacks.onDrawStart; }\n\t\t\tif (callbacks.onPointDraw !== undefined) { this.callbacks.onPointDraw = callbacks.onPointDraw; }\n\t\t\tif (callbacks.onDrawEnd !== undefined) { this.callbacks.onDrawEnd = callbacks.onDrawEnd; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.AddPoint = function (point)\n\t{\n\t\tthis.points.push (point);\n\t};\n\n\tJSM.SpriteViewer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.points = [];\n\t};\n\n\tJSM.SpriteViewer.prototype.Resize = function ()\n\t{\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderPosition = function (maxDistance, x, y)\n\t{\n\t\tvar position = new JSM.Coord2D (x, y);\n\t\t\n\t\tvar minIndex = -1;\n\t\tvar minDistance = JSM.Inf;\n\t\tvar i, projected, distance;\n\t\tfor (i = 0; i < this.projected.length; i++) {\n\t\t\tprojected = this.projected[i];\n\t\t\tdistance = position.DistanceTo (new JSM.Coord2D (projected.position.x, projected.position.y));\n\t\t\tif (JSM.IsLower (distance, maxDistance) && JSM.IsLower (distance, minDistance)) {\n\t\t\t\tminIndex = projected.originalIndex;\n\t\t\t\tminDistance = distance;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn minIndex;\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderMouse = function (maxDistance)\n\t{\n\t\treturn this.NearestPointUnderPosition (maxDistance, this.navigation.mouse.curr.x, this.navigation.mouse.curr.y);\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderTouch = function (maxDistance)\n\t{\n\t\treturn this.NearestPointUnderPosition (maxDistance, this.navigation.touch.curr.x, this.navigation.touch.curr.y);\n\t};\n\n\tJSM.SpriteViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SpriteViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.SpriteViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.SpriteViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, coord, distance;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tdistance = center.DistanceTo (coord);\n\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\tradius = distance;\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.SpriteViewer.prototype.Draw = function ()\n\t{\n\t\tif (this.callbacks.onDrawStart !== null) {\n\t\t\tthis.callbacks.onDrawStart (this.canvas);\n\t\t}\n\n\t\tvar aspectRatio = this.canvas.width / this.canvas.height;\n\t\tvar viewPort = [0, 0, this.canvas.width, this.canvas.height];\n\t\tthis.projected = [];\n\t\t\n\t\tvar i, coord, projected;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tprojected = JSM.Project (coord, this.camera.eye, this.camera.center, this.camera.up, this.camera.fieldOfView * JSM.DegRad, aspectRatio, this.camera.nearClippingPlane, this.camera.farClippingPlane, viewPort);\n\t\t\tprojected.y = this.canvas.height - projected.y;\n\t\t\tif (projected !== null) {\n\t\t\t\tthis.projected.push ({position : projected, originalIndex : i});\n\t\t\t}\n\t\t}\n\n\t\tthis.projected.sort (function (a, b) {\n\t\t\tif (a.position.z > b.position.z) {\n\t\t\t\treturn -1;\n\t\t\t} else if (a.position.z < b.position.z) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\tfor (i = 0; i < this.projected.length; i++) {\n\t\t\tif (this.callbacks.onPointDraw !== null) {\n\t\t\t\tthis.callbacks.onPointDraw (this.canvas, this.projected[i].originalIndex, this.projected[i].position);\n\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks.onDrawEnd !== null) {\n\t\t\tthis.callbacks.onDrawEnd (this.canvas);\n\t\t}\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/viewer',[\"../core/jsm\"],function(JSM){\n\tJSM.Viewer = function ()\n\t{\n\t\tthis.camera = null;\n\t\tthis.renderer = null;\n\t\tthis.navigation = null;\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!this.InitRenderer (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitNavigation (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.Reset = function ()\n\t{\n\t\tthis.RemoveBodies ();\n\t\tthis.RemoveLights ();\n\t\tthis.SetAmbientLight (new JSM.RenderAmbientLight (0x7f7f7f));\n\t\tthis.EnableCameraLight ();\n\t};\n\n\tJSM.Viewer.prototype.InitRenderer = function (canvas)\n\t{\n\t\tthis.renderer = new JSM.Renderer ();\n\t\tif (!this.renderer.Init (canvas)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.InitNavigation = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.renderer.canvas, this.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.InitLights = function ()\n\t{\n\t\tthis.SetAmbientLight (new JSM.RenderAmbientLight (0x7f7f7f));\n\t\tthis.EnableCameraLight ();\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.renderer.SetClearColor (red, green, blue);\n\t};\n\n\tJSM.Viewer.prototype.EnableCameraLight = function ()\n\t{\n\t\tif (this.cameraLight !== null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cameraLight = new JSM.RenderDirectionalLight (0x7f7f7f, 0xffffff, new JSM.Vector (1.0, 0.0, 0.0));\n\t\tthis.AddLight (this.cameraLight);\n\t};\n\n\tJSM.Viewer.prototype.DisableCameraLight = function ()\n\t{\n\t\tif (this.cameraLight === null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.RemoveLight (this.cameraLight);\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.GetCameraLight = function ()\n\t{\n\t\treturn this.cameraLight;\n\t};\n\n\tJSM.Viewer.prototype.SetAmbientLight = function (light)\n\t{\n\t\tthis.renderer.SetAmbientLight (light);\n\t};\n\n\tJSM.Viewer.prototype.AddLight = function (light)\n\t{\n\t\tthis.renderer.AddLight (light);\n\t};\n\n\tJSM.Viewer.prototype.RemoveLight = function (light)\n\t{\n\t\tthis.renderer.RemoveLight (light);\n\t};\n\n\tJSM.Viewer.prototype.RemoveLights = function ()\n\t{\n\t\tthis.renderer.RemoveLights ();\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.AddBody = function (renderBody)\n\t{\n\t\tthis.renderer.AddBody (renderBody, this.Draw.bind (this));\n\t};\n\n\tJSM.Viewer.prototype.AddBodies = function (renderBodies)\n\t{\n\t\tthis.renderer.AddBodies (renderBodies, this.Draw.bind (this));\n\t};\n\n\tJSM.Viewer.prototype.RemoveBody = function (body)\n\t{\n\t\tthis.renderer.RemoveBody (body);\n\t};\n\n\tJSM.Viewer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.renderer.RemoveBodies ();\n\t};\n\n\tJSM.Viewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t};\n\n\tJSM.Viewer.prototype.SetFullscreen = function (fullscreen)\n\t{\n\t\tthis.navigation.SetFullscreen (fullscreen);\n\t};\n\n\tJSM.Viewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.Viewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tthis.renderer.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshes (function (mesh) {\n\t\t\t\tvar i, vertex;\n\t\t\t\tfor (i = 0; i < mesh.VertexCount (); i++) {\n\t\t\t\t\tvertex = mesh.GetTransformedVertex (i, transformation);\n\t\t\t\t\tmin.x = JSM.Minimum (min.x, vertex.x);\n\t\t\t\t\tmin.y = JSM.Minimum (min.y, vertex.y);\n\t\t\t\t\tmin.z = JSM.Minimum (min.z, vertex.z);\n\t\t\t\t\tmax.x = JSM.Maximum (max.x, vertex.x);\n\t\t\t\t\tmax.y = JSM.Maximum (max.y, vertex.y);\n\t\t\t\t\tmax.z = JSM.Maximum (max.z, vertex.z);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.Viewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tthis.renderer.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshes (function (mesh) {\n\t\t\t\tvar i, vertex, distance;\n\t\t\t\tfor (i = 0; i < mesh.VertexCount (); i++) {\n\t\t\t\t\tvertex = mesh.GetTransformedVertex (i, transformation);\n\t\t\t\t\tdistance = center.DistanceTo (vertex);\n\t\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\t\tradius = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.Viewer.prototype.FindObjects = function (screenX, screenY)\n\t{\n\t\treturn this.renderer.FindObjects (this.camera, screenX, screenY);\n\t};\n\n\tJSM.Viewer.prototype.Resize = function ()\n\t{\n\t\tthis.renderer.Resize ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.Viewer.prototype.Draw = function ()\n\t{\n\t\tvar camera = this.camera;\n\t\tvar cameraLight = this.GetCameraLight ();\n\t\tif (cameraLight !== null) {\n\t\t\tcameraLight.direction = JSM.CoordSub (camera.center, camera.eye).Normalize ();\n\t\t}\n\t\tthis.renderer.Render (camera);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/pointcloudviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.PointCloudViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.renderer = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.PointCloudViewer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!this.InitRenderer (canvas, camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitNavigation ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.InitRenderer = function (canvas, camera)\n\t{\n\t\tthis.renderer = new JSM.PointCloudRenderer ();\n\t\tif (!this.renderer.Init (canvas, camera)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.InitNavigation = function ()\n\t{\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.renderer.canvas, this.renderer.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.renderer.SetClearColor (red, green, blue);\n\t};\n\n\tJSM.PointCloudViewer.prototype.SetPointSize = function (pointSize)\n\t{\n\t\tthis.renderer.SetPointSize (pointSize);\n\t};\n\n\tJSM.PointCloudViewer.prototype.AddPoints = function (points, colors)\n\t{\n\t\tthis.renderer.AddPoints (points, colors);\n\t};\n\n\tJSM.PointCloudViewer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.renderer.RemovePoints ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, j, points, point;\n\t\tfor (i = 0; i < this.renderer.points.length; i++) {\n\t\t\tpoints = this.renderer.points[i].pointArray;\n\t\t\tfor (j = 0; j < points.length; j = j + 3) {\n\t\t\t\tpoint = new JSM.Coord (points[j], points[j + 1], points[j + 2]);\n\t\t\t\tmin.x = JSM.Minimum (min.x, point.x);\n\t\t\t\tmin.y = JSM.Minimum (min.y, point.y);\n\t\t\t\tmin.z = JSM.Minimum (min.z, point.z);\n\t\t\t\tmax.x = JSM.Maximum (max.x, point.x);\n\t\t\t\tmax.y = JSM.Maximum (max.y, point.y);\n\t\t\t\tmax.z = JSM.Maximum (max.z, point.z);\n\t\t\t}\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, j, points, point, distance;\n\t\tfor (i = 0; i < this.renderer.points.length; i++) {\n\t\t\tpoints = this.renderer.points[i].pointArray;\n\t\t\tfor (j = 0; j < points.length; j = j + 3) {\n\t\t\t\tpoint = new JSM.Coord (points[j], points[j + 1], points[j + 2]);\n\t\t\t\tdistance = center.DistanceTo (point);\n\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\tradius = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.PointCloudViewer.prototype.Resize = function ()\n\t{\n\t\tthis.renderer.Resize ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.Draw = function ()\n\t{\n\t\tthis.renderer.Render ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/solidgenerator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSolidWithRadius\n\t* Description: Generates a special solid with the given radius.\n\t* Parameters:\n\t*\tsolidName {string} the name of the solid\n\t*\tradius {number} the radius of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSolidWithRadius = function (solidName, radius)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar equalRadius = true;\n\t\t\n\t\tif (solidName === 'Tetrahedron') {\n\t\t\tresult = JSM.GenerateTetrahedron ();\n\t\t} else if (solidName === 'Hexahedron') {\n\t\t\tresult = JSM.GenerateHexahedron ();\n\t\t} else if (solidName === 'Octahedron') {\n\t\t\tresult = JSM.GenerateOctahedron ();\n\t\t} else if (solidName === 'Dodecahedron') {\n\t\t\tresult = JSM.GenerateDodecahedron ();\n\t\t} else if (solidName === 'Icosahedron') {\n\t\t\tresult = JSM.GenerateIcosahedron ();\n\t\t} else if (solidName === 'TruncatedTetrahedron') {\n\t\t\tresult = JSM.GenerateTruncatedTetrahedron ();\n\t\t} else if (solidName === 'Cuboctahedron') {\n\t\t\tresult = JSM.GenerateCuboctahedron ();\n\t\t} else if (solidName === 'TruncatedCube') {\n\t\t\tresult = JSM.GenerateTruncatedCube ();\n\t\t} else if (solidName === 'TruncatedOctahedron') {\n\t\t\tresult = JSM.GenerateTruncatedOctahedron ();\n\t\t} else if (solidName === 'Rhombicuboctahedron') {\n\t\t\tresult = JSM.GenerateRhombicuboctahedron ();\n\t\t} else if (solidName === 'TruncatedCuboctahedron') {\n\t\t\tresult = JSM.GenerateTruncatedCuboctahedron ();\n\t\t} else if (solidName === 'SnubCube') {\n\t\t\tresult = JSM.GenerateSnubCube ();\n\t\t} else if (solidName === 'Icosidodecahedron') {\n\t\t\tresult = JSM.GenerateIcosidodecahedron ();\n\t\t} else if (solidName === 'TruncatedDodecahedron') {\n\t\t\tresult = JSM.GenerateTruncatedDodecahedron ();\n\t\t} else if (solidName === 'TruncatedIcosahedron') {\n\t\t\tresult = JSM.GenerateTruncatedIcosahedron ();\n\t\t} else if (solidName === 'Rhombicosidodecahedron') {\n\t\t\tresult = JSM.GenerateRhombicosidodecahedron ();\n\t\t} else if (solidName === 'TruncatedIcosidodecahedron') {\n\t\t\tresult = JSM.GenerateTruncatedIcosidodecahedron ();\n\t\t} else if (solidName === 'SnubDodecahedron') {\n\t\t\tresult = JSM.GenerateSnubDodecahedron ();\n\t\t} else if (solidName === 'TetrakisHexahedron') {\n\t\t\tresult = JSM.GenerateTetrakisHexahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'RhombicDodecahedron') {\n\t\t\tresult = JSM.GenerateRhombicDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'PentakisDodecahedron') {\n\t\t\tresult = JSM.GeneratePentakisDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallStellatedDodecahedron') {\n\t\t\tresult = JSM.GenerateSmallStellatedDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'GreatDodecahedron') {\n\t\t\tresult = JSM.GenerateGreatDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallTriambicIcosahedron') {\n\t\t\tresult = JSM.GenerateSmallTriambicIcosahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'GreatStellatedDodecahedron') {\n\t\t\tresult = JSM.GenerateGreatStellatedDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallTriakisOctahedron') {\n\t\t\tresult = JSM.GenerateSmallTriakisOctahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'StellaOctangula') {\n\t\t\tresult = JSM.GenerateStellaOctangula ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'TriakisTetrahedron') {\n\t\t\tresult = JSM.GenerateTriakisTetrahedron ();\n\t\t\tequalRadius = false;\n\t\t}\n\n\t\tif (result.VertexCount () > 0) {\n\t\t\tvar i;\n\t\t\n\t\t\tvar maxRadius = 0.0;\n\t\t\tif (equalRadius) {\n\t\t\t\tmaxRadius = result.GetVertexPosition (0).Length ();\n\t\t\t} else {\n\t\t\t\tvar currentRadius;\n\t\t\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\t\t\tcurrentRadius = result.GetVertexPosition (i).Length ();\n\t\t\t\t\tif (JSM.IsGreater (currentRadius, maxRadius)) {\n\t\t\t\t\t\tmaxRadius = currentRadius;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar scale = radius / maxRadius;\n\t\t\t\n\t\t\tvar vertex;\n\t\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\t\tvertex = result.GetVertex (i);\n\t\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTetrahedron\n\t* Description: Generates a tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTetrahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, +a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, -a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, +a, -a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, -a, -a)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 2, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 3, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 2, 3]));\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateHexahedron\n\t* Description: Generates a hexahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateHexahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 1, 5, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 2, 3, 1]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 7, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 5, 7, 6]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateOctahedron\n\t* Description: Generates an octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateOctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +b);\n\t\tJSM.AddVertexToBody (result, -a, +b, +b);\n\t\tJSM.AddVertexToBody (result, +b, +a, +b);\n\t\tJSM.AddVertexToBody (result, +b, -a, +b);\n\t\tJSM.AddVertexToBody (result, +b, +b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 3, 5]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 3]);\n\t\tJSM.AddPolygonToBody (result, [0, 5, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 2, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 3]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateDodecahedron\n\t* Description: Generates a dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\t\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +d, +c);\n\t\tJSM.AddVertexToBody (result, +b, +d, -c);\n\t\tJSM.AddVertexToBody (result, +b, -d, +c);\n\t\tJSM.AddVertexToBody (result, +b, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +b);\n\t\tJSM.AddVertexToBody (result, +d, -c, +b);\n\t\tJSM.AddVertexToBody (result, -d, +c, +b);\n\t\tJSM.AddVertexToBody (result, -d, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +d);\n\t\tJSM.AddVertexToBody (result, -c, +b, +d);\n\t\tJSM.AddVertexToBody (result, +c, +b, -d);\n\t\tJSM.AddVertexToBody (result, -c, +b, -d);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 10, 2, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 16, 18, 1, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 12, 14, 3, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5, 14, 12]);\n\t\tJSM.AddPolygonToBody (result, [1, 18, 4, 11, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6, 15, 13]);\n\t\tJSM.AddPolygonToBody (result, [2, 13, 4, 18, 16]);\n\t\tJSM.AddPolygonToBody (result, [3, 14, 5, 19, 17]);\n\t\tJSM.AddPolygonToBody (result, [3, 17, 6, 10, 8]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 15, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 11, 7, 19]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 19, 7, 15]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateIcosahedron\n\t* Description: Generates an icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateIcosahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 6, 10]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 10, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [4, 8, 9]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 8]);\n\t\tJSM.AddPolygonToBody (result, [6, 11, 10]);\n\t\tJSM.AddPolygonToBody (result, [7, 10, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedTetrahedron\n\t* Description: Generates a truncated tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedTetrahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 3.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 7]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 6, 5, 9, 8]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 7, 11, 10, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 7, 4, 8, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 6, 10, 11, 3]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboctahedron\n\t* Description: Generates a cuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 5, 11]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 7, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6]);\n\t\tJSM.AddPolygonToBody (result, [3, 6, 8]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 7]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 4, 1, 5]);\n\t\tJSM.AddPolygonToBody (result, [0, 11, 3, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 2, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 3, 7]);\n\t\tJSM.AddPolygonToBody (result, [4, 8, 6, 10]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 7, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedCube\n\t* Description: Generates a truncated cube.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedCube = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = Math.sqrt (2.0) - 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, -b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 21, 13]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 1, 17, 21, 5, 3, 19, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 10, 2, 4, 12, 9, 1]);\n\t\tJSM.AddPolygonToBody (result, [2, 18, 22, 6, 7, 23, 20, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 5, 13, 15, 7, 6, 14, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 16, 19, 11, 14, 22, 18, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 20, 23, 15, 13, 21, 17]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedOctahedron\n\t* Description: Generates a truncated octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedOctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, +b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +c, +a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, -a, +b);\n\n\t\tJSM.AddPolygonToBody (result, [0, 10, 2, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 3, 11]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [5, 15, 7, 13]);\n\t\tJSM.AddPolygonToBody (result, [16, 22, 18, 20]);\n\t\tJSM.AddPolygonToBody (result, [17, 21, 19, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 4, 14, 21, 17, 10]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 16, 20, 12, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 6, 12, 20, 18, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 19, 21, 14, 6]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 13, 22, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 17, 23, 15, 5]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 15, 23, 19, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 9, 18, 22, 13, 7]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRhombicuboctahedron\n\t* Description: Generates a rhombicuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 1.0 + Math.sqrt (2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, -b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 21, 13]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 18, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 11, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 13, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 20, 4]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 22, 6]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 15, 7]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 23, 21]);\n\t\tJSM.AddPolygonToBody (result, [8, 9, 13, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 16, 17, 9]);\n\t\tJSM.AddPolygonToBody (result, [10, 12, 20, 18]);\n\t\tJSM.AddPolygonToBody (result, [10, 14, 15, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 13, 21, 19]);\n\t\tJSM.AddPolygonToBody (result, [14, 22, 23, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 18, 20, 17]);\n\t\tJSM.AddPolygonToBody (result, [19, 21, 23, 22]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedCuboctahedron\n\t* Description: Generates a truncated cuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedCuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 1.0 + Math.sqrt (2.0);\n\t\tvar c = 1.0 + 2.0 * Math.sqrt (2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, +a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, -b, -c);\n\t\tJSM.AddVertexToBody (result, -a, +b, -c);\n\t\tJSM.AddVertexToBody (result, -a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, -b, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, +a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, -b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, -b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\t\tJSM.AddVertexToBody (result, -b, -a, +c);\n\t\tJSM.AddVertexToBody (result, -b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, -b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, -a);\n\t\tJSM.AddVertexToBody (result, -b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, +c, +a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, +a, -b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, -b);\n\t\tJSM.AddVertexToBody (result, -c, -a, +b);\n\t\tJSM.AddVertexToBody (result, +c, -a, -b);\n\t\tJSM.AddVertexToBody (result, -c, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, -b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, -b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\t\tJSM.AddVertexToBody (result, +c, -b, -a);\n\t\tJSM.AddVertexToBody (result, -c, -b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 11, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 13, 9]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 15, 7]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 35, 32]);\n\t\tJSM.AddPolygonToBody (result, [17, 34, 38, 21]);\n\t\tJSM.AddPolygonToBody (result, [18, 33, 37, 22]);\n\t\tJSM.AddPolygonToBody (result, [23, 39, 36, 20]);\n\t\tJSM.AddPolygonToBody (result, [24, 40, 43, 27]);\n\t\tJSM.AddPolygonToBody (result, [25, 29, 46, 42]);\n\t\tJSM.AddPolygonToBody (result, [26, 30, 45, 41]);\n\t\tJSM.AddPolygonToBody (result, [28, 44, 47, 31]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 32, 40, 24, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 27, 43, 34, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 9, 25, 42, 35, 19]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 26, 41, 33, 18]);\n\t\tJSM.AddPolygonToBody (result, [4, 21, 38, 46, 29, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 20, 36, 45, 30, 14]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 37, 44, 28, 13]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 31, 47, 39, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 18, 22, 6, 2, 19, 16]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 21, 4, 7, 23, 20, 5]);\n\t\tJSM.AddPolygonToBody (result, [8, 24, 27, 10, 14, 30, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [9, 13, 28, 31, 15, 12, 29, 25]);\n\t\tJSM.AddPolygonToBody (result, [32, 35, 42, 46, 38, 34, 43, 40]);\n\t\tJSM.AddPolygonToBody (result, [33, 41, 45, 36, 39, 47, 44, 37]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSnubCube\n\t* Description: Generates a snub cube.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSnubCube = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = (1.0 / 3.0) * (Math.pow (17 + 3.0 * Math.sqrt (33.0), 1.0 / 3.0) - Math.pow (-17 + 3.0 * Math.sqrt (33.0), 1.0 / 3.0) - 1.0);\n\t\tvar c = 1.0 / b;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, +a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, -a, -b, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, -b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, +a, -b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, -b);\n\t\tJSM.AddVertexToBody (result, -a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, -b, +a, -c);\n\t\tJSM.AddVertexToBody (result, -b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, -b, +a);\n\t\tJSM.AddVertexToBody (result, +c, -b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\tJSM.AddPolygonToBody (result, [0, 9, 22]);\n\t\tJSM.AddPolygonToBody (result, [0, 17, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 22, 19]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 20]);\n\t\tJSM.AddPolygonToBody (result, [1, 18, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 20, 16]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 8, 21]);\n\t\tJSM.AddPolygonToBody (result, [2, 16, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 21, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 23]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 23, 17]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 10]);\n\t\tJSM.AddPolygonToBody (result, [4, 18, 15]);\n\t\tJSM.AddPolygonToBody (result, [5, 14, 8]);\n\t\tJSM.AddPolygonToBody (result, [5, 16, 12]);\n\t\tJSM.AddPolygonToBody (result, [6, 12, 9]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 11]);\n\t\tJSM.AddPolygonToBody (result, [7, 19, 13]);\n\t\tJSM.AddPolygonToBody (result, [8, 14, 23]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 20]);\n\t\tJSM.AddPolygonToBody (result, [10, 13, 22]);\n\t\tJSM.AddPolygonToBody (result, [11, 15, 21]);\n\t\tJSM.AddPolygonToBody (result, [12, 16, 20]);\n\t\tJSM.AddPolygonToBody (result, [13, 19, 22]);\n\t\tJSM.AddPolygonToBody (result, [14, 17, 23]);\n\t\tJSM.AddPolygonToBody (result, [15, 18, 21]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 19, 3, 17]);\n\t\tJSM.AddPolygonToBody (result, [1, 16, 2, 18]);\n\t\tJSM.AddPolygonToBody (result, [4, 15, 7, 13]);\n\t\tJSM.AddPolygonToBody (result, [5, 12, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [8, 23, 11, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 20, 10, 22]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateIcosidodecahedron\n\t* Description: Generates an icosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateIcosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = 1.0 / 2.0;\n\t\tvar d = b / 2.0;\n\t\tvar e = (1.0 + b) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\n\t\tJSM.AddVertexToBody (result, +c, +d, +e);\n\t\tJSM.AddVertexToBody (result, +c, +d, -e);\n\t\tJSM.AddVertexToBody (result, +c, -d, +e);\n\t\tJSM.AddVertexToBody (result, -c, +d, +e);\n\t\tJSM.AddVertexToBody (result, +c, -d, -e);\n\t\tJSM.AddVertexToBody (result, -c, +d, -e);\n\t\tJSM.AddVertexToBody (result, -c, -d, +e);\n\t\tJSM.AddVertexToBody (result, -c, -d, -e);\n\n\t\tJSM.AddVertexToBody (result, +d, +e, +c);\n\t\tJSM.AddVertexToBody (result, +d, -e, +c);\n\t\tJSM.AddVertexToBody (result, -d, +e, +c);\n\t\tJSM.AddVertexToBody (result, +d, +e, -c);\n\t\tJSM.AddVertexToBody (result, -d, -e, +c);\n\t\tJSM.AddVertexToBody (result, +d, -e, -c);\n\t\tJSM.AddVertexToBody (result, -d, +e, -c);\n\t\tJSM.AddVertexToBody (result, -d, -e, -c);\n\n\t\tJSM.AddVertexToBody (result, +e, +c, +d);\n\t\tJSM.AddVertexToBody (result, -e, +c, +d);\n\t\tJSM.AddVertexToBody (result, +e, +c, -d);\n\t\tJSM.AddVertexToBody (result, +e, -c, +d);\n\t\tJSM.AddVertexToBody (result, -e, +c, -d);\n\t\tJSM.AddVertexToBody (result, -e, -c, +d);\n\t\tJSM.AddVertexToBody (result, +e, -c, -d);\n\t\tJSM.AddVertexToBody (result, -e, -c, -d);\n\n\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\tJSM.AddPolygonToBody (result, [0, 12, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 13]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 7]);\n\t\tJSM.AddPolygonToBody (result, [2, 14, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 20, 16]);\n\t\tJSM.AddPolygonToBody (result, [3, 18, 21]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 15]);\n\t\tJSM.AddPolygonToBody (result, [4, 22, 25]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 24]);\n\t\tJSM.AddPolygonToBody (result, [5, 26, 29]);\n\t\tJSM.AddPolygonToBody (result, [5, 27, 23]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 17, 24]);\n\t\tJSM.AddPolygonToBody (result, [8, 15, 25]);\n\t\tJSM.AddPolygonToBody (result, [9, 16, 23]);\n\t\tJSM.AddPolygonToBody (result, [10, 28, 19]);\n\t\tJSM.AddPolygonToBody (result, [11, 26, 20]);\n\t\tJSM.AddPolygonToBody (result, [12, 27, 18]);\n\t\tJSM.AddPolygonToBody (result, [13, 21, 29]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 25, 22, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 9, 23, 27, 12]);\n\t\tJSM.AddPolygonToBody (result, [1, 7, 24, 28, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 29, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [2, 16, 9, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [2, 17, 7, 11, 20]);\n\t\tJSM.AddPolygonToBody (result, [3, 15, 8, 12, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 21, 13, 10, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 24, 17, 14, 22]);\n\t\tJSM.AddPolygonToBody (result, [4, 25, 15, 19, 28]);\n\t\tJSM.AddPolygonToBody (result, [5, 23, 16, 20, 26]);\n\t\tJSM.AddPolygonToBody (result, [5, 29, 21, 18, 27]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedDodecahedron\n\t* Description: Generates a truncated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 2.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\t\tvar e = 2.0 + c;\n\t\tvar f = 2.0 * c;\n\t\tvar g = Math.pow (c, 2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +d, +e);\n\t\tJSM.AddVertexToBody (result, +a, +d, -e);\n\t\tJSM.AddVertexToBody (result, +a, -d, +e);\n\t\tJSM.AddVertexToBody (result, +a, -d, -e);\n\n\t\tJSM.AddVertexToBody (result, +e, +a, +d);\n\t\tJSM.AddVertexToBody (result, -e, +a, +d);\n\t\tJSM.AddVertexToBody (result, +e, +a, -d);\n\t\tJSM.AddVertexToBody (result, -e, +a, -d);\n\n\t\tJSM.AddVertexToBody (result, +d, +e, +a);\n\t\tJSM.AddVertexToBody (result, +d, -e, +a);\n\t\tJSM.AddVertexToBody (result, -d, +e, +a);\n\t\tJSM.AddVertexToBody (result, -d, -e, +a);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +g);\n\t\tJSM.AddVertexToBody (result, +c, +b, -g);\n\t\tJSM.AddVertexToBody (result, +c, -b, +g);\n\t\tJSM.AddVertexToBody (result, -c, +b, +g);\n\t\tJSM.AddVertexToBody (result, +c, -b, -g);\n\t\tJSM.AddVertexToBody (result, -c, +b, -g);\n\t\tJSM.AddVertexToBody (result, -c, -b, +g);\n\t\tJSM.AddVertexToBody (result, -c, -b, -g);\n\n\t\tJSM.AddVertexToBody (result, +g, +c, +b);\n\t\tJSM.AddVertexToBody (result, +g, +c, -b);\n\t\tJSM.AddVertexToBody (result, +g, -c, +b);\n\t\tJSM.AddVertexToBody (result, -g, +c, +b);\n\t\tJSM.AddVertexToBody (result, +g, -c, -b);\n\t\tJSM.AddVertexToBody (result, -g, +c, -b);\n\t\tJSM.AddVertexToBody (result, -g, -c, +b);\n\t\tJSM.AddVertexToBody (result, -g, -c, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +g, +c);\n\t\tJSM.AddVertexToBody (result, +b, +g, -c);\n\t\tJSM.AddVertexToBody (result, +b, -g, +c);\n\t\tJSM.AddVertexToBody (result, -b, +g, +c);\n\t\tJSM.AddVertexToBody (result, +b, -g, -c);\n\t\tJSM.AddVertexToBody (result, -b, +g, -c);\n\t\tJSM.AddVertexToBody (result, -b, -g, +c);\n\t\tJSM.AddVertexToBody (result, -b, -g, -c);\n\n\t\tJSM.AddPolygonToBody (result, [0, 12, 15]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 13]);\n\t\tJSM.AddPolygonToBody (result, [2, 18, 14]);\n\t\tJSM.AddPolygonToBody (result, [3, 16, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 22]);\n\t\tJSM.AddPolygonToBody (result, [5, 26, 23]);\n\t\tJSM.AddPolygonToBody (result, [6, 24, 21]);\n\t\tJSM.AddPolygonToBody (result, [7, 25, 27]);\n\t\tJSM.AddPolygonToBody (result, [8, 28, 29]);\n\t\tJSM.AddPolygonToBody (result, [9, 32, 30]);\n\t\tJSM.AddPolygonToBody (result, [10, 33, 31]);\n\t\tJSM.AddPolygonToBody (result, [11, 34, 35]);\n\t\tJSM.AddPolygonToBody (result, [36, 44, 52]);\n\t\tJSM.AddPolygonToBody (result, [37, 53, 45]);\n\t\tJSM.AddPolygonToBody (result, [38, 54, 46]);\n\t\tJSM.AddPolygonToBody (result, [39, 55, 47]);\n\t\tJSM.AddPolygonToBody (result, [40, 48, 56]);\n\t\tJSM.AddPolygonToBody (result, [41, 49, 57]);\n\t\tJSM.AddPolygonToBody (result, [42, 50, 58]);\n\t\tJSM.AddPolygonToBody (result, [43, 59, 51]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 14, 38, 46, 22, 20, 44, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 15, 39, 47, 23, 26, 50, 42, 18, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 19, 43, 51, 27, 25, 49, 41, 17]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 37, 45, 21, 24, 48, 40, 16, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 6, 21, 45, 53, 29, 28, 52, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [4, 22, 46, 54, 30, 32, 56, 48, 24, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 27, 51, 59, 35, 34, 58, 50, 26]);\n\t\tJSM.AddPolygonToBody (result, [5, 23, 47, 55, 31, 33, 57, 49, 25, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 31, 55, 39, 15, 12, 36, 52, 28]);\n\t\tJSM.AddPolygonToBody (result, [8, 29, 53, 37, 13, 17, 41, 57, 33, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 11, 35, 59, 43, 19, 16, 40, 56, 32]);\n\t\tJSM.AddPolygonToBody (result, [9, 30, 54, 38, 14, 18, 42, 58, 34, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedIcosahedron\n\t* Description: Generates a truncated icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedIcosahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 1.0;\n\t\tvar c = 2.0;\n\t\tvar d = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar e = 3.0 * d;\n\t\tvar f = 1.0 + 2.0 * d;\n\t\tvar g = 2.0 + d;\n\t\tvar h = 2.0 * d;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +e);\n\t\tJSM.AddVertexToBody (result, +a, +b, -e);\n\t\tJSM.AddVertexToBody (result, +a, -b, +e);\n\t\tJSM.AddVertexToBody (result, +a, -b, -e);\n\n\t\tJSM.AddVertexToBody (result, +b, +e, +a);\n\t\tJSM.AddVertexToBody (result, +b, -e, +a);\n\t\tJSM.AddVertexToBody (result, -b, +e, +a);\n\t\tJSM.AddVertexToBody (result, -b, -e, +a);\n\n\t\tJSM.AddVertexToBody (result, +e, +a, +b);\n\t\tJSM.AddVertexToBody (result, -e, +a, +b);\n\t\tJSM.AddVertexToBody (result, +e, +a, -b);\n\t\tJSM.AddVertexToBody (result, -e, +a, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +b, +g, +h);\n\t\tJSM.AddVertexToBody (result, +b, +g, -h);\n\t\tJSM.AddVertexToBody (result, +b, -g, +h);\n\t\tJSM.AddVertexToBody (result, -b, +g, +h);\n\t\tJSM.AddVertexToBody (result, +b, -g, -h);\n\t\tJSM.AddVertexToBody (result, -b, +g, -h);\n\t\tJSM.AddVertexToBody (result, -b, -g, +h);\n\t\tJSM.AddVertexToBody (result, -b, -g, -h);\n\n\t\tJSM.AddVertexToBody (result, +g, +h, +b);\n\t\tJSM.AddVertexToBody (result, +g, -h, +b);\n\t\tJSM.AddVertexToBody (result, -g, +h, +b);\n\t\tJSM.AddVertexToBody (result, +g, +h, -b);\n\t\tJSM.AddVertexToBody (result, -g, -h, +b);\n\t\tJSM.AddVertexToBody (result, +g, -h, -b);\n\t\tJSM.AddVertexToBody (result, -g, +h, -b);\n\t\tJSM.AddVertexToBody (result, -g, -h, -b);\n\n\t\tJSM.AddVertexToBody (result, +h, +b, +g);\n\t\tJSM.AddVertexToBody (result, -h, +b, +g);\n\t\tJSM.AddVertexToBody (result, +h, +b, -g);\n\t\tJSM.AddVertexToBody (result, +h, -b, +g);\n\t\tJSM.AddVertexToBody (result, -h, +b, -g);\n\t\tJSM.AddVertexToBody (result, -h, -b, +g);\n\t\tJSM.AddVertexToBody (result, +h, -b, -g);\n\t\tJSM.AddVertexToBody (result, -h, -b, -g);\n\n\t\tJSM.AddPolygonToBody (result, [0, 28, 36, 39, 29]);\n\t\tJSM.AddPolygonToBody (result, [1, 32, 41, 37, 30]);\n\t\tJSM.AddPolygonToBody (result, [2, 33, 42, 38, 31]);\n\t\tJSM.AddPolygonToBody (result, [3, 34, 40, 43, 35]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 44, 47, 13]);\n\t\tJSM.AddPolygonToBody (result, [5, 16, 49, 45, 14]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 50, 46, 15]);\n\t\tJSM.AddPolygonToBody (result, [7, 18, 48, 51, 19]);\n\t\tJSM.AddPolygonToBody (result, [8, 20, 52, 55, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 24, 57, 53, 22]);\n\t\tJSM.AddPolygonToBody (result, [10, 25, 58, 54, 23]);\n\t\tJSM.AddPolygonToBody (result, [11, 26, 56, 59, 27]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 31, 55, 52, 28]);\n\t\tJSM.AddPolygonToBody (result, [0, 29, 53, 57, 33, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 35, 59, 56, 32]);\n\t\tJSM.AddPolygonToBody (result, [1, 30, 54, 58, 34, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 6, 15, 39, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 37, 41, 17, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 19, 43, 40, 16]);\n\t\tJSM.AddPolygonToBody (result, [5, 14, 38, 42, 18, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 23, 47, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [8, 21, 45, 49, 25, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 11, 27, 51, 48, 24]);\n\t\tJSM.AddPolygonToBody (result, [9, 22, 46, 50, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 28, 52, 20, 44]);\n\t\tJSM.AddPolygonToBody (result, [13, 47, 23, 54, 30, 37]);\n\t\tJSM.AddPolygonToBody (result, [14, 45, 21, 55, 31, 38]);\n\t\tJSM.AddPolygonToBody (result, [15, 46, 22, 53, 29, 39]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 34, 58, 25, 49]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 32, 56, 26, 50]);\n\t\tJSM.AddPolygonToBody (result, [18, 42, 33, 57, 24, 48]);\n\t\tJSM.AddPolygonToBody (result, [19, 51, 27, 59, 35, 43]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRhombicosidodecahedron\n\t* Description: Generates a rhombicosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 1.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = Math.pow (c, 2.0);\n\t\tvar e = Math.pow (c, 3.0);\n\t\tvar f = 2.0 * c;\n\t\tvar g = 2.0 + c;\n\n\t\tJSM.AddVertexToBody (result, +b, +b, +e);\n\t\tJSM.AddVertexToBody (result, +b, +b, -e);\n\t\tJSM.AddVertexToBody (result, +b, -b, +e);\n\t\tJSM.AddVertexToBody (result, -b, +b, +e);\n\t\tJSM.AddVertexToBody (result, +b, -b, -e);\n\t\tJSM.AddVertexToBody (result, -b, +b, -e);\n\t\tJSM.AddVertexToBody (result, -b, -b, +e);\n\t\tJSM.AddVertexToBody (result, -b, -b, -e);\n\n\t\tJSM.AddVertexToBody (result, +e, +b, +b);\n\t\tJSM.AddVertexToBody (result, +e, +b, -b);\n\t\tJSM.AddVertexToBody (result, +e, -b, +b);\n\t\tJSM.AddVertexToBody (result, -e, +b, +b);\n\t\tJSM.AddVertexToBody (result, +e, -b, -b);\n\t\tJSM.AddVertexToBody (result, -e, +b, -b);\n\t\tJSM.AddVertexToBody (result, -e, -b, +b);\n\t\tJSM.AddVertexToBody (result, -e, -b, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +e, +b);\n\t\tJSM.AddVertexToBody (result, +b, +e, -b);\n\t\tJSM.AddVertexToBody (result, +b, -e, +b);\n\t\tJSM.AddVertexToBody (result, -b, +e, +b);\n\t\tJSM.AddVertexToBody (result, +b, -e, -b);\n\t\tJSM.AddVertexToBody (result, -b, +e, -b);\n\t\tJSM.AddVertexToBody (result, -b, -e, +b);\n\t\tJSM.AddVertexToBody (result, -b, -e, -b);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +g, +a, +d);\n\t\tJSM.AddVertexToBody (result, +g, +a, -d);\n\t\tJSM.AddVertexToBody (result, -g, +a, +d);\n\t\tJSM.AddVertexToBody (result, -g, +a, -d);\n\n\t\tJSM.AddVertexToBody (result, +d, +g, +a);\n\t\tJSM.AddVertexToBody (result, -d, +g, +a);\n\t\tJSM.AddVertexToBody (result, +d, -g, +a);\n\t\tJSM.AddVertexToBody (result, -d, -g, +a);\n\n\t\tJSM.AddVertexToBody (result, +a, +d, +g);\n\t\tJSM.AddVertexToBody (result, +a, -d, +g);\n\t\tJSM.AddVertexToBody (result, +a, +d, -g);\n\t\tJSM.AddVertexToBody (result, +a, -d, -g);\n\n\t\tJSM.AddPolygonToBody (result, [0, 56, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 58]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 57]);\n\t\tJSM.AddPolygonToBody (result, [4, 59, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 48, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 49]);\n\t\tJSM.AddPolygonToBody (result, [11, 14, 50]);\n\t\tJSM.AddPolygonToBody (result, [13, 51, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 52, 17]);\n\t\tJSM.AddPolygonToBody (result, [18, 20, 54]);\n\t\tJSM.AddPolygonToBody (result, [19, 21, 53]);\n\t\tJSM.AddPolygonToBody (result, [22, 55, 23]);\n\t\tJSM.AddPolygonToBody (result, [24, 32, 40]);\n\t\tJSM.AddPolygonToBody (result, [25, 41, 33]);\n\t\tJSM.AddPolygonToBody (result, [26, 42, 34]);\n\t\tJSM.AddPolygonToBody (result, [27, 43, 35]);\n\t\tJSM.AddPolygonToBody (result, [28, 36, 44]);\n\t\tJSM.AddPolygonToBody (result, [29, 37, 45]);\n\t\tJSM.AddPolygonToBody (result, [30, 38, 46]);\n\t\tJSM.AddPolygonToBody (result, [31, 47, 39]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [0, 24, 40, 56]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 58, 41, 25]);\n\t\tJSM.AddPolygonToBody (result, [2, 57, 42, 26]);\n\t\tJSM.AddPolygonToBody (result, [3, 56, 43, 27]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 44, 59]);\n\t\tJSM.AddPolygonToBody (result, [5, 29, 45, 58]);\n\t\tJSM.AddPolygonToBody (result, [6, 30, 46, 57]);\n\t\tJSM.AddPolygonToBody (result, [7, 59, 47, 31]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 12, 9]);\n\t\tJSM.AddPolygonToBody (result, [8, 32, 24, 48]);\n\t\tJSM.AddPolygonToBody (result, [9, 49, 25, 33]);\n\t\tJSM.AddPolygonToBody (result, [10, 48, 26, 34]);\n\t\tJSM.AddPolygonToBody (result, [11, 13, 15, 14]);\n\t\tJSM.AddPolygonToBody (result, [11, 50, 27, 35]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 28, 49]);\n\t\tJSM.AddPolygonToBody (result, [13, 37, 29, 51]);\n\t\tJSM.AddPolygonToBody (result, [14, 38, 30, 50]);\n\t\tJSM.AddPolygonToBody (result, [15, 51, 31, 39]);\n\t\tJSM.AddPolygonToBody (result, [16, 17, 21, 19]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 32, 52]);\n\t\tJSM.AddPolygonToBody (result, [17, 52, 33, 41]);\n\t\tJSM.AddPolygonToBody (result, [18, 22, 23, 20]);\n\t\tJSM.AddPolygonToBody (result, [18, 54, 34, 42]);\n\t\tJSM.AddPolygonToBody (result, [19, 53, 35, 43]);\n\t\tJSM.AddPolygonToBody (result, [20, 44, 36, 54]);\n\t\tJSM.AddPolygonToBody (result, [21, 45, 37, 53]);\n\t\tJSM.AddPolygonToBody (result, [22, 46, 38, 55]);\n\t\tJSM.AddPolygonToBody (result, [23, 55, 39, 47]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 26, 48, 24]);\n\t\tJSM.AddPolygonToBody (result, [1, 25, 49, 28, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 27, 50, 30, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 31, 51, 29]);\n\t\tJSM.AddPolygonToBody (result, [8, 9, 33, 52, 32]);\n\t\tJSM.AddPolygonToBody (result, [10, 34, 54, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 35, 53, 37, 13]);\n\t\tJSM.AddPolygonToBody (result, [14, 15, 39, 55, 38]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 43, 56, 40]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 58, 45, 21]);\n\t\tJSM.AddPolygonToBody (result, [18, 42, 57, 46, 22]);\n\t\tJSM.AddPolygonToBody (result, [20, 23, 47, 59, 44]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedIcosidodecahedron\n\t* Description: Generates a truncated icosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedIcosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 2.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = 1.0 / b;\n\t\tvar d = 3.0 + b;\n\t\tvar e = 2.0 / b;\n\t\tvar f = 1 + 2.0 * b;\n\t\tvar g = Math.pow (b, 2.0);\n\t\tvar h = -1.0 + 3.0 * b;\n\t\tvar i = -1.0 + 2.0 * b;\n\t\tvar j = 2.0 + b;\n\t\tvar k = 3.0;\n\t\tvar l = 2.0 * b;\n\n\t\tJSM.AddVertexToBody (result, +c, +c, +d);\n\t\tJSM.AddVertexToBody (result, +c, +c, -d);\n\t\tJSM.AddVertexToBody (result, +c, -c, +d);\n\t\tJSM.AddVertexToBody (result, -c, +c, +d);\n\t\tJSM.AddVertexToBody (result, +c, -c, -d);\n\t\tJSM.AddVertexToBody (result, -c, +c, -d);\n\t\tJSM.AddVertexToBody (result, -c, -c, +d);\n\t\tJSM.AddVertexToBody (result, -c, -c, -d);\n\n\t\tJSM.AddVertexToBody (result, +c, +d, +c);\n\t\tJSM.AddVertexToBody (result, +c, -d, +c);\n\t\tJSM.AddVertexToBody (result, -c, +d, +c);\n\t\tJSM.AddVertexToBody (result, +c, +d, -c);\n\t\tJSM.AddVertexToBody (result, -c, -d, +c);\n\t\tJSM.AddVertexToBody (result, +c, -d, -c);\n\t\tJSM.AddVertexToBody (result, -c, +d, -c);\n\t\tJSM.AddVertexToBody (result, -c, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +c);\n\t\tJSM.AddVertexToBody (result, -d, +c, +c);\n\t\tJSM.AddVertexToBody (result, +d, +c, -c);\n\t\tJSM.AddVertexToBody (result, +d, -c, +c);\n\t\tJSM.AddVertexToBody (result, -d, +c, -c);\n\t\tJSM.AddVertexToBody (result, -d, -c, +c);\n\t\tJSM.AddVertexToBody (result, +d, -c, -c);\n\t\tJSM.AddVertexToBody (result, -d, -c, -c);\n\n\t\tJSM.AddVertexToBody (result, +e, +b, +f);\n\t\tJSM.AddVertexToBody (result, +e, +b, -f);\n\t\tJSM.AddVertexToBody (result, +e, -b, +f);\n\t\tJSM.AddVertexToBody (result, -e, +b, +f);\n\t\tJSM.AddVertexToBody (result, +e, -b, -f);\n\t\tJSM.AddVertexToBody (result, -e, +b, -f);\n\t\tJSM.AddVertexToBody (result, -e, -b, +f);\n\t\tJSM.AddVertexToBody (result, -e, -b, -f);\n\n\t\tJSM.AddVertexToBody (result, +b, +f, +e);\n\t\tJSM.AddVertexToBody (result, +b, -f, +e);\n\t\tJSM.AddVertexToBody (result, -b, +f, +e);\n\t\tJSM.AddVertexToBody (result, +b, +f, -e);\n\t\tJSM.AddVertexToBody (result, -b, -f, +e);\n\t\tJSM.AddVertexToBody (result, +b, -f, -e);\n\t\tJSM.AddVertexToBody (result, -b, +f, -e);\n\t\tJSM.AddVertexToBody (result, -b, -f, -e);\n\n\t\tJSM.AddVertexToBody (result, +f, +e, +b);\n\t\tJSM.AddVertexToBody (result, -f, +e, +b);\n\t\tJSM.AddVertexToBody (result, +f, +e, -b);\n\t\tJSM.AddVertexToBody (result, +f, -e, +b);\n\t\tJSM.AddVertexToBody (result, -f, +e, -b);\n\t\tJSM.AddVertexToBody (result, -f, -e, +b);\n\t\tJSM.AddVertexToBody (result, +f, -e, -b);\n\t\tJSM.AddVertexToBody (result, -f, -e, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +g, +h);\n\t\tJSM.AddVertexToBody (result, +c, +g, -h);\n\t\tJSM.AddVertexToBody (result, +c, -g, +h);\n\t\tJSM.AddVertexToBody (result, -c, +g, +h);\n\t\tJSM.AddVertexToBody (result, +c, -g, -h);\n\t\tJSM.AddVertexToBody (result, -c, +g, -h);\n\t\tJSM.AddVertexToBody (result, -c, -g, +h);\n\t\tJSM.AddVertexToBody (result, -c, -g, -h);\n\n\t\tJSM.AddVertexToBody (result, +g, +h, +c);\n\t\tJSM.AddVertexToBody (result, +g, -h, +c);\n\t\tJSM.AddVertexToBody (result, -g, +h, +c);\n\t\tJSM.AddVertexToBody (result, +g, +h, -c);\n\t\tJSM.AddVertexToBody (result, -g, -h, +c);\n\t\tJSM.AddVertexToBody (result, +g, -h, -c);\n\t\tJSM.AddVertexToBody (result, -g, +h, -c);\n\t\tJSM.AddVertexToBody (result, -g, -h, -c);\n\n\t\tJSM.AddVertexToBody (result, +h, +c, +g);\n\t\tJSM.AddVertexToBody (result, -h, +c, +g);\n\t\tJSM.AddVertexToBody (result, +h, +c, -g);\n\t\tJSM.AddVertexToBody (result, +h, -c, +g);\n\t\tJSM.AddVertexToBody (result, -h, +c, -g);\n\t\tJSM.AddVertexToBody (result, -h, -c, +g);\n\t\tJSM.AddVertexToBody (result, +h, -c, -g);\n\t\tJSM.AddVertexToBody (result, -h, -c, -g);\n\n\t\tJSM.AddVertexToBody (result, +i, +a, +j);\n\t\tJSM.AddVertexToBody (result, +i, +a, -j);\n\t\tJSM.AddVertexToBody (result, +i, -a, +j);\n\t\tJSM.AddVertexToBody (result, -i, +a, +j);\n\t\tJSM.AddVertexToBody (result, +i, -a, -j);\n\t\tJSM.AddVertexToBody (result, -i, +a, -j);\n\t\tJSM.AddVertexToBody (result, -i, -a, +j);\n\t\tJSM.AddVertexToBody (result, -i, -a, -j);\n\n\t\tJSM.AddVertexToBody (result, +a, +j, +i);\n\t\tJSM.AddVertexToBody (result, +a, -j, +i);\n\t\tJSM.AddVertexToBody (result, -a, +j, +i);\n\t\tJSM.AddVertexToBody (result, +a, +j, -i);\n\t\tJSM.AddVertexToBody (result, -a, -j, +i);\n\t\tJSM.AddVertexToBody (result, +a, -j, -i);\n\t\tJSM.AddVertexToBody (result, -a, +j, -i);\n\t\tJSM.AddVertexToBody (result, -a, -j, -i);\n\n\t\tJSM.AddVertexToBody (result, +j, +i, +a);\n\t\tJSM.AddVertexToBody (result, -j, +i, +a);\n\t\tJSM.AddVertexToBody (result, +j, +i, -a);\n\t\tJSM.AddVertexToBody (result, +j, -i, +a);\n\t\tJSM.AddVertexToBody (result, -j, +i, -a);\n\t\tJSM.AddVertexToBody (result, -j, -i, +a);\n\t\tJSM.AddVertexToBody (result, +j, -i, -a);\n\t\tJSM.AddVertexToBody (result, -j, -i, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +k, +l);\n\t\tJSM.AddVertexToBody (result, +b, +k, -l);\n\t\tJSM.AddVertexToBody (result, +b, -k, +l);\n\t\tJSM.AddVertexToBody (result, -b, +k, +l);\n\t\tJSM.AddVertexToBody (result, +b, -k, -l);\n\t\tJSM.AddVertexToBody (result, -b, +k, -l);\n\t\tJSM.AddVertexToBody (result, -b, -k, +l);\n\t\tJSM.AddVertexToBody (result, -b, -k, -l);\n\n\t\tJSM.AddVertexToBody (result, +k, +l, +b);\n\t\tJSM.AddVertexToBody (result, +k, -l, +b);\n\t\tJSM.AddVertexToBody (result, -k, +l, +b);\n\t\tJSM.AddVertexToBody (result, +k, +l, -b);\n\t\tJSM.AddVertexToBody (result, -k, -l, +b);\n\t\tJSM.AddVertexToBody (result, +k, -l, -b);\n\t\tJSM.AddVertexToBody (result, -k, +l, -b);\n\t\tJSM.AddVertexToBody (result, -k, -l, -b);\n\n\t\tJSM.AddVertexToBody (result, +l, +b, +k);\n\t\tJSM.AddVertexToBody (result, -l, +b, +k);\n\t\tJSM.AddVertexToBody (result, +l, +b, -k);\n\t\tJSM.AddVertexToBody (result, +l, -b, +k);\n\t\tJSM.AddVertexToBody (result, -l, +b, -k);\n\t\tJSM.AddVertexToBody (result, -l, -b, +k);\n\t\tJSM.AddVertexToBody (result, +l, -b, -k);\n\t\tJSM.AddVertexToBody (result, -l, -b, -k);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [8, 11, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 15, 13]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 22, 18]);\n\t\tJSM.AddPolygonToBody (result, [17, 20, 23, 21]);\n\t\tJSM.AddPolygonToBody (result, [24, 72, 96, 48]);\n\t\tJSM.AddPolygonToBody (result, [25, 49, 97, 73]);\n\t\tJSM.AddPolygonToBody (result, [26, 50, 98, 74]);\n\t\tJSM.AddPolygonToBody (result, [27, 51, 99, 75]);\n\t\tJSM.AddPolygonToBody (result, [28, 76, 100, 52]);\n\t\tJSM.AddPolygonToBody (result, [29, 77, 101, 53]);\n\t\tJSM.AddPolygonToBody (result, [30, 78, 102, 54]);\n\t\tJSM.AddPolygonToBody (result, [31, 55, 103, 79]);\n\t\tJSM.AddPolygonToBody (result, [32, 80, 104, 56]);\n\t\tJSM.AddPolygonToBody (result, [33, 57, 105, 81]);\n\t\tJSM.AddPolygonToBody (result, [34, 58, 106, 82]);\n\t\tJSM.AddPolygonToBody (result, [35, 59, 107, 83]);\n\t\tJSM.AddPolygonToBody (result, [36, 84, 108, 60]);\n\t\tJSM.AddPolygonToBody (result, [37, 85, 109, 61]);\n\t\tJSM.AddPolygonToBody (result, [38, 86, 110, 62]);\n\t\tJSM.AddPolygonToBody (result, [39, 63, 111, 87]);\n\t\tJSM.AddPolygonToBody (result, [40, 88, 112, 64]);\n\t\tJSM.AddPolygonToBody (result, [41, 65, 113, 89]);\n\t\tJSM.AddPolygonToBody (result, [42, 66, 114, 90]);\n\t\tJSM.AddPolygonToBody (result, [43, 67, 115, 91]);\n\t\tJSM.AddPolygonToBody (result, [44, 92, 116, 68]);\n\t\tJSM.AddPolygonToBody (result, [45, 93, 117, 69]);\n\t\tJSM.AddPolygonToBody (result, [46, 94, 118, 70]);\n\t\tJSM.AddPolygonToBody (result, [47, 71, 119, 95]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 24, 48, 51, 27, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 29, 53, 49, 25]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 30, 54, 50, 26]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 52, 55, 31, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 32, 56, 59, 35, 11]);\n\t\tJSM.AddPolygonToBody (result, [9, 13, 37, 61, 57, 33]);\n\t\tJSM.AddPolygonToBody (result, [10, 14, 38, 62, 58, 34]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 60, 63, 39, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 64, 67, 43, 19]);\n\t\tJSM.AddPolygonToBody (result, [17, 21, 45, 69, 65, 41]);\n\t\tJSM.AddPolygonToBody (result, [18, 22, 46, 70, 66, 42]);\n\t\tJSM.AddPolygonToBody (result, [20, 44, 68, 71, 47, 23]);\n\t\tJSM.AddPolygonToBody (result, [72, 112, 88, 104, 80, 96]);\n\t\tJSM.AddPolygonToBody (result, [73, 97, 83, 107, 90, 114]);\n\t\tJSM.AddPolygonToBody (result, [74, 98, 81, 105, 91, 115]);\n\t\tJSM.AddPolygonToBody (result, [75, 99, 82, 106, 89, 113]);\n\t\tJSM.AddPolygonToBody (result, [76, 118, 94, 109, 85, 100]);\n\t\tJSM.AddPolygonToBody (result, [78, 117, 93, 108, 84, 102]);\n\t\tJSM.AddPolygonToBody (result, [79, 103, 87, 111, 95, 119]);\n\t\tJSM.AddPolygonToBody (result, [86, 101, 77, 116, 92, 110]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 26, 74, 115, 67, 64, 112, 72, 24]);\n\t\tJSM.AddPolygonToBody (result, [1, 25, 73, 114, 66, 70, 118, 76, 28, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 27, 75, 113, 65, 69, 117, 78, 30, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 31, 79, 119, 71, 68, 116, 77, 29]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 34, 82, 99, 51, 48, 96, 80, 32]);\n\t\tJSM.AddPolygonToBody (result, [9, 33, 81, 98, 50, 54, 102, 84, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 35, 83, 97, 49, 53, 101, 86, 38, 14]);\n\t\tJSM.AddPolygonToBody (result, [13, 15, 39, 87, 103, 55, 52, 100, 85, 37]);\n\t\tJSM.AddPolygonToBody (result, [16, 18, 42, 90, 107, 59, 56, 104, 88, 40]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 89, 106, 58, 62, 110, 92, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [19, 43, 91, 105, 57, 61, 109, 94, 46, 22]);\n\t\tJSM.AddPolygonToBody (result, [21, 23, 47, 95, 111, 63, 60, 108, 93, 45]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSnubDodecahedron\n\t* Description: Generates a snub dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSnubDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 2.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = Math.pow (b / 2.0 + (1.0 / 2.0) * Math.sqrt (b - (5.0 / 27.0)), 1.0 / 3.0) + Math.pow (b / 2.0 - (1.0 / 2.0) * Math.sqrt (b - (5.0 / 27.0)), 1.0 / 3.0);\n\t\tvar d = c - (1.0 / c);\n\t\tvar e = c * b + Math.pow (b, 2.0) + b / c;\n\t\tvar f = 2.0 * d;\n\t\tvar g = 2.0 * e;\n\t\tvar h = d + (e / b) + b;\n\t\tvar i = -(d * b) + e + (1.0 / b);\n\t\tvar j = (d / b) + (e * b) - 1.0;\n\t\tvar k = -(d / b) + (e * b) + 1.0;\n\t\tvar l = -d + (e / b) - b;\n\t\tvar m = (d * b) + e - (1.0 / b);\n\t\tvar n = -(d / b) + (e * b) - 1.0;\n\t\tvar o = d - (e / b) - b;\n\t\tvar p = (d * b) + e + (1.0 / b);\n\t\tvar q = d + (e / b) - b;\n\t\tvar r = (d * b) - e + (1.0 / b);\n\t\tvar s = (d / b) + (e * b) + 1.0;\n\n\t\tJSM.AddVertexToBody (result, +f, +a, -g);\n\t\tJSM.AddVertexToBody (result, +f, -a, +g);\n\t\tJSM.AddVertexToBody (result, -f, +a, +g);\n\t\tJSM.AddVertexToBody (result, -f, -a, -g);\n\n\t\tJSM.AddVertexToBody (result, +a, -g, +f);\n\t\tJSM.AddVertexToBody (result, -a, +g, +f);\n\t\tJSM.AddVertexToBody (result, +a, +g, -f);\n\t\tJSM.AddVertexToBody (result, -a, -g, -f);\n\n\t\tJSM.AddVertexToBody (result, -g, +f, +a);\n\t\tJSM.AddVertexToBody (result, +g, +f, -a);\n\t\tJSM.AddVertexToBody (result, +g, -f, +a);\n\t\tJSM.AddVertexToBody (result, -g, -f, -a);\n\n\t\tJSM.AddVertexToBody (result, +h, +i, -j);\n\t\tJSM.AddVertexToBody (result, +h, -i, +j);\n\t\tJSM.AddVertexToBody (result, -h, +i, +j);\n\t\tJSM.AddVertexToBody (result, -h, -i, -j);\n\n\t\tJSM.AddVertexToBody (result, +i, -j, +h);\n\t\tJSM.AddVertexToBody (result, -i, +j, +h);\n\t\tJSM.AddVertexToBody (result, +i, +j, -h);\n\t\tJSM.AddVertexToBody (result, -i, -j, -h);\n\n\t\tJSM.AddVertexToBody (result, -j, +h, +i);\n\t\tJSM.AddVertexToBody (result, +j, +h, -i);\n\t\tJSM.AddVertexToBody (result, +j, -h, +i);\n\t\tJSM.AddVertexToBody (result, -j, -h, -i);\n\n\t\tJSM.AddVertexToBody (result, +k, +l, -m);\n\t\tJSM.AddVertexToBody (result, +k, -l, +m);\n\t\tJSM.AddVertexToBody (result, -k, +l, +m);\n\t\tJSM.AddVertexToBody (result, -k, -l, -m);\n\n\t\tJSM.AddVertexToBody (result, +l, -m, +k);\n\t\tJSM.AddVertexToBody (result, -l, +m, +k);\n\t\tJSM.AddVertexToBody (result, +l, +m, -k);\n\t\tJSM.AddVertexToBody (result, -l, -m, -k);\n\n\t\tJSM.AddVertexToBody (result, -m, +k, +l);\n\t\tJSM.AddVertexToBody (result, +m, +k, -l);\n\t\tJSM.AddVertexToBody (result, +m, -k, +l);\n\t\tJSM.AddVertexToBody (result, -m, -k, -l);\n\n\t\tJSM.AddVertexToBody (result, +n, +o, -p);\n\t\tJSM.AddVertexToBody (result, +n, -o, +p);\n\t\tJSM.AddVertexToBody (result, -n, +o, +p);\n\t\tJSM.AddVertexToBody (result, -n, -o, -p);\n\n\t\tJSM.AddVertexToBody (result, +o, -p, +n);\n\t\tJSM.AddVertexToBody (result, -o, +p, +n);\n\t\tJSM.AddVertexToBody (result, +o, +p, -n);\n\t\tJSM.AddVertexToBody (result, -o, -p, -n);\n\n\t\tJSM.AddVertexToBody (result, -p, +n, +o);\n\t\tJSM.AddVertexToBody (result, +p, +n, -o);\n\t\tJSM.AddVertexToBody (result, +p, -n, +o);\n\t\tJSM.AddVertexToBody (result, -p, -n, -o);\n\n\t\tJSM.AddVertexToBody (result, +q, +r, -s);\n\t\tJSM.AddVertexToBody (result, +q, -r, +s);\n\t\tJSM.AddVertexToBody (result, -q, +r, +s);\n\t\tJSM.AddVertexToBody (result, -q, -r, -s);\n\n\t\tJSM.AddVertexToBody (result, +r, -s, +q);\n\t\tJSM.AddVertexToBody (result, -r, +s, +q);\n\t\tJSM.AddVertexToBody (result, +r, +s, -q);\n\t\tJSM.AddVertexToBody (result, -r, -s, -q);\n\n\t\tJSM.AddVertexToBody (result, -s, +q, +r);\n\t\tJSM.AddVertexToBody (result, +s, +q, -r);\n\t\tJSM.AddVertexToBody (result, +s, -q, +r);\n\t\tJSM.AddVertexToBody (result, -s, -q, -r);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 51]);\n\t\tJSM.AddPolygonToBody (result, [0, 30, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 48, 3]);\n\t\tJSM.AddPolygonToBody (result, [0, 51, 30]);\n\t\tJSM.AddPolygonToBody (result, [1, 2, 50]);\n\t\tJSM.AddPolygonToBody (result, [1, 28, 13]);\n\t\tJSM.AddPolygonToBody (result, [1, 49, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 50, 28]);\n\t\tJSM.AddPolygonToBody (result, [2, 29, 14]);\n\t\tJSM.AddPolygonToBody (result, [2, 49, 29]);\n\t\tJSM.AddPolygonToBody (result, [3, 31, 15]);\n\t\tJSM.AddPolygonToBody (result, [3, 48, 31]);\n\t\tJSM.AddPolygonToBody (result, [4, 7, 55]);\n\t\tJSM.AddPolygonToBody (result, [4, 34, 16]);\n\t\tJSM.AddPolygonToBody (result, [4, 52, 7]);\n\t\tJSM.AddPolygonToBody (result, [4, 55, 34]);\n\t\tJSM.AddPolygonToBody (result, [5, 6, 54]);\n\t\tJSM.AddPolygonToBody (result, [5, 32, 17]);\n\t\tJSM.AddPolygonToBody (result, [5, 53, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 54, 32]);\n\t\tJSM.AddPolygonToBody (result, [6, 33, 18]);\n\t\tJSM.AddPolygonToBody (result, [6, 53, 33]);\n\t\tJSM.AddPolygonToBody (result, [7, 35, 19]);\n\t\tJSM.AddPolygonToBody (result, [7, 52, 35]);\n\t\tJSM.AddPolygonToBody (result, [8, 11, 59]);\n\t\tJSM.AddPolygonToBody (result, [8, 26, 20]);\n\t\tJSM.AddPolygonToBody (result, [8, 56, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 59, 26]);\n\t\tJSM.AddPolygonToBody (result, [9, 10, 58]);\n\t\tJSM.AddPolygonToBody (result, [9, 24, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 57, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 58, 24]);\n\t\tJSM.AddPolygonToBody (result, [10, 25, 22]);\n\t\tJSM.AddPolygonToBody (result, [10, 57, 25]);\n\t\tJSM.AddPolygonToBody (result, [11, 27, 23]);\n\t\tJSM.AddPolygonToBody (result, [11, 56, 27]);\n\t\tJSM.AddPolygonToBody (result, [12, 18, 21]);\n\t\tJSM.AddPolygonToBody (result, [12, 21, 24]);\n\t\tJSM.AddPolygonToBody (result, [12, 30, 18]);\n\t\tJSM.AddPolygonToBody (result, [13, 16, 22]);\n\t\tJSM.AddPolygonToBody (result, [13, 22, 25]);\n\t\tJSM.AddPolygonToBody (result, [13, 28, 16]);\n\t\tJSM.AddPolygonToBody (result, [14, 17, 20]);\n\t\tJSM.AddPolygonToBody (result, [14, 20, 26]);\n\t\tJSM.AddPolygonToBody (result, [14, 29, 17]);\n\t\tJSM.AddPolygonToBody (result, [15, 19, 23]);\n\t\tJSM.AddPolygonToBody (result, [15, 23, 27]);\n\t\tJSM.AddPolygonToBody (result, [15, 31, 19]);\n\t\tJSM.AddPolygonToBody (result, [16, 34, 22]);\n\t\tJSM.AddPolygonToBody (result, [17, 32, 20]);\n\t\tJSM.AddPolygonToBody (result, [18, 33, 21]);\n\t\tJSM.AddPolygonToBody (result, [19, 35, 23]);\n\t\tJSM.AddPolygonToBody (result, [24, 58, 36]);\n\t\tJSM.AddPolygonToBody (result, [25, 57, 37]);\n\t\tJSM.AddPolygonToBody (result, [26, 59, 38]);\n\t\tJSM.AddPolygonToBody (result, [27, 56, 39]);\n\t\tJSM.AddPolygonToBody (result, [28, 50, 40]);\n\t\tJSM.AddPolygonToBody (result, [29, 49, 41]);\n\t\tJSM.AddPolygonToBody (result, [30, 51, 42]);\n\t\tJSM.AddPolygonToBody (result, [31, 48, 43]);\n\t\tJSM.AddPolygonToBody (result, [32, 54, 44]);\n\t\tJSM.AddPolygonToBody (result, [33, 53, 45]);\n\t\tJSM.AddPolygonToBody (result, [34, 55, 46]);\n\t\tJSM.AddPolygonToBody (result, [35, 52, 47]);\n\t\tJSM.AddPolygonToBody (result, [36, 43, 48]);\n\t\tJSM.AddPolygonToBody (result, [36, 46, 43]);\n\t\tJSM.AddPolygonToBody (result, [36, 58, 46]);\n\t\tJSM.AddPolygonToBody (result, [37, 41, 49]);\n\t\tJSM.AddPolygonToBody (result, [37, 45, 41]);\n\t\tJSM.AddPolygonToBody (result, [37, 57, 45]);\n\t\tJSM.AddPolygonToBody (result, [38, 40, 50]);\n\t\tJSM.AddPolygonToBody (result, [38, 47, 40]);\n\t\tJSM.AddPolygonToBody (result, [38, 59, 47]);\n\t\tJSM.AddPolygonToBody (result, [39, 42, 51]);\n\t\tJSM.AddPolygonToBody (result, [39, 44, 42]);\n\t\tJSM.AddPolygonToBody (result, [39, 56, 44]);\n\t\tJSM.AddPolygonToBody (result, [40, 47, 52]);\n\t\tJSM.AddPolygonToBody (result, [41, 45, 53]);\n\t\tJSM.AddPolygonToBody (result, [42, 44, 54]);\n\t\tJSM.AddPolygonToBody (result, [43, 46, 55]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 12, 24, 36, 48]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 25, 37, 49]);\n\t\tJSM.AddPolygonToBody (result, [2, 14, 26, 38, 50]);\n\t\tJSM.AddPolygonToBody (result, [3, 15, 27, 39, 51]);\n\t\tJSM.AddPolygonToBody (result, [4, 16, 28, 40, 52]);\n\t\tJSM.AddPolygonToBody (result, [5, 17, 29, 41, 53]);\n\t\tJSM.AddPolygonToBody (result, [6, 18, 30, 42, 54]);\n\t\tJSM.AddPolygonToBody (result, [7, 19, 31, 43, 55]);\n\t\tJSM.AddPolygonToBody (result, [8, 20, 32, 44, 56]);\n\t\tJSM.AddPolygonToBody (result, [9, 21, 33, 45, 57]);\n\t\tJSM.AddPolygonToBody (result, [10, 22, 34, 46, 58]);\n\t\tJSM.AddPolygonToBody (result, [11, 23, 35, 47, 59]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: AddCumulatedPolygonToBody\n\t* Description: Adds polygons to a body by cumulating the original polygons vertex index array.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} the vertices of the original polygon\n\t*\theight {number} the height of the cumulation\n\t*/\n\tJSM.AddCumulatedPolygonToBody = function (body, vertices, height)\n\t{\n\t\tfunction CalculatePolygonCentroidAndNormal (vertices, centroidCoord, normalVector)\n\t\t{\n\t\t\tvar vertexCoords = [];\n\t\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\t\tvertexCoords.push (body.GetVertexPosition (vertices[i]));\n\t\t\t}\n\t\t\t\n\t\t\tvar centroid = JSM.CalculateCentroid (vertexCoords);\n\t\t\tvar normal = JSM.CalculateNormal (vertexCoords);\n\n\t\t\tcentroidCoord.Set (centroid.x, centroid.y, centroid.z);\n\t\t\tnormalVector.Set (normal.x, normal.y, normal.z);\n\t\t}\n\n\t\tvar centroidCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar normalVector = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tCalculatePolygonCentroidAndNormal (vertices, centroidCoord, normalVector);\n\t\tcentroidCoord.Offset (normalVector, height);\n\t\t\n\t\tvar centroid = body.VertexCount ();\n\t\tJSM.AddVertexToBody (body, centroidCoord.x, centroidCoord.y, centroidCoord.z);\n\n\t\tvar count = vertices.length;\n\n\t\tvar i, curr, next;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = vertices[i];\n\t\t\tnext = vertices [i < count - 1 ? i + 1 : 0];\n\t\t\tJSM.AddPolygonToBody (body, [curr, next, centroid]);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedTetrahedron\n\t* Description: Generates a cumulated tetrahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedTetrahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, +a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, -a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, +a, -a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, -a, -a)));\n\n\t\tvar edgeLength = 2.0 * Math.sqrt (2.0);\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 1, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 1], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 2, 3], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedHexahedron\n\t* Description: Generates a cumulated hexahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedHexahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tvar edgeLength = 2.0;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 1, 5, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 4, 1], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 6, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 7, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 6, 7, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 5, 7, 6], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedOctahedron\n\t* Description: Generates a cumulated octahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedOctahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +b);\n\t\tJSM.AddVertexToBody (result, -a, +b, +b);\n\t\tJSM.AddVertexToBody (result, +b, +a, +b);\n\t\tJSM.AddVertexToBody (result, +b, -a, +b);\n\t\tJSM.AddVertexToBody (result, +b, +b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +b, -a);\n\n\t\tvar edgeLength = Math.sqrt (2.0);\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 4, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 5, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 2, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 3, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 5, 3], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedDodecahedron\n\t* Description: Generates a cumulated dodecahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedDodecahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +d, +c);\n\t\tJSM.AddVertexToBody (result, +b, +d, -c);\n\t\tJSM.AddVertexToBody (result, +b, -d, +c);\n\t\tJSM.AddVertexToBody (result, +b, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +b);\n\t\tJSM.AddVertexToBody (result, +d, -c, +b);\n\t\tJSM.AddVertexToBody (result, -d, +c, +b);\n\t\tJSM.AddVertexToBody (result, -d, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +d);\n\t\tJSM.AddVertexToBody (result, -c, +b, +d);\n\t\tJSM.AddVertexToBody (result, +c, +b, -d);\n\t\tJSM.AddVertexToBody (result, -c, +b, -d);\n\n\t\tvar edgeLength = Math.sqrt (5.0) - 1.0;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 8, 10, 2, 16], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 16, 18, 1, 12], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 12, 14, 3, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 9, 5, 14, 12], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 18, 4, 11, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 10, 6, 15, 13], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 13, 4, 18, 16], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 14, 5, 19, 17], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 17, 6, 10, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [4, 13, 15, 7, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [5, 9, 11, 7, 19], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [6, 17, 19, 7, 15], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedIcosahedron\n\t* Description: Generates a cumulated icosahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedIcosahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tvar edgeLength = 2;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 4, 6], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 6, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 8, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 9, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 3, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 10], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 6, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 10, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 11, 6], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 5, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 7, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 9, 7], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 5, 7], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 7, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 10, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [4, 8, 10], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [6, 11, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [5, 10, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [7, 9, 11], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTetrakisHexahedron\n\t* Description: Generates a tetrakis hexahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTetrakisHexahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = 1.0 / 4.0;\n\t\treturn JSM.GenerateCumulatedHexahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateRhombicDodecahedron\n\t* Description: Generates a rhombic dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = 1.0 / 2.0;\n\t\treturn JSM.GenerateCumulatedHexahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GeneratePentakisDodecahedron\n\t* Description: Generates a pentakis dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePentakisDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt ((65.0 + 22.0 * Math.sqrt (5.0)) / 5.0) / 19.0;\n\t\treturn JSM.GenerateCumulatedDodecahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallStellatedDodecahedron\n\t* Description: Generates a small stellated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallStellatedDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt ((5.0 + 2.0 * Math.sqrt (5.0)) / 5.0);\n\t\treturn JSM.GenerateCumulatedDodecahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateGreatDodecahedron\n\t* Description: Generates a great dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGreatDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = (Math.sqrt (3.0) * (Math.sqrt (5.0) - 3.0)) / 6.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallTriambicIcosahedron\n\t* Description: Generates a small triambic icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallTriambicIcosahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (15.0) / 15.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateGreatStellatedDodecahedron\n\t* Description: Generates a great stellated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGreatStellatedDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = (Math.sqrt (3.0) * (3.0 + Math.sqrt (5.0))) / 6.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallTriakisOctahedron\n\t* Description: Generates a small triakis octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallTriakisOctahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (3.0) - 2.0 * Math.sqrt (6.0) / 3.0;\n\t\treturn JSM.GenerateCumulatedOctahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateStellaOctangula\n\t* Description: Generates a stella octangula.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateStellaOctangula = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (6.0) / 3.0;\n\t\treturn JSM.GenerateCumulatedOctahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateTriakisTetrahedron\n\t* Description: Generates a triakis tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriakisTetrahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (6.0) / 15.0;\n\t\treturn JSM.GenerateCumulatedTetrahedron (pyramidUnitHeight);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/extgenerator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: LegoDimensions\n\t* Description: Class that contains lego brick dimensions.\n\t*/\n\tJSM.LegoDimensions = function ()\n\t{\n\t\tthis.legoWidth = 0.78;\n\t\tthis.legoSmallHeight = 0.32;\n\t\tthis.legoLargeHeight = 0.96;\n\t\tthis.legoWallWidth = 0.16;\n\t\tthis.legoCylinderWidth = 0.5;\n\t\tthis.legoCylinderHeight = 0.17;\n\t\tthis.legoBottomSmallCylinderWidth = 0.3;\n\t\tthis.legoBottomLargeCylinderWidth = 0.6;\n\t\tthis.legoBottomLargeCylinderWallWidth = 0.1;\n\t};\n\n\t/**\n\t* Function: GenerateLegoBrick\n\t* Description: Generates a lego brick.\n\t* Parameters:\n\t*\trows {integer} the row count\n\t*\tcolumns {integer} the columns count\n\t*\tisLarge {boolean} the brick is large\n\t*\thasTopCylinders {boolean} the brick has top cylinders\n\t*\thasBottomCylinders {boolean} the brick has bottom cylinders\n\t*\tsegmentation {integer} the segmentation of cylinders\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLegoBrick = function (rows, columns, isLarge, hasTopCylinders, hasBottomCylinders, segmentation, isCurved)\n\t{\n\t\tfunction OffsetBody (body, offset)\n\t\t{\n\t\t\tvar i, vertex;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\tvertex.position = JSM.CoordAdd (vertex.position, offset);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar legoDimensions = new JSM.LegoDimensions ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar unitWidth = legoDimensions.legoWidth;\n\t\tvar unitHeight = legoDimensions.legoLargeHeight;\n\t\tif (!isLarge) {\n\t\t\tunitHeight = legoDimensions.legoSmallHeight;\n\t\t}\n\t\tvar wallWidth = legoDimensions.legoWallWidth;\n\t\tvar topCylinderWidth = legoDimensions.legoCylinderWidth;\n\t\tvar topCylinderHeight = legoDimensions.legoCylinderHeight;\n\t\tvar bottomSmallCylinderWidth = legoDimensions.legoBottomSmallCylinderWidth;\n\t\tvar bottomLargeCylinderWidth = legoDimensions.legoBottomLargeCylinderWidth;\n\t\tvar bottomLargeCylinderWallWidth = legoDimensions.legoBottomLargeCylinderWallWidth;\n\n\t\tvar basePolygon = [];\n\t\tbasePolygon.push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, unitWidth * columns, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (0.0, unitWidth * columns, 0.0));\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar walls = JSM.GeneratePrismShell (basePolygon, normal, unitHeight - wallWidth, wallWidth, true);\n\t\tresult.Merge (walls);\n\t\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbasePolygon[i].z = unitHeight - wallWidth;\n\t\t}\n\t\t\n\t\tvar top = JSM.GeneratePrism (basePolygon, normal, wallWidth, true, null);\n\t\tresult.Merge (top);\n\t\t\n\t\tvar cylinderCenter, cylinder;\n\t\tif (hasTopCylinders) {\n\t\t\tfor (i = 0; i < rows; i++) {\n\t\t\t\tfor (j = 0; j < columns; j++) {\n\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * i + unitWidth / 2.0, unitWidth * j + unitWidth / 2.0, unitHeight + topCylinderHeight / 2.0);\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (topCylinderWidth / 2.0, topCylinderHeight, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasBottomCylinders) {\n\t\t\tvar circle, bigger, columnWise;\n\t\t\tif ((rows === 1 && columns > 1) || (columns === 1 && rows > 1)) {\n\t\t\t\tbigger = columns;\n\t\t\t\tcolumnWise = true;\n\t\t\t\tif (rows > columns) {\n\t\t\t\t\tbigger = rows;\n\t\t\t\t\tcolumnWise = false;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < bigger - 1; i++) {\n\t\t\t\t\tif (columnWise) {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth / 2.0, unitWidth * (i + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth / 2.0, (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t}\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (bottomSmallCylinderWidth / 2.0, unitHeight - wallWidth, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t} else if (rows > 1 && columns > 1) {\n\t\t\t\tfor (i = 0; i < rows - 1; i++) {\n\t\t\t\t\tfor (j = 0; j < columns - 1; j++) {\n\t\t\t\t\t\tcircle = [];\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth * (j + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t\tcylinder = JSM.GenerateCylinderShell (bottomLargeCylinderWidth / 2.0, unitHeight - wallWidth, bottomLargeCylinderWallWidth, segmentation, true, isCurved);\n\t\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateConvexHullBody\n\t* Description: Generates a convex hull body from the given coordinates.\n\t* Parameters:\n\t*\tcoord {Coord[*]} the coordinates\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateConvexHullBody = function (coords)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar convexHull = JSM.ConvexHull3D (coords);\n\t\t\n\t\tvar oldToNewIndexTable = {};\n\t\tvar i, j, current, index;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tif (!(index in oldToNewIndexTable)) {\n\t\t\t\t\toldToNewIndexTable[index] = result.VertexCount ();\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coords[index]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tnewPolygon = [];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tnewPolygon.push (oldToNewIndexTable[index]);\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon (newPolygon));\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSuperShape\n\t* Description: Generates a supershape.\n\t* Parameters:\n\t*\tparameters {12 numbers} the supershape parameters\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSuperShape = function (\taLon, bLon, mLon, n1Lon, n2Lon, n3Lon,\n\t\t\t\t\t\t\t\t\t\taLat, bLat, mLat, n1Lat, n2Lat, n3Lat,\n\t\t\t\t\t\t\t\t\t\tsegmentation, isCurved)\n\t{\n\t\tfunction CartesianToSpherical (coord)\n\t\t{\n\t\t\tvar radius = Math.sqrt (coord.x * coord.x + coord.y * coord.y + coord.z * coord.z);\n\t\t\tvar phi = Math.asin (coord.z / radius);\n\t\t\tvar theta = Math.atan2 (coord.y, coord.x);\n\t\t\treturn [radius, phi, theta];\n\t\t}\n\n\t\tfunction CalculateSuperFormula (p, a, b, m, n1, n2, n3)\n\t\t{\n\t\t\tvar abs1 = Math.abs (Math.cos (m * p / 4.0) / a);\n\t\t\tvar abs2 = Math.abs (Math.sin (m * p / 4.0) / b);\n\t\t\treturn Math.pow (Math.pow (abs1, n2) + Math.pow (abs2, n3), -1.0 / n1);\n\t\t}\n\n\t\tfunction CalculateSuperFormulaCoordinate (phi, theta)\n\t\t{\n\t\t\tvar coord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tvar rPhi = CalculateSuperFormula (phi, aLat, bLat, mLat, n1Lat, n2Lat, n3Lat);\n\t\t\tvar rTheta = CalculateSuperFormula (theta, aLon, bLon, mLon, n1Lon, n2Lon, n3Lon);\n\t\t\tcoord.x = rTheta * Math.cos (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.y = rTheta * Math.sin (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.z = rPhi * Math.sin (phi);\n\t\t\treturn coord;\n\t\t}\n\n\t\tvar result = JSM.GenerateSphere (1.0, segmentation, isCurved);\n\n\t\tvar i, vertex, coord, spherical, newCoord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tcoord = vertex.position;\n\t\t\tspherical = CartesianToSpherical (coord);\n\t\t\tnewCoord = CalculateSuperFormulaCoordinate (spherical[1], spherical[2]);\n\t\t\tvertex.SetPosition (newCoord);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/subdivision',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CatmullClarkSubdivisionOneIteration\n\t* Description: Runs one iteration of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivisionOneIteration = function (body)\n\t{\n\t\tfunction AddOriginalVertices (body, result, adjacencyInfo)\n\t\t{\n\t\t\tvar i, vertCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvertCoord = body.GetVertexPosition (i);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertCoord.Clone ()));\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tvar i, j, pgon, vertCoord, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tpgonCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j < pgon.verts.length; j++) {\n\t\t\t\t\tvertCoord = body.GetVertexPosition (pgon.verts[j]);\n\t\t\t\t\tpgonCoord = JSM.CoordAdd (pgonCoord, vertCoord);\n\t\t\t\t}\n\n\t\t\t\tpgonCoord.MultiplyScalar (1.0 / pgon.verts.length);\n\t\t\t\tpgonVertices.push (result.AddVertex (new JSM.BodyVertex (pgonCoord)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar i, j, edge, edgeCoord1, edgeCoord2, edgeCoord, pgonIndex, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord1 = body.GetVertexPosition (edge.vert1);\n\t\t\t\tedgeCoord2 = body.GetVertexPosition (edge.vert2);\n\t\t\t\tif (adjacencyInfo.IsContourEdge (edge)) {\n\t\t\t\t\tedgeCoord = JSM.MidCoord (edgeCoord1, edgeCoord2);\n\t\t\t\t} else {\n\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord1, edgeCoord2);\n\t\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t\tpgonIndex = (j === 0 ? edge.pgon1 : edge.pgon2);\n\t\t\t\t\t\tpgonCoord = result.GetVertexPosition (pgonVertices[pgonIndex]);\n\t\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord, pgonCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeCoord.MultiplyScalar (1.0 / 4.0);\n\t\t\t\t}\n\t\t\t\tedgeVertices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord)));\n\t\t\t}\n\t\t}\n\n\t\tfunction MoveOriginalVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tfunction MoveContourVertex (newVertCoord, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = newVertCoord.x;\n\t\t\t\tvertCoord.y = newVertCoord.y;\n\t\t\t\tvertCoord.z = newVertCoord.z;\n\t\t\t}\t\t\n\t\t\t\n\t\t\tfunction MoveVertex (pgonAverage, edgeAverage, vertEdgeCount, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = (pgonAverage.x + 2.0 * edgeAverage.x + (vertEdgeCount - 3) * vertCoord.x) / vertEdgeCount;\n\t\t\t\tvertCoord.y = (pgonAverage.y + 2.0 * edgeAverage.y + (vertEdgeCount - 3) * vertCoord.y) / vertEdgeCount;\n\t\t\t\tvertCoord.z = (pgonAverage.z + 2.0 * edgeAverage.z + (vertEdgeCount - 3) * vertCoord.z) / vertEdgeCount;\n\t\t\t}\n\t\t\n\t\t\tvar edgeMidCoords = [];\n\t\t\t\n\t\t\tvar edge, edgeCoord;\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (body.GetVertexPosition (edge.vert1), body.GetVertexPosition (edge.vert2));\n\t\t\t\tedgeMidCoords.push (edgeCoord);\n\t\t\t}\n\t\t\n\t\t\tvar vert, pgon, vertCoord, currentVertCoord;\n\t\t\tvar pgonAverage, edgeAverage, edgeCountForAverage;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvert = adjacencyInfo.verts[i];\n\t\t\t\tvertCoord = result.GetVertexPosition (i);\n\t\t\t\tif (adjacencyInfo.IsContourVertex (vert)) {\n\t\t\t\t\tedgeCountForAverage = 0;\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tif (adjacencyInfo.IsContourEdge (adjacencyInfo.edges[edge])) {\n\t\t\t\t\t\t\tedgeCoord = edgeMidCoords [vert.edges[j]];\n\t\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.Add (vertCoord);\n\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / edgeCountForAverage);\n\t\t\t\t\tMoveContourVertex (edgeAverage, vertCoord);\n\t\t\t\t} else {\n\t\t\t\t\tpgonAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < vert.pgons.length; j++) {\n\t\t\t\t\t\tpgon = vert.pgons[j];\n\t\t\t\t\t\tcurrentVertCoord = result.GetVertexPosition (pgonVertices[pgon]);\n\t\t\t\t\t\tpgonAverage.Add (currentVertCoord);\n\t\t\t\t\t}\n\t\t\t\t\tpgonAverage.MultiplyScalar (1.0 / vert.pgons.length);\n\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tedgeCoord = edgeMidCoords [edge];\n\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / vert.edges.length);\n\t\t\t\t\tMoveVertex (pgonAverage, edgeAverage, vert.edges.length, vertCoord);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar edgeCount, currentEdge, nextEdge;\n\t\t\tvar centroid, currentEdgeVertex, originalVertex, nextEdgeVertex;\n\t\t\tvar polygon, oldPolygon;\n\t\t\tvar i, j, pgon;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tedgeCount = pgon.verts.length;\n\t\t\t\tfor (j = 0; j < edgeCount; j++) {\n\t\t\t\t\tcurrentEdge = pgon.pedges[j];\n\t\t\t\t\tnextEdge = pgon.pedges[(j + 1) % edgeCount];\n\n\t\t\t\t\tcentroid = pgonVertices[i];\n\t\t\t\t\tcurrentEdgeVertex = edgeVertices[currentEdge.index];\n\t\t\t\t\toriginalVertex = adjacencyInfo.GetPolyEdgeStartVertex (nextEdge);\n\t\t\t\t\tnextEdgeVertex = edgeVertices[nextEdge.index];\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([centroid, currentEdgeVertex, originalVertex, nextEdgeVertex]);\n\t\t\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\t\t\tpolygon.material = oldPolygon.material;\n\t\t\t\t\tpolygon.curved = oldPolygon.curved;\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\n\t\tvar pgonVertices = [];\n\t\tvar edgeVertices = [];\n\n\t\tAddOriginalVertices (body, result, adjacencyInfo);\n\t\tAddPolygonVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\n\t\tMoveOriginalVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CatmullClarkSubdivision\n\t* Description: Runs multiple iterations of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\titerations {integer} the iteration number\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivision = function (body, iterations)\n\t{\n\t\tvar result = body;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < iterations; i++) {\n\t\t\tresult = JSM.CatmullClarkSubdivisionOneIteration (result);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/csg',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: BooleanOperation\n\t* Description: Makes a boolean operation on the given bodies.\n\t* Parameters:\n\t*\toperation {string} the operation ('Union', 'Difference', or 'Intersection')\n\t*\taBody {Body} the first body\n\t*\tbBody {Body} the second body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.BooleanOperation = function (operation, aBody, bBody)\n\t{\n\t\tfunction AddPolygonToBody (polygon, body, octree, reversed)\n\t\t{\n\t\t\tfunction AddBodyVertex (coord, octree)\n\t\t\t{\n\t\t\t\tvar merge = false;\n\t\t\t\tif (merge) {\n\t\t\t\t\tvar index = octree.FindCoord (coord);\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\tindex = body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\toctree.AddCoord (coord);\n\t\t\t\t\t}\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t}\n\n\t\t\tvar bodyPolygon = new JSM.BodyPolygon ([]);\n\n\t\t\tvar i, vertexIndex;\n\t\t\tif (!reversed) {\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (polygon.userData !== undefined) {\n\t\t\t\tbodyPolygon.SetMaterialIndex (polygon.userData.material);\n\t\t\t}\n\t\t\tbody.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tfunction AddPolygonsToBody (polygons, body, octree, reversed)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tAddPolygonToBody (polygons[i], body, octree, reversed);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ClipNodePolygonsWithTree (nodes, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t\t{\n\t\t\tfunction SetPolygonsUserData (polygons, userData)\n\t\t\t{\n\t\t\t\tvar i, polygon;\n\t\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\t\tpolygon = polygons[i];\n\t\t\t\t\tif (polygon.userData === undefined) {\n\t\t\t\t\t\tpolygon.userData = userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < nodes.length; i++) {\n\t\t\t\tnode = nodes[i];\n\t\t\t\tJSM.ClipPolygonWithBSPTree (node.polygon, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons);\n\t\t\t\tSetPolygonsUserData (frontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (backPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarFrontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarBackPolygons, node.userData);\n\t\t\t}\n\t\t}\n\n\t\tvar aTree = new JSM.BSPTree ();\n\t\tvar bTree = new JSM.BSPTree ();\n\t\tJSM.AddBodyToBSPTree (aBody, aTree, 'a');\n\t\tJSM.AddBodyToBSPTree (bBody, bTree, 'b');\n\n\t\tvar aFrontPolygons = [];\n\t\tvar aBackPolygons = [];\n\t\tvar aPlanarFrontPolygons = [];\n\t\tvar aPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (aTree.GetNodes (), bTree, aFrontPolygons, aBackPolygons, aPlanarFrontPolygons, aPlanarBackPolygons);\n\n\t\tvar bFrontPolygons = [];\n\t\tvar bBackPolygons = [];\n\t\tvar bPlanarFrontPolygons = [];\n\t\tvar bPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (bTree.GetNodes (), aTree, bFrontPolygons, bBackPolygons, bPlanarFrontPolygons, bPlanarBackPolygons);\n\n\t\tvar result = new JSM.Body ();\n\t\tvar resultOctree = new JSM.Octree (JSM.BoxUnion (aBody.GetBoundingBox (), bBody.GetBoundingBox ()));\n\t\t\n\t\tif (operation == 'Union') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bPlanarFrontPolygons, result, resultOctree, false);\n\t\t} else if (operation == 'Difference') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, true);\n\t\t} else if (operation == 'Intersection') {\n\t\t\tAddPolygonsToBody (aBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, false);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/surfaces',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSurface\n\t* Description: Generates a parametric surface.\n\t* Parameters:\n\t*\txRange {number[2]} the from-to range on x axis\n\t*\tyRange {number[2]} the from-to range on y axis\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tuseTriangles {boolean} generate triangles instead of quadrangles\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tgetPointCallback {function} callback function which returns the point for a position\n\t*\tuserData {anything} user data which will be passed to getPointCallback\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSurface = function (xRange, yRange, xSegmentation, ySegmentation, useTriangles, isCurved, getPointCallback, userData)\n\t{\n\t\tfunction AddVertices (result, xStart, yStart, xSegment, ySegment)\n\t\t{\n\t\t\tvar i, j, u, v, coord;\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tu = xStart + j * xSegment;\n\t\t\t\t\tv = yStart + i * ySegment;\n\t\t\t\t\tcoord = getPointCallback (i, j, u, v, userData);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (result)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\tvar polygon;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (useTriangles) {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xRange[0];\n\t\tvar yStart = yRange[0];\n\t\tvar xDiff = xRange[1] - xRange[0];\n\t\tvar yDiff = yRange[1] - yRange[0];\n\t\tvar xSegment = xDiff / xSegmentation;\n\t\tvar ySegment = yDiff / ySegmentation;\n\t\t\n\t\tAddVertices (result, xStart, yStart, xSegment, ySegment);\n\t\tAddPolygons (result);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: SurfaceControlPoints\n\t* Description: Represents control points for surface generation.\n\t* Parameters:\n\t*\tn {integer} the first dimension\n\t*\tm {integer} the second dimension\n\t*/\n\tJSM.SurfaceControlPoints = function (n, m)\n\t{\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\tthis.points = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tthis.points.push ([]);\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tthis.points[i].push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetNValue\n\t* Description: Returns the n value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetNValue = function ()\n\t{\n\t\treturn this.n;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetMValue\n\t* Description: Returns the m value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetMValue = function ()\n\t{\n\t\treturn this.m;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetControlPoint\n\t* Description: Returns a control point.\n\t* Parameters:\n\t*\ti {integer} the first dimension\n\t*\tj {integer} the second dimension\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetControlPoint = function (i, j)\n\t{\n\t\treturn this.points[i][j];\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.InitPlanar\n\t* Description: Inits planar control points.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\txSize {number} the y size\n\t*/\n\tJSM.SurfaceControlPoints.prototype.InitPlanar = function (xSize, ySize)\n\t{\n\t\tvar iStep = xSize / this.n;\n\t\tvar jStep = ySize / this.m;\n\n\t\tvar i, j, point;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tpoint = this.points[i][j];\n\t\t\t\tpoint.x = i * iStep;\n\t\t\t\tpoint.y = j * jStep;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateBezierSurface\n\t* Description: Generates a bezier surface base on the given control points.\n\t* Parameters:\n\t*\tsurfaceControlPoints {SurfaceControlPoints} the control points\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateBezierSurface = function (surfaceControlPoints, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tfunction GetBezierSurfacePoint (uIndex, vIndex, u, v, surfaceControlPoints)\n\t\t{\n\t\t\tvar i, j, result, tmp1, tmp2, scalar;\n\t\t\tvar n = surfaceControlPoints.GetNValue ();\n\t\t\tvar m = surfaceControlPoints.GetMValue ();\n\t\t\t\n\t\t\tresult = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tfor (i = 0; i <= n; i++) {\n\t\t\t\ttmp1 = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j <= m; j++) {\n\t\t\t\t\tscalar = JSM.BernsteinPolynomial (i, n, u) * JSM.BernsteinPolynomial (j, m, v);\n\t\t\t\t\ttmp2 = surfaceControlPoints.GetControlPoint (i, j).Clone ().MultiplyScalar (scalar);\n\t\t\t\t\ttmp1 = JSM.CoordAdd (tmp1, tmp2);\n\t\t\t\t}\n\t\t\t\tresult = JSM.CoordAdd (result, tmp1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = JSM.GenerateSurface ([0, 1], [0, 1], xSegmentation, ySegmentation, false, isCurved, GetBezierSurfacePoint, surfaceControlPoints);\n\t\treturn body;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/svgtomodel/svgtomodel',[\"../../core/jsm\"],function(JSM){\n\t/**\n\t* Function: SvgToModel\n\t* Description: Converts an svg objects rect, path and polygon elements to a body.\n\t* Parameters:\n\t*\tsvgObject {html svg element} the svg element\n\t*\theight {number} the height of the result body\n\t*\tsegmentLength {number} the maximum length of curved segments\n\t*\tcurveAngle {number} if not null, defines the curve angle of the model\n\t* Returns:\n\t*\t{Model} the result\n\t*/\n\tJSM.SvgToModel = function (svgObject, height, segmentLength, curveAngle)\n\t{\n\t\tfunction SegmentElem (elem, segmentLength)\n\t\t{\n\t\t\tfunction AddTransformedVertex (dummySVG, result, elem, x, y)\n\t\t\t{\n\t\t\t\tvar point = dummySVG.createSVGPoint ();\n\t\t\t\tpoint.x = x;\n\t\t\t\tpoint.y = y;\n\t\t\t\t\n\t\t\t\tvar transformed = point;\n\t\t\t\tvar matrix = elem.getCTM ();\n\t\t\t\tif (matrix !== undefined && matrix !== null) {\n\t\t\t\t\ttransformed = point.matrixTransform (matrix);\t\t\t\t\n\t\t\t\t}\n\t\t\t\tvar transformedCoord = new JSM.Coord2D (transformed.x, transformed.y);\n\t\t\t\tvar resultCoord = new JSM.Coord2D (x, y);\n\t\t\t\t\n\t\t\t\tvar contour = result.GetLastContour ();\n\t\t\t\tvar contourVertexCount = contour.VertexCount ();\n\t\t\t\tif (contourVertexCount > 0) {\n\t\t\t\t\tif (contour.GetVertex (contourVertexCount - 1).IsEqualWithEps (transformedCoord, 0.1)) {\n\t\t\t\t\t\treturn resultCoord;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontour.AddVertex (transformed.x, transformed.y);\n\t\t\t\treturn resultCoord;\n\t\t\t}\n\n\t\t\tfunction SegmentCurve (dummySVG, originalPath, segmentLength, lastCoord, items, result)\n\t\t\t{\n\t\t\t\tfunction CreatePath (items)\n\t\t\t\t{\n\t\t\t\t\tfunction GenerateMoveCommand (x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 'M ' + x + ' ' + y + ' ';\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tvar svgNameSpace = 'http://www.w3.org/2000/svg';\n\t\t\t\t\tvar path = document.createElementNS (svgNameSpace, 'path');\n\n\t\t\t\t\tvar commandString = GenerateMoveCommand (lastCoord.x, lastCoord.y);\n\t\t\t\t\tvar i, item, command, largeArcFlag, sweepFlag;\n\t\t\t\t\tfor (i = 0; i < items.length; i++) {\n\t\t\t\t\t\titem = items[i];\n\t\t\t\t\t\tif (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ||\n\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL) {\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ? 'C' : 'c');\n\t\t\t\t\t\t\tcommandString += command + ' ' + item.x1 + ' ' + item.y1 + ' ' + item.x2 + ' ' + item.y2 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ? 'Q' : 'q');\n\t\t\t\t\t\t\tcommandString += command + ' ' + item.x1 + ' ' + item.y1 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ? 'A' : 'a');\n\t\t\t\t\t\t\tlargeArcFlag = (item.largeArcFlag ? 1 : 0);\n\t\t\t\t\t\t\tsweepFlag = (item.sweepFlag ? 1 : 0);\n\t\t\t\t\t\t\tcommandString +=  command + ' ' + item.r1 + ' ' + item.r2 + ' ' + item.angle + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ? 'S' : 's');\n\t\t\t\t\t\t\tcommandString +=  command + ' ' + item.x2 + ' ' + item.y2 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// unknown segment type\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpath.setAttributeNS (null, 'd', commandString);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar path = CreatePath (items);\n\t\t\t\tvar pathLength = path.getTotalLength ();\n\n\t\t\t\tvar segmentation = 0;\n\t\t\t\tif (segmentLength > 0) {\n\t\t\t\t\tsegmentation = parseInt (pathLength / segmentLength, 10);\n\t\t\t\t}\n\t\t\t\tif (segmentation < 3) {\n\t\t\t\t\tsegmentation = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar step = pathLength / segmentation;\n\t\t\t\tvar i, point;\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tpoint = path.getPointAtLength (i * step);\n\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, originalPath, point.x, point.y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn lastCoord;\n\t\t\t}\n\t\t\t\n\t\t\tfunction IsCurvedItem (item)\n\t\t\t{\n\t\t\t\treturn\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\t\t\t}\n\t\t\t\n\t\t\tfunction IsSmoothItem (item)\n\t\t\t{\n\t\t\t\treturn\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\t\t\t}\n\n\t\t\tfunction RemoveEqualEndVertices (polygon)\n\t\t\t{\n\t\t\t\tvar contour = polygon.GetLastContour ();\n\t\t\t\tvar vertexCount = contour.VertexCount ();\n\t\t\t\tif (vertexCount === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar firstCoord = contour.GetVertex (0);\n\t\t\t\tvar lastCoord = contour.GetVertex (vertexCount - 1);\n\t\t\t\tif (firstCoord.IsEqualWithEps (lastCoord, 0.1)) {\n\t\t\t\t\t// TODO: Do not access vertices directly\n\t\t\t\t\tcontour.vertices.pop ();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction StartNewContour (result)\n\t\t\t{\n\t\t\t\tif (result.GetLastContour ().VertexCount () > 0) {\n\t\t\t\t\tRemoveEqualEndVertices (result);\n\t\t\t\t\tresult.AddContour ();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction SVGColorToHex (path)\n\t\t\t{\n\t\t\t\tvar svgColor = '';\n\t\t\t\tvar target = path;\n\t\t\t\twhile (target !== null && target !== undefined && svgColor.length === 0) {\n\t\t\t\t\tsvgColor = target.getAttribute ('fill');\n\t\t\t\t\tif (svgColor === null) {\n\t\t\t\t\t\tsvgColor = target.style.fill;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = target.parentElement;\n\t\t\t\t}\n\n\t\t\t\tvar result = 0x000000;\n\t\t\t\tif (svgColor.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (svgColor[0] == '#') {\n\t\t\t\t\tresult = JSM.HexColorToRGBColor (svgColor.substring (1));\n\t\t\t\t} else {\n\t\t\t\t\tvar firstBracket = svgColor.indexOf ('(');\n\t\t\t\t\tvar secondBracket = svgColor.indexOf (')');\n\t\t\t\t\tif (firstBracket == -1 || secondBracket == -1) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar numbers = svgColor.substring (firstBracket + 1, secondBracket);\n\t\t\t\t\tvar rgb = numbers.split (', ');\n\t\t\t\t\tif (rgb.length != 3) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tresult = JSM.RGBComponentsToHexColor (rgb[0], rgb[1], rgb[2]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\n\t\t\tvar result = new JSM.ContourPolygon2D ();\n\t\t\tresult.AddContour ();\n\n\t\t\tvar dummySVG = document.createElementNS ('http://www.w3.org/2000/svg', 'svg');\n\n\t\t\tvar i, j;\n\t\t\tif (elem instanceof SVGPathElement) {\n\t\t\t\tvar lastCoord = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lastMoveCoord = new JSM.Coord2D (0.0, 0.0);\n\n\t\t\t\tvar currentSegmentLength = segmentLength;\n\t\t\t\tif (elem.hasAttribute ('segmentlength')) {\n\t\t\t\t\tcurrentSegmentLength = parseFloat (elem.getAttribute ('segmentlength'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar item, items, currentItem;\n\t\t\t\tfor (i = 0; i < elem.pathSegList.numberOfItems; i++) {\n\t\t\t\t\titem = elem.pathSegList.getItem (i);\n\t\t\t\t\tif (item.pathSegType == SVGPathSeg.PATHSEG_CLOSEPATH) {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_MOVETO_ABS) {\n\t\t\t\t\t\tStartNewContour (result);\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, item.y);\n\t\t\t\t\t\tlastMoveCoord = lastCoord.Clone ();\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_MOVETO_REL) {\n\t\t\t\t\t\tStartNewContour (result);\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastMoveCoord.x + item.x, lastMoveCoord.y + item.y);\n\t\t\t\t\t\tlastMoveCoord = lastCoord.Clone ();\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x + item.x, lastCoord.y + item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, lastCoord.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x, item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x + item.x, lastCoord.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x, lastCoord.y + item.y);\n\t\t\t\t\t} else if (IsCurvedItem (item)) {\n\t\t\t\t\t\titems = [];\n\t\t\t\t\t\tif (IsSmoothItem (item)) {\n\t\t\t\t\t\t\tfor (j = i; j < elem.pathSegList.numberOfItems; j++) {\n\t\t\t\t\t\t\t\tcurrentItem = elem.pathSegList.getItem (j);\n\t\t\t\t\t\t\t\tif (!IsSmoothItem (currentItem)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titems.push (currentItem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti = j - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems.push (item);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastCoord = SegmentCurve (dummySVG, elem, currentSegmentLength, lastCoord, items, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unknown segment type\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRemoveEqualEndVertices (result);\n\t\t\t} else if (elem instanceof SVGRectElement) {\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value, elem.y.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value + elem.width.baseVal.value, elem.y.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value + elem.width.baseVal.value, elem.y.baseVal.value + elem.height.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value, elem.y.baseVal.value + elem.height.baseVal.value);\n\t\t\t} else if (elem instanceof SVGPolygonElement) {\n\t\t\t\tvar point;\n\t\t\t\tfor (i = 0; i < elem.points.numberOfItems; i++) {\n\t\t\t\t\tpoint = elem.points.getItem (i);\n\t\t\t\t\tAddTransformedVertex (dummySVG, result, elem, point.x, point.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.color = SVGColorToHex (elem);\n\t\t\tresult.originalElem = elem;\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction SegmentPaths (svgObject, segmentLength)\n\t\t{\n\t\t\tfunction AddElemType (svgObject, elemType, result)\n\t\t\t{\n\t\t\t\tvar elems = svgObject.getElementsByTagName (elemType);\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\t\t\tresult.push (elems[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar result = [];\n\t\t\tvar elems = [];\n\t\t\tAddElemType (svgObject, 'path', elems);\n\t\t\tAddElemType (svgObject, 'rect', elems);\n\t\t\tAddElemType (svgObject, 'polygon', elems);\n\t\t\t\n\t\t\tvar currentSegmentLength = segmentLength;\n\t\t\tif (svgObject.hasAttribute ('segmentlength')) {\n\t\t\t\tcurrentSegmentLength = parseFloat (svgObject.getAttribute ('segmentlength'));\n\t\t\t}\n\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\t\tcurrent = SegmentElem (elems[i], currentSegmentLength);\n\t\t\t\tresult.push (current);\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction ContourPolygonToPrisms (polygon, height, curveAngle)\n\t\t{\n\t\t\tfunction AppendPolygonVertices (polygon, vertexArray, reversed)\n\t\t\t{\n\t\t\t\tvar i, coord;\n\t\t\t\tif (!reversed) {\n\t\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\t\t\tvertexArray.push (new JSM.Coord (coord.x, -coord.y, 0.0));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\t\t\tvertexArray.push (new JSM.Coord (coord.x, -coord.y, 0.0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction CreateBasePolygon (polygon)\n\t\t\t{\n\t\t\t\tvar basePolygon = [];\n\t\t\t\tvar orientation = polygon.GetOrientation ();\n\t\t\t\tvar reversed = (orientation == JSM.Orientation.CounterClockwise);\n\t\t\t\tAppendPolygonVertices (polygon, basePolygon, reversed);\n\t\t\t\treturn basePolygon;\n\t\t\t}\n\t\t\n\t\t\tfunction AddHoleToBasePolygon (basePolygon, holePolygon)\n\t\t\t{\n\t\t\t\tbasePolygon.push (null);\n\t\t\t\tvar orientation = holePolygon.GetOrientation ();\n\t\t\t\tvar reversed = (orientation == JSM.Orientation.Clockwise);\n\t\t\t\tAppendPolygonVertices (holePolygon, basePolygon, reversed);\n\t\t\t}\n\n\t\t\tvar prisms = [];\n\t\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\t\t\n\t\t\tvar currentHeight = height;\n\t\t\tif (polygon.originalElem !== undefined) {\n\t\t\t\tif (polygon.originalElem.hasAttribute ('modelheight')) {\n\t\t\t\t\tcurrentHeight = parseFloat (polygon.originalElem.getAttribute ('modelheight'));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar basePolygon, baseOrientation, prism;\n\t\t\tvar contourCount = polygon.ContourCount ();\n\t\t\tif (contourCount === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif (contourCount == 1) {\n\t\t\t\tbaseOrientation = polygon.GetContour (0).GetOrientation ();\n\t\t\t\tbasePolygon = CreateBasePolygon (polygon.GetContour (0));\n\t\t\t\tprism = JSM.GeneratePrism (basePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\tprisms.push (prism);\n\t\t\t} else if (contourCount > 1) {\n\t\t\t\tbaseOrientation = polygon.GetContour (0).GetOrientation ();\n\t\t\t\tvar holeBasePolygon = CreateBasePolygon (polygon.GetContour (0));\n\t\t\t\tvar hasHoles = false;\n\t\t\t\t\n\t\t\t\tvar i, orientation;\n\t\t\t\tfor (i = 1; i < polygon.ContourCount (); i++) {\n\t\t\t\t\torientation = polygon.GetContour (i).GetOrientation ();\n\t\t\t\t\tif (orientation == baseOrientation) {\n\t\t\t\t\t\tbasePolygon = CreateBasePolygon (polygon.GetContour (i));\n\t\t\t\t\t\tprism = JSM.GeneratePrism (basePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\t\tprisms.push (prism);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAddHoleToBasePolygon (holeBasePolygon, polygon.GetContour (i));\n\t\t\t\t\t\thasHoles = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasHoles) {\n\t\t\t\t\tprism = JSM.GeneratePrism (holeBasePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\tprisms.push (prism);\n\t\t\t\t} else {\n\t\t\t\t\tprism = JSM.GeneratePrismWithHole (holeBasePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\tprisms.push (prism);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar material = new JSM.Material ({ambient : polygon.color, diffuse : polygon.color});\n\t\t\treturn [prisms, material];\n\t\t}\n\t\t\n\t\tvar model = new JSM.Model ();\n\t\tvar polygons = SegmentPaths (svgObject, segmentLength);\n\n\t\tvar currentHeight = height;\n\t\tif (svgObject.hasAttribute ('modelheight')) {\n\t\t\tcurrentHeight = parseFloat (svgObject.getAttribute ('modelheight'));\n\t\t}\n\t\t\n\t\tvar i, j, prismsAndMaterial, currentPrisms, currentPrism, currentMaterial;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tprismsAndMaterial = ContourPolygonToPrisms (polygons[i], currentHeight, curveAngle);\n\t\t\tif (prismsAndMaterial === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentPrisms = prismsAndMaterial[0];\n\t\t\tcurrentMaterial = prismsAndMaterial[1];\n\t\t\tmodel.AddMaterial (currentMaterial);\n\t\t\tfor (j = 0; j < currentPrisms.length; j++) {\n\t\t\t\tcurrentPrism = currentPrisms[j];\n\t\t\t\tcurrentPrism.SetPolygonsMaterialIndex (model.MaterialCount () - 1);\n\t\t\t\tmodel.AddBody (currentPrism);\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/textgenerator/textgenerator',[\"../../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateText\n\t* Description:\n\t*\tGenerates 3D model from the given text. It should get a font\n\t*\tspecification object created with facetype.js.\n\t* Parameters:\n\t*\ttext {string} the text\n\t*\tfontSpec {object} the font specification object generated with facetype.js\n\t*\tfontScale {number} the scale of the generated model\n\t*\tfontHeight {number} the height of the generated model\n\t*\tfontSegmentation {integer} the segmentation of font glyphs\n\t* Returns:\n\t*\t{Model} the result\n\t*/\n\tJSM.GenerateText = function (text, fontSpec, fontScale, fontHeight, fontSegmentation)\n\t{\n\t\tfunction CreatePathFromSpecification (commands, segmentation, offset, scale)\n\t\t{\n\t\t\tfunction Num (str)\n\t\t\t{\n\t\t\t\treturn parseFloat (str);\n\t\t\t}\n\t\t\n\t\t\tvar path = new JSM.Path2D ({\n\t\t\t\tsegmentation : segmentation,\n\t\t\t\toffset : offset,\n\t\t\t\tscale : scale\n\t\t\t});\n\t\t\t\n\t\t\tvar parts = commands.split (' ');\n\t\t\tvar index = 0;\n\t\t\tvar current;\n\t\t\twhile (index < parts.length) {\n\t\t\t\tcurrent = parts[index++];\n\t\t\t\tif (current.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (current == 'm') {\n\t\t\t\t\tpath.MoveTo (Num (parts[index + 0]), Num (parts[index + 1]));\n\t\t\t\t\tindex += 2;\n\t\t\t\t} else if (current == 'l') {\n\t\t\t\t\tpath.LineTo (Num (parts[index + 0]), Num (parts[index + 1]));\n\t\t\t\t\tindex += 2;\n\t\t\t\t} else if (current == 'b') {\n\t\t\t\t\tpath.CubicBezierTo (Num (parts[index + 0]), Num (parts[index + 1]), Num (parts[index + 2]), Num (parts[index + 3]), Num (parts[index + 4]), Num (parts[index + 5]));\n\t\t\t\t\tindex += 6;\n\t\t\t\t} else if (current == 'z') {\n\t\t\t\t\tpath.Close ();\n\t\t\t\t} else {\n\t\t\t\t\tJSM.Message ('Invalid path command found: ' + current);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n\t\tvar model = new JSM.Model ();\n\t\tvar offset = new JSM.Vector2D (0.0, 0.0);\n\t\tvar scale = new JSM.Coord2D (fontScale, fontScale);\n\t\tvar i, character, glyphs, path, bodies;\n\t\tfor (i = 0; i < text.length; i++) {\n\t\t\tcharacter = text[i];\n\t\t\tglyphs = fontSpec.glyphs[character];\n\t\t\tif (glyphs === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpath = CreatePathFromSpecification (glyphs.o, fontSegmentation, offset, scale);\n\t\t\tbodies = JSM.GeneratePrismsFromPath2D (path, fontHeight, true, 160 * JSM.DegRad);\n\t\t\tmodel.AddBodies (bodies);\n\t\t\toffset.x += glyphs.ha * scale.x;\n\t\t}\n\t\treturn model;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/threeviewer/threeconverter',[\"../../core/jsm\"],function(JSM){\n\tJSM.ConvertBodyToThreeMeshes = function (body, materials, conversionData)\n\t{\n\t\tvar theConversionData = {\n\t\t\ttextureLoadedCallback : null,\n\t\t\thasConvexPolygons : false\n\t\t};\n\n\t\tif (conversionData !== undefined && conversionData !== null) {\n\t\t\ttheConversionData.textureLoadedCallback = JSM.ValueOrDefault (conversionData.textureLoadedCallback, theConversionData.textureLoadedCallback);\n\t\t\ttheConversionData.hasConvexPolygons = JSM.ValueOrDefault (conversionData.hasConvexPolygons, theConversionData.hasConvexPolygons);\n\t\t}\n\t\t\n\t\tvar meshes = [];\n\t\tvar threeGeometry = null;\n\t\tvar threeMaterial = null;\n\n\t\tvar explodeData = {\n\t\t\thasConvexPolygons : theConversionData.hasConvexPolygons,\n\t\t\tonPointGeometryStart : function (material) {\n\t\t\t\t\tthreeMaterial = new JSM.THREE.PointsMaterial ({\n\t\t\t\t\t\tcolor : material.diffuse,\n\t\t\t\t\t\tsize: material.pointSize\n\t\t\t\t\t});\n\t\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t},\n\t\t\tonPointGeometryEnd : function () {\n\t\t\t\tvar points = new JSM.THREE.Points (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (points);\n\t\t\t},\n\t\t\tonPoint : function (vertex)\t{\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex.x, vertex.y, vertex.z));\n\t\t\t},\n\t\t\tonLineGeometryStart : function (material) {\n\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t\tthreeMaterial = new JSM.THREE.LineBasicMaterial ({\n\t\t\t\t\tcolor : material.diffuse\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLineGeometryEnd : function () {\n\t\t\t\tvar lines = new JSM.THREE.LineSegments (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (lines);\n\t\t\t},\n\t\t\tonLine : function (begVertex, endVertex) {\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (begVertex.x, begVertex.y, begVertex.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (endVertex.x, endVertex.y, endVertex.z));\n\t\t\t},\n\t\t\tonGeometryStart : function (material) {\n\t\t\t\tvar hasTexture = (material.texture !== null);\n\t\t\t\tvar hasOpacity = (material.opacity !== 1.0);\n\n\t\t\t\tvar diffuse = material.diffuse;\n\t\t\t\tvar specular = material.specular;\n\t\t\t\tvar shininess = material.shininess;\n\t\t\t\tif (shininess === 0.0) {\n\t\t\t\t\tspecular = 0x000000;\n\t\t\t\t\tshininess = 1;\n\t\t\t\t}\n\n\t\t\t\tthreeMaterial = new JSM.THREE.MeshPhongMaterial ({\n\t\t\t\t\tcolor : diffuse,\n\t\t\t\t\tspecular : specular,\n\t\t\t\t\tshininess : shininess\n\t\t\t\t});\n\n\t\t\t\tif (!material.singleSided) {\n\t\t\t\t\tthreeMaterial.side = JSM.THREE.DoubleSide;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hasOpacity) {\n\t\t\t\t\tthreeMaterial.opacity = material.opacity;\n\t\t\t\t\tthreeMaterial.transparent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\tvar theMaterial = threeMaterial;\n\t\t\t\t\tvar textureName = material.texture;\n\t\t\t\t\tvar loader = new JSM.THREE.TextureLoader ();\n\t\t\t\t\tloader.load (textureName, function (texture) {\n\t\t\t\t\t\ttexture.image = JSM.ResizeImageToPowerOfTwoSides (texture.image);\n\t\t\t\t\t\ttexture.wrapS = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttheMaterial.map = texture;\n\t\t\t\t\t\ttheMaterial.needsUpdate = true;\n\t\t\t\t\t\tif (theConversionData.textureLoadedCallback !== null) {\n\t\t\t\t\t\t\ttheConversionData.textureLoadedCallback ();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t},\n\t\t\tonGeometryEnd : function () {\n\t\t\t\tthreeGeometry.computeFaceNormals ();\n\t\t\t\tvar mesh = new JSM.THREE.Mesh (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (mesh);\n\t\t\t},\n\t\t\tonTriangle : function (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3) {\n\t\t\t\tvar lastVertexIndex = threeGeometry.vertices.length;\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex1.x, vertex1.y, vertex1.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex2.x, vertex2.y, vertex2.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex3.x, vertex3.y, vertex3.z));\n\t\t\t\tvar face = new JSM.THREE.Face3 (lastVertexIndex + 0, lastVertexIndex + 1, lastVertexIndex + 2);\n\t\t\t\tthreeGeometry.faces.push (face);\n\t\t\t\t\n\t\t\t\tif (normal1 !== null && normal2 !== null && normal3 !== null) {\n\t\t\t\t\tvar normalArray = [];\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal1.x, normal1.y, normal1.z));\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal2.x, normal2.y, normal2.z));\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal3.x, normal3.y, normal3.z));\n\t\t\t\t\tthreeGeometry.faces[threeGeometry.faces.length - 1].vertexNormals = normalArray;\n\t\t\t\t}\n\n\t\t\t\tif (uv1 !== null && uv2 !== null && uv3 !== null) {\n\t\t\t\t\tvar uvArray = [];\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv1.x, -uv1.y));\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv2.x, -uv2.y));\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv3.x, -uv3.y));\n\t\t\t\t\tthreeGeometry.faceVertexUvs[0].push (uvArray);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tJSM.ExplodeBody (body, materials, explodeData);\n\t\treturn meshes;\n\t};\n\n\tJSM.ConvertModelToThreeMeshes = function (model, conversionData)\n\t{\n\t\tvar meshes = [];\n\t\tvar materials = model.GetMaterialSet ();\n\t\t\n\t\tvar i, j, body, currentMeshes;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentMeshes = JSM.ConvertBodyToThreeMeshes (body, materials, conversionData);\n\t\t\tfor (j = 0; j < currentMeshes.length; j++) {\n\t\t\t\tmeshes.push (currentMeshes[j]);\n\t\t\t}\n\t\t}\n\n\t\treturn meshes;\n\t};\n\n\tJSM.ConvertJSONDataToThreeMeshes = function (jsonData, textureLoadedCallback, asyncCallbacks)\n\t{\n\t\tfunction AddMesh (mesh, meshIndex, materials, resultMeshes)\n\t\t{\n\t\t\tfunction AddTriangles (currentTriangles, vertices, normals, uvs, materials, resultMeshes)\n\t\t\t{\n\t\t\t\tfunction GetTextureCoordinate (u, v, offset, scale, rotation)\n\t\t\t\t{\n\t\t\t\t\tvar result = new JSM.THREE.Vector2 (u, v);\n\t\t\t\t\tif (!JSM.IsZero (rotation)) {\n\t\t\t\t\t\tvar si = Math.sin (rotation * JSM.DegRad);\n\t\t\t\t\t\tvar co = Math.cos (rotation * JSM.DegRad);\n\t\t\t\t\t\tresult.x = co * u - si * v;\n\t\t\t\t\t\tresult.y = si * u + co * v;\n\t\t\t\t\t}\n\t\t\t\t\tresult.x = offset[0] + result.x * scale[0];\n\t\t\t\t\tresult.y = offset[1] + result.y * scale[1];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar materialIndex = currentTriangles.material;\n\t\t\t\tvar parameters = currentTriangles.parameters;\n\t\t\t\tvar materialData = materials[materialIndex];\n\t\t\t\t\n\t\t\t\tvar textureName = materialData.texture;\n\t\t\t\tvar textureOffset = materialData.offset;\n\t\t\t\tvar textureScale = materialData.scale;\n\t\t\t\tvar textureRotation = materialData.rotation;\n\t\t\t\t\n\t\t\t\tvar diffuseColor = new JSM.THREE.Color ();\n\t\t\t\tvar specularColor = new JSM.THREE.Color ();\n\t\t\t\tvar shininess = materialData.shininess || 0.0;\n\n\t\t\t\tdiffuseColor.setRGB (materialData.diffuse[0], materialData.diffuse[1], materialData.diffuse[2]);\n\t\t\t\tspecularColor.setRGB (materialData.specular[0], materialData.specular[1], materialData.specular[2]);\n\n\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\tdiffuseColor.setRGB (1.0, 1.0, 1.0);\n\t\t\t\t\tspecularColor.setRGB (1.0, 1.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\tif (textureOffset === undefined || textureOffset === null) {\n\t\t\t\t\t\ttextureOffset = [0.0, 0.0];\n\t\t\t\t\t}\n\t\t\t\t\tif (textureScale === undefined || textureScale === null) {\n\t\t\t\t\t\ttextureScale = [1.0, 1.0];\n\t\t\t\t\t}\n\t\t\t\t\tif (textureRotation === undefined || textureRotation === null) {\n\t\t\t\t\t\ttextureRotation = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shininess === 0.0) {\n\t\t\t\t\tspecularColor.setRGB (0.0, 0.0, 0.0);\n\t\t\t\t\tshininess = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = new JSM.THREE.MeshPhongMaterial ({\n\t\t\t\t\t\tcolor : diffuseColor.getHex (),\n\t\t\t\t\t\tspecular : specularColor.getHex (),\n\t\t\t\t\t\tshininess : shininess,\n\t\t\t\t\t\tside : JSM.THREE.DoubleSide\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (materialData.opacity !== 1.0) {\n\t\t\t\t\tmaterial.opacity = materialData.opacity;\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\tvar loader = new JSM.THREE.TextureLoader ();\n\t\t\t\t\tvar theMaterial = material;\n\t\t\t\t\tloader.load (textureName, function (texture) {\n\t\t\t\t\t\ttexture.image = JSM.ResizeImageToPowerOfTwoSides (texture.image);\n\t\t\t\t\t\ttexture.wrapS = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttheMaterial.map = texture;\n\t\t\t\t\t\ttheMaterial.needsUpdate = true;\n\t\t\t\t\t\tif (textureLoadedCallback !== undefined && textureLoadedCallback !== null) {\n\t\t\t\t\t\t\ttextureLoadedCallback ();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar geometry = new JSM.THREE.Geometry ();\n\n\t\t\t\tvar v1, v2, v3, n1, n2, n3, u1, u2, u3;\n\t\t\t\tvar lastVertex, lastFace, vertexNormals, textureUVs;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < parameters.length; j += 9) {\n\t\t\t\t\tv1 = 3 * parameters[j + 0];\n\t\t\t\t\tv2 = 3 * parameters[j + 1];\n\t\t\t\t\tv3 = 3 * parameters[j + 2];\n\t\t\t\t\tn1 = 3 * parameters[j + 3];\n\t\t\t\t\tn2 = 3 * parameters[j + 4];\n\t\t\t\t\tn3 = 3 * parameters[j + 5];\n\t\t\t\t\tu1 = 2 * parameters[j + 6];\n\t\t\t\t\tu2 = 2 * parameters[j + 7];\n\t\t\t\t\tu3 = 2 * parameters[j + 8];\n\t\t\t\t\t\n\t\t\t\t\tlastVertex = geometry.vertices.length;\n\t\t\t\t\tlastFace = geometry.faces.length;\n\t\t\t\t\t\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v1 + 0], vertices[v1 + 1], vertices[v1 + 2]));\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v2 + 0], vertices[v2 + 1], vertices[v2 + 2]));\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v3 + 0], vertices[v3 + 1], vertices[v3 + 2]));\n\t\t\t\t\tgeometry.faces.push (new JSM.THREE.Face3 (lastVertex + 0, lastVertex + 1, lastVertex + 2));\n\n\t\t\t\t\tvertexNormals = [];\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n1 + 0], normals[n1 + 1], normals[n1 + 2]));\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n2 + 0], normals[n2 + 1], normals[n2 + 2]));\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n3 + 0], normals[n3 + 1], normals[n3 + 2]));\n\t\t\t\t\tgeometry.faces[lastFace].vertexNormals = vertexNormals;\n\n\t\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\t\ttextureUVs = [];\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u1 + 0], uvs[u1 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u2 + 0], uvs[u2 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u3 + 0], uvs[u3 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\tgeometry.faceVertexUvs[0].push (textureUVs);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar mesh = new JSM.THREE.Mesh (geometry, material);\n\t\t\t\tmesh.originalJsonMaterialIndex = materialIndex;\n\t\t\t\tmesh.originalJsonMeshIndex = meshIndex;\n\t\t\t\tresultMeshes.push (mesh);\n\t\t\t}\n\n\t\t\tvar vertices = mesh.vertices;\n\t\t\tif (vertices === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar normals = mesh.normals;\n\t\t\tif (normals === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar uvs = mesh.uvs;\n\t\t\tif (uvs === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tvar triangles = mesh.triangles;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\tAddTriangles (triangles[i], vertices, normals, uvs, materials, resultMeshes);\n\t\t\t}\n\t\t}\n\n\t\tvar resultMeshes = [];\n\n\t\tvar materials = jsonData.materials;\n\t\tif (materials === undefined) {\n\t\t\treturn resultMeshes;\n\t\t}\n\t\t\n\t\tvar meshes = jsonData.meshes;\n\t\tif (meshes === undefined) {\n\t\t\treturn resultMeshes;\n\t\t}\n\t\t\n\t\tvar i = 0;\n\t\tJSM.AsyncRunTask (\n\t\t\tfunction () {\n\t\t\t\tAddMesh (meshes[i], i, materials, resultMeshes);\n\t\t\t\ti = i + 1;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tasyncCallbacks,\n\t\t\tmeshes.length, 0, resultMeshes\n\t\t);\n\n\t\treturn resultMeshes;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/threeviewer/threeviewer',[\"../../core/jsm\"],function(JSM){\n\tJSM.ThreeViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\t\n\t\tthis.scene = null;\n\t\tthis.camera = null;\n\t\tthis.renderer = null;\n\t\tthis.ambientLight = null;\n\t\tthis.directionalLight = null;\n\t\tthis.runBeforeRender = null;\n\t\tthis.runAfterRender = null;\n\n\t\tthis.cameraMove = null;\n\t\tthis.navigation = null;\n\t\tthis.settings = null;\n\t\tthis.drawLoop = null;\n\t\tthis.enableDraw = null;\n\t};\n\n\tJSM.ThreeViewer.prototype.Start = function (canvas, settings)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitSettings (settings)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.InitThree (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (settings)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.drawLoop = false;\n\t\tthis.enableDraw = true;\n\t\tthis.DrawIfNeeded ();\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitSettings = function (settings)\n\t{\n\t\tthis.settings = {\n\t\t\tcameraEyePosition : new JSM.Coord (1.0, 1.0, 1.0),\n\t\t\tcameraCenterPosition : new JSM.Coord (0.0, 0.0, 0.0),\n\t\t\tcameraUpVector : new JSM.Coord (0.0, 0.0, 1.0),\n\t\t\tlightAmbientColor : [0.5, 0.5, 0.5],\n\t\t\tlightDiffuseColor : [0.5, 0.5, 0.5]\n\t\t};\n\n\t\tif (settings !== undefined) {\n\t\t\tif (settings.cameraEyePosition !== undefined) { this.settings.cameraEyePosition = JSM.CoordFromArray (settings.cameraEyePosition); }\n\t\t\tif (settings.cameraCenterPosition !== undefined) { this.settings.cameraCenterPosition = JSM.CoordFromArray (settings.cameraCenterPosition); }\n\t\t\tif (settings.cameraUpVector !== undefined) { this.settings.cameraUpVector = JSM.CoordFromArray (settings.cameraUpVector); }\n\t\t\tif (settings.lightAmbientColor !== undefined) { this.settings.lightAmbientColor = settings.lightAmbientColor; }\n\t\t\tif (settings.lightDiffuseColor !== undefined) { this.settings.lightDiffuseColor = settings.lightDiffuseColor; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitThree = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas || !this.canvas.getContext) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.scene = new JSM.THREE.Scene();\n\t\tif (!this.scene) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar parameters = {\n\t\t\tcanvas : this.canvas,\n\t\t\tantialias : true\n\t\t};\n\t\tthis.renderer = new JSM.THREE.WebGLRenderer (parameters);\n\t\tif (!this.renderer) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.renderer.setClearColor (new JSM.THREE.Color (0xffffff));\n\t\tthis.renderer.setSize (this.canvas.width, this.canvas.height);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitCamera = function (settings)\n\t{\n\t\tthis.cameraMove = new JSM.Camera (\n\t\t\tJSM.CoordFromArray (settings.cameraEyePosition),\n\t\t\tJSM.CoordFromArray (settings.cameraCenterPosition),\n\t\t\tJSM.CoordFromArray (settings.cameraUpVector),\n\t\t\tsettings.fieldOfView,\n\t\t\tsettings.nearClippingPlane,\n\t\t\tsettings.farClippingPlane\n\t\t);\n\t\tif (!this.cameraMove) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.cameraMove, this.DrawIfNeeded.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.camera = new JSM.THREE.PerspectiveCamera (this.cameraMove.fieldOfView, this.canvas.width / this.canvas.height, this.cameraMove.nearClippingPlane, this.cameraMove.farClippingPlane);\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.scene.add (this.camera);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitLights = function ()\n\t{\n\t\tvar ambientColor = new JSM.THREE.Color ();\n\t\tvar diffuseColor = new JSM.THREE.Color ();\n\t\tambientColor.setRGB (this.settings.lightAmbientColor[0], this.settings.lightAmbientColor[1], this.settings.lightAmbientColor[2]);\n\t\tdiffuseColor.setRGB (this.settings.lightDiffuseColor[0], this.settings.lightDiffuseColor[1], this.settings.lightDiffuseColor[2]);\n\n\t\tthis.ambientLight = new JSM.THREE.AmbientLight (ambientColor.getHex ());\n\t\tif (!this.ambientLight) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.scene.add (this.ambientLight);\n\t\t\n\t\tthis.directionalLight = new JSM.THREE.DirectionalLight (diffuseColor.getHex ());\n\t\tif (!this.directionalLight) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar lightPosition = new JSM.THREE.Vector3 ().subVectors (this.cameraMove.eye, this.cameraMove.center);\n\t\tthis.directionalLight.position.set (lightPosition.x, lightPosition.y, lightPosition.z);\n\n\t\tthis.scene.add (this.directionalLight);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetRunBeforeRender = function (runBeforeRender)\n\t{\n\t\tthis.runBeforeRender = runBeforeRender;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetRunAfterRender = function (runAfterRender)\n\t{\n\t\tthis.runAfterRender = runAfterRender;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetClearColor = function (color)\n\t{\n\t\tthis.renderer.setClearColor (new JSM.THREE.Color (color));\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AddMesh = function (mesh)\n\t{\n\t\tthis.scene.add (mesh);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AddMeshes = function (meshes)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < meshes.length; i++) {\n\t\t\tthis.scene.add (meshes[i]);\n\t\t}\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.MeshCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.VisibleMeshCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsVisibleObject (current)) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.VertexCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tcount = count + current.geometry.vertices.length;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.FaceCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (current instanceof JSM.THREE.Mesh) {\n\t\t\t\tcount = count + current.geometry.faces.length;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.GetMesh = function (index)\n\t{\n\t\tvar current = null;\n\t\tvar currIndex = 0;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < this.scene.children.length; i++) {\n\t\t\tcurrent = this.scene.children[i];\n\t\t\tif (this.IsRelevantObject (current)) {\n\t\t\t\tif (currIndex == index) {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\tcurrIndex = currIndex + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\n\tJSM.ThreeViewer.prototype.ShowMesh = function (mesh)\n\t{\n\t\tmesh.visible = true;\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.HideMesh = function (mesh)\n\t{\n\t\tmesh.visible = false;\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveMesh = function (mesh)\n\t{\n\t\tmesh.geometry.dispose ();\n\t\tthis.scene.remove (mesh);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveMeshes = function ()\n\t{\n\t\tvar current;\n\t\tvar i;\n\t\tfor (i = 0; i < this.scene.children.length; i++) {\n\t\t\tcurrent = this.scene.children[i];\n\t\t\tif (this.IsRelevantObject (current)) {\n\t\t\t\tcurrent.geometry.dispose ();\n\t\t\t\tthis.scene.remove (current);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveLastMesh = function ()\n\t{\n\t\tvar found = null;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tfound = current;\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (found !== null) {\n\t\t\tthis.scene.remove (found);\n\t\t}\n\t\t\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.SetCamera = function (eye, center, up)\n\t{\n\t\tthis.navigation.SetCamera (eye, center, up);\n\t\tthis.navigation.SetOrbitCenter (center.Clone ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.Resize = function ()\n\t{\n\t\tthis.camera.aspect = this.canvas.width / this.canvas.height;\n\t\tthis.camera.updateProjectionMatrix ();\n\t\tthis.renderer.setSize (this.canvas.width, this.canvas.height);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.FitInWindow = function ()\n\t{\n\t\tif (this.VisibleMeshCount () === 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.FitMeshesInWindow = function (meshes)\n\t{\n\t\tif (meshes.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar sphere = this.GetFilteredBoundingSphere (function (obj) {\n\t\t\treturn meshes.indexOf (obj) != -1;\n\t\t});\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AdjustClippingPlanes = function (radiusLimit)\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tif (sphere.GetRadius () < radiusLimit) {\n\t\t\tthis.camera.near = 0.1;\n\t\t\tthis.camera.far = 1000.0;\n\t\t} else {\n\t\t\tthis.camera.near = 10.0;\n\t\t\tthis.camera.far = 1000000.0;\n\t\t}\n\t\tthis.camera.updateProjectionMatrix ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.ThreeViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredCenter (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredBoundingBox (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredBoundingSphere (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredCenter = function (needToProcess)\n\t{\n\t\tvar boundingBox = this.GetFilteredBoundingBox (needToProcess);\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredBoundingBox = function (needToProcess)\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar geometry, coord;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (needToProcess (current)) {\n\t\t\t\tgeometry = current.geometry;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < geometry.vertices.length; j++) {\n\t\t\t\t\tcoord = geometry.vertices[j].clone ();\n\t\t\t\t\tcoord.add (current.position);\n\t\t\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredBoundingSphere = function (needToProcess)\n\t{\n\t\tvar center = this.GetFilteredCenter (needToProcess);\n\t\tvar radius = 0.0;\n\n\t\tvar geometry, coord, distance;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (needToProcess (current)) {\n\t\t\t\tgeometry = current.geometry;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < geometry.vertices.length; j++) {\n\t\t\t\t\tcoord = geometry.vertices[j].clone ();\n\t\t\t\t\tcoord.add (current.position);\n\t\t\t\t\tdistance = center.DistanceTo (new JSM.Coord (coord.x, coord.y, coord.z));\n\t\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\t\tradius = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderPosition = function (x, y)\n\t{\n\t\tvar mouseX = (x / this.canvas.width) * 2 - 1;\n\t\tvar mouseY = -(y / this.canvas.height) * 2 + 1;\n\n\t\tvar cameraPosition = this.camera.position;\n\t\tvar vector = new JSM.THREE.Vector3 (mouseX, mouseY, 0.5);\n\t\tvector.unproject (this.camera);\n\t\tvector.sub (cameraPosition);\n\t\tvector.normalize ();\n\n\t\tvar ray = new JSM.THREE.Raycaster (cameraPosition, vector);\n\t\treturn ray.intersectObjects (this.scene.children);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderMouse = function ()\n\t{\n\t\treturn this.GetObjectsUnderPosition (this.navigation.mouse.curr.x, this.navigation.mouse.curr.y);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderTouch = function ()\n\t{\n\t\treturn this.GetObjectsUnderPosition (this.navigation.touch.curr.x, this.navigation.touch.curr.y);\n\t};\n\n\tJSM.ThreeViewer.prototype.ProjectVector = function (x, y, z)\n\t{\n\t\tvar width = this.canvas.width;\n\t\tvar height = this.canvas.height;\n\t\tvar halfWidth = width / 2;\n\t\tvar halfHeight = height / 2;\n\n\t\tvar vector = new JSM.THREE.Vector3 (x, y, z);\n\t\tvector.project (this.camera);\n\t\tvector.x = (vector.x * halfWidth) + halfWidth;\n\t\tvector.y = -(vector.y * halfHeight) + halfHeight;\n\t\treturn vector;\n\t};\n\n\tJSM.ThreeViewer.prototype.EnableDraw = function (enable)\n\t{\n\t\tthis.enableDraw = enable;\n\t};\n\n\tJSM.ThreeViewer.prototype.Draw = function ()\n\t{\n\t\tif (!this.enableDraw) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.runBeforeRender !== null) {\n\t\t\tthis.runBeforeRender ();\n\t\t}\n\n\t\tthis.camera.position.set (this.cameraMove.eye.x, this.cameraMove.eye.y, this.cameraMove.eye.z);\n\t\tthis.camera.up.set (this.cameraMove.up.x, this.cameraMove.up.y, this.cameraMove.up.z);\n\t\tthis.camera.lookAt (new JSM.THREE.Vector3 (this.cameraMove.center.x, this.cameraMove.center.y, this.cameraMove.center.z));\n\n\t\tvar lightPosition = new JSM.THREE.Vector3 ().subVectors (this.cameraMove.eye, this.cameraMove.center);\n\t\tthis.directionalLight.position.set (lightPosition.x, lightPosition.y, lightPosition.z);\n\n\t\tthis.renderer.render (this.scene, this.camera);\n\t\t\n\t\tif (this.runAfterRender !== null) {\n\t\t\tthis.runAfterRender ();\n\t\t}\n\t\t\n\t\tif (this.drawLoop) {\n\t\t\trequestAnimationFrame (this.Draw.bind (this));\n\t\t}\n\t};\n\n\tJSM.ThreeViewer.prototype.DrawIfNeeded = function ()\n\t{\n\t\tif (!this.drawLoop) {\n\t\t\tthis.Draw ();\n\t\t}\n\t};\n\n\tJSM.ThreeViewer.prototype.StartDrawLoop = function ()\n\t{\n\t\tthis.drawLoop = true;\n\t\tthis.Draw ();\n\t};\n\n\tJSM.ThreeViewer.prototype.IsRelevantObject = function (threeObj)\n\t{\n\t\treturn (threeObj instanceof JSM.THREE.Mesh || threeObj instanceof JSM.THREE.LineSegments || threeObj instanceof JSM.THREE.Points);\n\t};\n\n\tJSM.ThreeViewer.prototype.IsVisibleObject = function (threeObj)\n\t{\n\t\treturn this.IsRelevantObject (threeObj) && threeObj.visible;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/main',[\r\n\t\"skylark-langx/skylark\",\r\n\t\"./core/jsm\",\r\n\t\"./core/timer\",\r\n\t\"./core/algorithm\",\r\n\t\"./core/async\",\r\n\t\"./core/check\",\r\n\t\"./core/jsonloader\",\r\n\t\"./geometry/definitions\",\r\n\t\"./geometry/coord2d\",\r\n\t\"./geometry/coord\",\r\n\t\"./geometry/determinant\",\r\n\t\"./geometry/coordutils\",\r\n\t\"./geometry/matrix\",\r\n\t\"./geometry/coordsystem\",\r\n\t\"./geometry/sector\",\r\n\t\"./geometry/line\",\r\n\t\"./geometry/box\",\r\n\t\"./geometry/sphere\",\r\n\t\"./geometry/transformation\",\r\n\t\"./geometry/plane\",\r\n\t\"./geometry/projection\",\r\n\t\"./geometry/convexhull\",\r\n\t\"./geometry/polygon2d\",\r\n\t\"./geometry/polygon\",\r\n\t\"./geometry/cutpolygon\",\r\n\t\"./geometry/triangulation\",\r\n\t\"./geometry/octree\",\r\n\t\"./geometry/bsptree\",\r\n\t\"./geometry/curves\",\r\n\t\"./geometry/utilities\",\r\n\t\"./geometry/ray\",\r\n\t\"./geometry/path\",\r\n\t\"./modeler/color\",\r\n\t\"./modeler/material\",\r\n\t\"./modeler/materialset\",\r\n\t\"./modeler/body\",\r\n\t\"./modeler/model\",\r\n\t\"./modeler/adjacencyinfo\",\r\n\t\"./modeler/bodyutils\",\r\n\t\"./modeler/textureutils\",\r\n\t\"./modeler/cututils\",\r\n\t\"./modeler/generator\",\r\n\t\"./modeler/camera\",\r\n\t\"./modeler/explode\",\r\n\t\"./modeler/exporter\",\r\n\t\"./modeler/trianglebody\",\r\n\t\"./modeler/trianglemodel\",\r\n\t\"./modeler/converter\",\r\n\t\"./modeler/rayutils\",\r\n\t\"./import/binaryreader\",\r\n\t\"./import/importerutils\",\r\n\t\"./import/importer3ds\",\r\n\t\"./import/importerobj\",\r\n\t\"./import/importerstl\",\r\n\t\"./import/importeroff\",\r\n\t\"./import/importercommon\",\r\n\t\"./renderer/webglutils\",\r\n\t\"./renderer/renderlight\",\r\n\t\"./renderer/rendermaterial\",\r\n\t\"./renderer/rendermesh\",\r\n\t\"./renderer/renderbody\",\r\n\t\"./renderer/shaderprogram\",\r\n\t\"./renderer/renderer\",\r\n\t\"./renderer/pointcloudrenderer\",\r\n\t\"./renderer/renderconverter\",\r\n\t\"./viewer/mouse\",\r\n\t\"./viewer/touch\",\r\n\t\"./viewer/painter\",\r\n\t\"./viewer/drawing\",\r\n\t\"./viewer/navigation\",\r\n\t\"./viewer/softwareviewer\",\r\n\t\"./viewer/spriteviewer\",\r\n\t\"./viewer/viewer\",\r\n\t\"./viewer/pointcloudviewer\",\r\n\t\"./extras/solidgenerator\",\r\n\t\"./extras/extgenerator\",\r\n\t\"./extras/subdivision\",\r\n\t\"./extras/csg\",\r\n\t\"./extras/surfaces\",\r\n\t\"./extensions/svgtomodel/svgtomodel\",\r\n\t\"./extensions/textgenerator/textgenerator\",\r\n\t\"./extensions/threeviewer/threeconverter\",\r\n\t\"./extensions/threeviewer/threeviewer\"\r\n\r\n],function(skyalrk,jsm){\r\n\treturn skylark.attach(\"intg.jsmodeler\",jsm);\r\n});\ndefine('skylark-jsmodeler', ['skylark-jsmodeler/main'], function (main) { return main; });\n\n"]}