{"version":3,"sources":["skylark-jsmodeler.js"],"names":["define","JSM","this","mainVersion","subVersion","RandomNumber","from","to","Math","random","RandomInt","floor","RandomBoolean","SeededRandomInt","seed","ValueOrDefault","val","def","undefined","PrevIndex","index","length","NextIndex","CopyObjectProperties","source","target","overwrite","property","hasOwnProperty","GetObjectProperty","object","propertyName","defaultValue","propertyValue","Message","message","console","log","Timer","start","stop","prototype","Start","date","Date","getTime","Stop","end","Result","FPSCounter","frames","current","Get","interval","elapsed","parseInt","SwapArrayValues","array","temp","BubbleSort","onCompare","onSwap","compareFunction","i","j","swapFunction","ShiftArray","count","push","shift","AsyncRunTask","taskFunction","callbacks","runCount","timeout","userData","onStart","OnStart","RunTask","currentCount","needContinue","onProgress","OnProgress","setTimeout","onFinish","OnFinished","IsWebGLEnabled","window","WebGLRenderingContext","canvas","document","createElement","getContext","exception","IsFileApiEnabled","File","FileReader","FileList","Blob","URL","LoadJsonFile","fileName","onReady","request","XMLHttpRequest","overrideMimeType","open","onreadystatechange","readyState","jsonData","JSON","parse","responseText","send","Eps","Inf","RadDeg","DegRad","IsZero","a","abs","IsPositive","IsNegative","IsLower","b","IsGreater","IsEqual","IsEqualWithEps","eps","IsLowerOrEqual","IsGreaterOrEqual","Minimum","Maximum","ArcSin","value","PI","asin","ArcCos","acos","Coord2D","x","y","Set","coord","DistanceTo","sqrt","AngleTo","aDirection","Clone","Normalize","bDirection","product","VectorDot2D","Length","MultiplyScalar","scalar","SetLength","thisLength","Offset","direction","distance","normal","Rotate","angle","origo","co","cos","si","sin","ToString","Vector2D","CoordFromArray2D","CoordToArray2D","CoordAdd2D","CoordSub2D","Coord","z","VectorDot","IsCollinearWith","IsPerpendicularWith","Add","Sub","axis","u","v","w","ToCoord2D","zNormal","Vector","VectorCross","rotated","CoordFromArray","CoordToArray","CoordAdd","CoordSub","result","MatrixDeterminant2x2","m00","m01","m10","m11","MatrixDeterminant3x3","m02","m12","m20","m21","m22","subDet1","subDet2","subDet3","MatrixDeterminant4x4","m03","m13","m23","m30","m31","m32","m33","subDet4","Orientation","Invalid","CounterClockwise","Clockwise","MidCoord2D","CoordOrientation2D","c","determinant","CoordSignedDistance2D","abDirection","PolarToCartesian","radius","theta","GetArcLengthFromAngle","GetAngleFromArcLength","arcLength","MidCoord","CoordSignedDistance","GetVectorsFullAngle","CoordOrientation","a2","b2","c2","orientation","SphericalToCartesian","phi","CylindricalToCartesian","height","GetArcLength","GetFullArcLength","CalculateCentroid","coords","centroid","CalculateTriangleNormal","v0","v1","v2","CalculateNormal","nextIndex","next","BarycentricInterpolation","vertex0","vertex1","vertex2","value0","value1","value2","position","GetTriangleArea","s","areaSquare","edge0","edge1","edge2","distance0","distance1","distance2","area","area0","area1","area2","interpolated0","interpolated1","interpolated2","interpolated","MatrixIdentity","MatrixClone","matrix","MatrixTranspose","MatrixVectorMultiply","vector","a00","a01","a02","a03","b00","b01","b02","b03","b10","b11","b12","b13","b20","b21","b22","b23","b30","b31","b32","b33","MatrixMultiply","matrix1","matrix2","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","MatrixDeterminant","b04","b05","b06","b07","b08","b09","MatrixInvert","MatrixTranslation","MatrixRotation","u2","w2","MatrixRotationQuaternion","quaternion","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","MatrixRotationX","MatrixRotationY","MatrixRotationZ","ApplyTransformation","resultVector","ApplyRotation","CoordSystem","e1","e2","e3","ToDirectionVectors","ToAbsoluteCoords","CoordSectorPosition2D","CoordInsideOfSector","CoordOnSectorEndCoord","CoordOutsideOfSector","SectorSectorPosition2D","SectorsDontIntersect","SectorsIntersectCoincident","SectorsIntersectEndPoint","SectorsIntersectOnePoint","CoordSectorPosition","Sector2D","beg","GetLength","CoordPosition","x1","y1","ux","uy","SectorPosition","sector","intersection","IsOnSegment","max","min","calcIntersection","aBeg","aEnd","bBeg","bEnd","equalBeg","equalEnd","x3","y3","x4","y4","numeratorA","numeratorB","denominator","distA","distB","ProjectCoord","denom","dir","Sector","z1","bu","GetSectorSegmentation2D","segmentation","offseted","step","GetSectorSegmentation","CoordLinePosition2D","CoordOnLine","CoordAtLineLeft","CoordAtLineRight","LineLinePosition2D","LinesDontIntersect","LinesIntersectsOnePoint","LinesIntersectsCoincident","CoordLinePosition","CoordOutsideOfLine","LineLinePosition","Line2D","LinePosition","line","Line","projected","ClosestPoint","thisClosestPoint","lineClosestPoint","Dmnop","m","n","o","p","aDir","aStart","bDir","bStart","d1010","d0210","d0232","d3210","d3232","nom","mua","mub","aClosest","bClosest","Box2D","GetCenter","Box","GetSize","IsCoordInside","BoxUnion","aBox","bBox","Sphere","center","GetRadius","Transformation","GetMatrix","SetMatrix","Append","Apply","IdentityTransformation","transformation","TranslationTransformation","translation","OffsetTransformation","RotationTransformation","RotationXTransformation","RotationYTransformation","RotationZTransformation","RotationXYZTransformation","xAngle","yAngle","zAngle","CoordPlanePosition","CoordOnPlane","CoordInFrontOfPlane","CoordAtBackOfPlane","LinePlanePosition","LineParallelToPlane","LineIntersectsPlane","Plane","d","GetNormal","CoordDistance","signed","side","LineIntersection","GetPlaneFromCoordAndDirection","plane","pa","pb","pc","pd","GetPlaneFromThreeCoords","CoordPlaneSignedDirectionalDistance","CoordPlaneDirectionalDistance","MatrixView","eye","up","MatrixPerspective","fieldOfView","aspectRatio","nearPlane","farPlane","f","tan","nf","Project","viewPort","input","viewMatrix","perspectiveMatrix","projectionMatrix","output","Unproject","inverseMatrix","ConvexHull2D","FindNextCoord","first","minValue","minIndex","FindLeftMostCoord","ConvexHull3D","AddVertex","body","vertex","vertices","AddEdge","triangleIndex","edgeIndex","edges","vert1","vert2","newEdge","tri1","tri2","edge","AddTriangle","triangles","edge3","triangle","valid","RemoveTriangleFromEdge","RemoveTriangle","CheckTetrahedronOrientation","aCoord","bCoord","cCoord","dCoord","adSub","bdSub","cdSub","GetTetrahedronVolume","AddCoordToHull","edge1Vis","edge2Vis","edge3Vis","visibleTriangles","newTriangle","newTriangles","AddInitialTetrahedron","Complexity","Convex","Concave","Complex","CoordPolygonPosition2D","OnVertex","OnEdge","Inside","Outside","SectorPolygonPosition2D","IntersectionOnePoint","IntersectionCoincident","IntersectionOnVertex","NoIntersection","Polygon2D","cache","Clear","AddVertexCoord","ClearCache","GetVertex","RemoveVertex","splice","VertexCount","EnumerateVertices","callback","GetNextVertex","GetPrevVertex","ShiftVertices","ReverseVertices","reverse","GetVertexAngle","prev","curr","prevDir","nextDir","GetSignedArea","signedArea","GetArea","GetOrientation","GetComplexity","complexity","polygonOrientain","IsConcaveVertex","GetVertexOrientation","vertexOrientations","IsConvexVertex","vertexOrientation","IntersectionCount","begYDist","endYDist","begBelow","begAbove","endBelow","endAbove","begOnLine","endOnLine","yMoveRatio","GetIntersection","upwardEdge","edgeFrom","edgeTo","vertexCount","intersections","begIndex","endIndex","edgeBegIndex","edgeEndIndex","edgeBeg","edgeEnd","currentSector","IsDiagonal","fromVertex","toVertex","polygon","DiagonalIntersectsAnyEdges","midCoord","DiagonalInsideOfPolygon","ToArray","FromArray","GetBoundingBox","boundingBox","ContourPolygon2D","contours","lastContour","AddContourVertex","contourIndex","AddContourVertexCoord","ContourVertexCount","AddContour","contour","GetLastContour","GetContourVertex","vertexIndex","GetContour","ContourCount","contourOrientation","Polygon","ToPolygon2D","ContourPolygon","ToContourPolygon2D","OffsetPolygonContour","width","prevVertex","currVertex","nextVertex","offsetedCoord","CutVertexType","Left","Right","Cut","PolygonCutter","geometryInterface","Reset","aSidePolygons","bSidePolygons","cutPolygons","allVertexType","CalculateOriginalPolygonData","cloned","CalculateCutPolygonData","CalculateEntryVertices","CalculateCuttedPolygons","originalPolygon","originalPolygonVertexTypes","cutPolygon","cutPolygonVertexTypes","cutPolygonVertexDistances","cutVertexIndices","entryVertices","entryVertexTypes","type","aSideFound","bSideFound","getVertexSide","IsIntersectionVertex","originalType","prevType","AddCutVertexToPolygon","polygonCutter","AddIntersectionVertex","originalIndex","prevIndex","getIntersectionVertex","AddOriginalVertex","nextType","createPolygon","lastVertex","getVertexDistances","aDist","bDist","SortCutVertices","GetEntryVertexType","currIndex","currSideType","prevSideType","nextSideType","currVertexDistance","prevVertexDistance","nextVertexDistance","vertexType","AddOneSideCuttedPolygons","reversed","AddEntryPairToArray","entryPairs","fromIndex","toIndex","currVertexIndex","RemoveEntryPairFromArray","AddCutPolygon","currEntryVertex","AddVertexIfNotDuplicated","startVertexIndex","currPolygon","polygonSide","FindPairIndex","startIndex","pairIndex","CreateEntryPairsArray","CutPolygon2DWithLine","leftPolygons","rightPolygons","edgeLine","lineLinePosition","refLineStart","refLineDir","refLine","distances","cutter","CutPolygonWithPlane","frontPolygons","backPolygons","linePlanePosition","polygonNormal","planeNormal","refPlaneNormal","refPlaneOrigin","refPlane","SegmentPolygon2D","xSegments","ySegments","CutPolygonsOneDirection","inputPolygons","resultPolygons","segmentCount","segmentSize","startCoordinate","segmentDir","cutDir","CutPolygon","left","right","newPolygonsToProcess","polygonsToProcess","startCoord","xSize","ySize","xSegmentSize","ySegmentSize","originalPolygons","bottomLeft","topLeft","xCuttedPolygons","yCuttedPolygons","ConvertContourPolygonToPolygon2D","inputPolygon","vertexMap","AddResultVertex","resultPolygon","originalContour","originalVertex","holeIndex","conversionData","entryPoint","IsEntryPoint","resultVertex","holeVertex","SegmentIntersectsPolygon","segmentBeg","segmentEnd","addedHoles","IsExistingEntryPosition","entryPositions","resultVertexIndex","holeVertexIndex","holePolygon","GetEntryPoint","mainContourBeg","mainEntryVertex","mainEntryContourIndex","mainEntryVertexIndex","contourBeg","contourEnd","AddHole","contourCount","mainContour","holeQueue","holeTryouts","TriangulateConvexPolygon","TriangulateConcavePolygon2D","FindSplitDiagonal","SplitPolygon","polygonData","diagonal","resultData","map","resultData1","resultData2","polygonStack","inputMap","GetInitialVertexMap","pop","TriangulatePolygon2D","TriangulatePolygon","polygon2D","TraverseOctreeNodes","octree","nodeFound","TraverseNode","node","children","child","root","CreateOctreeChildNodes","originalBox","createNodeCallback","CreateNode","dirX","dirY","dirZ","size","box","Octree","maxCoordNumInNodes","CreateNewNode","AddCoord","AddCoordToNode","FindCoord","FindNodeForCoord","FindCoordInNode","found","SplitNode","xGreater","yGreater","zGreater","myThis","nodeBox","nodeCoords","parent","newNode","TriangleOctree","AddTriangleToNode","IsTriangleInNode","BSPTree","AddPolygon","AddPolygonToNode","Traverse","inside","outside","GetNodes","NodeCount","planePolygons","cutSucceeded","AddInsidePolygonsToNode","AddOutsidePolygonsToNode","polygons","ClipPolygonWithBSPTree","bspTree","planarFrontPolygons","planarBackPolygons","CutPolygonWithNode","isPlanar","cutBackPolygons","cutFrontPolygons","cutPlanarPolygons","AddInsidePolygons","AddOutsidePolygons","CutPolygonsWithNode","AddPolygonsToArray","polygonArray","TraverseBSPTreeForEyePosition","eyePosition","coordPlanePosition","GenerateCubicBezierCurve","p0","p1","p2","p3","GetCubicBezierPoint","t","t2","t3","invT","invT2","invT3","BernsteinPolynomial","k","coefficient","BinomialCoefficient","pow","GenerateBezierCurve","points","point","bernstein","GetGaussianCParameter","epsilon","GetGaussianValue","exp","GenerateCirclePoints","segments","GetRuledMesh","aCoords","bCoords","lineSegmentation","meshSegmentation","directions","lengths","Ray","origin","GetOrigin","GetDirection","IsLengthReached","Path2D","settings","offset","scale","positionAdded","currentPolygon","MoveTo","Close","LineTo","AddPolygonPoint","CubicBezierTo","cp1x","cp1y","cp2x","cp2y","bezierPoints","CheckAndCorrectPolygon","basePolygon","IsBasePolygon","baseOrientation","baseContour","polygonOrientation","firstVertex","firstVertexPosition","FindBasePolygon","contourPolygon","PolygonCount","GetPolygon","GetPolygons","GetCurrentPolygon","polygonX","polygonY","HexColorToRGBComponents","hexColor","hexString","toString","r","substr","g","HexColorToNormalizedRGBComponents","rgb","HexColorToRGBColor","RGBComponentsToHexColor","red","green","blue","IntegerToHex","intString","Material","parameters","ambient","diffuse","specular","shininess","opacity","reflection","singleSided","pointSize","texture","textureWidth","textureHeight","MaterialSet","materials","defaultMaterial","AddMaterial","material","GetMaterial","GetDefaultMaterial","Count","BodyVertex","GetPosition","SetPosition","BodyPoint","GetVertexIndex","SetVertexIndex","HasMaterialIndex","GetMaterialIndex","SetMaterialIndex","InheritAttributes","BodyLine","GetBegVertexIndex","SetBegVertexIndex","GetEndVertexIndex","SetEndVertexIndex","BodyPolygon","curved","AddVertexIndex","InsertVertexIndex","polygonIndex","vertIndex","GetVertexIndices","SetVertexIndices","VertexIndexCount","HasCurveGroup","GetCurveGroup","SetCurveGroup","group","ReverseVertexIndices","TextureProjectionType","Planar","Cubic","Cylindrical","BodyTextureProjection","SetCubic","GetType","GetCoords","SetType","SetCoords","SetPlanar","xDirection","yDirection","zDirection","SetCylindrical","Transform","Body","AddPoint","AddLine","lines","GetVertexPosition","SetVertexPosition","GetPoint","GetLine","SetPointsMaterialIndex","SetLinesMaterialIndex","SetPolygonsMaterialIndex","SetPolygonsCurveGroup","bodyVertIndex","pointsToDelete","linesToDelete","polygonsToDelete","RemovePoint","RemoveLine","RemovePolygon","PointCount","LineCount","GetTextureProjection","projection","SetTextureProjection","SetPlanarTextureProjection","SetCubicTextureProjection","SetCylindricalTextureProjection","GetBoundingSphere","OffsetToOrigo","Merge","newPoint","newLine","newPolygon","oldVertexCount","Model","bodies","AddBody","AddBodies","GetBody","BodyCount","GetMaterialSet","MaterialCount","VertInfo","pgons","EdgeInfo","pgon1","pgon2","PolyEdgeInfo","PgonInfo","verts","pedges","AdjacencyInfo","Calculate","adjacencyInfo","pgonInfo","fromVertexIndex","toVertexIndex","pedge","currEdge","ConnectPgonAndEdgeToVert","vert","pgonIndex","indexOf","ConnectEdge","pgon","IsContourVertex","IsContourEdge","pgonCount","GetEdgePolygonCount","GetAnotherPgonOfEdge","GetPolyEdgeStartVertex","polyEdge","GetPolyEdgeEndVertex","CalculateBodyVertexToPolygon","IsSolidBody","CheckSolidBody","pgon1Reverse","pgon2Reverse","TraversePgonsAlongEdges","onPgonFound","AddNeighboursToStack","pgonStack","anotherPgon","currentPgonIndex","pgonIsProcessed","AddVertexToBody","AddPointToBody","AddLineToBody","AddPolygonToBody","CheckBody","CalculateBodyPolygonNormal","currentIndex","CalculateBodyPolygonNormals","CalculateBodyVertexNormals","average","neighbourPolygons","polygonNormals","vertexToPolygon","CalculatePolygonCurveGroups","curveAngle","curveGroups","firstGroup","lastGroup","CalculatePolygonCentroid","MakeBodyInsideOut","SoftMoveBodyVertex","currentDistance","newDistance","referenceCoord","GenerateWireBody","TriangulateWithCentroids","centroidCoord","centroidIndex","oldPolygon","oldPolygonCount","TriangulatePolygons","triangleIndices","bodyTriangle","GenerateRandomMaterials","seeded","GetRandomInt","color","AddBodyToBSPTree","id","ConvertBodyPolygonToPolygon","CalculatePlanarTextureCoord","system","xyPlane","xzPlane","yzPlane","CalculateCubicTextureCoord","currentDirection","correctPlane","maxProduct","planeSystem","CalculateCylindricalTextureCoord","e3Direction","baseLine","projectedCoord","projectedDistance","e1Direction","coordDirection","CalculatePolygonPlanarTextureCoords","CalculatePolygonCubicTextureCoords","CalculatePolygonCylindricalTextureCoords","textureValues","angles","needRepair","CalculateBodyPlanarTextureCoords","CalculateBodyCubicTextureCoords","CalculateBodyCylindricalTextureCoords","CalculateBodyTextureCoords","CutBodyByPlane","CutBodyPolygonByPlane","indexTable","rawResult","rawIndexTable","hasIndexTable","front","needCut","currentVertex","lastIndex","GetInsertedVertexIndex","originalVertexCount","polygon3D","vertexPosition","cuttedPolygon","cuttedPolygons","cuttedIndexTables","remainsVertex","originalOldToNewIndex","newPolygonVertices","GenerateRectangle","GenerateCuboid","zSize","GenerateCuboidSides","sides","GenerateSegmentedRectangle","xSegmentation","ySegmentation","xStart","yStart","xSegment","ySegment","AddVertices","top","ntop","AddPolygons","GenerateSegmentedCuboid","GetLevelOffset","level","GetLevelSideVertices","zCoord","zSegment","zStart","prevSideVertices","levelSideVertices","currSideVertices","GenerateCircle","circlePoints","topPolygon","GenerateSphere","isCurved","circle","topIndex","bottomIndex","GenerateTriangulatedSphere","iterations","iteration","oldVertexCoord","oldBody","currentEdge","edgeVertexIndices","currentPgon","polygonVertexIndices","edgeCoord","currentPolyEdge","GenerateIcosahedron","currentRadius","GenerateCylinder","withTopAndBottom","bottomPolygon","GeneratePie","GenerateCone","topRadius","bottomRadius","topDegenerated","bottomDegenerated","avgRadius","GeneratePrismGeometry","bottomVertices","topVertices","bodyPolygon","GeneratePrismFromPolygon","firtVertex","firstDirection","GeneratePrism","GeneratePrismWithHole","contourOffsets","AddContours","contourPolygon2D","simplePolygon","mapValue","topTriangle","bottomTriangle","AddTopBottomPolygons","GeneratePrismsFromPath2D","path","GetPrismPolygon","GeneratePrismShell","offsetedPolygon","innerBasePolygon","GenerateCylinderShell","bottom","cartesian","GenerateLineShell","basePolyLine","withStartAndEnd","innerCoord","offsetDirection","innerBasePolyLine","GenerateTorus","outerRadius","innerRadius","outerSegmentation","innerSegmentation","coord2D","axisDir","GeneratePolyTorus","GenerateRuledFromSectors","aSector","bSector","GenerateGrid","xSector","ySector","GenerateSquareGrid","GenerateRuledFromSectorsWithHeight","newVertex","newpolygonVertexIndices","topVertexCount","GenerateRuledFromCoords","GenerateRevolved","polyLine","curveMode","circular","curveModeFlag","axisNormalDir","axisLine","projectedToBaseLine","GenerateTube","basePolygons","GenerateFunctionSurface","function3D","intervalMin","intervalMax","GenerateFunctionSurfaceSolid","bottomZ","Camera","nearClippingPlane","farClippingPlane","ExplodeBody","explodeData","SeparateByMaterial","itemsByMaterial","itemsWithNoMaterial","itemCount","getMaterial","ExplodePointsByMaterial","pointIndices","materialIndex","onPointGeometryStart","onPoint","onPointGeometryEnd","pointsByMaterial","pointsWithNoMaterial","ExplodePoints","ExplodeLinesByMaterial","lineIndices","onLineGeometryStart","onLine","onLineGeometryEnd","linesByMaterial","linesWithNoMaterial","ExplodeLines","ExplodePolygonsByMaterial","polygonIndices","derivedData","ExplodePolygon","CreateTriangle","vertex3","normal1","normal2","normal3","uv1","uv2","uv3","onTriangle","convexPolygon","hasConvexPolygons","vertexNormals","textureCoords","onGeometryStart","onGeometryEnd","polygonsByMaterial","polygonsWithNoMaterial","hasTextureCoords","CalculatePolygonsDerivedData","ExplodePolygons","ExportBodyContentToStl","name","AddLineToContent","stlContent","AddTriangleToContent","useTriangulation","ExportBodyToStl","ExportModelToStl","model","ExportBodyContentToObj","vertexOffset","normalOffset","AddToContent","objContent","AddNormal","normalVector","vertCoord","ExportBodyToObj","ExportModelToObj","ExportMaterialsToGdl","rgbString","gdlContent","writeMaterials","ExportBodyGeometryToGdl","character","status","lastMaterialIndex","pedgeList","ExportBodyToGdl","ExportModelToGdl","TriangleBody","normals","uvs","defaultUVIndex","SetName","GetName","SetVertex","GetTriangleNormal","normalPosition","curve","n0","n1","n2","NormalCount","AddUV","AddDefaultUV","GetUV","UVCount","u0","u1","mat","GetTriangle","TriangleCount","Finalize","FinalizeTriangle","triangleNormals","vertexToTriangles","AddAverageNormal","neighbourTriangleIndex","neighbourTriangle","averageNormal","averageCount","neighbourTriangles","normalIndex","GetDefaultMaterialIndex","ConvertTriangleBodyToOctree","TriangleModel","AddDefaultMaterial","AddBodyToIndex","FinalizeMaterials","defaultMaterialData","rotation","FinalizeBodies","ConvertBodyToTriangleBody","ConvertModelToTriangleModel","triangleBody","ConvertTriangleModelToJsonData","ConvertBody","mesh","trianglesByMaterial","materialCount","jsonTriangles","version","meshes","jsonMaterial","ConvertMaterials","MergeJsonDataMeshes","MergeMesh","currentMesh","materialToTriangles","MergeTriangles","currentTriangles","uvOffset","trianglesIndex","triangleParameters","MergeAttributes","RayTriangleIntersection","ray","rayOrigin","rayDirection","edgeDir1","edgeDir2","pVector","isFrontFacing","invDeterminant","tVector","qVector","scaledDirection","RayBoxIntersection","rayOriginVec","rayDirectionVec","minB","maxB","quadrant","candidatePlane","originInBox","maxT","whichPlane","xCoord","intersectionCoord","RayOctreeIntersection","minIntersection","foundIntersection","calcMinIntersection","currentIntersection","RayTriangleBodyIntersection","RayTriangleModelIntersection","bodyIndex","RayTriangleModelIntersectionWithOctree","hasIntersection","BinaryReader","arrayBuffer","isLittleEndian","dataView","DataView","GetByteLength","byteLength","Skip","bytes","End","ReadBoolean","getInt8","ReadCharacter","ReadUnsignedCharacter","getUint8","ReadInteger16","getInt16","ReadUnsignedInteger16","getUint16","ReadInteger32","getInt32","ReadUnsignedInteger32","getUint32","ReadFloat32","getFloat32","ReadDouble64","getFloat64","GetArrayBufferFromURL","url","responseType","onload","response","onerror","onError","GetArrayBufferFromFile","file","reader","onloadend","event","DONE","readAsArrayBuffer","GetStringBufferFromURL","stringBuffer","GetStringBufferFromFile","readAsText","LoadMultipleBuffers","inputList","LoadMultipleBuffersInternal","currentInput","loaderFunction","isFile","isArrayBuffer","originalObject","resultBuffer","Read3dsFile","OnLog","logText","logLevel","onLog","onVertex","OnTextureVertex","onTextureVertex","OnFace","flags","onFace","OnFaceMaterial","faceIndex","materialName","onFaceMaterial","OnFaceSmoothingGroup","smoothingGroup","onFaceSmoothingGroup","ReadChunk","chunkId","chunkLength","SkipChunk","GetChunkEnd","ReadName","letter","String","fromCharCode","ReadVector","ReadChunks","endByte","chunks","ReadColorChunk","hasLinColor","MAT_COLOR","MAT_LIN_COLOR","MAT_COLOR_F","MAT_LIN_COLOR_F","ReadPercentageChunk","percentage","PERCENTAGE","PERCENTAGE_F","ReadMaterialChunk","MAT_NAME","MAT_AMBIENT","MAT_DIFFUSE","MAT_SPECULAR","MAT_SHININESS","MAT_SHININESS_STRENGTH","shininessStrength","MAT_TRANSPARENCY","transparency","MAT_TEXMAP","MAT_TEXMAP_NAME","MAT_TEXMAP_UOFFSET","MAT_TEXMAP_VOFFSET","MAT_TEXMAP_USCALE","MAT_TEXMAP_VSCALE","MAT_TEXMAP_ROTATION","ReadTextureMapChunk","onMaterial","OnMaterial","ReadFacesChunk","faceCount","TRI_MATERIAL","ReadFaceMaterialsChunk","TRI_SMOOTH","ReadFaceSmoothingGroupsChunk","ReadTransformationChunk","onTransformation","OnTransformation","ReadMeshChunk","objectName","onMesh","OnMesh","TRI_VERTEX","ReadVerticesChunk","TRI_TEXVERTEX","texVertexCount","ReadTextureVerticesChunk","TRI_FACE","TRI_TRANSFORMATION","ReadObjectChunk","OBJ_TRIMESH","OBJ_LIGHT","ReadLightChunk","OBJ_CAMERA","ReadCameraChunk","ReadObjectNodeChunk","ReadTrackVector","tmp","keyNum","OBJECT_ROTATION","objectNode","nodeId","userId","pivot","positions","rotations","scales","OBJECT_HIERARCHY","OBJECT_PIVOT","OBJECT_POSITION","OBJECT_SCALE","OBJECT_ID","onObjectNode","OnObjectNode","ReadMainChunk","EDIT3DS","EDIT_MATERIAL","EDIT_OBJECT","ReadEditorChunk","KF3DS","OBJECT_NODE","ReadKeyFrameChunk","MAIN3DS","ReadFile","Convert3dsToJsonData","OnFileRequested","onFileRequested","triangleModel","currentBody","materialNameToIndex","bodyNameToIndex","nodeHierarcy","nodes","nodeIdToIndex","GetShininess","GetOpacity","currentMaterial","textureBuffer","blob","blobURL","createObjectURL","meshName","meshData","faceToMaterial","faceToSmoothingGroup","objectNodes","nodeIndex","MatrixScale","MatrixTranslate","TransformBodyVertices","transformedVertex","currentMeshData","meshTransformation","GetMeshTransformation","nodeTransformation","GetNodeTransformation","GetNodePosition","quat","omega","GetQuatFromAxisAndAngle","GetNodeRotation","GetNodeScale","parentIndex","parentNode","parentTransformation","meshMatrix","invMeshMatrix","invMatrix","flippedMatrix","finalMatrix","FlipByXCoordinates","nodePivotPoint","GetNodePivotPoint","FinalizeMesh","hasTextureCoordinates","DuplicateBody","instanceIndex","clonedBody","currentNode","firstNode","addedBody","FinalizeMeshes","ReadObjFile","ProcessLine","objectCounter","GetIndex","GetFileName","keyword","fileNameIndex","trim","textureName","lineParts","split","parseFloat","normalCount","onNormal","OnNormal","uvCount","onTexCoord","OnTexCoord","partSplitted","onUseMaterial","onNewMaterial","OnNewMaterial","onMaterialComponent","OnMaterialComponent","onMaterialParameter","OnMaterialParameter","onMaterialTexture","fileStringBuffer","ProcessFile","ConvertObjToJsonData","currentMaterialIndex","globalVertices","globalNormals","globalUVs","globalToLocalVertices","globalToLocalNormals","globalToLocalUVs","log2","GetLocalIndex","globalValueArray","globalToLocalIndices","globalIndex","valueAdderFunc","globalValue","GetLocalVertexIndex","GetLocalNormalIndex","GetLocalUVIndex","hasNormals","hasUVs","ReadBinaryStlFile","triangleCount","ReadAsciiStlFile","lineIndex","nextLineIndex","currentLineIndex","currentLine","GetVertices","IsBinaryStlFile","ConvertStlToJsonData","v0Index","v1Index","v2Index","triangleNormal","ReadOffFile","readState","offHeaderFound","infoFound","readVertices","readFaces","ConvertOffToJsonData","ImportFileList","descriptors","InitFromFiles","fileList","descriptor","originalFileName","toUpperCase","extension","GetFileExtension","InitFromURLs","urlList","GetInputList","IsArrayBuffer","inputListElem","fullFileName","splitted","decodeURI","GetFileDescriptor","GetMainFileIndex","IsSupportedExtension","GetFileIndexByName","currentFileName","lastPoint","lastIndexOf","ConvertImportFileListToJsonData","importFileList","OnError","OnReady","fileNames","FileRequested","resultBuffers","requestedFileIndex","missing","requested","mainFileIndex","mainFile","main","mainFileBuffer","ConvertFileListToJsonData","ConvertURLListToJsonData","IsPowerOfTwo","NextPowerOfTwo","ResizeImageToPowerOfTwoSides","image","context","drawImage","getImageData","WebGLInitContext","viewport","clearColor","WebGLInitShaderProgram","vertexShader","fragmentShader","CompileShader","script","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","fragmentShaderScript","vertexShaderScript","FRAGMENT_SHADER","VERTEX_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","CreateShader","useProgram","WebGLGetFloatTextureBufferSize","ceil","WebGLCreateFloatTextureBuffer","floatArray","Float32Array","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","RGBA","FLOAT","RenderAmbientLight","RenderDirectionalLight","RenderMaterialFlags","Point","Triangle","Textured","Transparent","RenderMaterial","SetBuffers","textureImage","RenderMesh","vertexArray","normalArray","uvArray","vertexBuffer","normalBuffer","uvBuffer","SetMaterial","SetVertexArray","SetNormalArray","SetUVArray","HasVertexArray","HasNormalArray","HasUVArray","GetVertexArray","GetNormalArray","GetUVArray","GetVertexBuffer","GetNormalBuffer","GetUVBuffer","GetTransformedVertex","RenderBody","AddMesh","EnumerateMeshes","onMeshFound","meshType","EnumerateTypedMeshes","HasTypedMeshes","typedMesh","typedMeshes","EnumerateMeshesWithFlag","flag","GetTransformation","GetTransformationMatrix","SetTransformation","AppendTransformation","ShaderType","TexturedTriangle","ShaderProgram","globalParams","shaders","currentShader","currentType","cullEnabled","Init","InitGlobalParams","InitShaders","GetMaxLightCount","maxLightCount","noDirectionalLight","InitShader","shaderType","join","GetVertexShaderScript","GetFragmentShaderScript","vertexPositionAttribute","getAttribLocation","vertexNormalAttribute","ambientLightColorUniform","getUniformLocation","lightUniforms","diffuseColor","specularColor","materialUniforms","ambientColor","vMatrixUniform","pMatrixUniform","tMatrixUniform","vertexUVAttribute","samplerUniform","pointSizeUniform","InitShaderParameters","enable","DEPTH_TEST","depthFunc","LEQUAL","BLEND","blendEquation","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","disable","CULL_FACE","CompileMaterial","textureLoaded","Image","src","resizedImage","LINEAR","LINEAR_MIPMAP_LINEAR","UNSIGNED_BYTE","generateMipmap","CompileMesh","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","itemSize","numItems","GetShader","UseShader","SetParameters","ambientLight","directionalLights","GetLight","light","lightDirection","uniform3f","uniformMatrix4fv","SetCullEnabled","DrawArrays","uniform1f","enableVertexAttribArray","vertexAttribPointer","activeTexture","TEXTURE0","uniform1i","drawArrays","TRIANGLES","POINTS","LINES","Renderer","InitContext","InitView","InitLights","InitBodies","SetClearColor","SetAmbientLight","AddLight","RemoveLight","RemoveLights","renderBody","renderBodies","EnumerateBodies","onBodyFound","RemoveBody","RemoveBodies","Resize","FindObjects","camera","screenX","screenY","screenCoord","unprojected","renderMesh","sort","Render","DrawMeshes","renderer","materialType","HasFlag","MaterialTypeToShaderType","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","PointCloudRenderer","InitBuffers","CreateShaderFromScript","vertexColorAttribute","SetPointSize","AddPoints","colors","pointBuffer","pointArray","colorBuffer","colorArray","RemovePoints","ConvertBodyToRenderBody","MaterialToRenderMaterial","renderAmbient","renderDiffuse","renderSpecular","renderMaterial","begVertex","endVertex","ConvertModelToRenderBodies","ConvertJSONDataToRenderBodies","asyncCallbacks","meshIndex","resultBodies","ConvertTrianglesToRenderMesh","GetTextureCoordinate","AppendTriangleCoords","targetArray","sourceArray","indexArray","componentCount","sourceVertexIndex","componentIndex","hasTexture","transformedUV","ConvertMeshToRenderBody","Mouse","down","button","ctrl","alt","diff","Down","div","eventParameters","which","shiftKey","ctrlKey","altKey","SetCurrent","Move","Up","Out","currX","clientX","currY","clientY","getBoundingClientRect","clientRect","pageXOffset","pageYOffset","Touch","fingers","touches","GetEventCoord","touch","pageX","pageY","OrderPolygons","GetPolygonCenter","HasLowerDistance","maxViewDistances","polygonCenterDistances","NeedToChangeOrder","needToChangeOrderCache","minViewDistances","PolygonViewOverlap","sPlane","polygonPlanes","pPlane","isSBehindP","sPolygon","isPFrontOfS","pPolygon","PolygonIsFrontOfPlane","polygonCenters","ordered","minDistance","maxDistance","polygonCenter","polygonCenterDistance","polygonViewVector","polygonDirection","polygonPlane","viewDirection","cameraPlane","CalculatePolygonValues","OrderPolygonsByMaxViewDistance","ReorderPolygons","CanvasDrawer","GetWidth","GetHeight","clearRect","fillStyle","fillRect","DrawLine","beginPath","moveTo","lineTo","stroke","DrawPolygon","closePath","fill","SVGDrawer","svgObject","svgNameSpace","getAttribute","lastChild","removeChild","svgLine","createElementNS","setAttributeNS","appendChild","pointsString","svgPolyon","DrawProjectedBody","drawMode","needClear","drawer","AddProjectedCoord","projectedPolygon","GetProjectedPolygonFromBody","orderedPolygons","GetProjectedPolygonFromPolygon","currentCoord","drawedLines","Navigation","drawCallback","resizeCallback","mouse","cameraFixUp","cameraEnableOrbit","cameraEnablePan","cameraEnableZoom","cameraNearDistanceLimit","cameraFarDistanceLimit","orbitCenter","fullscreen","addEventListener","OnMouseMove","OnMouseUp","OnMouseDown","OnMouseWheel","OnTouchStart","OnTouchMove","OnTouchEnd","OnContextMenu","OnResize","SetCamera","EnableFixUp","EnableOrbit","EnablePan","EnableZoom","SetNearDistanceLimit","limit","SetFarDistanceLimit","SetOrbitCenter","FitInWindow","offsetToOrigo","centerEyeDirection","SetFullscreen","ResizeCallback","Orbit","angleX","angleY","radAngleX","radAngleY","horizontalDirection","differentCenter","originalAngle","newAngle","verticalDirection","Pan","moveX","moveY","Zoom","ratio","zoomIn","move","DrawCallback","innerWidth","innerHeight","preventDefault","eyeCenterDistance","OnMouseOut","delta","detail","wheelDelta","SoftwareViewer","navigation","InitCanvas","InitCamera","Draw","bind","sphere","bodyAndMaterials","SpriteViewer","InitCallbacks","onPointDraw","onDrawStart","onDrawEnd","NearestPointUnderPosition","NearestPointUnderMouse","NearestPointUnderTouch","Viewer","cameraLight","InitRenderer","InitNavigation","EnableCameraLight","DisableCameraLight","GetCameraLight","PointCloudViewer","GenerateSolidWithRadius","solidName","equalRadius","GenerateTetrahedron","GenerateHexahedron","GenerateOctahedron","GenerateDodecahedron","GenerateTruncatedTetrahedron","GenerateCuboctahedron","GenerateTruncatedCube","GenerateTruncatedOctahedron","GenerateRhombicuboctahedron","GenerateTruncatedCuboctahedron","GenerateSnubCube","GenerateIcosidodecahedron","GenerateTruncatedDodecahedron","GenerateTruncatedIcosahedron","GenerateRhombicosidodecahedron","GenerateTruncatedIcosidodecahedron","GenerateSnubDodecahedron","GenerateTetrakisHexahedron","GenerateRhombicDodecahedron","GeneratePentakisDodecahedron","GenerateSmallStellatedDodecahedron","GenerateGreatDodecahedron","GenerateSmallTriambicIcosahedron","GenerateGreatStellatedDodecahedron","GenerateSmallTriakisOctahedron","GenerateStellaOctangula","GenerateTriakisTetrahedron","maxRadius","e","h","l","q","AddCumulatedPolygonToBody","vertexCoords","CalculatePolygonCentroidAndNormal","GenerateCumulatedTetrahedron","pyramidUnitHeight","edgeLength","GenerateCumulatedHexahedron","GenerateCumulatedOctahedron","GenerateCumulatedDodecahedron","GenerateCumulatedIcosahedron","LegoDimensions","legoWidth","legoSmallHeight","legoLargeHeight","legoWallWidth","legoCylinderWidth","legoCylinderHeight","legoBottomSmallCylinderWidth","legoBottomLargeCylinderWidth","legoBottomLargeCylinderWallWidth","GenerateLegoBrick","rows","columns","isLarge","hasTopCylinders","hasBottomCylinders","OffsetBody","legoDimensions","unitWidth","unitHeight","wallWidth","topCylinderWidth","topCylinderHeight","bottomSmallCylinderWidth","bottomLargeCylinderWidth","bottomLargeCylinderWallWidth","walls","cylinderCenter","cylinder","bigger","columnWise","GenerateConvexHullBody","convexHull","oldToNewIndexTable","GenerateSuperShape","aLon","bLon","mLon","n1Lon","n2Lon","n3Lon","aLat","bLat","mLat","n1Lat","n2Lat","n3Lat","CartesianToSpherical","atan2","CalculateSuperFormula","n3","abs1","abs2","CalculateSuperFormulaCoordinate","rPhi","rTheta","spherical","newCoord","CatmullClarkSubdivisionOneIteration","pgonVertices","edgeVertices","AddOriginalVertices","pgonCoord","AddPolygonVertices","edgeCoord1","edgeCoord2","AddEdgeVertices","MoveContourVertex","newVertCoord","MoveVertex","pgonAverage","edgeAverage","vertEdgeCount","currentVertCoord","edgeCountForAverage","edgeMidCoords","MoveOriginalVertices","edgeCount","nextEdge","currentEdgeVertex","nextEdgeVertex","AddNewPolygons","CatmullClarkSubdivision","BooleanOperation","operation","aBody","bBody","AddBodyVertex","AddPolygonsToBody","ClipNodePolygonsWithTree","tree","SetPolygonsUserData","aTree","bTree","aFrontPolygons","aBackPolygons","aPlanarFrontPolygons","aPlanarBackPolygons","bFrontPolygons","bBackPolygons","bPlanarFrontPolygons","resultOctree","GenerateSurface","xRange","yRange","useTriangles","getPointCallback","xDiff","yDiff","SurfaceControlPoints","GetNValue","GetMValue","GetControlPoint","InitPlanar","iStep","jStep","GenerateBezierSurface","surfaceControlPoints","uIndex","vIndex","tmp1","tmp2","SvgToModel","segmentLength","SegmentElem","elem","AddTransformedVertex","dummySVG","createSVGPoint","transformed","getCTM","matrixTransform","transformedCoord","resultCoord","contourVertexCount","SegmentCurve","originalPath","lastCoord","items","item","command","largeArcFlag","sweepFlag","commandString","pathSegType","SVGPathSeg","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_ABS","PATHSEG_ARC_REL","r1","r2","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","CreatePath","pathLength","getTotalLength","getPointAtLength","IsCurvedItem","IsSmoothItem","RemoveEqualEndVertices","firstCoord","StartNewContour","SVGPathElement","currentItem","lastMoveCoord","currentSegmentLength","hasAttribute","pathSegList","numberOfItems","getItem","PATHSEG_CLOSEPATH","PATHSEG_MOVETO_ABS","PATHSEG_MOVETO_REL","PATHSEG_LINETO_ABS","PATHSEG_LINETO_REL","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","SVGRectElement","baseVal","SVGPolygonElement","svgColor","style","parentElement","substring","firstBracket","secondBracket","numbers","SVGColorToHex","originalElem","ContourPolygonToPrisms","AppendPolygonVertices","CreateBasePolygon","AddHoleToBasePolygon","prism","prisms","currentHeight","holeBasePolygon","hasHoles","prismsAndMaterial","currentPrisms","currentPrism","AddElemType","elemType","elems","getElementsByTagName","SegmentPaths","GenerateText","text","fontSpec","fontScale","fontHeight","fontSegmentation","CreatePathFromSpecification","commands","Num","str","parts","glyphs","ha","ConvertBodyToThreeMeshes","theConversionData","textureLoadedCallback","threeGeometry","threeMaterial","THREE","PointsMaterial","Geometry","Points","Vector3","LineBasicMaterial","LineSegments","hasOpacity","MeshPhongMaterial","DoubleSide","transparent","theMaterial","loader","TextureLoader","load","wrapS","RepeatWrapping","wrapT","needsUpdate","computeFaceNormals","Mesh","lastVertexIndex","face","Face3","faces","Vector2","faceVertexUvs","ConvertModelToThreeMeshes","currentMeshes","ConvertJSONDataToThreeMeshes","resultMeshes","AddTriangles","materialData","textureOffset","textureScale","textureRotation","Color","setRGB","getHex","v3","u3","lastFace","textureUVs","geometry","originalJsonMaterialIndex","originalJsonMeshIndex","ThreeViewer","scene","directionalLight","runBeforeRender","runAfterRender","cameraMove","drawLoop","enableDraw","InitSettings","InitThree","DrawIfNeeded","cameraEyePosition","cameraCenterPosition","cameraUpVector","lightAmbientColor","lightDiffuseColor","Scene","antialias","WebGLRenderer","setClearColor","setSize","PerspectiveCamera","add","AmbientLight","DirectionalLight","lightPosition","subVectors","set","SetRunBeforeRender","SetRunAfterRender","AddMeshes","MeshCount","traverse","IsRelevantObject","VisibleMeshCount","IsVisibleObject","FaceCount","GetMesh","ShowMesh","visible","HideMesh","RemoveMesh","dispose","remove","RemoveMeshes","RemoveLastMesh","aspect","updateProjectionMatrix","FitMeshesInWindow","GetFilteredBoundingSphere","obj","AdjustClippingPlanes","radiusLimit","near","far","GetFilteredCenter","GetFilteredBoundingBox","needToProcess","clone","GetObjectsUnderPosition","mouseX","mouseY","cameraPosition","unproject","sub","normalize","Raycaster","intersectObjects","GetObjectsUnderMouse","GetObjectsUnderTouch","ProjectVector","halfWidth","halfHeight","project","EnableDraw","lookAt","render","requestAnimationFrame","StartDrawLoop","threeObj","skylark","jsm","attach"],"mappings":"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B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KAEAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,EAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,EAAA,KAC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GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KAEAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,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BAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,KAEAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EA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CAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KAEAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,EAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,EAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,KACAl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,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,IAAA,KAEAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,MACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,MACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,MACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MAEAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,GAAA,GAAA,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,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,IACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,EAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,iBAAA77B,GAAA,GAAA,GAAA,KACAlM,EAAA+nC,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AAilF,YAAAziF,UAAAunF,cAAA,WAEA9pF,KAAAslF,UAAA,EACAtlF,KAAA4vE,QAGA7vE,EAAAilF,YAAAziF,UAAA0kF,iBAAA,SAAA8C,GAEA,OAAAA,aAAAhqF,EAAAmiF,MAAAoB,MAAAyG,aAAAhqF,EAAAmiF,MAAAM,cAAAuH,aAAAhqF,EAAAmiF,MAAAG,QAGAtiF,EAAAilF,YAAAziF,UAAA4kF,gBAAA,SAAA4C,GAEA,OAAA/pF,KAAAinF,iBAAA8C,IAAAA,EAAAxC,SAGAxnF,IAGAD,EAAA,0BACA,wBACA,aACA,eACA,mBACA,eACA,eACA,oBACA,yBACA,qBACA,mBACA,yBACA,wBACA,oBACA,yBACA,oBACA,kBACA,iBACA,oBACA,4BACA,mBACA,wBACA,wBACA,uBACA,qBACA,wBACA,2BACA,oBACA,qBACA,oBACA,uBACA,iBACA,kBACA,kBACA,qBACA,wBACA,iBACA,kBACA,0BACA,sBACA,yBACA,qBACA,sBACA,mBACA,oBACA,qBACA,yBACA,0BACA,sBACA,qBACA,wBACA,yBACA,uBACA,uBACA,uBACA,uBACA,0BACA,wBACA,yBACA,4BACA,wBACA,wBACA,2BACA,sBACA,gCACA,6BACA,iBACA,iBACA,mBACA,mBACA,sBACA,0BACA,wBACA,kBACA,4BACA,0BACA,wBACA,uBACA,eACA,oBACA,qCACA,2CACA,0CACA,wCAEA,SAAAkqF,EAAAC,GACA,OAAAD,EAAAE,OAAA,iBAAAD,KAEAnqF,EAAA,qBAAA,0BAAA,SAAAo1D,GAAA,OAAAA","file":"../skylark-jsmodeler.js","sourcesContent":["define('skylark-jsmodeler/core/jsm',[],function(){\n\tvar JSM = function ()\n\t{\n\t\tthis.mainVersion = 0;\n\t\tthis.subVersion = 45;\n\t};\n\n\t/**\n\t* Function: RandomNumber\n\t* Description: Generates a random number between two numbers.\n\t* Parameters:\n\t*\tfrom {number} lowest random result\n\t*\tto {number} highest random result\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.RandomNumber = function (from, to)\n\t{\n\t\treturn Math.random () * (to - from) + from;\n\t};\n\n\t/**\n\t* Function: RandomInt\n\t* Description: Generates a random integer between two integers.\n\t* Parameters:\n\t*\tfrom {integer} lowest random result\n\t*\tto {integer} highest random result\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.RandomInt = function (from, to)\n\t{\n\t\treturn Math.floor ((Math.random () * (to - from + 1)) + from);\n\t};\n\n\t/**\n\t* Function: RandomBoolean\n\t* Description: Generates a random boolean value.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.RandomBoolean = function ()\n\t{\n\t\treturn JSM.RandomInt (0, 1) === 1;\n\t};\n\n\t/**\n\t* Function: SeededRandomInt\n\t* Description: Generates a random integer between two integers. A seed number can be specified.\n\t* Parameters:\n\t*\tfrom {integer} lowest random result\n\t*\tto {integer} highest random result\n\t*\tseed {integer} seed value\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SeededRandomInt = function (from, to, seed)\n\t{\n\t    var random = ((seed * 9301 + 49297) % 233280) / 233280;\n\t\treturn Math.floor ((random * (to - from + 1)) + from);\n\t};\n\n\t/**\n\t* Function: ValueOrDefault\n\t* Description: Returns the given value, or a default if it is undefined.\n\t* Parameters:\n\t*\tval {anything} new value\n\t*\tdef {anything} default value\n\t* Returns:\n\t*\t{anything} the result\n\t*/\n\tJSM.ValueOrDefault = function (val, def)\n\t{\n\t\tif (val === undefined || val === null) {\n\t\t\treturn def;\n\t\t}\n\t\treturn val;\n\t};\n\n\t/**\n\t* Function: PrevIndex\n\t* Description: Returns the circular previous index for an array with the given length.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t*\tlength {integer} the number of indices\n\t*/\n\tJSM.PrevIndex = function (index, length)\n\t{\n\t\treturn index > 0 ? index - 1 : length - 1;\n\t};\n\n\t/**\n\t* Function: NextIndex\n\t* Description: Returns the circular next index for an array with the given length.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t*\tlength {integer} the number of indices\n\t*/\n\tJSM.NextIndex = function (index, length)\n\t{\n\t\treturn index < length - 1 ? index + 1 : 0;\n\t};\n\n\t/**\n\t* Function: CopyObjectProperties\n\t* Description: Copies one object properties to another object.\n\t* Parameters:\n\t*\tsource {anything} source object\n\t*\ttarget {anything} target object\n\t*\toverwrite {boolean} overwrite existing properties\n\t*/\n\tJSM.CopyObjectProperties = function (source, target, overwrite)\n\t{\n\t\tif (source === undefined || source === null ||\n\t\t\ttarget === undefined || target === null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar property;\n\t\tfor (property in source) {\n\t\t\tif (source.hasOwnProperty (property)) {\n\t\t\t\tif (overwrite || target[property] === undefined || target[property] === null) {\n\t\t\t\t\ttarget[property] = source[property];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GetObjectProperty\n\t* Description: Returns the given property of the object. If it doesn't exist, returns the given default value.\n\t* Parameters:\n\t*\tobject {anything} the object\n\t*\tpropertyName {string} the name of the property\n\t*\tdefaultValue {anything} the default value\n\t*/\n\tJSM.GetObjectProperty = function (object, propertyName, defaultValue)\n\t{\n\t\tif (object === undefined || object === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tvar propertyValue = object[propertyName];\n\t\tif (propertyValue === undefined || propertyValue === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\t\n\t\treturn propertyValue;\n\t};\n\n\t/**\n\t* Function: Message\n\t* Description: Writes a message to the console.\n\t* Parameters:\n\t*\tmessage {string} the message\n\t*/\n\tJSM.Message = function (message)\n\t{\n\t\tconsole.log ('JSModeler: ' + message);\n\t};\n\n\treturn JSM;\n});\n\n\n\ndefine('skylark-jsmodeler/core/timer',[\"./jsm\"],function(JSM){\n\t/**\n\t* Class: Timer\n\t* Description: Utility class for time measure.\n\t*/\n\tJSM.Timer = function ()\t{\n\t\tthis.start = 0;\n\t\tthis.stop = 0;\n\t};\n\n\t/**\n\t* Function: Timer.Start\n\t* Description: Starts the timer.\n\t*/\n\tJSM.Timer.prototype.Start = function ()\t{\n\t\tvar date = new Date ();\n\t\tthis.start = date.getTime ();\n\t};\n\n\t/**\n\t* Function: Timer.Stop\n\t* Description: Stops the timer.\n\t*/\n\tJSM.Timer.prototype.Stop = function ()\t{\n\t\tvar date = new Date ();\n\t\tthis.end = date.getTime ();\n\t};\n\n\t/**\n\t* Function: Timer.Result\n\t* Description: Returns the time between start and stop.\n\t* Returns:\n\t*\t{number} The result.\n\t*/\n\tJSM.Timer.prototype.Result = function (){\n\t\treturn (this.end - this.start);\n\t};\n\n\t/**\n\t* Class: FPSCounter\n\t* Description:\n\t*\tUtility class for FPS count. It calculates the frames and returns FPS count for the last interval\n\t*\twith the given length. The Get function should called in every frame.\n\t*/\n\tJSM.FPSCounter = function (){\n\t\tthis.start = null;\n\t\tthis.frames = null;\n\t\tthis.current = null;\n\t};\n\n\t/**\n\t* Function: FPSCounter.Get\n\t* Description: Returns the FPS count for the last interval with the given length.\n\t* Parameters:\n\t*\tinterval {integer} the interval length in milliseconds\n\t* Returns:\n\t*\t{integer} The result.\n\t*/\n\tJSM.FPSCounter.prototype.Get = function (interval)\t{\n\t\tvar date = new Date ();\n\t\tvar end = date.getTime ();\n\t\tif (this.start === null) {\n\t\t\tthis.start = end;\n\t\t\tthis.frames = 0;\n\t\t\tthis.current = 0;\n\t\t}\n\n\t\tif (interval === null || interval === undefined) {\n\t\t\tinterval = 1000;\n\t\t}\n\t\t\n\t\tthis.frames = this.frames + 1;\n\t\tvar elapsed = end - this.start;\n\t\tif (elapsed >= interval) {\n\t\t\tthis.current = 1000 * (this.frames / elapsed);\n\t\t\tthis.start = end;\n\t\t\tthis.frames = 0;\n\t\t}\n\n\t\treturn parseInt (this.current, 10);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/algorithm',[\"./jsm\"],function(JSM){\n\n\t/**\n\t* Function: SwapArrayValues\n\t* Description: Swaps to array values.\n\t* Parameters:\n\t*\tarray {anything[]} the array\n\t*\tfrom {integer} from index\n\t*\tto {integer} to index\n\t*/\n\tJSM.SwapArrayValues = function (array, from, to){\n\t\tvar temp = array[from];\n\t\tarray[from] = array[to];\n\t\tarray[to] = temp;\n\t};\n\n\t/**\n\t* Function: BubbleSort\n\t* Description: Sorts an array with bubble sort.\n\t* Parameters:\n\t*\tarray {anything[]} the array to sort\n\t*\tonCompare {function} the compare function\n\t*\tonSwap {function} the swap function\n\t*/\n\tJSM.BubbleSort = function (array, onCompare, onSwap){\n\t\tif (array.length < 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar compareFunction = onCompare;\n\t\tif (compareFunction === undefined || compareFunction === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar swapFunction = onSwap;\n\t\tif (swapFunction === undefined || swapFunction === null) {\n\t\t\tswapFunction = function (i, j) {\n\t\t\t\tJSM.SwapArrayValues (array, i, j);\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < array.length - 1; i++) {\n\t\t\tfor (j = 0; j < array.length - i - 1; j++) {\n\t\t\t\tif (!compareFunction (array[j], array[j + 1])) {\n\t\t\t\t\tswapFunction (j, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: ShiftArray\n\t* Description: Shifts an array.\n\t* Parameters:\n\t*\tarray {anything[]} the array to shift\n\t*\tcount {integer} shift count\n\t*/\n\tJSM.ShiftArray = function (array, count){\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tarray.push (array.shift ());\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/async',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: AsyncRunTask\n\t* Description:\n\t*\tCalls a function multiple times asynchronously. If the environment\n\t*\tis not specified, it will run synchronously.\n\t* Parameters:\n\t*\ttaskFunction {function} the function to run\n\t*\tcallbacks {object} callbacks for start, process, and finish\n\t*\trunCount {integer} the count of runs\n\t*\ttimeout {integer} the timeout between runs\n\t*\tuserData {anything} task specific data\n\t*/\n\tJSM.AsyncRunTask = function (taskFunction, callbacks, runCount, timeout, userData)\n\t{\n\t\tfunction OnStart (runCount, userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onStart !== undefined && callbacks.onStart !== null) {\n\t\t\t\tcallbacks.onStart (runCount, userData);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnProgress (currentCount, userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onProgress !== undefined && callbacks.onProgress !== null) {\n\t\t\t\tcallbacks.onProgress (currentCount, userData);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnFinished (userData, callbacks)\n\t\t{\n\t\t\tif (callbacks.onFinish !== undefined && callbacks.onFinish !== null) {\n\t\t\t\tcallbacks.onFinish (userData);\n\t\t\t}\n\t\t}\n\n\t\tfunction RunTask (currentCount, userData, callbacks)\n\t\t{\n\t\t\tvar needContinue = taskFunction ();\n\t\t\tOnProgress (currentCount, userData, callbacks);\n\t\t\tif (needContinue && currentCount < runCount - 1) {\n\t\t\t\tsetTimeout (function () {\n\t\t\t\t\tRunTask (currentCount + 1, userData, callbacks);\n\t\t\t\t}, timeout);\n\t\t\t} else {\n\t\t\t\tsetTimeout (function () {\n\t\t\t\t\tOnFinished (userData, callbacks);\n\t\t\t\t}, timeout);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tvar i, needContinue;\n\t\t\tfor (i = 0; i < runCount; i++) {\n\t\t\t\tneedContinue = taskFunction ();\n\t\t\t\tif (!needContinue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tOnStart (runCount, userData, callbacks);\n\t\tRunTask (0, userData, callbacks);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/check',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: IsWebGLEnabled\n\t* Description: Returns if WebGL is enabled in the browser.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsWebGLEnabled = function (){\n\t\tif (!window.WebGLRenderingContext) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tvar canvas = document.createElement ('canvas');\n\t\t\tif (!canvas.getContext ('experimental-webgl') && !canvas.getContext ('webgl')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (exception) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: IsFileApiEnabled\n\t* Description: Returns if file api is enabled in the browser.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsFileApiEnabled = function ()\t{\n\t\tif (!window.File || !window.FileReader || !window.FileList || !window.Blob || !window.URL) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/core/jsonloader',[\"./jsm\"],function(JSM){\n\t/**\n\t* Function: LoadJsonFile\n\t* Description: Loads a json file, and calls a callback with the parsed json.\n\t* Parameters:\n\t*\tfileName {string} the name of the json\n\t*\tonReady {function} the callback\n\t*/\n\tJSM.LoadJsonFile = function (fileName, onReady)\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.overrideMimeType ('application/json');\n\t\trequest.open ('GET', fileName, true);\n\t\trequest.onreadystatechange = function () {\n\t\t\tif (request.readyState == 4) {\n\t\t\t\tvar jsonData = JSON.parse (request.responseText);\n\t\t\t\tonReady (jsonData);\n\t\t\t}\n\t\t};\n\t\trequest.send (null);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/definitions',[\"../core/jsm\"],function(JSM){\n\tJSM.Eps = 0.00000001;\n\tJSM.Inf = 9999999999;\n\tJSM.RadDeg = 57.29577951308232;\n\tJSM.DegRad = 0.017453292519943;\n\n\t/**\n\t* Function: IsZero\n\t* Description: Determines if the given value is near zero. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsZero = function (a)\n\t{\n\t\treturn Math.abs (a) < JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsPositive\n\t* Description: Determines if the given value is positive. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsPositive = function (a)\n\t{\n\t\treturn a > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsNegative\n\t* Description: Determines if the given value is negative. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} the value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsNegative = function (a)\n\t{\n\t\treturn a < -JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsLower\n\t* Description: Determines if a value is lower than an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsLower = function (a, b)\n\t{\n\t\treturn b - a > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsGreater\n\t* Description: Determines if a value is greater than an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsGreater = function (a, b)\n\t{\n\t\treturn a - b > JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsEqual\n\t* Description: Determines if two values are equal. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsEqual = function (a, b)\n\t{\n\t\treturn Math.abs (b - a) < JSM.Eps;\n\t};\n\n\t/**\n\t* Function: IsEqualWithEps\n\t* Description: Determines if two values are equal. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t*\teps {number} epsilon value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsEqualWithEps = function (a, b, eps)\n\t{\n\t\treturn Math.abs (b - a) < eps;\n\t};\n\n\t/**\n\t* Function: IsLowerOrEqual\n\t* Description: Determines if a value is lower or equal to an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsLowerOrEqual = function (a, b)\n\t{\n\t\treturn JSM.IsLower (a, b) || JSM.IsEqual (a, b);\n\t};\n\n\t/**\n\t* Function: IsGreaterOrEqual\n\t* Description: Determines if a value is greater or equal to an other. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsGreaterOrEqual = function (a, b)\n\t{\n\t\treturn JSM.IsGreater (a, b) || JSM.IsEqual (a, b);\n\t};\n\n\t/**\n\t* Function: Minimum\n\t* Description: Returns the minimum of two values. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Minimum = function (a, b)\n\t{\n\t\treturn JSM.IsLower (a, b) ? a : b;\n\t};\n\n\t/**\n\t* Function: Maximum\n\t* Description: Returns the maximum of two values. Uses epsilon for comparison.\n\t* Parameters:\n\t*\ta {number} first value\n\t*\tb {number} second value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Maximum = function (a, b)\n\t{\n\t\treturn JSM.IsGreater (a, b) ? a : b;\n\t};\n\n\t/**\n\t* Function: ArcSin\n\t* Description: Calculates the arcus sinus value.\n\t* Parameters:\n\t*\tvalue {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ArcSin = function (value)\n\t{\n\t\tif (JSM.IsGreaterOrEqual (value, 1.0)) {\n\t\t\treturn Math.PI / 2.0;\n\t\t} else if (JSM.IsLowerOrEqual (value, -1.0)) {\n\t\t\treturn - Math.PI / 2.0;\n\t\t}\n\t\t\n\t\treturn Math.asin (value);\n\t};\n\n\t/**\n\t* Function: ArcCos\n\t* Description: Calculates the arcus cosinus value.\n\t* Parameters:\n\t*\tvalue {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ArcCos = function (value)\n\t{\n\t\tif (JSM.IsGreaterOrEqual (value, 1.0)) {\n\t\t\treturn 0.0;\n\t\t} else if (JSM.IsLowerOrEqual (value, -1.0)) {\n\t\t\treturn Math.PI;\n\t\t}\n\t\t\n\t\treturn Math.acos (value);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coord2d',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Coord2D\n\t* Description: Represents a 2D coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*/\n\tJSM.Coord2D = function (x, y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t};\n\n\t/**\n\t* Function: Coord2D.Set\n\t* Description: Sets the coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*/\n\tJSM.Coord2D.prototype.Set = function (x, y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t};\n\n\t/**\n\t* Function: Coord2D.IsEqual\n\t* Description: Returns if the coordinate is equal with the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord2D.prototype.IsEqual = function (coord)\n\t{\n\t\treturn JSM.IsEqual (this.x, coord.x) && JSM.IsEqual (this.y, coord.y);\n\t};\n\n\t/**\n\t* Function: Coord2D.IsEqualWithEps\n\t* Description: Returns if the coordinate is equal with the given one. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*\teps {number} the epsilon\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord2D.prototype.IsEqualWithEps = function (coord, eps)\n\t{\n\t\treturn JSM.IsEqualWithEps (this.x, coord.x, eps) && JSM.IsEqualWithEps (this.y, coord.y, eps);\n\t};\n\n\t/**\n\t* Function: Coord2D.DistanceTo\n\t* Description: Calculates the coordinate distance to the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.DistanceTo = function (coord)\n\t{\n\t\treturn Math.sqrt ((coord.x - this.x) * (coord.x - this.x) + (coord.y - this.y) * (coord.y - this.y));\n\t};\n\n\t/**\n\t* Function: Coord2D.AngleTo\n\t* Description: Calculates the coordinate vector angle to the given one.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.AngleTo = function (coord)\n\t{\n\t\tvar aDirection = this.Clone ().Normalize ();\n\t\tvar bDirection = coord.Clone ().Normalize ();\n\t\tif (aDirection.IsEqual (bDirection)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvar product = JSM.VectorDot2D (aDirection, bDirection);\n\t\treturn JSM.ArcCos (product);\n\t};\n\n\t/**\n\t* Function: Coord2D.Length\n\t* Description: Calculates the length of the coordinate vector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord2D.prototype.Length = function ()\n\t{\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y);\n\t};\n\n\t/**\n\t* Function: Coord2D.MultiplyScalar\n\t* Description: Multiplies the vector with a scalar.\n\t* Parameters:\n\t*\tscalar {number} the scalar\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.MultiplyScalar = function (scalar)\n\t{\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Normalize\n\t* Description: Normalizes the coordinate vector.\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Normalize = function ()\n\t{\n\t\tvar length = this.Length ();\n\t\tif (JSM.IsPositive (length)) {\n\t\t\tthis.MultiplyScalar (1.0 / length);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.SetLength\n\t* Description: Sets the length of the coordinate vector.\n\t* Parameters:\n\t*\tlength {number} the length\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.SetLength = function (length)\n\t{\n\t\tvar thisLength = this.Length ();\n\t\tif (JSM.IsPositive (thisLength)) {\n\t\t\tthis.MultiplyScalar (length / thisLength);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Offset\n\t* Description: Offsets the coordinate.\n\t* Parameters:\n\t*\tdirection {Vector2D} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Offset = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tthis.x += normal.x * distance;\n\t\tthis.y += normal.y * distance;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.Rotate\n\t* Description: Rotates the coordinate.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord2D} the origo of the rotation\n\t* Returns:\n\t*\t{Coord2D} this pointer\n\t*/\n\tJSM.Coord2D.prototype.Rotate = function (angle, origo)\n\t{\n\t\tvar x = this.x - origo.x;\n\t\tvar y = this.y - origo.y;\n\t\tvar co = Math.cos (angle);\n\t\tvar si = Math.sin (angle);\n\t\tthis.x = x * co - y * si + origo.x;\n\t\tthis.y = x * si + y * co + origo.y;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord2D.ToString\n\t* Description: Converts the coordinate values to string.\n\t* Returns:\n\t*\t{string} the string representation of the coordinate\n\t*/\n\tJSM.Coord2D.prototype.ToString = function ()\n\t{\n\t\treturn ('(' + this.x + ', ' + this.y + ')');\n\t};\n\n\t/**\n\t* Function: Coord2D.Clone\n\t* Description: Clones the coordinate.\n\t* Returns:\n\t*\t{Coord2D} a cloned instance\n\t*/\n\tJSM.Coord2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Coord2D (this.x, this.y);\n\t};\n\n\t/**\n\t* Class: Vector2D\n\t* Description: Same as Coord2D.\n\t*/\n\tJSM.Vector2D = JSM.Coord2D;\n\n\t/**\n\t* Function: CoordFromArray2D\n\t* Description: Returns a coordinate from an array of components.\n\t* Parameters:\n\t*\tarray {number[2]} the array of components\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordFromArray2D = function (array)\n\t{\n\t\treturn new JSM.Coord2D (array[0], array[1]);\n\t};\n\n\t/**\n\t* Function: CoordToArray2D\n\t* Description: Returns array of components from a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\tarray {number[2]} the result\n\t*/\n\tJSM.CoordToArray2D = function (coord)\n\t{\n\t\treturn [coord.x, coord.y];\n\t};\n\n\t/**\n\t* Function: CoordAdd2D\n\t* Description: Adds two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordAdd2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D (a.x + b.x, a.y + b.y);\n\t};\n\n\t/**\n\t* Function: CoordSub2D\n\t* Description: Subs two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CoordSub2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D (a.x - b.x, a.y - b.y);\n\t};\n\n\t/**\n\t* Function: VectorDot2D\n\t* Description: Calculates the dot product of two vectors.\n\t* Parameters:\n\t*\ta {Vector2D} the first vector\n\t*\tb {Vector2D} the second vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.VectorDot2D = function (a, b)\n\t{\n\t\treturn a.x * b.x + a.y * b.y;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coord',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Coord\n\t* Description: Represents a 3D coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*\tz {number} the third component\n\t*/\n\tJSM.Coord = function (x, y, z)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t};\n\n\t/**\n\t* Function: Coord.Set\n\t* Description: Sets the coordinate.\n\t* Parameters:\n\t*\tx {number} the first component\n\t*\ty {number} the second component\n\t*\tz {number} the third component\n\t*/\n\tJSM.Coord.prototype.Set = function (x, y, z)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t};\n\n\t/**\n\t* Function: Coord.IsEqual\n\t* Description: Returns if the coordinate is equal with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsEqual = function (coord)\n\t{\n\t\treturn JSM.IsEqual (this.x, coord.x) && JSM.IsEqual (this.y, coord.y) && JSM.IsEqual (this.z, coord.z);\n\t};\n\n\t/**\n\t* Function: Coord.IsEqualWithEps\n\t* Description: Returns if the coordinate is equal with the given one. Uses the given epsilon for comparison.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\teps {number} the epsilon\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsEqualWithEps = function (coord, eps)\n\t{\n\t\treturn JSM.IsEqualWithEps (this.x, coord.x, eps) && JSM.IsEqualWithEps (this.y, coord.y, eps) && JSM.IsEqualWithEps (this.z, coord.z, eps);\n\t};\n\n\t/**\n\t* Function: Coord.DistanceTo\n\t* Description: Calculates the coordinate distance to the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.DistanceTo = function (coord)\n\t{\n\t\treturn Math.sqrt ((coord.x - this.x) * (coord.x - this.x) + (coord.y - this.y) * (coord.y - this.y) + (coord.z - this.z) * (coord.z - this.z));\n\t};\n\n\t/**\n\t* Function: Coord.AngleTo\n\t* Description: Calculates the coordinate vector angle to the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.AngleTo = function (coord)\n\t{\n\t\tvar aDirection = this.Clone ().Normalize ();\n\t\tvar bDirection = coord.Clone ().Normalize ();\n\t\tif (aDirection.IsEqual (bDirection)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvar product = JSM.VectorDot (aDirection, bDirection);\n\t\treturn JSM.ArcCos (product);\n\t};\n\n\t/**\n\t* Function: Coord.IsCollinearWith\n\t* Description: Returns if the coordinate vector is collinear with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsCollinearWith = function (coord)\n\t{\n\t\tvar angle = this.AngleTo (coord);\n\t\treturn JSM.IsEqual (angle, 0.0) || JSM.IsEqual (angle, Math.PI);\n\t};\n\n\t/**\n\t* Function: Coord.IsPerpendicularWith\n\t* Description: Returns if the coordinate vector is perpendicular with the given one.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Coord.prototype.IsPerpendicularWith = function (coord)\n\t{\n\t\tvar angle = this.AngleTo (coord);\n\t\treturn JSM.IsEqual (angle, Math.PI / 2.0);\n\t};\n\n\t/**\n\t* Function: Coord.Length\n\t* Description: Calculates the length of the coordinate vector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Coord.prototype.Length = function ()\n\t{\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y + this.z * this.z);\n\t};\n\n\t/**\n\t* Function: Coord.Add\n\t* Description: Adds the given coordinate to coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Coord.prototype.Add = function (coord)\n\t{\n\t\tthis.x += coord.x;\n\t\tthis.y += coord.y;\n\t\tthis.z += coord.z;\n\t};\n\n\t/**\n\t* Function: Coord.Sub\n\t* Description: Subs the given coordinate from coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Coord.prototype.Sub = function (coord)\n\t{\n\t\tthis.x -= coord.x;\n\t\tthis.y -= coord.y;\n\t\tthis.z -= coord.z;\n\t};\n\n\t/**\n\t* Function: Coord.MultiplyScalar\n\t* Description: Multiplies the vector with a scalar.\n\t* Parameters:\n\t*\tscalar {number} the scalar\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.MultiplyScalar = function (scalar)\n\t{\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Normalize\n\t* Description: Normalizes the coordinate vector.\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.Normalize = function ()\n\t{\n\t\tvar length = this.Length ();\n\t\tif (JSM.IsPositive (length)) {\n\t\t\tthis.MultiplyScalar (1.0 / length);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.SetLength\n\t* Description: Sets the length of the coordinate vector.\n\t* Parameters:\n\t*\tlength {number} the length\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.SetLength = function (length)\n\t{\n\t\tvar thisLength = this.Length ();\n\t\tif (JSM.IsPositive (thisLength)) {\n\t\t\tthis.MultiplyScalar (length / thisLength);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Offset\n\t* Description: Offsets the coordinate.\n\t* Parameters:\n\t*\tdirection {Vector} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\tJSM.Coord.prototype.Offset = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tthis.x += normal.x * distance;\n\t\tthis.y += normal.y * distance;\n\t\tthis.z += normal.z * distance;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.Rotate\n\t* Description: Rotates the coordinate.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Coord} this pointer\n\t*/\n\n\tJSM.Coord.prototype.Rotate = function (axis, angle, origo)\n\t{\n\t\tvar normal = axis.Clone ().Normalize ();\n\n\t\tvar u = normal.x;\n\t\tvar v = normal.y;\n\t\tvar w = normal.z;\n\n\t\tvar x = this.x - origo.x;\n\t\tvar y = this.y - origo.y;\n\t\tvar z = this.z - origo.z;\n\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\t\tthis.x = - u * (- u * x - v * y - w * z) * (1.0 - co) + x * co + (- w * y + v * z) * si;\n\t\tthis.y = - v * (- u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;\n\t\tthis.z = - w * (- u * x - v * y - w * z) * (1.0 - co) + z * co + (- v * x + u * y) * si;\n\t\t\n\t\tthis.x += origo.x;\n\t\tthis.y += origo.y;\n\t\tthis.z += origo.z;\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: Coord.ToCoord2D\n\t* Description: Converts the coordinate to a 2D coordinate.\n\t* Parameters:\n\t*\tnormal {Vector} the normal vector for conversion\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.Coord.prototype.ToCoord2D = function (normal)\n\t{\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar zNormal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar axis = JSM.VectorCross (normal, zNormal);\n\t\tvar angle = normal.AngleTo (zNormal);\n\t\tvar rotated = this.Clone ().Rotate (axis, angle, origo);\n\t\treturn new JSM.Coord2D (rotated.x, rotated.y);\n\t};\n\n\t/**\n\t* Function: Coord.ToString\n\t* Description: Converts the coordinate values to string.\n\t* Returns:\n\t*\t{string} the string representation of the coordinate\n\t*/\n\tJSM.Coord.prototype.ToString = function ()\n\t{\n\t\treturn ('(' + this.x + ', ' + this.y + ', ' + this.z + ')');\n\t};\n\n\t/**\n\t* Function: Coord.Clone\n\t* Description: Clones the coordinate.\n\t* Returns:\n\t*\t{Coord} a cloned instance\n\t*/\n\tJSM.Coord.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Coord (this.x, this.y, this.z);\n\t};\n\n\t/**\n\t* Class: Vector\n\t* Description: Same as Coord.\n\t*/\n\tJSM.Vector = JSM.Coord;\n\n\t/**\n\t* Function: CoordFromArray\n\t* Description: Returns a coordinate from an array of components.\n\t* Parameters:\n\t*\tarray {number[3]} the array of components\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordFromArray = function (array)\n\t{\n\t\treturn new JSM.Coord (array[0], array[1], array[2]);\n\t};\n\n\t/**\n\t* Function: CoordToArray\n\t* Description: Returns array of components from a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\tarray {number[3]} the result\n\t*/\n\tJSM.CoordToArray = function (coord)\n\t{\n\t\treturn [coord.x, coord.y, coord.z];\n\t};\n\n\t/**\n\t* Function: CoordAdd\n\t* Description: Adds two coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordAdd = function (a, b)\n\t{\n\t\treturn new JSM.Coord (a.x + b.x, a.y + b.y, a.z + b.z);\n\t};\n\n\t/**\n\t* Function: CoordSub\n\t* Description: Subs two coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CoordSub = function (a, b)\n\t{\n\t\treturn new JSM.Coord (a.x - b.x, a.y - b.y, a.z - b.z);\n\t};\n\n\t/**\n\t* Function: VectorDot\n\t* Description: Calculates the dot product of two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.VectorDot = function (a, b)\n\t{\n\t\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n\t};\n\n\t/**\n\t* Function: VectorCross\n\t* Description: Calculates the cross product of two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.VectorCross = function (a, b)\n\t{\n\t\tvar result = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tresult.x = a.y * b.z - a.z * b.y;\n\t\tresult.y = a.z * b.x - a.x * b.z;\n\t\tresult.z = a.x * b.y - a.y * b.x;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/determinant',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixDeterminant2x2\n\t* Description: Calculates the determinant of a 2x2 matrix.\n\t* Parameters:\n\t*\tm00..m11 {4 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant2x2 = function (m00, m01,\n\t\t\t\t\t\t\t\t\t\tm10, m11)\n\t{\n\t\treturn m00 * m11 - m01 * m10;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant3x3\n\t* Description: Calculates the determinant of a 3x3 matrix.\n\t* Parameters:\n\t*\tm00..m22 {9 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant3x3 = function (m00, m01, m02,\n\t\t\t\t\t\t\t\t\t\tm10, m11, m12,\n\t\t\t\t\t\t\t\t\t\tm20, m21, m22)\n\t{\n\t\tvar subDet1 = JSM.MatrixDeterminant2x2 (m11, m12, m21, m22);\n\t\tvar subDet2 = JSM.MatrixDeterminant2x2 (m10, m12, m20, m22);\n\t\tvar subDet3 = JSM.MatrixDeterminant2x2 (m10, m11, m20, m21);\n\t\treturn m00 * subDet1 - m01 * subDet2 + m02 * subDet3;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant4x4\n\t* Description: Calculates the determinant of a 4x4 matrix.\n\t* Parameters:\n\t*\tm00..m33 {16 numbers} the matrix values\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.MatrixDeterminant4x4 = function (m00, m01, m02, m03,\n\t\t\t\t\t\t\t\t\t\tm10, m11, m12, m13,\n\t\t\t\t\t\t\t\t\t\tm20, m21, m22, m23,\n\t\t\t\t\t\t\t\t\t\tm30, m31, m32, m33)\n\t{\n\t\tvar subDet1 = JSM.MatrixDeterminant3x3 (m11, m12, m13, m21, m22, m23, m31, m32, m33);\n\t\tvar subDet2 = JSM.MatrixDeterminant3x3 (m10, m12, m13, m20, m22, m23, m30, m32, m33);\n\t\tvar subDet3 = JSM.MatrixDeterminant3x3 (m10, m11, m13, m20, m21, m23, m30, m31, m33);\n\t\tvar subDet4 = JSM.MatrixDeterminant3x3 (m10, m11, m12, m20, m21, m22, m30, m31, m32);\n\t\treturn subDet1 * m00 - subDet2 * m01 + subDet3 * m02 - subDet4 * m03;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coordutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Orientation\n\t* Description: Orientation of coordinates.\n\t* Values:\n\t*\t{Invalid} invalid orientation or collinear\n\t*\t{CounterClockwise} counter clockwise orientation\n\t*\t{Clockwise} clockwise orientation\n\t*/\n\tJSM.Orientation = {\n\t\tInvalid : 0,\n\t\tCounterClockwise : 1,\n\t\tClockwise : 2\n\t};\n\n\t/**\n\t* Function: MidCoord2D\n\t* Description: Calculates the coordinate in the middle of two coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} first coordinate\n\t*\tb {Coord2D} second coordinate\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.MidCoord2D = function (a, b)\n\t{\n\t\treturn new JSM.Coord2D ((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n\t};\n\n\t/**\n\t* Function: CoordOrientation2D\n\t* Description: Calculates the turn type of three coordinates.\n\t* Parameters:\n\t*\ta {Coord2D} the first coordinate\n\t*\tb {Coord2D} the second coordinate\n\t*\tc {Coord2D} the third coordinate\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.CoordOrientation2D = function (a, b, c)\n\t{\n\t\tvar m00 = a.x;\n\t\tvar m01 = a.y;\n\t\tvar m10 = b.x;\n\t\tvar m11 = b.y;\n\t\tvar m20 = c.x;\n\t\tvar m21 = c.y;\n\t    \n\t\tvar determinant = m00 * m11 + m01 * m20 + m10 * m21 - m11 * m20 - m01 * m10 - m00 * m21;\n\t\tif (JSM.IsPositive (determinant)) {\n\t\t\treturn JSM.Orientation.CounterClockwise;\n\t\t} else if (JSM.IsNegative (determinant)) {\n\t\t\treturn JSM.Orientation.Clockwise;\n\t\t}\n\t\t\n\t\treturn JSM.Orientation.Invalid;\t\n\t};\n\n\t/**\n\t* Function: CoordSignedDistance2D\n\t* Description: Calculates the distance of two coordinates along a direction vector.\n\t* Parameters:\n\t*\ta {Coord2D} first coordinate\n\t*\tb {Coord2D} second coordinate\n\t*\tdirection {Vector2D} direction vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordSignedDistance2D = function (a, b, direction)\n\t{\n\t\tvar abDirection = JSM.CoordSub2D (b, a);\n\t\tvar distance = a.DistanceTo (b);\n\t\t\n\t\tvar angle = abDirection.AngleTo (direction);\n\t\tif (JSM.IsPositive (angle)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: PolarToCartesian\n\t* Description: Converts a polar coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\ttheta {number} the angle component\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.PolarToCartesian = function (radius, theta)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\t\tresult.x = radius * Math.cos (theta);\n\t\tresult.y = radius * Math.sin (theta);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetArcLengthFromAngle\n\t* Description: Calculates arc length from radius and angle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\ttheta {number} the angle of rotation\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetArcLengthFromAngle = function (radius, theta)\n\t{\n\t\treturn theta * radius;\n\t};\n\n\t/**\n\t* Function: GetAngleFromArcLength\n\t* Description: Calculates angle from arc length.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tarcLength {number} the arc length\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetAngleFromArcLength = function (radius, arcLength)\n\t{\n\t\tif (JSM.IsEqual (radius, 0.0)) {\n\t\t\treturn 0.0;\n\t\t}\n\t\t\n\t\treturn arcLength / radius;\n\t};\n\n\t/**\n\t* Function: MidCoord\n\t* Description: Calculates the coordinate in the middle of two coordinates.\n\t* Parameters:\n\t*\ta {Coord} first coordinate\n\t*\tb {Coord} second coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.MidCoord = function (a, b)\n\t{\n\t\treturn new JSM.Coord ((a.x + b.x) / 2.0, (a.y + b.y) / 2.0, (a.z + b.z) / 2.0);\n\t};\n\n\t/**\n\t* Function: CoordSignedDistance\n\t* Description: Calculates the distance of two coordinates along a direction vector.\n\t* Parameters:\n\t*\ta {Coord} first coordinate\n\t*\tb {Coord} second coordinate\n\t*\tdirection {Vector} direction vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordSignedDistance = function (a, b, direction)\n\t{\n\t\tvar abDirection = JSM.CoordSub (b, a);\n\t\tvar distance = a.DistanceTo (b);\n\t\t\n\t\tvar angle = abDirection.AngleTo (direction);\n\t\tif (JSM.IsPositive (angle)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: GetVectorsFullAngle\n\t* Description: Calculates the full angle (0 to pi) of two vectors with the given normal vector.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tnormal {Vector} the normal vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetVectorsFullAngle = function (a, b, normal)\n\t{\n\t\tvar angle = a.AngleTo (b);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tif (JSM.CoordOrientation (a, origo, b, normal) == JSM.Orientation.Clockwise) {\n\t\t\tangle = 2.0 * Math.PI - angle;\n\t\t}\n\t\t\n\t\treturn angle;\n\t};\n\n\t/**\n\t* Function: CoordOrientation\n\t* Description: Calculates the turn type of three coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t*\tc {Coord} the third coordinate\n\t*\tnormal {Vector} normal vector for calculation\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.CoordOrientation = function (a, b, c, normal)\n\t{\n\t\tvar a2 = a.ToCoord2D (normal);\n\t\tvar b2 = b.ToCoord2D (normal);\n\t\tvar c2 = c.ToCoord2D (normal);\n\t\tvar orientation = JSM.CoordOrientation2D (a2, b2, c2);\n\n\t\tvar zNormal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar angle = normal.AngleTo (zNormal);\n\t\tif (JSM.IsEqual (angle, Math.PI)) {\n\t\t\tif (orientation == JSM.Orientation.CounterClockwise) {\n\t\t\t\torientation = JSM.Orientation.Clockwise;\n\t\t\t} else if (orientation == JSM.Orientation.Clockwise) {\n\t\t\t\torientation = JSM.Orientation.CounterClockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: SphericalToCartesian\n\t* Description: Converts a spherical coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\ttheta {number} the angle component\n\t*\tphi {number} the phi component\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SphericalToCartesian = function (radius, theta, phi)\n\t{\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = radius * Math.sin (theta) * Math.cos (phi);\n\t\tresult.y = radius * Math.sin (theta) * Math.sin (phi);\n\t\tresult.z = radius * Math.cos (theta);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CylindricalToCartesian\n\t* Description: Converts a cylindrical coordinate to a cartesian coordinate.\n\t* Parameters:\n\t*\tradius {number} the radius component\n\t*\theight {number} the height component\n\t*\ttheta {number} the theta component\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CylindricalToCartesian = function (radius, height, theta)\n\t{\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = radius * Math.cos (theta);\n\t\tresult.y = radius * Math.sin (theta);\n\t\tresult.z = height;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetArcLength\n\t* Description: Calculates arc length between two vectors.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tradius {number} the radius component\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetArcLength = function (a, b, radius)\n\t{\n\t\tvar angle = a.AngleTo (b);\n\t\treturn angle * radius;\n\t};\n\n\t/**\n\t* Function: GetFullArcLength\n\t* Description: Calculates arc length between two vectors with the given normal vector.\n\t* Parameters:\n\t*\ta {Vector} the first vector\n\t*\tb {Vector} the second vector\n\t*\tradius {number} the radius component\n\t*\tnormal {Vector} the normal vector\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetFullArcLength = function (a, b, radius, normal)\n\t{\n\t\tvar angle = JSM.GetVectorsFullAngle (a, b, normal);\n\t\treturn angle * radius;\n\t};\n\n\t/**\n\t* Function: CalculateCentroid\n\t* Description: Calculates center points of the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the array of coordinates\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculateCentroid = function (coords)\n\t{\n\t\tvar count = coords.length;\n\t\tvar centroid = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tif (count >= 1) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcentroid = JSM.CoordAdd (centroid, coords[i]);\n\t\t\t}\n\t\t\tcentroid.MultiplyScalar (1.0 / count);\n\t\t}\n\n\t\treturn centroid;\n\t};\n\n\t/**\n\t* Function: CalculateTriangleNormal\n\t* Description: Calculates normal vector for the given triangle vertices.\n\t* Parameters:\n\t*\tv0 {Coord} the first vertex of the triangle\n\t*\tv1 {Coord} the second vertex of the triangle\n\t*\tv2 {Coord} the third vertex of the triangle\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateTriangleNormal = function (v0, v1, v2)\n\t{\n\t\tvar v = JSM.CoordSub (v1, v0);\n\t\tvar w = JSM.CoordSub (v2, v0);\n\t\t\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tnormal.x = (v.y * w.z - v.z * w.y);\n\t\tnormal.y = (v.z * w.x - v.x * w.z);\n\t\tnormal.z = (v.x * w.y - v.y * w.x);\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateNormal\n\t* Description: Calculates normal vector for the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the array of coordinates\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateNormal = function (coords)\n\t{\n\t\tvar count = coords.length;\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex;\n\t\t\tvar current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i % count;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = coords[currentIndex];\n\t\t\t\tnext = coords[nextIndex];\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: BarycentricInterpolation\n\t* Description: Calculates barycentric interpolation for the given values.\n\t* Parameters:\n\t*\tvertex0, vertex1, vertex2 {Coord} the vertices of interpolation\n\t*\tvalue0, value1, value2 {Coord} the values to interpolate\n\t*\tposition {Coord} the position of interpolation\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.BarycentricInterpolation = function (vertex0, vertex1, vertex2, value0, value1, value2, position)\n\t{\n\t\tfunction GetTriangleArea (a, b, c)\n\t\t{\n\t\t\tvar s = (a + b + c) / 2.0;\n\t\t\tvar areaSquare = s * (s - a) * (s - b) * (s - c);\n\t\t\tif (areaSquare < 0.0) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn Math.sqrt (areaSquare);\n\t\t}\n\t\t\n\t\tvar edge0 = vertex0.DistanceTo (vertex1);\n\t\tvar edge1 = vertex1.DistanceTo (vertex2);\n\t\tvar edge2 = vertex2.DistanceTo (vertex0);\n\t\t\n\t\tvar distance0 = vertex0.DistanceTo (position);\n\t\tvar distance1 = vertex1.DistanceTo (position);\n\t\tvar distance2 = vertex2.DistanceTo (position);\n\t\t\n\t\tvar area = GetTriangleArea (edge0, edge1, edge2);\n\t\tif (JSM.IsZero (area)) {\n\t\t\treturn value0;\n\t\t}\n\t\t\n\t\tvar area0 = GetTriangleArea (edge0, distance0, distance1);\n\t\tvar area1 = GetTriangleArea (edge1, distance1, distance2);\n\t\tvar area2 = GetTriangleArea (edge2, distance0, distance2);\n\t\t\n\t\tvar interpolated0 = value0.Clone ().MultiplyScalar (area1);\n\t\tvar interpolated1 = value1.Clone ().MultiplyScalar (area2);\n\t\tvar interpolated2 = value2.Clone ().MultiplyScalar (area0);\n\t\tvar interpolated = JSM.CoordAdd (JSM.CoordAdd (interpolated0, interpolated1), interpolated2);\n\t\tinterpolated.MultiplyScalar (1.0 / area);\n\t\treturn interpolated;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/matrix',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixIdentity\n\t* Description: Generates an identity matrix.\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixIdentity = function ()\n\t{\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixClone\n\t* Description: Clones a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixClone = function (matrix)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = matrix[0];\n\t\tresult[1] = matrix[1];\n\t\tresult[2] = matrix[2];\n\t\tresult[3] = matrix[3];\n\t\tresult[4] = matrix[4];\n\t\tresult[5] = matrix[5];\n\t\tresult[6] = matrix[6];\n\t\tresult[7] = matrix[7];\n\t\tresult[8] = matrix[8];\n\t\tresult[9] = matrix[9];\n\t\tresult[10] = matrix[10];\n\t\tresult[11] = matrix[11];\n\t\tresult[12] = matrix[12];\n\t\tresult[13] = matrix[13];\n\t\tresult[14] = matrix[14];\n\t\tresult[15] = matrix[15];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixTranspose\n\t* Description: Transposes a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixTranspose = function (matrix)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = matrix[0];\n\t\tresult[1] = matrix[4];\n\t\tresult[2] = matrix[8];\n\t\tresult[3] = matrix[12];\n\t\tresult[4] = matrix[1];\n\t\tresult[5] = matrix[5];\n\t\tresult[6] = matrix[9];\n\t\tresult[7] = matrix[13];\n\t\tresult[8] = matrix[2];\n\t\tresult[9] = matrix[6];\n\t\tresult[10] = matrix[10];\n\t\tresult[11] = matrix[14];\n\t\tresult[12] = matrix[3];\n\t\tresult[13] = matrix[7];\n\t\tresult[14] = matrix[11];\n\t\tresult[15] = matrix[15];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixVectorMultiply\n\t* Description: Multiplies a matrix with a vector.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tvector {number[4]} the vector\n\t* Returns:\n\t*\t{number[4]} the result vector\n\t*/\n\tJSM.MatrixVectorMultiply = function (matrix, vector)\n\t{\n\t\tvar a00 = vector[0];\n\t\tvar a01 = vector[1];\n\t\tvar a02 = vector[2];\n\t\tvar a03 = vector[3];\n\t\tvar b00 = matrix[0];\n\t\tvar b01 = matrix[1];\n\t\tvar b02 = matrix[2];\n\t\tvar b03 = matrix[3];\n\t\tvar b10 = matrix[4];\n\t\tvar b11 = matrix[5];\n\t\tvar b12 = matrix[6];\n\t\tvar b13 = matrix[7];\n\t\tvar b20 = matrix[8];\n\t\tvar b21 = matrix[9];\n\t\tvar b22 = matrix[10];\n\t\tvar b23 = matrix[11];\n\t\tvar b30 = matrix[12];\n\t\tvar b31 = matrix[13];\n\t\tvar b32 = matrix[14];\n\t\tvar b33 = matrix[15];\n\n\t\tvar result = [];\n\t\tresult[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n\t\tresult[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n\t\tresult[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n\t\tresult[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixMultiply\n\t* Description: Multiplies a two matrices.\n\t* Parameters:\n\t*\tmatrix1 {number[16]} first matrix\n\t*\tmatrix2 {number[16]} second matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixMultiply = function (matrix1, matrix2)\n\t{\n\t\tvar a00 = matrix1[0];\n\t\tvar a01 = matrix1[1];\n\t\tvar a02 = matrix1[2];\n\t\tvar a03 = matrix1[3];\n\t\tvar a10 = matrix1[4];\n\t\tvar a11 = matrix1[5];\n\t\tvar a12 = matrix1[6];\n\t\tvar a13 = matrix1[7];\n\t\tvar a20 = matrix1[8];\n\t\tvar a21 = matrix1[9];\n\t\tvar a22 = matrix1[10];\n\t\tvar a23 = matrix1[11];\n\t\tvar a30 = matrix1[12];\n\t\tvar a31 = matrix1[13];\n\t\tvar a32 = matrix1[14];\n\t\tvar a33 = matrix1[15];\n\t\t\n\t\tvar b00 = matrix2[0];\n\t\tvar b01 = matrix2[1];\n\t\tvar b02 = matrix2[2];\n\t\tvar b03 = matrix2[3];\n\t\tvar b10 = matrix2[4];\n\t\tvar b11 = matrix2[5];\n\t\tvar b12 = matrix2[6];\n\t\tvar b13 = matrix2[7];\n\t\tvar b20 = matrix2[8];\n\t\tvar b21 = matrix2[9];\n\t\tvar b22 = matrix2[10];\n\t\tvar b23 = matrix2[11];\n\t\tvar b30 = matrix2[12];\n\t\tvar b31 = matrix2[13];\n\t\tvar b32 = matrix2[14];\n\t\tvar b33 = matrix2[15];\n\t\t\t\n\t\tvar result = [];\n\t\tresult[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n\t\tresult[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n\t\tresult[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n\t\tresult[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n\t\tresult[4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n\t\tresult[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n\t\tresult[6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n\t\tresult[7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n\t\tresult[8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n\t\tresult[9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n\t\tresult[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n\t\tresult[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n\t\tresult[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n\t\tresult[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n\t\tresult[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n\t\tresult[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixDeterminant\n\t* Description: Calculates the determinant of a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number} the determinant\n\t*/\n\tJSM.MatrixDeterminant = function (matrix)\n\t{\n\t\tvar a00 = matrix[0];\n\t\tvar a01 = matrix[1];\n\t\tvar a02 = matrix[2];\n\t\tvar a03 = matrix[3];\n\t\tvar a10 = matrix[4];\n\t\tvar a11 = matrix[5];\n\t\tvar a12 = matrix[6];\n\t\tvar a13 = matrix[7];\n\t\tvar a20 = matrix[8];\n\t\tvar a21 = matrix[9];\n\t\tvar a22 = matrix[10];\n\t\tvar a23 = matrix[11];\n\t\tvar a30 = matrix[12];\n\t\tvar a31 = matrix[13];\n\t\tvar a32 = matrix[14];\n\t\tvar a33 = matrix[15];\n\n\t\tvar b00 = a00 * a11 - a01 * a10;\n\t\tvar b01 = a00 * a12 - a02 * a10;\n\t\tvar b02 = a00 * a13 - a03 * a10;\n\t\tvar b03 = a01 * a12 - a02 * a11;\n\t\tvar b04 = a01 * a13 - a03 * a11;\n\t\tvar b05 = a02 * a13 - a03 * a12;\n\t\tvar b06 = a20 * a31 - a21 * a30;\n\t\tvar b07 = a20 * a32 - a22 * a30;\n\t\tvar b08 = a20 * a33 - a23 * a30;\n\t\tvar b09 = a21 * a32 - a22 * a31;\n\t\tvar b10 = a21 * a33 - a23 * a31;\n\t\tvar b11 = a22 * a33 - a23 * a32;\n\t\t\n\t\tvar determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\treturn determinant;\n\t};\n\n\t/**\n\t* Function: MatrixInvert\n\t* Description: Inverts a matrix.\n\t* Parameters:\n\t*\tmatrix {number[16]} the source matrix\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixInvert = function (matrix)\n\t{\n\t\tvar a00 = matrix[0];\n\t\tvar a01 = matrix[1];\n\t\tvar a02 = matrix[2];\n\t\tvar a03 = matrix[3];\n\t\tvar a10 = matrix[4];\n\t\tvar a11 = matrix[5];\n\t\tvar a12 = matrix[6];\n\t\tvar a13 = matrix[7];\n\t\tvar a20 = matrix[8];\n\t\tvar a21 = matrix[9];\n\t\tvar a22 = matrix[10];\n\t\tvar a23 = matrix[11];\n\t\tvar a30 = matrix[12];\n\t\tvar a31 = matrix[13];\n\t\tvar a32 = matrix[14];\n\t\tvar a33 = matrix[15];\n\n\t\tvar b00 = a00 * a11 - a01 * a10;\n\t\tvar b01 = a00 * a12 - a02 * a10;\n\t\tvar b02 = a00 * a13 - a03 * a10;\n\t\tvar b03 = a01 * a12 - a02 * a11;\n\t\tvar b04 = a01 * a13 - a03 * a11;\n\t\tvar b05 = a02 * a13 - a03 * a12;\n\t\tvar b06 = a20 * a31 - a21 * a30;\n\t\tvar b07 = a20 * a32 - a22 * a30;\n\t\tvar b08 = a20 * a33 - a23 * a30;\n\t\tvar b09 = a21 * a32 - a22 * a31;\n\t\tvar b10 = a21 * a33 - a23 * a31;\n\t\tvar b11 = a22 * a33 - a23 * a32;\n\t\t\n\t\tvar determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = [];\n\t\t\n\t\tresult[0] = (a11 * b11 - a12 * b10 + a13 * b09) / determinant;\n\t\tresult[1] = (a02 * b10 - a01 * b11 - a03 * b09) / determinant;\n\t\tresult[2] = (a31 * b05 - a32 * b04 + a33 * b03) / determinant;\n\t\tresult[3] = (a22 * b04 - a21 * b05 - a23 * b03) / determinant;\n\t\tresult[4] = (a12 * b08 - a10 * b11 - a13 * b07) / determinant;\n\t\tresult[5] = (a00 * b11 - a02 * b08 + a03 * b07) / determinant;\n\t\tresult[6] = (a32 * b02 - a30 * b05 - a33 * b01) / determinant;\n\t\tresult[7] = (a20 * b05 - a22 * b02 + a23 * b01) / determinant;\n\t\tresult[8] = (a10 * b10 - a11 * b08 + a13 * b06) / determinant;\n\t\tresult[9] = (a01 * b08 - a00 * b10 - a03 * b06) / determinant;\n\t\tresult[10] = (a30 * b04 - a31 * b02 + a33 * b00) / determinant;\n\t\tresult[11] = (a21 * b02 - a20 * b04 - a23 * b00) / determinant;\n\t\tresult[12] = (a11 * b07 - a10 * b09 - a12 * b06) / determinant;\n\t\tresult[13] = (a00 * b09 - a01 * b07 + a02 * b06) / determinant;\n\t\tresult[14] = (a31 * b01 - a30 * b03 - a32 * b00) / determinant;\n\t\tresult[15] = (a20 * b03 - a21 * b01 + a22 * b00) / determinant;\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixTranslation\n\t* Description: Creates a translation matrix.\n\t* Parameters:\n\t*\tx {number} x offset of the transformation\n\t*\ty {number} y offset of the transformation\n\t*\tz {number} z offset of the transformation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixTranslation = function (x, y, z)\n\t{\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = x;\n\t\tresult[13] = y;\n\t\tresult[14] = z;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotation\n\t* Description: Creates a rotation matrix around the given axis.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotation = function (axis, angle, origo)\n\t{\n\t\tvar normal = axis.Clone ().Normalize ();\n\n\t\tvar u = normal.x;\n\t\tvar v = normal.y;\n\t\tvar w = normal.z;\n\n\t\tvar u2 = u * u;\n\t\tvar v2 = v * v;\n\t\tvar w2 = w * w;\n\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\t\t\n\t\tvar result = [];\n\t\tif (origo === undefined || origo === null) {\n\t\t\tresult[0] = u2 + (v2 + w2) * co;\n\t\t\tresult[1] = u * v * (1.0 - co) + w * si;\n\t\t\tresult[2] = u * w * (1.0 - co) - v * si;\n\t\t\tresult[3] = 0.0;\n\t\t\tresult[4] = u * v * (1.0 - co) - w * si;\n\t\t\tresult[5] = v2 + (u2 + w2) * co;\n\t\t\tresult[6] = v * w * (1.0 - co) + u * si;\n\t\t\tresult[7] = 0.0;\n\t\t\tresult[8] = u * w * (1.0 - co) + v * si;\n\t\t\tresult[9] = v * w * (1.0 - co) - u * si;\n\t\t\tresult[10] = w2 + (u2 + v2) * co;\n\t\t\tresult[11] = 0.0;\n\t\t\tresult[12] = 0.0;\n\t\t\tresult[13] = 0.0;\n\t\t\tresult[14] = 0.0;\n\t\t\tresult[15] = 1.0;\n\t\t} else {\n\t\t\tvar a = origo.x;\n\t\t\tvar b = origo.y;\n\t\t\tvar c = origo.z;\n\t\t\n\t\t\tresult[0] = u2 + (v2 + w2) * co;\n\t\t\tresult[1] = u * v * (1.0 - co) + w * si;\n\t\t\tresult[2] = u * w * (1.0 - co) - v * si;\n\t\t\tresult[3] = 0.0;\n\t\t\tresult[4] = u * v * (1.0 - co) - w * si;\n\t\t\tresult[5] = v2 + (u2 + w2) * co;\n\t\t\tresult[6] = v * w * (1.0 - co) + u * si;\n\t\t\tresult[7] = 0.0;\n\t\t\tresult[8] = u * w * (1.0 - co) + v * si;\n\t\t\tresult[9] = v * w * (1.0 - co) - u * si;\n\t\t\tresult[10] = w2 + (u2 + v2) * co;\n\t\t\tresult[11] = 0.0;\n\t\t\tresult[12] = (a * (v2 + w2) - u * (b * v + c * w)) * (1.0 - co) + (b * w - c * v) * si;\n\t\t\tresult[13] = (b * (u2 + w2) - v * (a * u + c * w)) * (1.0 - co) + (c * u - a * w) * si;\n\t\t\tresult[14] = (c * (u2 + v2) - w * (a * u + b * v)) * (1.0 - co) + (a * v - b * u) * si;\n\t\t\tresult[15] = 1.0;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationQuaternion\n\t* Description: Creates a rotation matrix from a given quaternion.\n\t* Parameters:\n\t*\tquaternion {number[4]} the quaternion\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationQuaternion = function (quaternion)\n\t{\n\t\tvar x = quaternion[0];\n\t\tvar y = quaternion[1];\n\t\tvar z = quaternion[2];\n\t\tvar w = quaternion[3];\n\n\t\tvar x2 = x + x;\n\t\tvar y2 = y + y;\n\t\tvar z2 = z + z;\n\n\t\tvar xx = x * x2;\n\t\tvar xy = x * y2;\n\t\tvar xz = x * z2;\n\t\tvar yy = y * y2;\n\t\tvar yz = y * z2;\n\t\tvar zz = z * z2;\n\t\tvar wx = w * x2;\n\t\tvar wy = w * y2;\n\t\tvar wz = w * z2;\n\n\t\tvar result = [];\n\t\tresult[0] = 1.0 - (yy + zz);\n\t\tresult[1] = xy + wz;\n\t\tresult[2] = xz - wy;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = xy - wz;\n\t\tresult[5] = 1.0 - (xx + zz);\n\t\tresult[6] = yz + wx;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = xz + wy;\n\t\tresult[9] = yz - wx;\n\t\tresult[10] = 1.0 - (xx + yy);\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationX\n\t* Description: Creates a rotation matrix around the x axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationX = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = 1.0;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = co;\n\t\tresult[6] = si;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = -si;\n\t\tresult[10] = co;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationY\n\t* Description: Creates a rotation matrix around the y axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationY = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = co;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = -si;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = 1.0;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = si;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = co;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixRotationZ\n\t* Description: Creates a rotation matrix around the z axis.\n\t* Parameters:\n\t*\tangle {number} the angle of rotation\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixRotationZ = function (angle)\n\t{\n\t\tvar si = Math.sin (angle);\n\t\tvar co = Math.cos (angle);\n\n\t\tvar result = [];\n\t\tresult[0] = co;\n\t\tresult[1] = si;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = -si;\n\t\tresult[5] = co;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = 1.0;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = 0.0;\n\t\tresult[15] = 1.0;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ApplyTransformation\n\t* Description: Applies a matrix transformation to a coordinate.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.ApplyTransformation = function (matrix, coord)\n\t{\n\t\tvar vector = [];\n\t\tvector[0] = coord.x;\n\t\tvector[1] = coord.y;\n\t\tvector[2] = coord.z;\n\t\tvector[3] = 1.0;\n\t\t\n\t\tvar resultVector = JSM.MatrixVectorMultiply (matrix, vector);\n\t\tvar result = new JSM.Coord (resultVector[0], resultVector[1], resultVector[2]);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ApplyRotation\n\t* Description: Applies the rotation part of a matrix transformation to a coordinate.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.ApplyRotation = function (matrix, coord)\n\t{\n\t\tvar vector = [];\n\t\tvector[0] = coord.x;\n\t\tvector[1] = coord.y;\n\t\tvector[2] = coord.z;\n\t\tvector[3] = 0.0;\n\t\t\n\t\tvar resultVector = JSM.MatrixVectorMultiply (matrix, vector);\n\t\tvar result = new JSM.Coord (resultVector[0], resultVector[1], resultVector[2]);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/coordsystem',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: CoordSystem\n\t* Description: Represents coordinate system.\n\t* Parameters:\n\t*\torigo {Coord} origo\n\t*\te1 {Vector} first direction vector\n\t*\te2 {Vector} second direction vector\n\t*\te3 {Vector} third direction vector\n\t*/\n\tJSM.CoordSystem = function (origo, e1, e2, e3)\n\t{\n\t\tthis.origo = origo;\n\t\tthis.e1 = e1;\n\t\tthis.e2 = e2;\n\t\tthis.e3 = e3;\n\t};\n\n\t/**\n\t* Function: CoordSystem.Set\n\t* Description: Sets the coordinate system.\n\t* Parameters:\n\t*\torigo {Coord} origo\n\t*\te1 {Vector} first direction vector\n\t*\te2 {Vector} second direction vector\n\t*\te3 {Vector} third direction vector\n\t*/\n\tJSM.CoordSystem.prototype.Set = function (origo, e1, e2, e3)\n\t{\n\t\tthis.origo = origo;\n\t\tthis.e1 = e1;\n\t\tthis.e2 = e2;\n\t\tthis.e3 = e3;\n\t};\n\n\t/**\n\t* Function: CoordSystem.CoordSystemToDirectionVectors\n\t* Description: Converts coordinate system vectors to origo relative direction vectors.\n\t* Returns:\n\t*\t{CoordSystem} this pointer\n\t*/\n\tJSM.CoordSystem.prototype.ToDirectionVectors = function ()\n\t{\n\t\tthis.e1 = JSM.CoordSub (this.e1, this.origo);\n\t\tthis.e2 = JSM.CoordSub (this.e2, this.origo);\n\t\tthis.e3 = JSM.CoordSub (this.e3, this.origo);\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: CoordSystem.CoordSystemToAbsoluteCoords\n\t* Description: Converts the coordinate system vectors to absolute coordinates.\n\t* Returns:\n\t*\t{CoordSystem} this pointer\n\t*/\n\tJSM.CoordSystem.prototype.ToAbsoluteCoords = function ()\n\t{\n\t\tthis.e1 = JSM.CoordAdd (this.e1, this.origo);\n\t\tthis.e2 = JSM.CoordAdd (this.e2, this.origo);\n\t\tthis.e3 = JSM.CoordAdd (this.e3, this.origo);\n\t\treturn this;\n\t};\n\n\t/**\n\t* Function: CoordSystem.Clone\n\t* Description: Clones the coordinate system.\n\t* Returns:\n\t*\t{CoordSystem} a cloned instance\n\t*/\n\tJSM.CoordSystem.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.CoordSystem (this.origo.Clone (), this.e1.Clone (), this.e2.Clone (), this.e3.Clone ());\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/sector',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordSectorPosition2D\n\t* Description: Position of a coordinate and a sector.\n\t* Values:\n\t*\t{CoordInsideOfSector} coordinate lies inside of sector\n\t*\t{CoordOnSectorEndCoord} coordinate lies at the end of the sector\n\t*\t{CoordOutsideOfSector} coordinate lies outside of the sector\n\t*/\n\tJSM.CoordSectorPosition2D = {\n\t\tCoordInsideOfSector : 0,\n\t\tCoordOnSectorEndCoord : 1,\n\t\tCoordOutsideOfSector : 2\n\t};\n\n\t/**\n\t* Enum: SectorSectorPosition2D\n\t* Description: Position of two sectors.\n\t* Values:\n\t*\t{SectorsDontIntersect} sectors do not intersect\n\t*\t{SectorsIntersectCoincident} sectors intersect coincident\n\t*\t{SectorsIntersectEndPoint} sectors intersect at end point\n\t*\t{SectorsIntersectOnePoint} sectors intersect one point\n\t*/\n\tJSM.SectorSectorPosition2D = {\n\t\tSectorsDontIntersect : 0,\n\t\tSectorsIntersectCoincident : 1,\n\t\tSectorsIntersectEndPoint : 2,\n\t\tSectorsIntersectOnePoint : 3\n\t};\n\n\t/**\n\t* Enum: CoordSectorPosition\n\t* Description: Position of a coordinate and a sector.\n\t* Values:\n\t*\t{CoordInsideOfSector} coordinate lies inside of sector\n\t*\t{CoordOnSectorEndCoord} coordinate lies at the end of the sector\n\t*\t{CoordOutsideOfSector} coordinate lies outside of the sector\n\t*/\n\tJSM.CoordSectorPosition = {\n\t\tCoordInsideOfSector : 0,\n\t\tCoordOnSectorEndCoord : 1,\n\t\tCoordOutsideOfSector : 2\n\t};\n\n\t/**\n\t* Class: Sector2D\n\t* Description: Represents a 2D sector.\n\t* Parameters:\n\t*\tbeg {Coord2D} the beginning coordinate\n\t*\tend {Coord2D} the ending coordinate\n\t*/\n\tJSM.Sector2D = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector2D.Set\n\t* Description: Sets the sector.\n\t* Parameters:\n\t*\tbeg {Coord2D} the beginning coordinate\n\t*\tend {Coord2D} the ending coordinate\n\t*/\n\tJSM.Sector2D.prototype.Set = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.GetLength\n\t* Description: Returns the length of the sector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sector2D.prototype.GetLength = function ()\n\t{\n\t\treturn this.beg.DistanceTo (this.end);\n\t};\n\n\t/**\n\t* Function: Sector2D.CoordPosition\n\t* Description: Calculates the position of the sector and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Sector2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar x1 = this.beg.x;\n\t\tvar y1 = this.beg.y;\n\t\tvar x2 = this.end.x;\n\t\tvar y2 = this.end.y;\n\n\t\tvar length = this.GetLength ();\n\t\tif (JSM.IsZero (length)) {\n\t\t\tif (coord.IsEqual (this.beg)) {\n\t\t\t\treturn JSM.CoordSectorPosition2D.CoordOnSectorEndCoord;\n\t\t\t}\n\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar u = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / (length * length);\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar ux = x1 + u * (x2 - x1);\n\t\tvar uy = y1 + u * (y2 - y1);\n\t\tif (!JSM.IsEqual (ux, x) || !JSM.IsEqual (uy, y)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOutsideOfSector;\n\t\t}\n\n\t\tif (JSM.IsEqual (u, 0.0) || JSM.IsEqual (u, 1.0)) {\n\t\t\treturn JSM.CoordSectorPosition2D.CoordOnSectorEndCoord;\n\t\t}\n\n\t\treturn JSM.CoordSectorPosition2D.CoordInsideOfSector;\n\t};\n\n\t/**\n\t* Function: Sector2D.SectorPosition\n\t* Description: Calculates the position of the sector and the given sector.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tintersection {Coord2D} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{SectorSectorPosition2D} the result\n\t*/\n\tJSM.Sector2D.prototype.SectorPosition = function (sector, intersection)\n\t{\n\t\tfunction IsOnSegment (beg, end, coord)\n\t\t{\n\t\t\tif (!coord.IsEqual (beg) && !coord.IsEqual (end) &&\n\t\t\t\tJSM.IsLowerOrEqual (coord.x, Math.max (beg.x, end.x)) &&\n\t\t\t\tJSM.IsLowerOrEqual (coord.y, Math.max (beg.y, end.y)) &&\n\t\t\t\tJSM.IsGreaterOrEqual (coord.x, Math.min (beg.x, end.x)) &&\n\t\t\t\tJSM.IsGreaterOrEqual (coord.y, Math.min (beg.y, end.y)))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvar calcIntersection = (intersection !== undefined && intersection !== null);\n\t\t\n\t\tvar aBeg = this.beg;\n\t\tvar aEnd = this.end;\n\t\tvar bBeg = sector.beg;\n\t\tvar bEnd = sector.end;\n\t\t\n\t\tvar equalBeg = aBeg.IsEqual (bBeg) || aBeg.IsEqual (bEnd);\n\t\tvar equalEnd = aEnd.IsEqual (bBeg) || aEnd.IsEqual (bEnd);\n\t\tif (equalBeg && equalEnd) {\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectCoincident;\n\t\t}\n\n\t\tvar x1 = aBeg.x;\n\t\tvar y1 = aBeg.y;\n\t\tvar x2 = aEnd.x;\n\t\tvar y2 = aEnd.y;\n\t\tvar x3 = bBeg.x;\n\t\tvar y3 = bBeg.y;\n\t\tvar x4 = bEnd.x;\n\t\tvar y4 = bEnd.y;\n\n\t\tvar numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t\tvar numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t\tvar denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\tif (JSM.IsZero (denominator)) {\n\t\t\tif (JSM.IsZero (numeratorA) && JSM.IsZero (numeratorB)) {\n\t\t\t\tif (IsOnSegment (aBeg, aEnd, bBeg) ||\n\t\t\t\t\tIsOnSegment (aBeg, aEnd, bEnd) ||\n\t\t\t\t\tIsOnSegment (bBeg, bEnd, aBeg) ||\n\t\t\t\t\tIsOnSegment (bBeg, bEnd, aEnd))\n\t\t\t\t{\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectCoincident;\n\t\t\t\t} else if (equalBeg) {\n\t\t\t\t\tif (calcIntersection) {\n\t\t\t\t\t\tintersection.x = aBeg.x;\n\t\t\t\t\t\tintersection.y = aBeg.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t\t\t} else if (equalEnd) {\n\t\t\t\t\tif (calcIntersection) {\n\t\t\t\t\t\tintersection.x = aEnd.x;\n\t\t\t\t\t\tintersection.y = aEnd.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsDontIntersect;\n\t\t}\n\t\t\n\t\tvar distA = numeratorA / denominator;\n\t\tvar distB = numeratorB / denominator;\n\t\tif (JSM.IsLower (distA, 0.0) || JSM.IsGreater (distA, 1.0) ||\n\t\t\tJSM.IsLower (distB, 0.0) || JSM.IsGreater (distB, 1.0))\n\t\t{\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsDontIntersect;\n\t\t}\n\n\t\tif (equalBeg) {\n\t\t\tif (calcIntersection) {\n\t\t\t\tintersection.x = aBeg.x;\n\t\t\t\tintersection.y = aBeg.y;\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t} else if (equalEnd) {\n\t\t\tif (calcIntersection) {\n\t\t\t\tintersection.x = aEnd.x;\n\t\t\t\tintersection.y = aEnd.y;\n\t\t\t}\n\t\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectEndPoint;\n\t\t}\n\t\t\n\t\tif (calcIntersection) {\n\t\t\tintersection.x = x1 + distA * (x2 - x1);\n\t\t\tintersection.y = y1 + distA * (y2 - y1);\n\t\t}\n\t\treturn JSM.SectorSectorPosition2D.SectorsIntersectOnePoint;\n\t};\n\n\t/**\n\t* Function: Sector2D.ProjectCoord\n\t* Description: Calculates the projected coordinate of the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{Coord2D} the projected coordinate\n\t*/\n\tJSM.Sector2D.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\n\t\tvar beg = this.beg;\n\t\tvar end = this.end;\n\t\tvar x1 = beg.x;\n\t\tvar y1 = beg.y;\n\t\tvar x2 = end.x;\n\t\tvar y2 = end.y;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn beg.Clone ();\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1)) / denom;\n\t\tif (JSM.IsLower (u, 0.0)) {\n\t\t\treturn beg.Clone ();\n\t\t} else if (JSM.IsGreater (u, 1.0)) {\n\t\t\treturn end.Clone ();\n\t\t}\n\t\t\n\t\tvar dir = JSM.CoordSub2D (end, beg).MultiplyScalar (u);\n\t\tvar result = JSM.CoordAdd2D (beg, dir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Sector2D.Clone\n\t* Description: Clones the sector.\n\t* Returns:\n\t*\t{Sector2D} a cloned instance\n\t*/\n\tJSM.Sector2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sector2D (this.beg.Clone (), this.end.Clone ());\n\t};\n\n\t/**\n\t* Class: Sector\n\t* Description: Represents a 3D sector.\n\t* Parameters:\n\t*\tbeg {Coord} the beginning coordinate\n\t*\tend {Coord} the ending coordinate\n\t*/\n\tJSM.Sector = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.Set\n\t* Description: Sets the sector.\n\t* Parameters:\n\t*\tbeg {Coord} the beginning coordinate\n\t*\tend {Coord} the ending coordinate\n\t*/\n\tJSM.Sector.prototype.Set = function (beg, end)\n\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t};\n\n\t/**\n\t* Function: Sector.GetLength\n\t* Description: Returns the length of the sector.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sector.prototype.GetLength = function ()\n\t{\n\t\treturn this.beg.DistanceTo (this.end);\n\t};\n\n\t/**\n\t* Function: Sector.CoordPosition\n\t* Description: Calculates the position of the sector and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{CoordSectorPosition} the result\n\t*/\n\tJSM.Sector.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.beg;\n\t\tvar b = JSM.CoordSub (this.end, this.beg);\n\t\t\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\tif (a.IsEqual (coord)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOnSectorEndCoord;\n\t\t\t}\n\t\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\tvar c = JSM.CoordAdd (a, bu);\n\t\tvar distance = coord.DistanceTo (c);\n\t\tif (JSM.IsZero (distance)) {\n\t\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t\t\t} else if (JSM.IsEqual (u, 0.0) || JSM.IsEqual (u, 1.0)) {\n\t\t\t\treturn JSM.CoordSectorPosition.CoordOnSectorEndCoord;\n\t\t\t}\n\t\t\treturn JSM.CoordSectorPosition.CoordInsideOfSector;\n\t\t}\n\n\t\treturn JSM.CoordSectorPosition.CoordOutsideOfSector;\n\t};\n\n\t/**\n\t* Function: Sector.Clone\n\t* Description: Clones the sector.\n\t* Returns:\n\t*\t{Sector} a cloned instance\n\t*/\n\tJSM.Sector.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sector (this.beg.Clone (), this.end.Clone ());\n\t};\n\n\t/**\n\t* Function: GetSectorSegmentation2D\n\t* Description: Returns the segmented coordinates of a sector.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tsegmentation {integer} the segmentation\n\t* Returns:\n\t*\t{Coord2D[*]} the result coordinates\n\t*/\n\tJSM.GetSectorSegmentation2D = function (sector, segmentation)\n\t{\n\t\tvar direction = JSM.CoordSub2D (sector.end, sector.beg);\n\t\tvar length = sector.beg.DistanceTo (sector.end);\n\t\tvar step = length / segmentation;\n\t\tvar distance = 0.0;\n\n\t\tvar result = [];\n\t\tvar i, offseted;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\toffseted = sector.beg.Clone ().Offset (direction, distance);\n\t\t\tresult.push (offseted);\n\t\t\tdistance += step;\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetSectorSegmentation\n\t* Description: Returns the segmented coordinates of a sector.\n\t* Parameters:\n\t*\tsector {Sector} the sector\n\t*\tsegmentation {integer} the segmentation\n\t* Returns:\n\t*\t{Coord[*]} the result coordinates\n\t*/\n\tJSM.GetSectorSegmentation = function (sector, segmentation)\n\t{\n\t\tvar direction = JSM.CoordSub (sector.end, sector.beg);\n\t\tvar length = sector.beg.DistanceTo (sector.end);\n\t\tvar step = length / segmentation;\n\t\tvar distance = 0.0;\n\n\t\tvar result = [];\n\t\tvar i, offseted;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\toffseted = sector.beg.Clone ().Offset (direction, distance);\n\t\t\tresult.push (offseted);\n\t\t\tdistance += step;\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/line',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordLinePosition2D\n\t* Description: Position of a coordinate and a line.\n\t* Values:\n\t*\t{CoordOnLine} coordinate lies on the line\n\t*\t{CoordAtLineLeft} coordinate lies on the left side of the line\n\t*\t{CoordAtLineRight} coordinate lies on the left side right the line\n\t*/\n\tJSM.CoordLinePosition2D = {\n\t\tCoordOnLine : 0,\n\t\tCoordAtLineLeft : 1,\n\t\tCoordAtLineRight : 2\n\t};\n\n\t/**\n\t* Enum: LineLinePosition2D\n\t* Description: Position of two lines.\n\t* Values:\n\t*\t{LinesDontIntersect} lines do not intersect\n\t*\t{LinesIntersectsCoincident} lines intersect coincident\n\t*\t{LinesIntersectsOnePoint} lines intersect one point\n\t*/\n\tJSM.LineLinePosition2D = {\n\t\tLinesDontIntersect : 0,\n\t\tLinesIntersectsOnePoint : 1,\n\t\tLinesIntersectsCoincident : 2\n\t};\n\n\t/**\n\t* Enum: CoordLinePosition\n\t* Description: Position of a coordinate and a line.\n\t* Values:\n\t*\t{CoordOnLine} coordinate lies on the line\n\t*\t{CoordOutsideOfLine} coordinate lies outside of the line\n\t*/\n\tJSM.CoordLinePosition = {\n\t\tCoordOnLine : 0,\n\t\tCoordOutsideOfLine : 1\n\t};\n\n\t/**\n\t* Enum: LineLinePosition\n\t* Description: Position of two lines.\n\t* Values:\n\t*\t{LinesDontIntersect} lines do not intersect\n\t*\t{LinesIntersectsCoincident} lines intersect coincident\n\t*\t{LinesIntersectsOnePoint} lines intersect one point\n\t*/\n\tJSM.LineLinePosition = {\n\t\tLinesDontIntersect : 0,\n\t\tLinesIntersectsOnePoint : 1,\n\t\tLinesIntersectsCoincident : 2\n\t};\n\n\t/**\n\t* Class: Line2D\n\t* Description: Represents a 2D infinite line.\n\t* Parameters:\n\t*\tstart {Coord2D} the start point of the line\n\t*\tdirection {Vector2D} the direction of the line\n\t*/\n\tJSM.Line2D = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line2D.Set\n\t* Description: Sets the line.\n\t* Parameters:\n\t*\tstart {Coord2D} the start point of the line\n\t*\tdirection {Vector2D} the direction of the line\n\t*/\n\tJSM.Line2D.prototype.Set = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line2D.CoordPosition\n\t* Description: Calculates the position of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordLinePosition2D} the result\n\t*/\n\tJSM.Line2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar position = this.CoordSignedDistance (coord);\n\t\tif (JSM.IsPositive (position)) {\n\t\t\treturn JSM.CoordLinePosition2D.CoordAtLineLeft;\n\t\t} else if (JSM.IsNegative (position)) {\n\t\t\treturn JSM.CoordLinePosition2D.CoordAtLineRight;\n\t\t}\n\n\t\treturn JSM.CoordLinePosition2D.CoordOnLine;\n\t};\n\n\t/**\n\t* Function: Line2D.CoordSignedDistance\n\t* Description: Calculates the signed distance of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Line2D.prototype.CoordSignedDistance = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\t\treturn b.x * (y - a.y) - b.y * (x - a.x);\n\t};\n\n\t/**\n\t* Function: Line2D.LinePosition\n\t* Description: Calculates the position of the line and the given line.\n\t* Parameters:\n\t*\tline {Line2D} the line\n\t*\tintersection {Coord2D} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{LineLinePosition2D} the result\n\t*/\n\tJSM.Line2D.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar x1 = this.start.x;\n\t\tvar y1 = this.start.y;\n\t\tvar x2 = this.start.x + this.direction.x;\n\t\tvar y2 = this.start.y + this.direction.y;\n\t\tvar x3 = line.start.x;\n\t\tvar y3 = line.start.y;\n\t\tvar x4 = line.start.x + line.direction.x;\n\t\tvar y4 = line.start.y + line.direction.y;\n\t\t\n\t\tvar numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t\tvar numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t\tvar denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\tif (JSM.IsZero (denominator)) {\n\t\t\tif (JSM.IsZero (numeratorA) && JSM.IsZero (numeratorB)) {\n\t\t\t\treturn JSM.LineLinePosition2D.LinesIntersectsCoincident;\n\t\t\t}\n\t\t\treturn JSM.LineLinePosition2D.LinesDontIntersect;\n\t\t}\n\n\t\tvar distance = numeratorA / denominator;\n\t\tif (intersection !== null) {\n\t\t\tintersection.x = x1 + distance * (x2 - x1);\n\t\t\tintersection.y = y1 + distance * (y2 - y1);\n\t\t}\n\t\treturn JSM.LineLinePosition2D.LinesIntersectsOnePoint;\n\t};\n\n\t/**\n\t* Function: Line2D.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{Line2D} a cloned instance\n\t*/\n\tJSM.Line2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Line2D (this.start.Clone (), this.direction.Clone ());\n\t};\n\n\t/**\n\t* Class: Line\n\t* Description: Represents a 3D infinite line.\n\t* Parameters:\n\t*\tstart {Coord} the start point of the line\n\t*\tdirection {Vector} the direction of the line\n\t*/\n\tJSM.Line = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line.Set\n\t* Description: Sets the line.\n\t* Parameters:\n\t*\tstart {Coord} the start point of the line\n\t*\tdirection {Vector} the direction of the line\n\t*/\n\tJSM.Line.prototype.Set = function (start, direction)\n\t{\n\t\tthis.start = start;\n\t\tthis.direction = direction;\n\t};\n\n\t/**\n\t* Function: Line.CoordPosition\n\t* Description: Calculates the position of the line and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tprojected {Coord} (out) the projected coordinate\n\t* Returns:\n\t*\t{CoordLinePosition} the result\n\t*/\n\tJSM.Line.prototype.CoordPosition = function (coord, projected)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\tif (projected !== undefined) {\n\t\t\t\tprojected.Set (a.x, a.y, a.z);\n\t\t\t}\n\n\t\t\tif (a.IsEqual (coord)) {\n\t\t\t\treturn JSM.CoordLinePosition.CoordOnLine;\n\t\t\t}\n\n\t\t\treturn JSM.CoordLinePosition.CoordOutsideOfLine;\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\tvar c = JSM.CoordAdd (a, bu);\n\t\tif (projected !== undefined) {\n\t\t\tprojected.Set (c.x, c.y, c.z);\n\t\t}\n\n\t\tvar distance = coord.DistanceTo (c);\n\t\tif (JSM.IsZero (distance)) {\n\t\t\treturn JSM.CoordLinePosition.CoordOnLine;\n\t\t}\n\n\t\treturn JSM.CoordLinePosition.CoordOutsideOfLine;\n\t};\n\n\t/**\n\t* Function: Line.ProjectCoord\n\t* Description: Calculates the projected coordinate of the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Line.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.start;\n\t\tvar b = this.direction;\n\n\t\tvar x1 = a.x;\n\t\tvar y1 = a.y;\n\t\tvar z1 = a.z;\n\t\tvar x2 = a.x + b.x;\n\t\tvar y2 = a.y + b.y;\n\t\tvar z2 = a.z + b.z;\n\n\t\tvar denom = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn a.Clone ();\n\t\t}\n\n\t\tvar u = ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1)) / denom;\n\t\tvar bu = b.Clone ().MultiplyScalar (u);\n\t\treturn JSM.CoordAdd (a, bu);\n\t};\n\n\t/**\n\t* Function: Line.ClosestPoint\n\t* Description: Calculates the closest points between the line and a given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tthisClosestPoint {Coord} (out) the closest point on the current line\n\t*\tlineClosestPoint {Coord} (out) the closest point on the given line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.Line.prototype.ClosestPoint = function (line, thisClosestPoint, lineClosestPoint)\n\t{\n\t\tfunction Dmnop (v, m, n, o, p)\n\t\t{\n\t\t\tvar result = (v[m].x - v[n].x) * (v[o].x - v[p].x) + (v[m].y - v[n].y) * (v[o].y - v[p].y) + (v[m].z - v[n].z) * (v[o].z - v[p].z);\n\t\t\treturn result;\n\t\t}\n\n\t\tvar aDir = this.direction.Clone ().Normalize ();\n\t\tvar aStart = this.start;\n\t\tvar aEnd = JSM.CoordAdd (aStart, aDir);\n\n\t\tvar bDir = line.direction.Clone ().Normalize ();\n\t\tvar bStart = line.start;\n\t\tvar bEnd = JSM.CoordAdd (bStart, bDir);\n\t\t\n\t\tvar v = [aStart, aEnd, bStart, bEnd];\n\t\tvar d1010 = Dmnop (v, 1, 0, 1, 0);\n\t\tvar d0210 = Dmnop (v, 0, 2, 1, 0);\n\t\tvar d0232 = Dmnop (v, 0, 2, 3, 2);\n\t\tvar d3210 = Dmnop (v, 3, 2, 1, 0);\n\t\tvar d3232 = Dmnop (v, 3, 2, 3, 2);\n\t\tvar denom = (d1010 * d3232 - d3210 * d3210);\n\t\tif (JSM.IsEqual (denom, 0.0)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar nom = (d0232 * d3210 - d0210 * d3232);\n\t\tvar mua = nom / denom;\n\t\tvar mub = (d0232 + mua * d3210) / d3232;\n\n\t\tif (thisClosestPoint !== undefined) {\n\t\t\taDir.MultiplyScalar (mua);\n\t\t\tvar aClosest = JSM.CoordAdd (aStart, aDir);\n\t\t\tthisClosestPoint.Set (aClosest.x, aClosest.y, aClosest.z);\n\t\t}\n\t\t\n\t\tif (lineClosestPoint !== undefined) {\n\t\t\tbDir.MultiplyScalar (mub);\n\t\t\tvar bClosest = JSM.CoordAdd (bStart, bDir);\n\t\t\tlineClosestPoint.Set (bClosest.x, bClosest.y, bClosest.z);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Line.LinePosition\n\t* Description: Calculates the position of the line and the given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tintersection {Coord} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{LineLinePosition} the result\n\t*/\n\tJSM.Line.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar thisClosestPoint = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar lineClosestPoint = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tif (!this.ClosestPoint (line, thisClosestPoint, lineClosestPoint)) {\n\t\t\treturn JSM.LineLinePosition.LinesIntersectsCoincident;\n\t\t}\n\t\t\n\t\tif (thisClosestPoint.IsEqual (lineClosestPoint)) {\n\t\t\tif (intersection !== undefined) {\n\t\t\t\tintersection.Set (thisClosestPoint.x, thisClosestPoint.y, thisClosestPoint.z);\n\t\t\t}\n\t\t\treturn JSM.LineLinePosition.LinesIntersectsOnePoint;\n\t\t}\n\t\t\n\t\treturn JSM.LineLinePosition.LinesDontIntersect;\n\t};\n\n\t/**\n\t* Function: Line.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{Line} a cloned instance\n\t*/\n\tJSM.Line.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Line (this.start.Clone (), this.direction.Clone ());\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/box',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Box2D\n\t* Description: Represents a 2D box.\n\t* Parameters:\n\t*\tmin {Coord2D} the minimum position of the box\n\t*\tmin {Coord2D} the maximum position of the box\n\t*/\n\tJSM.Box2D = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box2D.Set\n\t* Description: Sets the box.\n\t* Parameters:\n\t*\tmin {Coord2D} the minimum position of the box\n\t*\tmin {Coord2D} the maximum position of the box\n\t*/\n\tJSM.Box2D.prototype.Set = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box2D.GetCenter\n\t* Description: Returns the center point of the box.\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.Box2D.prototype.GetCenter = function ()\n\t{\n\t\treturn JSM.MidCoord2D (this.min, this.max);\n\t};\n\n\t/**\n\t* Function: Box2D.Clone\n\t* Description: Clones the box.\n\t* Returns:\n\t*\t{Box2D} a cloned instance\n\t*/\n\tJSM.Box2D.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Box2D (this.min.Clone (), this.max.Clone ());\n\t};\n\n\t/**\n\t* Class: Box\n\t* Description: Represents a 3D box.\n\t* Parameters:\n\t*\tmin {Coord} the minimum position of the box\n\t*\tmin {Coord} the maximum position of the box\n\t*/\n\tJSM.Box = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box.Set\n\t* Description: Sets the box.\n\t* Parameters:\n\t*\tmin {Coord} the minimum position of the box\n\t*\tmin {Coord} the maximum position of the box\n\t*/\n\tJSM.Box.prototype.Set = function (min, max)\n\t{\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t};\n\n\t/**\n\t* Function: Box.GetCenter\n\t* Description: Returns the center point of the box.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Box.prototype.GetCenter = function ()\n\t{\n\t\treturn JSM.MidCoord (this.min, this.max);\n\t};\n\n\t/**\n\t* Function: Box.GetSize\n\t* Description: Returns the size of the box.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Box.prototype.GetSize = function ()\n\t{\n\t\treturn JSM.CoordSub (this.max, this.min);\n\t};\n\n\t/**\n\t* Function: Box.IsCoordInside\n\t* Description: Determines if the given coordinate is inside the box.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Box.prototype.IsCoordInside = function (coord)\n\t{\n\t\tif (JSM.IsLower (coord.x, this.min.x) || JSM.IsLower (coord.y, this.min.y) || JSM.IsLower (coord.z, this.min.z)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (JSM.IsGreater (coord.x, this.max.x) || JSM.IsGreater (coord.y, this.max.y) || JSM.IsGreater (coord.z, this.max.z)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Box.Clone\n\t* Description: Clones the box.\n\t* Returns:\n\t*\t{Box} a cloned instance\n\t*/\n\tJSM.Box.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Box (this.min.Clone (), this.max.Clone ());\n\t};\n\n\t/**\n\t* Function: BoxUnion\n\t* Description: Calculates the union of two 3D boxes.\n\t* Parameters:\n\t*\taBox {Box} the first box\n\t*\tbBox {Box} the second box\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.BoxUnion = function (aBox, bBox)\n\t{\n\t\tvar min = new JSM.Coord (JSM.Minimum (aBox.min.x, bBox.min.x), JSM.Minimum (aBox.min.y, bBox.min.y), JSM.Minimum (aBox.min.z, bBox.min.z));\n\t\tvar max = new JSM.Coord (JSM.Maximum (aBox.max.x, bBox.max.x), JSM.Maximum (aBox.max.y, bBox.max.y), JSM.Maximum (aBox.max.z, bBox.max.z));\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/sphere',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Sphere\n\t* Description: Represents a sphere.\n\t* Parameters:\n\t*\tcenter {Coord} the center of the sphere\n\t*\tradius {number} the radius of the sphere\n\t*/\n\tJSM.Sphere = function (center, radius)\n\t{\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t};\n\n\t/**\n\t* Function: Sphere.Set\n\t* Description: Sets the sphere.\n\t* Parameters:\n\t*\tcenter {Coord} the center of the sphere\n\t*\tradius {number} the radius of the sphere\n\t*/\n\tJSM.Sphere.prototype.Set = function (center, radius)\n\t{\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t};\n\n\t/**\n\t* Function: Sphere.GetCenter\n\t* Description: Returns the center of the sphere.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Sphere.prototype.GetCenter = function ()\n\t{\n\t\treturn this.center;\n\t};\n\n\t/**\n\t* Function: Sphere.GetRadius\n\t* Description: Returns the radius of the sphere.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Sphere.prototype.GetRadius = function ()\n\t{\n\t\treturn this.radius;\n\t};\n\n\t/**\n\t* Function: Sphere.Clone\n\t* Description: Clones the sphere.\n\t* Returns:\n\t*\t{Sphere} a cloned instance\n\t*/\n\tJSM.Sphere.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Sphere (this.center.Clone (), this.radius);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/transformation',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Transformation\n\t* Description: Represents a transformation matrix.\n\t*/\n\tJSM.Transformation = function ()\n\t{\n\t\tthis.matrix = JSM.MatrixIdentity ();\n\t};\n\n\t/**\n\t* Function: Transformation.GetMatrix\n\t* Description: Returns the matrix of the transformation.\n\t* Returns:\n\t*\t{number[16]} the matrix\n\t*/\n\tJSM.Transformation.prototype.GetMatrix = function ()\n\t{\n\t\treturn this.matrix;\n\t};\n\n\t/**\n\t* Function: Transformation.SetMatrix\n\t* Description: Sets matrix of the transformation.\n\t* Parameters:\n\t*\tmatrix {number[16]} the matrix\n\t*/\n\tJSM.Transformation.prototype.SetMatrix = function (matrix)\n\t{\n\t\tthis.matrix = matrix;\n\t};\n\n\t/**\n\t* Function: Transformation.Append\n\t* Description: Adds a transformation to the matrix.\n\t* Parameters:\n\t*\tsource {Transformation} the another transformation\n\t*/\n\tJSM.Transformation.prototype.Append = function (source)\n\t{\n\t\tthis.matrix = JSM.MatrixMultiply (this.matrix, source.matrix);\n\t};\n\n\t/**\n\t* Function: Transformation.Apply\n\t* Description: Apply transformation to a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Transformation.prototype.Apply = function (coord)\n\t{\n\t\treturn JSM.ApplyTransformation (this.matrix, coord);\n\t};\n\n\t/**\n\t* Function: Transformation.Clone\n\t* Description: Clones the transformation.\n\t* Returns:\n\t*\t{Transformation} a cloned instance\n\t*/\n\tJSM.Transformation.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Transformation ();\n\t\tresult.matrix = JSM.MatrixClone (this.matrix);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IdentityTransformation\n\t* Description: Generates an identity transformation.\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.IdentityTransformation = function ()\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixIdentity ();\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: TranslationTransformation\n\t* Description: Generates a translation transformation.\n\t* Parameters:\n\t*\ttranslation {Vector} the translation vector\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.TranslationTransformation = function (translation)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixTranslation (translation.x, translation.y, translation.z);\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: OffsetTransformation\n\t* Description: Generates an offset transformation.\n\t* Parameters:\n\t*\tdirection {Vector} the direction of the offset\n\t*\tdistance {number} the distance of the offset\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.OffsetTransformation = function (direction, distance)\n\t{\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tvar translation = normal.Clone ().MultiplyScalar (distance);\n\t\treturn JSM.TranslationTransformation (translation);\n\t};\n\n\t/**\n\t* Function: RotationTransformation\n\t* Description: Generates a rotation transformation.\n\t* Parameters:\n\t*\taxis {Vector} the axis of the rotation\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationTransformation = function (axis, angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.matrix = JSM.MatrixRotation (axis, angle, origo);\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationXTransformation\n\t* Description: Generates a rotation transformation around the x axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationXTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationX (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationXTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationYTransformation\n\t* Description: Generates a rotation transformation around the y axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationYTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationY (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationYTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationZTransformation\n\t* Description: Generates a rotation transformation around the z axis.\n\t* Parameters:\n\t*\tangle {number} the angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationZTransformation = function (angle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\tif (origo === undefined || origo === null) {\n\t\t\ttransformation.matrix = JSM.MatrixRotationZ (angle);\n\t\t} else {\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (-origo.x, -origo.y, -origo.z)));\n\t\t\ttransformation.Append (JSM.RotationZTransformation (angle));\n\t\t\ttransformation.Append (JSM.TranslationTransformation (new JSM.Vector (origo.x, origo.y, origo.z)));\n\t\t}\n\t\treturn transformation;\n\t};\n\n\t/**\n\t* Function: RotationXYZTransformation\n\t* Description: Generates a rotation transformation around all axis in x, y, z order.\n\t* Parameters:\n\t*\txAngle {number} the x angle of the rotation\n\t*\tyAngle {number} the y angle of the rotation\n\t*\tzAngle {number} the z angle of the rotation\n\t*\torigo {Coord} the origo of the rotation\n\t* Returns:\n\t*\t{Transformation} the result\n\t*/\n\tJSM.RotationXYZTransformation = function (xAngle, yAngle, zAngle, origo)\n\t{\n\t\tvar transformation = new JSM.Transformation ();\n\t\ttransformation.Append (JSM.RotationXTransformation (xAngle, origo));\n\t\ttransformation.Append (JSM.RotationYTransformation (yAngle, origo));\n\t\ttransformation.Append (JSM.RotationZTransformation (zAngle, origo));\n\t\treturn transformation;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/plane',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: CoordPlanePosition\n\t* Description: Position of a coordinate and a plane.\n\t* Values:\n\t*\t{CoordOnPlane} coordinate lies on the plane\n\t*\t{CoordInFrontOfPlane} coordinate lies in front of of the plane\n\t*\t{CoordAtBackOfPlane} coordinate lies at the back of the plane\n\t*/\n\tJSM.CoordPlanePosition = {\n\t\tCoordOnPlane : 0,\n\t\tCoordInFrontOfPlane : 1,\n\t\tCoordAtBackOfPlane : 2\n\t};\n\n\t/**\n\t* Enum: LinePlanePosition\n\t* Description: Position of a line and a plane.\n\t* Values:\n\t*\t{LineParallelToPlane} line is parallel to the plane\n\t*\t{LineIntersectsPlane} line intersects the plane\n\t*/\n\tJSM.LinePlanePosition = {\n\t\tLineParallelToPlane : 0,\n\t\tLineIntersectsPlane : 1\n\t};\n\n\t/**\n\t* Class: Plane\n\t* Description: Represents a plane.\n\t* Parameters:\n\t*\ta {number} the a component of plane equation\n\t*\tb {number} the b component of plane equation\n\t*\tc {number} the c component of plane equation\n\t*\td {number} the d component of plane equation\n\t*/\n\tJSM.Plane = function (a, b, c, d)\n\t{\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t};\n\n\t/**\n\t* Function: Plane.Set\n\t* Description: Sets the plane.\n\t* Parameters:\n\t*\ta {number} the a component of plane equation\n\t*\tb {number} the b component of plane equation\n\t*\tc {number} the c component of plane equation\n\t*\td {number} the d component of plane equation\n\t*/\n\tJSM.Plane.prototype.Set = function (a, b, c, d)\n\t{\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t};\n\n\t/**\n\t* Function: Plane.GetNormal\n\t* Description: Calculates the normal vector of the plane.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Plane.prototype.GetNormal = function ()\n\t{\n\t\treturn new JSM.Vector (this.a, this.b, this.c);\n\t};\n\n\t/**\n\t* Function: Plane.CoordSignedDistance\n\t* Description: Calculates the signed distance of a coordinate and the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Plane.prototype.CoordSignedDistance = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar distance = (a * x + b * y + c * z + d) / Math.sqrt (a * a + b * b + c * c);\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: Plane.CoordDistance\n\t* Description: Calculates the distance of a coordinate and the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Plane.prototype.CoordDistance = function (coord)\n\t{\n\t\tvar signed = this.CoordSignedDistance (coord);\n\t\treturn Math.abs (signed);\n\t};\n\n\t/**\n\t* Function: Plane.ProjectCoord\n\t* Description: Projects a coordinate to the plane.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{Coord} the projected coordinate\n\t*/\n\tJSM.Plane.prototype.ProjectCoord = function (coord)\n\t{\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar distance = this.CoordDistance (coord);\n\t\tvar side = a * x + b * y + c * z + d;\n\t\tif (JSM.IsGreater (side, 0.0)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\tvar normal = this.GetNormal ().Normalize ();\n\t\tvar result = coord.Clone ().Offset (normal, distance);\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Plane.CoordPosition\n\t* Description: Calculates the position of the plane and the given coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{CoordPlanePosition} thre result\n\t*/\n\tJSM.Plane.prototype.CoordPosition = function (coord)\n\t{\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar x = coord.x;\n\t\tvar y = coord.y;\n\t\tvar z = coord.z;\n\n\t\tvar s = a * x + b * y + c * z + d;\n\t\tif (JSM.IsPositive (s)) {\n\t\t\treturn JSM.CoordPlanePosition.CoordInFrontOfPlane;\n\t\t} else if (JSM.IsNegative (s)) {\n\t\t\treturn JSM.CoordPlanePosition.CoordAtBackOfPlane;\n\t\t}\n\t\t\n\t\treturn JSM.CoordPlanePosition.CoordOnPlane;\n\t};\n\n\t/**\n\t* Function: Plane.LinePosition\n\t* Description: Calculates the position of the plane and the given line.\n\t* Parameters:\n\t*\tline {Line} the line\n\t*\tintersection {Coord} (out) the intersection point if it exists\n\t* Returns:\n\t*\t{CoordLinePosition} the result\n\t*/\n\tJSM.Plane.prototype.LinePosition = function (line, intersection)\n\t{\n\t\tvar\tdirection = line.direction.Clone ().Normalize ();\n\n\t\tvar x1 = line.start.x;\n\t\tvar y1 = line.start.y;\n\t\tvar z1 = line.start.z;\n\n\t\tvar x2 = line.start.x + direction.x;\n\t\tvar y2 = line.start.y + direction.y;\n\t\tvar z2 = line.start.z + direction.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn JSM.LinePlanePosition.LineParallelToPlane;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tif (intersection !== undefined) {\n\t\t\tdirection.MultiplyScalar (u);\n\t\t\tvar i = JSM.CoordAdd (line.start, direction);\n\t\t\tintersection.Set (i.x, i.y, i.z);\n\t\t}\n\n\t\treturn JSM.LinePlanePosition.LineIntersectsPlane;\n\t};\n\n\t/**\n\t* Function: Plane.LineIntersection\n\t* Description:\n\t*\tCalculates the intersection point of a line and a plane.\n\t*\tThe line should not be parallel to the plane.\n\t* Parameters:\n\t*\tline {Line} the line\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Plane.prototype.LineIntersection = function (line)\n\t{\n\t\tvar\tdirection = line.direction.Clone ().Normalize ();\n\n\t\tvar x1 = line.start.x;\n\t\tvar y1 = line.start.y;\n\t\tvar z1 = line.start.z;\n\n\t\tvar x2 = line.start.x + direction.x;\n\t\tvar y2 = line.start.y + direction.y;\n\t\tvar z2 = line.start.z + direction.z;\n\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar c = this.c;\n\t\tvar d = this.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tdirection.MultiplyScalar (u);\n\t\treturn JSM.CoordAdd (line.start, direction);\n\t};\n\n\t/**\n\t* Function: Plane.Clone\n\t* Description: Clones the plane.\n\t* Returns:\n\t*\t{Plane} a cloned instance\n\t*/\n\tJSM.Plane.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Plane (this.a, this.b, this.c, this.d);\n\t};\n\n\t/**\n\t* Function: GetPlaneFromCoordAndDirection\n\t* Description: Generates a plane from a coordinate and a direction.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t* Returns:\n\t*\t{Plane} the result\n\t*/\n\tJSM.GetPlaneFromCoordAndDirection = function (coord, direction)\n\t{\n\t\tvar plane = new JSM.Plane ();\n\t\tvar normal = direction.Clone ().Normalize ();\n\t\tvar pa = normal.x;\n\t\tvar pb = normal.y;\n\t\tvar pc = normal.z;\n\t\tvar pd = -(pa * coord.x + pb * coord.y + pc * coord.z);\n\t\tplane.Set (pa, pb, pc, pd);\n\t\treturn plane;\n\t};\n\n\t/**\n\t* Function: GetPlaneFromThreeCoords\n\t* Description: Generates a plane from three coordinates.\n\t* Parameters:\n\t*\ta {Coord} the first coordinate\n\t*\tb {Coord} the second coordinate\n\t*\tc {Coord} the third coordinate\n\t* Returns:\n\t*\t{Plane} the result\n\t*/\n\tJSM.GetPlaneFromThreeCoords = function (a, b, c)\n\t{\n\t\tvar plane = new JSM.Plane ();\n\t\tvar pa = (b.y - a.y) * (c.z - a.z) - (c.y - a.y) * (b.z - a.z);\n\t\tvar pb = (b.z - a.z) * (c.x - a.x) - (c.z - a.z) * (b.x - a.x);\n\t\tvar pc = (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);\n\t\tvar pd = -(pa * a.x + pb * a.y + pc * a.z);\n\t\tplane.Set (pa, pb, pc, pd);\n\t\treturn plane;\n\t};\n\n\t/**\n\t* Function: CoordPlaneSignedDirectionalDistance\n\t* Description: Calculates the signed distance of a coordinate and a plane along a direction vector.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordPlaneSignedDirectionalDistance = function (coord, direction, plane)\n\t{\n\t\tvar\tnormal = direction.Clone ().Normalize ();\n\n\t\tvar x1 = coord.x;\n\t\tvar y1 = coord.y;\n\t\tvar z1 = coord.z;\n\n\t\tvar x2 = coord.x + normal.x;\n\t\tvar y2 = coord.y + normal.y;\n\t\tvar z2 = coord.z + normal.z;\n\n\t\tvar a = plane.a;\n\t\tvar b = plane.b;\n\t\tvar c = plane.c;\n\t\tvar d = plane.d;\n\n\t\tvar denom = (a * (x1 - x2) + b * (y1 - y2) + c * (z1 - z2));\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tvar u = (a * x1 + b * y1 + c * z1 + d) / denom;\n\t\tnormal.MultiplyScalar (u);\n\t\tvar intersection = JSM.CoordAdd (coord, normal);\n\t\tvar distance = coord.DistanceTo (intersection);\n\t\tvar s = a * x1 + b * y1 + c * z1 + d;\n\t\tif (JSM.IsNegative (s)) {\n\t\t\tdistance = -distance;\n\t\t}\n\n\t\treturn distance;\n\t};\n\n\t/**\n\t* Function: CoordPlaneDirectionalDistance\n\t* Description: Calculates the distance of a coordinate and a plane along a direction vector.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tdirection {Vector} the direction\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.CoordPlaneDirectionalDistance = function (coord, direction, plane)\n\t{\n\t\treturn Math.abs (JSM.CoordPlaneSignedDirectionalDistance (coord, direction, plane));\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/projection',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: MatrixView\n\t* Description: Creates a view matrix.\n\t* Parameters:\n\t*\teye {Coord} eye position\n\t*\tcenter {Coord} center position\n\t*\tup {Vector} up vector\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixView = function (eye, center, up)\n\t{\n\t\tif (eye.IsEqual (center)) {\n\t\t\treturn JSM.MatrixIdentity ();\n\t\t}\n\t\t\n\t\tvar result = [];\n\n\t\tvar d = JSM.CoordSub (eye, center).Normalize ();\n\t\tvar v = JSM.VectorCross (up, d).Normalize ();\n\t\tvar u = JSM.VectorCross (d, v).Normalize ();\n\n\t\tresult[0] = v.x;\n\t\tresult[1] = u.x;\n\t\tresult[2] = d.x;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = v.y;\n\t\tresult[5] = u.y;\n\t\tresult[6] = d.y;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = v.z;\n\t\tresult[9] = u.z;\n\t\tresult[10] = d.z;\n\t\tresult[11] = 0.0;\n\t\tresult[12] = -JSM.VectorDot (v, eye);\n\t\tresult[13] = -JSM.VectorDot (u, eye);\n\t\tresult[14] = -JSM.VectorDot (d, eye);\n\t\tresult[15] = 1.0;\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MatrixPerspective\n\t* Description: Creates a perspective matrix.\n\t* Parameters:\n\t*\tfieldOfView {number} field of view\n\t*\taspectRatio {number} aspect ratio\n\t*\tnearPlane {number} near clipping plane\n\t*\tfarPlane {number} far clipping plane\n\t* Returns:\n\t*\t{number[16]} the result matrix\n\t*/\n\tJSM.MatrixPerspective = function (fieldOfView, aspectRatio, nearPlane, farPlane)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar f = 1.0 / Math.tan (fieldOfView / 2.0);\n\t\tvar nf = 1.0 / (nearPlane - farPlane);\n\t\t\n\t\tresult[0] = f / aspectRatio;\n\t\tresult[1] = 0.0;\n\t\tresult[2] = 0.0;\n\t\tresult[3] = 0.0;\n\t\tresult[4] = 0.0;\n\t\tresult[5] = f;\n\t\tresult[6] = 0.0;\n\t\tresult[7] = 0.0;\n\t\tresult[8] = 0.0;\n\t\tresult[9] = 0.0;\n\t\tresult[10] = (farPlane + nearPlane) * nf;\n\t\tresult[11] = -1.0;\n\t\tresult[12] = 0.0;\n\t\tresult[13] = 0.0;\n\t\tresult[14] = (2.0 * farPlane * nearPlane) * nf;\n\t\tresult[15] = 0.0;\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Project\n\t* Description: Projects a 3D coordinate to 2D.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\teye {Coord} the eye of the camera\n\t*\tcenter {Coord} the center of the camera\n\t*\tup {Vector} the up vector of the camera\n\t*\tfieldOfView {number} camera field of view\n\t*\taspectRatio {number} aspect ratio of the desired image\n\t*\tnearPlane {number} near cutting plane distance\n\t*\tfarPlane {number} far cutting plane distance\n\t*\tviewPort {number[4]} view port coordinates in pixels\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Project = function (coord, eye, center, up, fieldOfView, aspectRatio, nearPlane, farPlane, viewPort)\n\t{\n\t\tvar input = [\n\t\t\tcoord.x,\n\t\t\tcoord.y,\n\t\t\tcoord.z,\n\t\t\t1.0\n\t\t];\n\n\t\tvar viewMatrix = JSM.MatrixView (eye, center, up);\n\t\tvar perspectiveMatrix = JSM.MatrixPerspective (fieldOfView, aspectRatio, nearPlane, farPlane);\n\t\tvar projectionMatrix = JSM.MatrixMultiply (viewMatrix, perspectiveMatrix);\n\t\tvar output = JSM.MatrixVectorMultiply (projectionMatrix, input);\n\t\tvar denom = output[3];\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = (output[0] / denom * 0.5 + 0.5) * viewPort[2] + viewPort[0];\n\t\tresult.y = (output[1] / denom * 0.5 + 0.5) * viewPort[3] + viewPort[1];\n\t\tresult.z = (output[2] / denom * 0.5 + 0.5);\n\t\treturn result;\t\n\t};\n\n\t/**\n\t* Function: Unproject\n\t* Description: Projects a 2D coordinate to 3D.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate (the z component can be zero)\n\t*\teye {Coord} the eye of the camera\n\t*\tcenter {Coord} the center of the camera\n\t*\tup {Vector} the up vector of the camera\n\t*\tfieldOfView {number} camera field of view\n\t*\taspectRatio {number} aspect ratio of the desired image\n\t*\tnearPlane {number} near cutting plane distance\n\t*\tfarPlane {number} far cutting plane distance\n\t*\tviewPort {number[4]} view port coordinates in pixels\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Unproject = function (coord, eye, center, up, fieldOfView, aspectRatio, nearPlane, farPlane, viewPort)\n\t{\n\t\tvar input = [\n\t\t\t(coord.x - viewPort[0]) / viewPort[2] * 2.0 - 1.0,\n\t\t\t(coord.y - viewPort[1]) / viewPort[3] * 2.0 - 1.0,\n\t\t\t2.0 * coord.z - 1,\n\t\t\t1.0\n\t\t];\n\t\t\n\t\tvar viewMatrix = JSM.MatrixView (eye, center, up);\n\t\tvar perspectiveMatrix = JSM.MatrixPerspective (fieldOfView, aspectRatio, nearPlane, farPlane);\n\t\tvar projectionMatrix = JSM.MatrixMultiply (viewMatrix, perspectiveMatrix);\n\t\tvar inverseMatrix = JSM.MatrixInvert (projectionMatrix);\n\t\tvar output = JSM.MatrixVectorMultiply (inverseMatrix, input);\n\t\tvar denom = output[3];\n\t\tif (JSM.IsZero (denom)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tresult.x = (output[0] / output[3]);\n\t\tresult.y = (output[1] / output[3]);\n\t\tresult.z = (output[2] / output[3]);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/convexhull',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ConvexHull2D\n\t* Description: Calculates the 2D convex hull from the given coordinates.\n\t* Parameters:\n\t*\tcoords {Coord2D[*]} the coordinate array\n\t* Returns:\n\t*\t{Coord2D[*]} coordinate array of the convex hull\n\t*/\n\tJSM.ConvexHull2D = function (coords)\n\t{\n\t\tfunction FindLeftMostCoord (coords)\n\t\t{\n\t\t\tvar count = coords.length;\n\t\t\tvar minValue = JSM.Inf;\n\t\t\tvar minIndex = -1;\n\t\t\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = coords[i].x;\n\t\t\t\tif (JSM.IsLower (current, minValue)) {\n\t\t\t\t\tminValue = current;\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn minIndex;\n\t\t}\n\t\t\n\t\tfunction FindNextCoord (coords, current)\n\t\t{\n\t\t\tvar count = coords.length;\n\t\t\tvar next = 0;\n\t\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 1; i < count; i++) {\n\t\t\t\tif (current == next) {\n\t\t\t\t\tnext = i;\n\t\t\t\t} else {\n\t\t\t\t\tif (JSM.CoordOrientation2D (coords[current], coords[next], coords[i]) == JSM.Orientation.Clockwise) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn next;\n\t\t}\n\n\t\tvar result = [];\n\t\tvar count = coords.length;\n\t\tif (count < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar first = FindLeftMostCoord (coords);\n\t\tvar current = first;\n\t\tvar next;\n\t\t\n\t\tdo {\n\t\t\tresult.push (current);\n\t\t\tnext = FindNextCoord (coords, current);\n\t\t\tcurrent = next;\n\t\t} while (next != first);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvexHull3D\n\t* Description:\n\t*\tCalculates the 3D convex hull from the given coordinates. The result defines\n\t*\tconvex hull triangles as an array of arrays with three coordinates.\n\t* Parameters:\n\t*\tcoords {Coord[*]} the coordinate array\n\t* Returns:\n\t*\t{Coord[3][*]} the result\n\t*/\n\tJSM.ConvexHull3D = function (coords)\n\t{\n\t\tfunction Vertex ()\n\t\t{\n\t\t\tthis.position = null;\n\t\t}\n\t\t\n\t\tfunction Edge ()\n\t\t{\n\t\t\tthis.vert1 = null;\n\t\t\tthis.vert2 = null;\n\t\t\tthis.tri1 = null;\n\t\t\tthis.tri2 = null;\n\t\t}\n\n\t\tfunction Triangle ()\n\t\t{\n\t\t\tthis.vertices = null;\n\t\t\tthis.edges = null;\n\t\t\tthis.valid = null;\n\t\t}\n\n\t\tfunction Body ()\n\t\t{\n\t\t\tthis.vertices = [];\n\t\t\tthis.edges = [];\n\t\t\tthis.triangles = [];\n\t\t}\n\n\t\tfunction AddVertex (body, coord)\n\t\t{\n\t\t\tvar vertex = new Vertex ();\n\t\t\tvertex.position = coord;\n\t\t\tbody.vertices.push (vertex);\n\t\t\treturn body.vertices.length - 1;\n\t\t}\n\n\t\tfunction AddEdge (body, triangleIndex, a, b)\n\t\t{\n\t\t\tvar edgeIndex = -1;\n\t\t\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < body.edges.length; i++) {\n\t\t\t\tcurrent = body.edges[i];\n\t\t\t\tif (current.vert1 == a && current.vert2 == b || current.vert1 == b && current.vert2 == a) {\n\t\t\t\t\tedgeIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (edgeIndex == -1) {\n\t\t\t\tvar newEdge = new Edge ();\n\t\t\t\tnewEdge.vert1 = a;\n\t\t\t\tnewEdge.vert2 = b;\n\t\t\t\tnewEdge.tri1 = -1;\n\t\t\t\tnewEdge.tri2 = -1;\n\t\t\t\tbody.edges.push (newEdge);\n\t\t\t\tedgeIndex = body.edges.length - 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar edge = body.edges[edgeIndex];\n\t\t\tif (edge.tri1 != triangleIndex && edge.tri2 != triangleIndex) {\n\t\t\t\tif (edge.tri1 == -1) {\n\t\t\t\t\tedge.tri1 = triangleIndex;\n\t\t\t\t} else if (edge.tri2 == -1) {\n\t\t\t\t\tedge.tri2 = triangleIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn edgeIndex;\n\t\t}\n\n\t\tfunction AddTriangle (body, a, b, c)\n\t\t{\n\t\t\tvar triangleIndex = body.triangles.length;\n\t\t\tvar edge1 = AddEdge (body, triangleIndex, a, b);\n\t\t\tvar edge2 = AddEdge (body, triangleIndex, b, c);\n\t\t\tvar edge3 = AddEdge (body, triangleIndex, c, a);\n\t\t\t\n\t\t\tvar triangle = new Triangle ();\n\t\t\ttriangle.vertices = [a, b, c];\n\t\t\ttriangle.edges = [edge1, edge2, edge3];\n\t\t\ttriangle.valid = true;\n\t\t\tbody.triangles.push (triangle);\n\t\t\treturn body.triangles.length - 1;\n\t\t}\n\n\t\tfunction RemoveTriangleFromEdge (body, triangleIndex, edgeIndex)\n\t\t{\n\t\t\tvar edge = body.edges[edgeIndex];\n\t\t\tif (edge.tri1 == triangleIndex) {\n\t\t\t\tedge.tri1 = -1;\n\t\t\t} else if (edge.tri2 == triangleIndex) {\n\t\t\t\tedge.tri2 = -1;\n\t\t\t}\n\t\t}\n\n\t\tfunction RemoveTriangle (body, triangleIndex)\n\t\t{\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tif (!triangle.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[0]);\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[1]);\n\t\t\tRemoveTriangleFromEdge (body, triangleIndex, triangle.edges[2]);\n\t\t\ttriangle.valid = false;\n\t\t}\n\n\t\tfunction GetTetrahedronVolume (body, a, b, c, d)\n\t\t{\n\t\t\tvar aCoord = body.vertices[a].position;\n\t\t\tvar bCoord = body.vertices[b].position;\n\t\t\tvar cCoord = body.vertices[c].position;\n\t\t\tvar dCoord = body.vertices[d].position;\n\t\t\t\n\t\t\tvar adSub = JSM.CoordSub (aCoord, dCoord);\n\t\t\tvar bdSub = JSM.CoordSub (bCoord, dCoord);\n\t\t\tvar cdSub = JSM.CoordSub (cCoord, dCoord);\n\t\t\t\n\t\t\treturn (JSM.VectorDot (adSub, JSM.VectorCross (bdSub, cdSub))) / 6.0;\n\t\t}\n\t\t\n\t\tfunction CheckTetrahedronOrientation (body, a, b, c, d)\n\t\t{\n\t\t\tif (JSM.IsLower (GetTetrahedronVolume (body, a, b, c, d), 0.0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddInitialTetrahedron (body)\n\t\t{\n\t\t\tvar triangleIndex = -1;\n\t\t\tif (CheckTetrahedronOrientation (body, 0, 1, 2, 3)) {\n\t\t\t\ttriangleIndex = AddTriangle (body, 0, 1, 2);\n\t\t\t} else {\n\t\t\t\ttriangleIndex = AddTriangle (body, 0, 2, 1);\n\t\t\t}\n\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tAddTriangle (body, triangle.vertices[0], triangle.vertices[2], 3);\n\t\t\tAddTriangle (body, triangle.vertices[2], triangle.vertices[1], 3);\n\t\t\tAddTriangle (body, triangle.vertices[1], triangle.vertices[0], 3);\n\t\t}\n\n\t\tfunction AddCoordToHull (body, index)\n\t\t{\n\t\t\tvar visibleTriangles = [];\n\t\t\t\n\t\t\tvar i, triangle;\n\t\t\tfor (i = 0; i < body.triangles.length; i++) {\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tvisibleTriangles.push (false);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (CheckTetrahedronOrientation (body, triangle.vertices[0], triangle.vertices[2], triangle.vertices[1], index)) {\n\t\t\t\t\tvisibleTriangles.push (true);\n\t\t\t\t} else {\n\t\t\t\t\tvisibleTriangles.push (false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar edge1, edge2, edge3, edge1Vis, edge2Vis, edge3Vis;\n\t\t\tvar newTriangles = [];\n\t\t\tfor (i = 0; i < visibleTriangles.length; i++) {\n\t\t\t\tif (!visibleTriangles[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tedge1 = body.edges[triangle.edges[0]];\n\t\t\t\tedge2 = body.edges[triangle.edges[1]];\n\t\t\t\tedge3 = body.edges[triangle.edges[2]];\n\n\t\t\t\tedge1Vis = (edge1.tri1 == -1 || edge1.tri2 == -1 || visibleTriangles[edge1.tri1] != visibleTriangles[edge1.tri2]);\n\t\t\t\tedge2Vis = (edge2.tri1 == -1 || edge2.tri2 == -1 || visibleTriangles[edge2.tri1] != visibleTriangles[edge2.tri2]);\n\t\t\t\tedge3Vis = (edge3.tri1 == -1 || edge3.tri2 == -1 || visibleTriangles[edge3.tri1] != visibleTriangles[edge3.tri2]);\n\t\t\t\t\n\t\t\t\tif (edge1Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[0], triangle.vertices[1], index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (edge2Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[1], triangle.vertices[2], index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (edge3Vis) {\n\t\t\t\t\tnewTriangles.push ([triangle.vertices[2], triangle.vertices[0], index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < visibleTriangles.length; i++) {\n\t\t\t\tif (!visibleTriangles[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttriangle = body.triangles[i];\n\t\t\t\tif (!triangle.valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRemoveTriangle (body, i);\n\t\t\t}\n\t\t\t\n\t\t\tvar newTriangle;\n\t\t\tfor (i = 0; i < newTriangles.length; i++) {\n\t\t\t\tnewTriangle = newTriangles[i];\n\t\t\t\tAddTriangle (body, newTriangle[0], newTriangle[1], newTriangle[2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\tvar count = coords.length;\n\t\tif (count < 4) {\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = new Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tAddVertex (body, coords[i]);\n\t\t}\n\t\t\n\t\tAddInitialTetrahedron (body);\n\t\tfor (i = 4; i < count; i++) {\n\t\t\tAddCoordToHull (body, i);\n\t\t}\n\t\t\n\t\tvar triangle;\n\t\tfor (i = 0; i < body.triangles.length; i++) {\n\t\t\ttriangle = body.triangles[i];\n\t\t\tif (triangle.valid) {\n\t\t\t\tresult.push (triangle.vertices);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/polygon2d',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Complexity\n\t* Description: Complexity of a polygon.\n\t* Values:\n\t*\t{Invalid} invalid polygon\n\t*\t{Convex} convex polygon\n\t*\t{Concave} concave polygon\n\t*\t{Complex} complex polygon (contains holes)\n\t*/\n\tJSM.Complexity = {\n\t\tInvalid : 0,\n\t\tConvex : 1,\n\t\tConcave : 2,\n\t\tComplex : 3\n\t};\n\n\t/**\n\t* Enum: CoordPolygonPosition2D\n\t* Description: Position of a coordinate and a polygon.\n\t* Values:\n\t*\t{OnVertex} coordinate lies on a vertex of the polygon\n\t*\t{OnEdge} coordinate lies on an edge of the polygon\n\t*\t{Inside} coordinate lies inside the polygon\n\t*\t{Outside} coordinate lies outside of the polygon\n\t*/\n\tJSM.CoordPolygonPosition2D = {\n\t\tOnVertex : 0,\n\t\tOnEdge : 1,\n\t\tInside : 2,\n\t\tOutside : 3\n\t};\n\n\t/**\n\t* Enum: SectorPolygonPosition2D\n\t* Description: Position of a sector and a polygon.\n\t* Values:\n\t*\t{IntersectionOnePoint} sector intersects polygon\n\t*\t{IntersectionCoincident} sector lies on an edge of the polygon\n\t*\t{IntersectionOnVertex} sector intersects polygon on a vertex\n\t*\t{NoIntersection} sector does not intersect polygon\n\t*/\n\tJSM.SectorPolygonPosition2D = {\n\t\tIntersectionOnePoint : 0,\n\t\tIntersectionCoincident : 1,\n\t\tIntersectionOnVertex : 2,\n\t\tNoIntersection : 3\n\t};\n\n\t/**\n\t* Class: Polygon2D\n\t* Description: Represents a 2D polygon.\n\t*/\n\tJSM.Polygon2D = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord2D (x, y));\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.Polygon2D.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon2D.RemoveVertex\n\t* Description: Removes a vertex from the polygon.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.RemoveVertex = function (index)\n\t{\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Polygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon2D.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon2D.EnumerateVertices\n\t* Description:\n\t*\tEnumerates the vertices of the polygon, and calls\n\t*\ta function for each vertex.\n\t* Parameters:\n\t*\tfrom {integer} the start vertex index\n\t*\tto {integer} the end vertex index\n\t*\tcallback {function} the callback function\n\t*/\n\tJSM.Polygon2D.prototype.EnumerateVertices = function (from, to, callback)\n\t{\n\t\tvar count = this.vertices.length;\n\t\tvar index = from;\n\t\tcallback (index);\n\t\twhile (index != to) {\n\t\t\tindex = (index + 1) % count;\n\t\t\tcallback (index);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.ShiftVertices\n\t* Description: Shifts polygon vertices.\n\t* Parameters:\n\t*\tcount {integer} the number of shifts\n\t*/\n\tJSM.Polygon2D.prototype.ShiftVertices = function (count)\n\t{\n\t\tJSM.ShiftArray (this.vertices, count);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub2D (prev, curr);\n\t\tvar nextDir = JSM.CoordSub2D (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tif (this.cache.signedArea !== null) {\n\t\t\treturn this.cache.signedArea;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tvar result = 0.0;\n\t\tif (count >= 3) {\n\t\t\tvar i, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = this.vertices[i];\n\t\t\t\tnext = this.vertices[(i + 1) % count];\n\t\t\t\tresult += current.x * next.y - next.x * current.y;\n\t\t\t}\n\t\t\tresult *= 0.5;\n\t\t}\n\t\t\n\t\tthis.cache.signedArea = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.cache.orientation !== null) {\n\t\t\treturn this.cache.orientation;\n\t\t}\n\n\t\tvar result = JSM.Orientation.Invalid;\n\t\tif (this.vertices.length >= 3) {\n\t\t\tvar signedArea = this.GetSignedArea ();\n\t\t\tif (JSM.IsPositive (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.CounterClockwise;\n\t\t\t} else if (JSM.IsNegative (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.Clockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.orientation = result;\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Polygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.cache.complexity !== null) {\n\t\t\treturn this.cache.complexity;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tif (count < 3) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\t\n\t\tvar result = JSM.Complexity.Invalid;\n\t\tvar polygonOrientain = this.GetOrientation ();\n\t\tif (polygonOrientain != JSM.Orientation.Invalid) {\n\t\t\tresult = JSM.Complexity.Convex;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (this.IsConcaveVertex (i)) {\n\t\t\t\t\tresult = JSM.Complexity.Concave;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.complexity = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexOrientation\n\t* Description: Calculates the orientation of the given vertex of the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexOrientation = function (index)\n\t{\n\t\tif (this.cache.vertexOrientations[index] !== undefined) {\n\t\t\treturn this.cache.vertexOrientations[index];\n\t\t}\n\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\t\n\t\tvar result = JSM.CoordOrientation2D (prev, curr, next);\n\t\tthis.cache.vertexOrientations[index] = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConvexVertex\n\t* Description: Returns if the given vertex is convex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConvexVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation == orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConcaveVertex\n\t* Description: Returns if the given vertex is concave.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConcaveVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation != orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.CoordPosition\n\t* Description: Calculates the position of a coordinate and the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordPolygonPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tfunction IntersectionCount (coord, beg, end)\n\t\t{\n\t\t\tfunction GetIntersection (coord, beg, end)\n\t\t\t{\n\t\t\t\tvar result = new JSM.Coord2D (beg.x, coord.y);\n\t\t\t\tif (!JSM.IsEqual (beg.y, coord.y)) {\n\t\t\t\t\tvar yMoveRatio = Math.abs ((beg.y - coord.y) / (end.y - beg.y));\n\t\t\t\t\tresult.x = beg.x + (end.x - beg.x) * yMoveRatio;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tvar begYDist = beg.y - coord.y;\n\t\t\tvar endYDist = end.y - coord.y;\n\t\t\t\n\t\t\tvar begBelow = JSM.IsNegative (begYDist);\n\t\t\tvar begAbove = JSM.IsPositive (begYDist);\n\t\t\tvar endBelow = JSM.IsNegative (endYDist);\n\t\t\tvar endAbove = JSM.IsPositive (endYDist);\n\t\t\tif ((begBelow && endBelow) || (begAbove && endAbove)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar begOnLine = !begBelow && !begAbove;\n\t\t\tvar endOnLine = !endBelow && !endAbove;\n\t\t\tif (begOnLine && endOnLine) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar intersection = GetIntersection (coord, beg, end);\n\t\t\tif (JSM.IsLower (intersection.x, coord.x)) {\n\t\t\t\treturn 0;\n\t\t\t} else if (JSM.IsGreater (intersection.x, coord.x)) {\n\t\t\t\tif (begOnLine || endOnLine) {\n\t\t\t\t\tvar upwardEdge = JSM.IsGreater (end.y, beg.y);\n\t\t\t\t\tif (begOnLine && upwardEdge || endOnLine && !upwardEdge) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tvar vertexCount = this.vertices.length;\n\t\tvar intersections = 0;\n\t\tvar i, edgeFrom, edgeTo, sector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeFrom = this.vertices[i];\n\t\t\tedgeTo = this.vertices[(i + 1) % vertexCount];\n\t\t\tsector = new JSM.Sector2D (edgeFrom, edgeTo);\n\t\t\tposition = sector.CoordPosition (coord);\n\t\t\tif (position == JSM.CoordSectorPosition2D.CoordInsideOfSector) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnEdge;\n\t\t\t} else if (position == JSM.CoordSectorPosition2D.CoordOnSectorEndCoord) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnVertex;\n\t\t\t}\n\t\t\tintersections += IntersectionCount (coord, edgeFrom, edgeTo);\n\t\t}\n\t\t\n\t\tif (intersections % 2 !== 0) {\n\t\t\treturn JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\treturn JSM.CoordPolygonPosition2D.Outside;\n\t};\n\n\t/**\n\t* Function: Polygon2D.SectorPosition\n\t* Description:\n\t*\tCalculates the position of a sector and the polygon. The given begin and end\n\t*\tvertex indices are omitted form intersection checking.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tbegIndex {integer} begin vertex index\n\t*\tendIndex {integer} end vertex index\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.SectorPosition = function (sector, begIndex, endIndex)\n\t{\n\t\tvar result = JSM.SectorPolygonPosition2D.NoIntersection;\n\t\tvar vertexCount = this.vertices.length;\n\t\tif (vertexCount < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar i, edgeBegIndex, edgeEndIndex, edgeBeg, edgeEnd;\n\t\tvar currentSector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeBegIndex = i;\n\t\t\tedgeEndIndex = (i + 1) % vertexCount;\n\t\t\tedgeBeg = this.vertices[edgeBegIndex];\n\t\t\tedgeEnd = this.vertices[edgeEndIndex];\n\t\t\tif (edgeBegIndex == begIndex || edgeEndIndex == begIndex || edgeBegIndex == endIndex || edgeEndIndex == endIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentSector = new JSM.Sector2D (edgeBeg, edgeEnd);\n\t\t\tposition = sector.SectorPosition (currentSector);\n\t\t\tif (position == JSM.SectorSectorPosition2D.SectorsIntersectOnePoint) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionOnePoint;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectCoincident) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionCoincident;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectEndPoint) {\n\t\t\t\tresult = JSM.SectorPolygonPosition2D.IntersectionOnVertex;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsDiagonal\n\t* Description: Returns if the sector between two vertices is diagonal.\n\t* Parameters:\n\t*\tfrom {integer} begin vertex index\n\t*\tto {integer} end vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsDiagonal = function (from, to)\n\t{\n\t\tfunction DiagonalIntersectsAnyEdges (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar sector = new JSM.Sector2D (fromVertex, toVertex);\n\t\t\tvar position = polygon.SectorPosition (sector, from, to);\n\t\t\tif (position != JSM.SectorPolygonPosition2D.NoIntersection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction DiagonalInsideOfPolygon (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar midCoord = new JSM.Coord2D (\n\t\t\t\t(fromVertex.x + toVertex.x) / 2.0,\n\t\t\t\t(fromVertex.y + toVertex.y) / 2.0\n\t\t\t);\n\t\t\tvar position = polygon.CoordPosition (midCoord);\n\t\t\treturn position == JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\t\n\t\tif (from == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.GetPrevVertex (from) == to || this.GetNextVertex (from) == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar fromVertex = this.vertices[from];\n\t\tvar toVertex = this.vertices[to];\n\t\tif (fromVertex.IsEqual (toVertex)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (DiagonalIntersectsAnyEdges (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!DiagonalInsideOfPolygon (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Polygon2D.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.Polygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon2D.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.Polygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t};\n\n\t/**\n\t * Function: Polygon2D.GetBoundingBox\n\t * Description: Calculates the bounding box of the polygon.\n\t * Returns:\n\t *\t{Box2D} the result\n\t */\n\tJSM.Polygon2D.prototype.GetBoundingBox = function ()\n\t{\n\t\tif (this.cache.boundingBox !== null) {\n\t\t\treturn this.cache.boundingBox;\n\t\t}\n\n\t\tvar result = new JSM.Box2D (\n\t\t\tnew JSM.Coord2D (JSM.Inf, JSM.Inf),\n\t\t\tnew JSM.Coord2D (-JSM.Inf, -JSM.Inf)\n\t\t);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tresult.min.x = JSM.Minimum (result.min.x, coord.x);\n\t\t\tresult.min.y = JSM.Minimum (result.min.y, coord.y);\n\t\t\tresult.max.x = JSM.Maximum (result.max.x, coord.x);\n\t\t\tresult.max.y = JSM.Maximum (result.max.y, coord.y);\n\t\t}\n\n\t\tthis.cache.boundingBox = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon2D.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tsignedArea : null,\n\t\t\torientation : null,\n\t\t\tvertexOrientations : {},\n\t\t\tcomplexity : null,\n\t\t\tboundingBox : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon2D} a cloned instance\n\t*/\n\tJSM.Polygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon2D\n\t* Description: Represents a 2D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon2D = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.lastContour.AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertex = function (contourIndex, x, y)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.ContourPolygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tthis.contours[i].ReverseVertices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon2D} the new contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon2D ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon2D} the contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContour = function (index)\n\t{\n\t\treturn this.contours[index];\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tvar area = 0.0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tarea += this.contours[i].GetSignedArea ();\n\t\t}\n\t\treturn area;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar orientation = this.contours[0].GetOrientation ();\n\t\tif (this.contours.length == 1) {\n\t\t\treturn orientation;\n\t\t}\n\t\tif (orientation == JSM.Orientation.Invalid) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar i, contourOrientation;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourOrientation = this.contours[i].GetOrientation ();\n\t\t\tif (contourOrientation == JSM.Orientation.Invalid) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t\tif (orientation == contourOrientation) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\tif (this.contours.length == 1) {\n\t\t\treturn this.contours[0].GetComplexity ();\n\t\t}\n\t\tvar i, contourComplexity;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourComplexity = this.contours[i].GetComplexity ();\n\t\t\tif (contourComplexity == JSM.Complexity.Invalid) {\n\t\t\t\treturn JSM.Complexity.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn JSM.Complexity.Complex;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} a cloned instance\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/polygon',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Polygon\n\t* Description: Represents a 3D polygon.\n\t*/\n\tJSM.Polygon = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.Polygon.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord (x, y, z));\n\t};\n\n\t/**\n\t* Function: Polygon.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord} the vertex\n\t*/\n\tJSM.Polygon.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub (prev, curr);\n\t\tvar nextDir = JSM.CoordSub (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon.GetNormal\n\t* Description: Calculates the normal vector of the polygon.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Polygon.prototype.GetNormal = function ()\n\t{\n\t\tif (this.cache.normal !== null) {\n\t\t\treturn this.cache.normal;\n\t\t}\n\t\tvar result = JSM.CalculateNormal (this.vertices);\n\t\tthis.cache.normal = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon.ToPolygon2D\n\t* Description: Converts the polygon to a 2D polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.Polygon.prototype.ToPolygon2D = function ()\n\t{\n\t\tvar normal = this.GetNormal ();\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i].ToCoord2D (normal);\n\t\t\tresult.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.Polygon.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord[*]} the array of vertices\n\t*/\n\tJSM.Polygon.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tnormal : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon} a cloned instance\n\t*/\n\tJSM.Polygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon\n\t* Description: Represents a 3D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.lastContour.AddVertex (x, y, z);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.ContourPolygon.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.AddContourVertex = function (contourIndex, x, y, z)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y, z);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.ContourPolygon.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon} the new contour\n\t*/\n\tJSM.ContourPolygon.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon} the result\n\t*/\n\tJSM.ContourPolygon.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord} the vertex\n\t*/\n\tJSM.ContourPolygon.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon} the contour\n\t*/\n\tJSM.ContourPolygon.prototype.GetContour = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex];\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ToContourPolygon2D\n\t* Description: Converts the polygon to a 2D polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} the result\n\t*/\n\tJSM.ContourPolygon.prototype.ToContourPolygon2D = function ()\n\t{\n\t\tvar normal = this.contours[0].GetNormal ();\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tresult.AddContour ();\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tresult.AddVertexCoord (vertex.ToCoord2D (normal));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.ContourPolygon.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon} a cloned instance\n\t*/\n\tJSM.ContourPolygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\n\t};\n\n\t/**\n\t* Function: OffsetPolygonContour\n\t* Description: Offsets all vertices of a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\twidth {number} the width of the offset\n\t* Returns:\n\t*\t{Polygon} the result\n\t*/\n\tJSM.OffsetPolygonContour = function (polygon, width)\n\t{\n\t\tvar count = polygon.VertexCount ();\n\t\tvar normal = polygon.GetNormal ();\n\n\t\tvar prev, curr, next;\n\t\tvar prevVertex, currVertex, nextVertex;\n\t\tvar prevDir, nextDir;\n\t\tvar distance, offsetedCoord;\n\t\t\n\t\tvar result = new JSM.Polygon ();\n\t\t\n\t\tvar i, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = polygon.GetPrevVertex (i);\n\t\t\tcurr = i;\n\t\t\tnext = polygon.GetNextVertex (i);\n\t\t\t\n\t\t\tprevVertex = polygon.GetVertex (prev);\n\t\t\tcurrVertex = polygon.GetVertex (curr);\n\t\t\tnextVertex = polygon.GetVertex (next);\n\n\t\t\tprevDir = JSM.CoordSub (prevVertex, currVertex);\n\t\t\tnextDir = JSM.CoordSub (nextVertex, currVertex);\n\t\t\tangle = prevDir.AngleTo (nextDir) / 2.0;\n\t\t\tif (JSM.CoordOrientation (prevVertex, currVertex, nextVertex, normal) == JSM.Orientation.Clockwise) {\n\t\t\t\tangle = Math.PI - angle;\n\t\t\t}\n\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\toffsetedCoord = currVertex.Clone ();\n\t\t\toffsetedCoord.Offset (nextDir, distance);\n\t\t\toffsetedCoord.Rotate (normal, angle, currVertex);\n\t\t\tresult.AddVertex (offsetedCoord.x, offsetedCoord.y, offsetedCoord.z);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/cutpolygon',[\"../core/jsm\"],function(JSM){\n\tJSM.CutVertexType = {\n\t\tLeft : 1,\n\t\tRight : 2,\n\t\tCut : 3\n\t};\n\n\tJSM.PolygonCutter = function (geometryInterface)\n\t{\n\t\tthis.geometryInterface = geometryInterface;\n\t\tthis.Reset ();\n\t};\n\n\tJSM.PolygonCutter.prototype.Cut = function (polygon, aSidePolygons, bSidePolygons, cutPolygons)\n\t{\n\t\tthis.Reset ();\n\t\t\n\t\tvar allVertexType = this.CalculateOriginalPolygonData (polygon);\n\t\tif (allVertexType !== null) {\n\t\t\tvar cloned = polygon.Clone ();\n\t\t\tif (allVertexType == JSM.CutVertexType.Left) {\n\t\t\t\taSidePolygons.push (cloned);\n\t\t\t} else if (allVertexType == JSM.CutVertexType.Right) {\n\t\t\t\tbSidePolygons.push (cloned);\n\t\t\t} else {\n\t\t\t\tcutPolygons.push (cloned);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCutPolygonData ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateEntryVertices ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCuttedPolygons (aSidePolygons, bSidePolygons)) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.Reset = function ()\n\t{\n\t\tthis.originalPolygon = null;\n\t\tthis.originalPolygonVertexTypes = null;\n\t\tthis.cutPolygon = null;\n\t\tthis.cutPolygonVertexTypes = null;\n\t\tthis.cutPolygonVertexDistances = null;\n\t\tthis.cutVertexIndices = null;\n\t\tthis.entryVertices = null;\n\t\tthis.entryVertexTypes = null;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateOriginalPolygonData = function (polygon)\n\t{\n\t\tthis.originalPolygon = polygon;\n\t\tthis.originalPolygonVertexTypes = [];\n\t\tvar aSideFound = false;\n\t\tvar bSideFound = false;\n\t\t\n\t\tvar i, vertex, type;\n\t\tfor (i = 0; i < this.originalPolygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\ttype = this.geometryInterface.getVertexSide (vertex);\n\t\t\tif (type == JSM.CutVertexType.Left) {\n\t\t\t\taSideFound = true;\n\t\t\t} else if (type == JSM.CutVertexType.Right) {\n\t\t\t\tbSideFound = true;\n\t\t\t}\n\t\t\tthis.originalPolygonVertexTypes.push (type);\n\t\t}\n\t\t\n\t\tif (aSideFound && bSideFound) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (aSideFound) {\n\t\t\treturn JSM.CutVertexType.Left;\n\t\t} else if (bSideFound) {\n\t\t\treturn JSM.CutVertexType.Right;\n\t\t}\n\t\t\n\t\treturn JSM.CutVertexType.Cut;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCutPolygonData = function ()\n\t{\n\t\tfunction IsIntersectionVertex (cutPolygonVertexTypes, originalType)\n\t\t{\n\t\t\tif (cutPolygonVertexTypes.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar prevType = cutPolygonVertexTypes[cutPolygonVertexTypes.length - 1];\n\t\t\tif (prevType == JSM.CutVertexType.Cut || originalType == JSM.CutVertexType.Cut) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn prevType != originalType;\n\t\t}\n\t\t\n\t\tfunction AddCutVertexToPolygon (polygonCutter, vertex, type)\n\t\t{\n\t\t\tpolygonCutter.cutPolygon.AddVertexCoord (vertex);\n\t\t\tpolygonCutter.cutPolygonVertexTypes.push (type);\n\t\t\tif (type == JSM.CutVertexType.Cut) {\n\t\t\t\tpolygonCutter.cutVertexIndices.push (polygonCutter.cutPolygonVertexTypes.length - 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddIntersectionVertex (polygonCutter, originalIndex)\n\t\t{\n\t\t\tvar prevIndex = polygonCutter.originalPolygon.GetPrevVertex (originalIndex);\n\t\t\tvar prevVertex = polygonCutter.originalPolygon.GetVertex (prevIndex);\n\t\t\tvar currVertex = polygonCutter.originalPolygon.GetVertex (originalIndex);\n\t\t\tvar intersection = polygonCutter.geometryInterface.getIntersectionVertex (prevVertex, currVertex);\n\t\t\tif (intersection === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tAddCutVertexToPolygon (polygonCutter, intersection, JSM.CutVertexType.Cut);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddOriginalVertex (polygonCutter, originalIndex, originalType)\n\t\t{\n\t\t\tvar vertex = polygonCutter.originalPolygon.GetVertex (originalIndex).Clone ();\n\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\n\t\t\tvar vertexCount = polygonCutter.originalPolygon.VertexCount ();\n\t\t\tvar prevType = polygonCutter.originalPolygonVertexTypes[JSM.PrevIndex (originalIndex, vertexCount)];\n\t\t\tvar nextType = polygonCutter.originalPolygonVertexTypes[JSM.NextIndex (originalIndex, vertexCount)];\n\t\t\tif (originalType == JSM.CutVertexType.Cut && prevType == nextType) {\n\t\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction SortCutVertices (cutPolygon, cutVertexIndices, cutPolygonVertexDistances)\n\t\t{\n\t\t\tif (cutVertexIndices.length < 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tJSM.BubbleSort (cutVertexIndices,\n\t\t\t\tfunction (a, b) {\n\t\t\t\t\tvar aDist = cutPolygonVertexDistances[a];\n\t\t\t\t\tvar bDist = cutPolygonVertexDistances[b];\n\t\t\t\t\treturn JSM.IsLower (aDist, bDist);\n\t\t\t\t},\n\t\t\t\tfunction (i, j) {\n\t\t\t\t\tJSM.SwapArrayValues (cutVertexIndices, i, j);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\treturn true;\n\t\t}\t\n\n\t\tthis.cutPolygon = this.geometryInterface.createPolygon ();\n\t\tthis.cutPolygonVertexTypes = [];\n\t\tthis.cutVertexIndices = [];\n\t\t\n\t\tvar vertexCount = this.originalPolygon.VertexCount ();\n\t\tvar i, lastVertex, originalIndex, originalType;\n\t\tfor (i = 0; i <= vertexCount; i++) {\n\t\t\tlastVertex = (i === vertexCount);\n\t\t\toriginalIndex = i;\n\t\t\tif (lastVertex) {\n\t\t\t\toriginalIndex = 0;\n\t\t\t}\n\t\t\t\n\t\t\toriginalType = this.originalPolygonVertexTypes[originalIndex];\n\t\t\tif (IsIntersectionVertex (this.cutPolygonVertexTypes, originalType)) {\n\t\t\t\tAddIntersectionVertex (this, originalIndex);\n\t\t\t}\n\t\t\t\n\t\t\tif (!lastVertex) {\n\t\t\t\tAddOriginalVertex (this, originalIndex, originalType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cutPolygonVertexDistances = this.geometryInterface.getVertexDistances (this.cutPolygon);\n\t\tif (!SortCutVertices (this.cutPolygon, this.cutVertexIndices, this.cutPolygonVertexDistances)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateEntryVertices = function ()\n\t{\n\t\tfunction GetEntryVertexType (cutPolygonVertexTypes, cutPolygonVertexDistances, currIndex)\n\t\t{\n\t\t\tvar currSideType = cutPolygonVertexTypes[currIndex];\n\t\t\tif (currSideType != JSM.CutVertexType.Cut) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tvar prevIndex = JSM.PrevIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar nextIndex = JSM.NextIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar prevSideType = cutPolygonVertexTypes[prevIndex];\n\t\t\tvar nextSideType = cutPolygonVertexTypes[nextIndex];\n\n\t\t\tvar currVertexDistance = cutPolygonVertexDistances[currIndex];\n\t\t\tvar prevVertexDistance = cutPolygonVertexDistances[prevIndex];\n\t\t\tvar nextVertexDistance = cutPolygonVertexDistances[nextIndex];\n\t\t\t\n\t\t\tif (prevSideType == JSM.CutVertexType.Right) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Left) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Cut) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\n\t\tthis.entryVertices = [];\n\t\tthis.entryVertexTypes = [];\n\t\tvar i, vertexIndex, vertexType;\n\t\tfor (i = 0; i < this.cutVertexIndices.length; i++) {\n\t\t\tvertexIndex = this.cutVertexIndices[i];\n\t\t\tvertexType = GetEntryVertexType (this.cutPolygonVertexTypes, this.cutPolygonVertexDistances, vertexIndex);\n\t\t\tif (vertexType !== 0) {\n\t\t\t\tthis.entryVertices.push (vertexIndex);\n\t\t\t\tthis.entryVertexTypes.push (vertexType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.entryVertices.length === 0 || this.entryVertices.length % 2 !== 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCuttedPolygons = function (aSidePolygons, bSidePolygons)\n\t{\n\t\tfunction AddOneSideCuttedPolygons (polygonCutter, aSidePolygons, bSidePolygons, reversed)\n\t\t{\n\t\t\tfunction AddEntryPairToArray (entryPairs, entryVertices, fromIndex, toIndex)\n\t\t\t{\n\t\t\t\tentryPairs[entryVertices[fromIndex]] = entryVertices[toIndex];\n\t\t\t\tentryPairs[entryVertices[toIndex]] = entryVertices[fromIndex];\n\t\t\t}\n\n\t\t\tfunction RemoveEntryPairFromArray (entryPairs, index)\n\t\t\t{\n\t\t\t\tentryPairs[entryPairs[index]] = -1;\n\t\t\t\tentryPairs[index] = -1;\n\t\t\t}\n\n\t\t\tfunction CreateEntryPairsArray (cutPolygon, entryVertices, entryVertexTypes)\n\t\t\t{\n\t\t\t\tfunction FindPairIndex (entryPairs, entryVertices, entryVertexTypes, startIndex)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = startIndex + 1; i < entryVertices.length; i++) {\n\t\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entryVertexTypes[startIndex] != entryVertexTypes[i]) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tvar entryPairs = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < cutPolygon.VertexCount (); i++) {\n\t\t\t\t\tentryPairs.push (-1);\n\t\t\t\t}\n\n\t\t\t\tvar pairIndex;\n\t\t\t\tfor (i = 0; i < entryVertices.length; i++) {\n\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpairIndex = FindPairIndex (entryPairs, entryVertices, entryVertexTypes, i);\n\t\t\t\t\tif (pairIndex == -1) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tAddEntryPairToArray (entryPairs, entryVertices, i, pairIndex);\n\t\t\t\t}\n\t\t\t\treturn entryPairs;\n\t\t\t}\n\t\t\t\n\t\t\tfunction GetNextVertex (currVertexIndex, cutPolygon, entryPairs)\n\t\t\t{\n\t\t\t\tif (entryPairs[currVertexIndex] != -1) {\n\t\t\t\t\tvar nextVertex = entryPairs[currVertexIndex];\n\t\t\t\t\tRemoveEntryPairFromArray (entryPairs, currVertexIndex);\n\t\t\t\t\treturn nextVertex;\n\t\t\t\t} else {\n\t\t\t\t\treturn JSM.NextIndex (currVertexIndex, cutPolygon.VertexCount ());\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tfunction AddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons)\n\t\t\t{\n\t\t\t\tfunction AddVertexIfNotDuplicated (polygon, vertex)\n\t\t\t\t{\n\t\t\t\t\tvar vertexCount = polygon.VertexCount ();\n\t\t\t\t\tif (vertexCount > 0 && polygon.GetVertex (vertexCount - 1).IsEqual (vertex)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpolygon.AddVertexCoord (vertex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar startVertexIndex = polygonCutter.entryVertices[currEntryVertex];\n\t\t\t\tif (entryPairs[startVertexIndex] !== -1) {\n\t\t\t\t\tvar currPolygon = polygonCutter.geometryInterface.createPolygon ();\n\t\t\t\t\tcurrPolygon.AddVertexCoord (polygonCutter.cutPolygon.GetVertex (startVertexIndex).Clone ());\n\t\t\t\t\tvar currVertexIndex = GetNextVertex (startVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\tvar polygonSide = null;\n\t\t\t\t\twhile (currVertexIndex != startVertexIndex) {\n\t\t\t\t\t\tif (polygonSide === null) {\n\t\t\t\t\t\t\tif (polygonCutter.cutPolygonVertexTypes[currVertexIndex] !== JSM.CutVertexType.Cut) {\n\t\t\t\t\t\t\t\tpolygonSide = polygonCutter.cutPolygonVertexTypes[currVertexIndex];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAddVertexIfNotDuplicated (currPolygon, polygonCutter.cutPolygon.GetVertex (currVertexIndex).Clone ());\n\t\t\t\t\t\tcurrVertexIndex = GetNextVertex (currVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\t}\n\t\t\t\t\tif (currPolygon.VertexCount () > 2) {\n\t\t\t\t\t\tif (polygonSide == JSM.CutVertexType.Left) {\n\t\t\t\t\t\t\taSidePolygons.push (currPolygon);\n\t\t\t\t\t\t} else if (polygonSide == JSM.CutVertexType.Right) {\n\t\t\t\t\t\t\tbSidePolygons.push (currPolygon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPairs = CreateEntryPairsArray (polygonCutter.cutPolygon, polygonCutter.entryVertices, polygonCutter.entryVertexTypes);\n\t\t\tif (entryPairs === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currEntryVertex = reversed ? polygonCutter.entryVertices.length - 1 : 0;\n\t\t\twhile (currEntryVertex >= 0 && currEntryVertex < polygonCutter.entryVertices.length) {\n\t\t\t\tAddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons);\n\t\t\t\tcurrEntryVertex = reversed ? currEntryVertex - 1 : currEntryVertex + 1;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, false)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, true)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CutPolygon2DWithLine\n\t* Description:\n\t*\tCuts a polygon with a line. The result array contains cutted\n\t*\tpolygons grouped by their position to the line.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tline {Line2D} the line\n\t*\tleftPolygons {Polygon2D[*]} (out) polygons on the left of the line\n\t*\trightPolygons {Polygon2D[*]} (out) polygons on the right of the line\n\t*\tcutPolygons {Polygon2D[*]} (out) polygons on the line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygon2DWithLine = function (polygon, line, leftPolygons, rightPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon2D ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = line.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordLinePosition2D.CoordAtLineLeft) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordLinePosition2D.CoordAtLineRight) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar edgeLine = new JSM.Line2D (currVertex, JSM.CoordSub2D (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lineLinePosition = line.LinePosition (edgeLine, intersection);\n\t\t\t\tif (lineLinePosition != JSM.LineLinePosition2D.LinesIntersectsOnePoint) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar origo = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar refLineStart = line.start.Clone ();\n\t\t\t\tvar refLineDir = line.direction.Clone ().Rotate (-Math.PI / 2.0, origo);\n\t\t\t\tvar refLine = new JSM.Line2D (refLineStart, refLineDir);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refLine.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, leftPolygons, rightPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: CutPolygonWithPlane\n\t* Description:\n\t*\tCuts a polygon with a plane. The result array contains cutted\n\t*\tpolygons grouped by their position to the plane.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tplane {Plane} the plane\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the plane\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the plane\n\t*\tcutPolygons {Polygon[*]} (out) polygons on the plane\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygonWithPlane = function (polygon, plane, frontPolygons, backPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = plane.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar line = new JSM.Line (currVertex, JSM.CoordSub (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tvar linePlanePosition = plane.LinePosition (line, intersection);\n\t\t\t\tif (linePlanePosition != JSM.LinePlanePosition.LineIntersectsPlane) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar polygonNormal = polygon.GetNormal ();\n\t\t\t\tvar planeNormal = new JSM.Vector (plane.a, plane.b, plane.c);\n\t\t\t\tvar refPlaneNormal = JSM.VectorCross (planeNormal, polygonNormal);\n\t\t\t\tvar refPlaneOrigin = polygon.GetVertex (0);\n\t\t\t\tvar refPlane = JSM.GetPlaneFromCoordAndDirection (refPlaneOrigin, refPlaneNormal);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refPlane.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, frontPolygons, backPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: SegmentPolygon2D\n\t* Description: Segments up a polygon along x and y axis.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\txSegments {integer} x segment number\n\t*\tySegments {integer} y segment number\n\t* Returns:\n\t*\t{Polygon[*]} result polygons\n\t*/\n\tJSM.SegmentPolygon2D = function (polygon, xSegments, ySegments)\n\t{\n\t\tfunction CutPolygonsOneDirection (inputPolygons, resultPolygons, segmentCount, segmentSize, startCoordinate, segmentDir, cutDir)\n\t\t{\n\t\t\tfunction CutPolygon (polygon, line, leftPolygons, rightPolygons)\n\t\t\t{\n\t\t\t\tvar left = [];\n\t\t\t\tvar right = [];\n\t\t\t\tvar cut = [];\n\t\t\t\tif (!JSM.CutPolygon2DWithLine (polygon, line, left, right, cut)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < left.length; i++) {\n\t\t\t\t\tleftPolygons.push (left[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < right.length; i++) {\n\t\t\t\t\trightPolygons.push (right[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar polygonsToProcess = inputPolygons;\n\t\t\tvar startCoord = startCoordinate.Clone ();\n\t\t\tvar i, j, line, newPolygonsToProcess;\n\t\t\tfor (i = 1; i < segmentCount; i++) {\n\t\t\t\tstartCoord.Offset (segmentDir, segmentSize);\n\t\t\t\tline = new JSM.Line2D (startCoord, cutDir);\n\t\t\t\tnewPolygonsToProcess = [];\n\t\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\t\tCutPolygon (polygonsToProcess[j], line, resultPolygons, newPolygonsToProcess);\n\t\t\t\t}\n\t\t\t\tpolygonsToProcess = newPolygonsToProcess;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\tresultPolygons.push (polygonsToProcess[j]);\n\t\t\t}\n\t\t}\n\n\t\tvar boundingBox = polygon.GetBoundingBox ();\n\t\tvar xSize = boundingBox.max.x - boundingBox.min.x;\n\t\tvar ySize = boundingBox.max.y - boundingBox.min.y;\n\t\tvar xSegmentSize = xSize / xSegments;\n\t\tvar ySegmentSize = ySize / ySegments;\n\n\t\tvar originalPolygons = [polygon];\n\t\tvar bottomLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.min.y);\n\t\tvar topLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.max.y);\n\n\t\tvar xCuttedPolygons = [];\n\t\tvar yCuttedPolygons = [];\n\t\tCutPolygonsOneDirection (originalPolygons, xCuttedPolygons, xSegments, xSegmentSize, bottomLeft, new JSM.Vector2D (1.0, 0.0), new JSM.Vector2D (0.0, 1.0));\n\t\tCutPolygonsOneDirection (xCuttedPolygons, yCuttedPolygons, ySegments, ySegmentSize, topLeft, new JSM.Vector2D (0.0, -1.0), new JSM.Vector2D (1.0, 0.0));\n\t\treturn yCuttedPolygons;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/triangulation',[\"../core/jsm\"],function(JSM){\n\tJSM.ConvertContourPolygonToPolygon2D = function (inputPolygon, vertexMap)\n\t{\n\t\tfunction AddResultVertex (resultPolygon, vertex, vertexMap, originalContour, originalVertex)\n\t\t{\n\t\t\tresultPolygon.AddVertexCoord (vertex);\n\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\tvertexMap.push ([originalContour, originalVertex]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)\n\t\t{\n\t\t\tfunction GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData)\n\t\t\t{\n\t\t\t\tfunction IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)\n\t\t\t\t{\n\t\t\t\t\tfunction SegmentIntersectsPolygon (polygon, segmentBeg, segmentEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sector = new JSM.Sector2D (segmentBeg, segmentEnd);\n\t\t\t\t\t\tvar position = polygon.SectorPosition (sector, -1, -1);\n\t\t\t\t\t\tif (position == JSM.SectorPolygonPosition2D.IntersectionOnePoint || position == JSM.SectorPolygonPosition2D.IntersectionCoincident) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SegmentIntersectsPolygon (resultPolygon, resultVertex, holeVertex)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i, hole;\n\t\t\t\t\tfor (i = 1; i < inputPolygon.ContourCount (); i++) {\n\t\t\t\t\t\tif (conversionData.addedHoles[i] !== undefined) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thole = inputPolygon.GetContour (i);\n\t\t\t\t\t\tif (SegmentIntersectsPolygon (hole, resultVertex, holeVertex)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction IsExistingEntryPosition (coord, conversionData)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < conversionData.entryPositions.length; i++) {\n\t\t\t\t\t\tif (coord.IsEqual (conversionData.entryPositions[i])) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar resultVertexIndex, holeVertexIndex, resultVertex, holeVertex;\n\t\t\t\tfor (resultVertexIndex = 0; resultVertexIndex < resultPolygon.VertexCount (); resultVertexIndex++) {\n\t\t\t\t\tfor (holeVertexIndex = 0; holeVertexIndex < holePolygon.VertexCount (); holeVertexIndex++) {\n\t\t\t\t\t\tresultVertex = resultPolygon.GetVertex (resultVertexIndex);\n\t\t\t\t\t\tholeVertex = holePolygon.GetVertex (holeVertexIndex);\n\t\t\t\t\t\tif (IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)) {\n\t\t\t\t\t\t\tif (IsExistingEntryPosition (resultVertex, conversionData) || IsExistingEntryPosition (holeVertex, conversionData)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconversionData.entryPositions.push (resultVertex.Clone ());\n\t\t\t\t\t\t\tconversionData.entryPositions.push (holeVertex.Clone ());\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tbeg : resultVertexIndex,\n\t\t\t\t\t\t\t\tend : holeVertexIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tfunction AddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap)\n\t\t\t{\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar mainContourBeg = entryPoint.beg;\n\t\t\t\tvar mainEntryVertex = resultPolygon.GetVertex (mainContourBeg).Clone ();\n\t\t\t\tresultPolygon.ShiftVertices (mainContourBeg + 1);\n\n\t\t\t\tvar mainEntryContourIndex = 0;\n\t\t\t\tvar mainEntryVertexIndex = 0;\n\t\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\t\tmainEntryContourIndex = vertexMap[mainContourBeg][0];\n\t\t\t\t\tmainEntryVertexIndex = vertexMap[mainContourBeg][1];\n\t\t\t\t\tJSM.ShiftArray (vertexMap, mainContourBeg + 1);\n\t\t\t\t}\n\n\t\t\t\tvar contourBeg = entryPoint.end;\n\t\t\t\tvar contourEnd = holePolygon.GetPrevVertex (contourBeg);\n\t\t\t\tholePolygon.EnumerateVertices (contourBeg, contourEnd, function (index) {\n\t\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (index).Clone (), vertexMap, holeIndex, index);\n\t\t\t\t});\n\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (contourBeg).Clone (), vertexMap, holeIndex, contourBeg);\n\t\t\t\tAddResultVertex (resultPolygon, mainEntryVertex, vertexMap, mainEntryContourIndex, mainEntryVertexIndex);\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPoint = GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData);\n\t\t\tif (entryPoint === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tvar contourCount = inputPolygon.ContourCount ();\n\t\tvar mainContour = inputPolygon.GetContour (0);\n\t\tvar resultPolygon = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < mainContour.VertexCount (); i++) {\n\t\t\tvertex = mainContour.GetVertex (i);\n\t\t\tAddResultVertex (resultPolygon, vertex.Clone (), vertexMap, 0, i);\n\t\t}\n\t\tif (contourCount == 1) {\n\t\t\treturn resultPolygon;\n\t\t}\n\t\t\n\t\tvar holeQueue = [];\n\t\tvar holeIndex;\n\t\tfor (holeIndex = 1; holeIndex < contourCount; holeIndex++) {\n\t\t\tholeQueue.push (holeIndex);\n\t\t}\n\t\t\n\t\tvar conversionData = {\n\t\t\taddedHoles : {},\n\t\t\tholeTryouts : {},\n\t\t\tentryPositions : []\n\t\t};\n\t\t\n\t\twhile (holeQueue.length > 0) {\n\t\t\tholeIndex = holeQueue.shift ();\n\t\t\tif (AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)) {\n\t\t\t\tconversionData.addedHoles[holeIndex] = true;\n\t\t\t} else {\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] === undefined) {\n\t\t\t\t\tconversionData.holeTryouts[holeIndex] = 0;\n\t\t\t\t}\n\t\t\t\tconversionData.holeTryouts[holeIndex] += 1;\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] > 10) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tholeQueue.push (holeIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn resultPolygon;\n\t};\n\n\tJSM.TriangulateConvexPolygon = function (polygon)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 1; i < polygon.VertexCount () - 1; i++) {\n\t\t\tresult.push ([0, i, i + 1]);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulateConcavePolygon2D = function (inputPolygon)\n\t{\n\t\tfunction GetInitialVertexMap (count)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tresult[i] = i;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction FindSplitDiagonal (polygon)\n\t\t{\n\t\t\tvar count = polygon.VertexCount ();\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (polygon.IsDiagonal (i, j)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tbeg : i,\n\t\t\t\t\t\t\tend : j\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction SplitPolygon (polygonData, diagonal)\n\t\t{\n\t\t\tfunction AddVertex (polygonData, resultData, index)\n\t\t\t{\n\t\t\t\tresultData.polygon.AddVertexCoord (polygonData.polygon.GetVertex (index));\n\t\t\t\tresultData.map.push (polygonData.map[index]);\n\t\t\t}\n\t\t\t\n\t\t\tvar resultData1 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\t\t\tvar resultData2 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\n\t\t\tvar beg, end;\n\t\t\t\n\t\t\tbeg = diagonal.beg;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.end);\n\t\t\tAddVertex (polygonData, resultData1, diagonal.end);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData1, index);\n\t\t\t});\n\n\t\t\tbeg = diagonal.end;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.beg);\n\t\t\tAddVertex (polygonData, resultData2, diagonal.beg);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData2, index);\n\t\t\t});\n\t\t\t\n\t\t\treturn {\n\t\t\t\tresultData1 : resultData1,\n\t\t\t\tresultData2 : resultData2\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar polygonStack = [];\n\t\tvar count = inputPolygon.VertexCount ();\n\t\tvar inputMap = GetInitialVertexMap (count);\n\t\tpolygonStack.push ({\n\t\t\tpolygon : inputPolygon,\n\t\t\tmap : inputMap\n\t\t});\n\t\t\n\t\tvar result = [];\n\t\tvar polygonData, vertexCount, diagonal, resultData;\n\t\twhile (polygonStack.length > 0) {\n\t\t\tpolygonData = polygonStack.pop ();\n\t\t\tvertexCount = polygonData.polygon.VertexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tresult.push (polygonData.map);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiagonal = FindSplitDiagonal (polygonData.polygon);\n\t\t\tif (diagonal === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresultData = SplitPolygon (polygonData, diagonal);\n\t\t\tpolygonStack.push (resultData.resultData1);\n\t\t\tpolygonStack.push (resultData.resultData2);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulatePolygon2D = function (polygon)\n\t{\n\t\tif (polygon === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar vertexCount = polygon.VertexCount ();\n\t\tif (vertexCount < 3) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (vertexCount == 3) {\n\t\t\treturn [[0, 1, 2]];\n\t\t}\n\t\t\n\t\tvar complexity = polygon.GetComplexity ();\n\t\tif (complexity === JSM.Complexity.Invalid) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (complexity == JSM.Complexity.Convex) {\n\t\t\treturn JSM.TriangulateConvexPolygon (polygon);\n\t\t}\n\t\t\n\t\treturn JSM.TriangulateConcavePolygon2D (polygon);\n\t};\n\n\t/**\n\t* Function: TriangulatePolygon\n\t* Description:\n\t*\tTriangulates a polygon. The result defines triangles as an\n\t*\tarray of arrays with three original vertex indices.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t* Returns:\n\t*\t{integer[3][*]} the result\n\t*/\n\tJSM.TriangulatePolygon = function (polygon)\n\t{\n\t\tvar polygon2D = polygon.ToPolygon2D ();\n\t\treturn JSM.TriangulatePolygon2D (polygon2D);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/octree',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: TraverseOctreeNodes\n\t* Description:\n\t*\tTraverses the nodes of the tree, and calls the given callback when a node found. The return value\n\t*\tof the callback determines if we need to continue traverse along that given node.\n\t* Parameters:\n\t*\toctree {Octree} the octree\n\t*\tnodeFound {function} the callback\n\t*/\n\tJSM.TraverseOctreeNodes = function (octree, nodeFound)\n\t{\n\t\tfunction TraverseNode (node, nodeFound)\n\t\t{\n\t\t\tif (!nodeFound (node)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (node.children === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, child;\n\t\t\tfor (i = 0; i < node.children.length; i++) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tTraverseNode (child, nodeFound);\n\t\t\t}\n\t\t}\n\n\t\tTraverseNode (octree.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: CreateOctreeChildNodes\n\t* Description:\n\t*\tCreate child nodes for an octree node. It calls a callback function\n\t*\twhich should create a new node element for the octree.\n\t* Parameters:\n\t*\toriginalBox {Box} the box of the original node\n\t*\tcreateNodeCallback {function} the callback function\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.CreateOctreeChildNodes = function (originalBox, createNodeCallback)\n\t{\n\t\tfunction CreateNode (originalBox, createNodeCallback, dirX, dirY, dirZ)\n\t\t{\n\t\t\tvar size = originalBox.GetSize ().Clone ();\n\t\t\tsize.MultiplyScalar (0.5);\n\t\t\tvar min = new JSM.Coord (\n\t\t\t\toriginalBox.min.x + dirX * size.x,\n\t\t\t\toriginalBox.min.y + dirY * size.y,\n\t\t\t\toriginalBox.min.z + dirZ * size.z\n\t\t\t);\n\t\t\tvar max = JSM.CoordAdd (min, size);\n\t\t\tvar box = new JSM.Box (min, max);\n\t\t\treturn createNodeCallback (box);\n\t\t}\n\n\t\tvar size = originalBox.GetSize ();\n\t\tif (JSM.IsZero (size.x) && JSM.IsZero (size.y) && JSM.IsZero (size.z)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar result = [\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 0.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 0.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 1.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 1.0, 0.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 0.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 0.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 1.0, 1.0, 1.0),\n\t\t\tCreateNode (originalBox, createNodeCallback, 0.0, 1.0, 1.0),\n\t\t];\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: Octree\n\t* Description: Defines an octree. The octree contains each coordinate only once.\n\t* Parameters:\n\t*\tbox {Box} bounding box\n\t*\tmaxCoordNumInNodes {integer} maximum number of coordinates in a node\n\t*/\n\tJSM.Octree = function (box, maxCoordNumInNodes)\n\t{\n\t\tthis.coords = [];\n\t\tthis.root = this.CreateNewNode (null, box);\n\t\tthis.maxCoordNumInNodes = maxCoordNumInNodes;\n\t\tif (this.maxCoordNumInNodes === undefined || this.maxCoordNumInNodes === null || this.maxCoordNumInNodes === 0) {\n\t\t\tthis.maxCoordNumInNodes = 50;\n\t\t}\n\t};\n\n\t/**\n\t* Function: Octree.AddCoord\n\t* Description:\n\t*\tAdds a coordinate to the octree. The return value is the stored index of the coordinate.\n\t*\tIf the coordinate was already in the octree, it returns the existing index.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.AddCoord = function (coord)\n\t{\n\t\treturn this.AddCoordToNode (coord, this.root);\n\t};\n\n\t/**\n\t* Function: Octree.FindCoord\n\t* Description:\n\t*\tFinds a coordinate in the octree, and returns the stored index of it.\n\t*\tThe return value is -1 if the coordinate does not exist.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.FindCoord = function (coord)\n\t{\n\t\tvar node = this.FindNodeForCoord (coord, this.root);\n\t\tif (node === null) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this.FindCoordInNode (coord, node);\n\t};\n\n\t/**\n\t* Function: Octree.FindCoordInNode\n\t* Description: Finds a coordinate in a node.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnode {object} the node\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.FindCoordInNode = function (coord, node)\n\t{\n\t\tvar i, current;\n\t\tfor (i = 0; i < node.coords.length; i++) {\n\t\t\tcurrent = node.coords[i];\n\t\t\tif (coord.IsEqual (this.coords[current])) {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: Octree.AddCoordToNode\n\t* Description: Adds a coordinate to a node.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\troot {object} the root node\n\t* Returns:\n\t*\t{integer} the stored index of the coordinate\n\t*/\n\tJSM.Octree.prototype.AddCoordToNode = function (coord, root)\n\t{\n\t\tvar node = this.FindNodeForCoord (coord, root);\n\t\tif (node === null) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tvar found = this.FindCoordInNode (coord, node);\n\t\tif (found != -1) {\t\n\t\t\treturn found;\n\t\t}\n\t\t\n\t\tif (node.coords.length >= this.maxCoordNumInNodes) {\n\t\t\tif (this.SplitNode (node)) {\n\t\t\t\treturn this.AddCoordToNode (coord, node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar index = this.coords.length;\n\t\tthis.coords.push (coord);\n\t\tnode.coords.push (index);\n\t\treturn index;\n\t};\n\n\t/**\n\t* Function: Octree.FindNodeForCoord\n\t* Description: Finds a node for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnode {object} the starting node\n\t* Returns:\n\t*\t{object} the found node\n\t*/\n\tJSM.Octree.prototype.FindNodeForCoord = function (coord, node)\n\t{\n\t\tif (node.children === null) {\n\t\t\treturn node;\n\t\t}\n\t\t\n\t\tvar center = node.box.GetCenter ();\n\t\tvar xGreater = coord.x > center.x;\n\t\tvar yGreater = coord.y > center.y;\n\t\tvar zGreater = coord.z > center.z;\n\t\t\n\t\tif (!xGreater && !yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[0]);\n\t\t} else if (xGreater && !yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[1]);\n\t\t} else if (xGreater && yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[2]);\n\t\t} else if (!xGreater && yGreater && !zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[3]);\n\t\t} else if (!xGreater && !yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[4]);\n\t\t} else if (xGreater && !yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[5]);\n\t\t} else if (xGreater && yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[6]);\n\t\t} else if (!xGreater && yGreater && zGreater) {\n\t\t\treturn this.FindNodeForCoord (coord, node.children[7]);\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\n\t/**\n\t* Function: Octree.SplitNode\n\t* Description: Splits a node to subnodes.\n\t* Parameters:\n\t*\tnode {object} the node\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.Octree.prototype.SplitNode = function (node)\n\t{\n\t\tvar myThis = this;\n\t\tvar children = JSM.CreateOctreeChildNodes (node.box, function (nodeBox) {\n\t\t\treturn myThis.CreateNewNode (node, nodeBox);\n\t\t});\n\t\t\n\t\tif (children === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tnode.children = children;\n\t\tvar nodeCoords = node.coords;\n\t\tnode.coords = [];\n\t\t\n\t\tvar i, newNode;\n\t\tfor (i = 0; i < nodeCoords.length; i++) {\n\t\t\tnewNode = this.FindNodeForCoord (this.coords[nodeCoords[i]], node);\n\t\t\tnewNode.coords.push (nodeCoords[i]);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Octree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Parameters:\n\t*\tparent {object} the parent node\n\t*\tbox {Box} the box of the node\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.Octree.prototype.CreateNewNode = function (parent, box)\n\t{\n\t\tvar newNode = {\n\t\t\tparent : parent,\n\t\t\tbox : box,\n\t\t\tcoords : [],\n\t\t\tchildren : null\n\t\t};\n\t\treturn newNode;\t\n\t};\n\n\t/**\n\t* Class: TriangleOctree\n\t* Description:\n\t*\tDefines an octree which stores triangles. Every triangle is placed in\n\t*\tthe smallest possible node which contains all of its vertices.\n\t* Parameters:\n\t*\tbox {Box} bounding box\n\t*/\n\tJSM.TriangleOctree = function (box)\n\t{\n\t\tthis.root = this.CreateNewNode (null, box);\n\t};\n\n\t/**\n\t* Function: TriangleOctree.AddTriangle\n\t* Description: Adds a triangle to the octree.\n\t* Parameters:\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t*\tuserData {anything} user data for the triangle\n\t*/\n\tJSM.TriangleOctree.prototype.AddTriangle = function (v0, v1, v2, userData)\n\t{\n\t\treturn this.AddTriangleToNode (v0, v1, v2, this.root, userData);\n\t};\n\n\t/**\n\t* Function: TriangleOctree.AddTriangleToNode\n\t* Description: Adds a coordinate to a node.\n\t* Parameters:\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t*\troot {object} the root node\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.TriangleOctree.prototype.AddTriangleToNode = function (v0, v1, v2, root, userData)\n\t{\n\t\tfunction IsTriangleInNode (v0, v1, v2, node)\n\t\t{\n\t\t\treturn node.box.IsCoordInside (v0) && node.box.IsCoordInside (v1) && node.box.IsCoordInside (v2);\n\t\t}\n\t\t\n\t\tif (!IsTriangleInNode (v0, v1, v2, root)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (root.children === null) {\n\t\t\tvar myThis = this;\n\t\t\troot.children = JSM.CreateOctreeChildNodes (root.box, function (nodeBox) {\n\t\t\t\treturn myThis.CreateNewNode (root, nodeBox);\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (root.children !== null) {\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < root.children.length; i++) {\n\t\t\t\tnode = root.children[i];\n\t\t\t\tif (this.AddTriangleToNode (v0, v1, v2, node, userData)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\troot.triangles.push ({\n\t\t\tv0 : v0,\n\t\t\tv1 : v1,\n\t\t\tv2 : v2,\n\t\t\tuserData : userData\n\t\t});\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TriangleOctree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Parameters:\n\t*\tparent {object} the parent node\n\t*\tbox {Box} the box of the node\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleOctree.prototype.CreateNewNode = function (parent, box)\n\t{\n\t\tvar newNode = {\n\t\t\tparent : parent,\n\t\t\tbox : box,\n\t\t\ttriangles : [],\n\t\t\tchildren : null\n\t\t};\n\t\treturn newNode;\t\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/bsptree',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: BSPTree\n\t* Description: Defines a BSP tree.\n\t*/\n\tJSM.BSPTree = function ()\n\t{\n\t\tthis.root = null;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygon\n\t* Description: Adds a polygon to the tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygon = function (polygon, userData)\n\t{\n\t\tif (this.root === null) {\n\t\t\tthis.root = this.CreateNewNode ();\n\t\t}\n\t\t\n\t\treturn this.AddPolygonToNode (this.root, polygon, userData);\n\t};\n\n\t/**\n\t* Function: BSPTree.Traverse\n\t* Description: Traverses the tree and calls a function on node found.\n\t* Parameters:\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.Traverse = function (nodeFound)\n\t{\n\t\tthis.TraverseNode (this.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: BSPTree.TraverseNode\n\t* Description: Traverses a node and its children and calls a function on node found.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.TraverseNode = function (node, nodeFound)\n\t{\n\t\tif (node !== null) {\n\t\t\tnodeFound (node);\n\t\t\tthis.TraverseNode (node.inside, nodeFound);\n\t\t\tthis.TraverseNode (node.outside, nodeFound);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Returns the nodes as an array.\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.BSPTree.prototype.GetNodes = function ()\n\t{\n\t\tvar result = [];\n\t\tthis.Traverse (function (node) {\n\t\t\tresult.push (node);\n\t\t});\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Count nodes.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BSPTree.prototype.NodeCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tthis.Traverse (function () {\n\t\t\tcount = count + 1;\n\t\t});\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygonToNode\n\t* Description: Adds a polygon to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygonToNode = function (node, polygon, userData)\n\t{\n\t\tif (polygon.VertexCount () < 3) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar normal;\n\t\tif (node.polygon === null) {\n\t\t\tnormal = polygon.GetNormal ();\n\t\t\tvar plane = JSM.GetPlaneFromCoordAndDirection (polygon.GetVertex (0), normal);\n\t\t\tnode.polygon = polygon;\n\t\t\tif (userData !== undefined) {\n\t\t\t\tnode.userData = userData;\n\t\t\t}\n\t\t\tnode.plane = plane;\n\t\t} else {\n\t\t\tvar backPolygons = [];\n\t\t\tvar frontPolygons = [];\n\t\t\tvar planePolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, frontPolygons, backPolygons, planePolygons);\n\t\t\tif (cutSucceeded) {\n\t\t\t\tif (backPolygons.length > 0) {\n\t\t\t\t\tthis.AddInsidePolygonsToNode (node, backPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (frontPolygons.length > 0) {\n\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, frontPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (planePolygons.length > 0) {\n\t\t\t\t\tnormal = polygon.GetNormal ();\n\t\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\t\tthis.AddInsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddInsidePolygonsToNode\n\t* Description: Adds inside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddInsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.inside === null) {\n\t\t\tnode.inside = this.CreateNewNode ();\n\t\t\tnode.inside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.inside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.AddOutsidePolygonsToNode\n\t* Description: Adds outside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddOutsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.outside === null) {\n\t\t\tnode.outside = this.CreateNewNode ();\n\t\t\tnode.outside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.outside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.BSPTree.prototype.CreateNewNode = function ()\n\t{\n\t\tvar node = {\n\t\t\tpolygon : null,\n\t\t\tuserData : null,\n\t\t\tplane : null,\n\t\t\tparent : null,\n\t\t\tinside : null,\n\t\t\toutside : null\n\t\t};\n\t\treturn node;\n\t};\n\n\t/**\n\t* Function: ClipPolygonWithBSPTree\n\t* Description: Clips a polygon with a created BSP tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the tree\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the tree\n\t*\tplanarFrontPolygons {Polygon[*]} (out) polygons on the tree looks front\n\t*\tplanarBackPolygons {Polygon[*]} (out) polygons on the tree looks back\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ClipPolygonWithBSPTree = function (polygon, bspTree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t{\n\t\tfunction CutPolygonWithNode (polygon, node, isPlanar)\n\t\t{\n\t\t\tif (node === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar cutBackPolygons = [];\n\t\t\tvar cutFrontPolygons = [];\n\t\t\tvar cutPlanarPolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, cutFrontPolygons, cutBackPolygons, cutPlanarPolygons);\n\t\t\tif (!cutSucceeded) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cutBackPolygons.length > 0) {\n\t\t\t\tAddInsidePolygons (node, cutBackPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutFrontPolygons.length > 0) {\n\t\t\t\tAddOutsidePolygons (node, cutFrontPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutPlanarPolygons.length > 0) {\n\t\t\t\tvar normal = polygon.GetNormal ();\n\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\tAddInsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t} else {\n\t\t\t\t\tAddOutsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction CutPolygonsWithNode (polygons, node, isPlanar)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tCutPolygonWithNode (polygons[i], node, isPlanar);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonsToArray (polygons, polygonArray)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tpolygonArray.push (polygons[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddInsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.inside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.inside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarBackPolygons : backPolygons);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddOutsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.outside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.outside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarFrontPolygons : frontPolygons);\n\t\t\t}\n\t\t}\n\n\t\tCutPolygonWithNode (polygon, bspTree.root, false);\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraverseBSPTreeForEyePosition\n\t* Description: Traverses a BSP tree for a given eye position.\n\t* Parameters:\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\teyePosition {Coord} the eye position\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.TraverseBSPTreeForEyePosition = function (bspTree, eyePosition, nodeFound)\n\t{\n\t\tfunction TraverseNode (node)\n\t\t{\n\t\t\tif (node !== null) {\n\t\t\t\tvar coordPlanePosition = node.plane.CoordPosition (eyePosition);\n\t\t\t\tif (coordPlanePosition == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t} else if (coordPlanePosition == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t} else {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTraverseNode (bspTree.root);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/curves',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateCubicBezierCurve\n\t* Description: Generates a bezier curve from the given points.\n\t* Parameters:\n\t*\tp0 {Coord2D} point 1\n\t*\tp1 {Coord2D} point 2\n\t*\tp2 {Coord2D} point 3\n\t*\tp3 {Coord2D} point 4\n\t*\tsegmentation {integer} the segmentation of the result curve\n\t* Returns:\n\t*\t{Coord2D[]} the result\n\t*/\n\tJSM.GenerateCubicBezierCurve = function (p0, p1, p2, p3, segmentation)\n\t{\n\t\tfunction GetCubicBezierPoint (p0, p1, p2, p3, t)\n\t\t{\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\tvar invT = 1.0 - t;\n\t\t\tvar invT2 = invT * invT;\n\t\t\tvar invT3 = invT2 * invT;\n\t\t\tvar x = invT3 * p0.x + 3.0 * invT2 * t * p1.x  + 3.0 * invT * t2 * p2.x + t3 * p3.x;\n\t\t\tvar y = invT3 * p0.y + 3.0 * invT2 * t * p1.y  + 3.0 * invT * t2 * p2.y + t3 * p3.y;\n\t\t\treturn new JSM.Coord2D (x, y);\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\tvar s = 1.0 / segmentation;\n\t\tvar i, coord;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tcoord = GetCubicBezierPoint (p0, p1, p2, p3, i * s);\n\t\t\tresult.push (coord);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BernsteinPolynomial\n\t* Description: Calculates the value of the Bernstein polynomial.\n\t* Parameters:\n\t*\tk {integer} the start index\n\t*\tn {integer} the end index\n\t*\tx {number} the value\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.BernsteinPolynomial = function (k, n, x)\n\t{\n\t\tfunction BinomialCoefficient (n, k)\n\t\t{\n\t\t\tvar result = 1.0;\n\t\t\tvar min = JSM.Minimum (k, n - k);\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < min; i++) {\n\t\t\t\tresult = result * (n - i);\n\t\t\t\tresult = result / (i + 1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar coefficient = BinomialCoefficient (n, k);\n\t\treturn coefficient * Math.pow (x, k) * Math.pow (1.0 - x, n - k);\n\t};\n\n\t/**\n\t* Function: GenerateBezierCurve\n\t* Description: Generates a bezier curve from the given points.\n\t* Parameters:\n\t*\tpoints {Coord2D[]} the points\n\t*\tsegmentation {integer} the segmentation of the result curve\n\t* Returns:\n\t*\t{Coord2D[]} the result\n\t*/\n\tJSM.GenerateBezierCurve = function (points, segmentation)\n\t{\n\t\tvar result = [];\n\t\tvar n = points.length - 1;\n\t\tvar s = 1.0 / segmentation;\n\t\t\n\t\tvar i, j, t, point, bernstein, coord;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tt = i * s;\n\t\t\tcoord = new JSM.Coord2D (0.0, 0.0);\n\t\t\tfor (j = 0; j <= n; j++) {\n\t\t\t\tpoint = points[j];\n\t\t\t\tbernstein = JSM.BernsteinPolynomial (j, n, t);\n\t\t\t\tcoord.x += point.x * bernstein;\n\t\t\t\tcoord.y += point.y * bernstein;\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/utilities',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GetGaussianCParameter\n\t* Description:\n\t*\tCalculates the gaussian functions c parameter which can be used\n\t*\tfor the gaussian function to reach epsilon at a given value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tepsilon {number} the epsilon value\n\t* Returns:\n\t*\t{number} the c parameter of the function\n\t*/\n\tJSM.GetGaussianCParameter = function (x, a, b, epsilon)\n\t{\n\t\treturn Math.sqrt (-(Math.pow (x - b, 2.0) / (2.0 * Math.log (epsilon / Math.abs (a)))));\n\t};\n\n\t/**\n\t* Function: GetGaussianValue\n\t* Description: Calculates the gaussian functions value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tc {number} the c parameter of the function\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetGaussianValue = function (x, a, b, c)\n\t{\n\t\treturn a * Math.exp (-(Math.pow (x - b, 2.0) / (2.0 * Math.pow (c, 2.0))));\n\t};\n\n\t/**\n\t* Function: GenerateCirclePoints\n\t* Description: Generates coordinates on circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {number} the segmentation of the circle\n\t*\torigo {Coord} the origo of the circle\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.GenerateCirclePoints = function (radius, segmentation, origo)\n\t{\n\t\tvar result = [];\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcoord = JSM.CylindricalToCartesian (radius, 0.0, theta);\n\t\t\tif (origo !== undefined && origo !== null) {\n\t\t\t\tcoord = JSM.CoordAdd (coord, origo);\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetRuledMesh\n\t* Description:\n\t*\tGenerates ruled mesh coordinates and polygons between two coordinate array.\n\t*\tThe two arrays should have the same length. The result is a coordinate array\n\t*\tand a polygon array which contains indices for vertices.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tsegmentation {number} the segmentation of the mesh\n\t*\tvertices {Coord[*]} (out) the vertices of the mesh\n\t*\tpolygons {integer[*][4]} (out) the polygons of the mesh\n\t*/\n\tJSM.GetRuledMesh = function (aCoords, bCoords, segmentation, vertices, polygons)\n\t{\n\t\tif (aCoords.length !== bCoords.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lineSegmentation = aCoords.length - 1;\n\t\tvar meshSegmentation = segmentation;\n\t\tvar directions = [];\n\t\tvar lengths = [];\n\n\t\tvar i, j;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tdirections.push (JSM.CoordSub (bCoords[i], aCoords[i]));\n\t\t\tlengths.push (aCoords[i].DistanceTo (bCoords[i]));\n\t\t}\n\n\t\tvar step, coord;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tstep = lengths[i] / meshSegmentation;\n\t\t\tfor (j = 0; j <= meshSegmentation; j++) {\n\t\t\t\tcoord = aCoords[i].Clone ().Offset (directions[i], step * j);\n\t\t\t\tvertices.push (coord);\n\t\t\t}\n\t\t}\n\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tfor (j = 0; j < meshSegmentation; j++) {\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + meshSegmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + 1;\n\t\t\t\tnext = current + meshSegmentation + 1;\n\t\t\t\tntop = next + 1;\n\n\t\t\t\tpolygon = [current, next, ntop, top];\n\t\t\t\tpolygons.push (polygon);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/ray',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Ray\n\t* Description: Represents a Ray.\n\t* Parameters:\n\t*\torigin {Coord} the starting point of the ray\n\t*\tdirection {Vector} the direction of the ray\n\t*\tlength {number} the length of the ray, null means infinite ray\n\t*/\n\tJSM.Ray = function (origin, direction, length)\n\t{\n\t\tthis.origin = origin;\n\t\tthis.direction = direction.Normalize ();\n\t\tthis.length = length;\n\t};\n\n\t/**\n\t* Function: Ray.Set\n\t* Description: Sets the ray.\n\t* Parameters:\n\t*\torigin {Coord} the starting point of the ray\n\t*\tdirection {Vector} the direction of the ray\n\t*\tlength {number} the length of the ray, null means infinite ray\n\t*/\n\tJSM.Ray.prototype.Set = function (origin, direction, length)\n\t{\n\t\tthis.origin = origin;\n\t\tthis.direction = direction.Normalize ();\n\t\tthis.length = length;\n\t};\n\n\t/**\n\t* Function: Ray.GetOrigin\n\t* Description: Returns the origin of the ray.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Ray.prototype.GetOrigin = function ()\n\t{\n\t\treturn this.origin;\n\t};\n\n\t/**\n\t* Function: Ray.GetDirection\n\t* Description: Returns the direction of the ray.\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.Ray.prototype.GetDirection = function ()\n\t{\n\t\treturn this.direction;\n\t};\n\n\t/**\n\t* Function: Ray.IsLengthReached\n\t* Description:\n\t*\tReturns if the given length is greater than the length of the ray.\n\t*\tAlways return false in case of infinite ray.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Ray.prototype.IsLengthReached = function (length)\n\t{\n\t\tif (this.length === undefined || this.length === null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn JSM.IsGreater (length, this.length);\n\t};\n\n\t/**\n\t* Function: Ray.Clone\n\t* Description: Clones the ray.\n\t* Returns:\n\t*\t{Ray} a cloned instance\n\t*/\n\tJSM.Ray.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.Ray (this.origin.Clone (), this.direction.Clone (), this.length);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/geometry/path',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Path2D\n\t* Description: Helper class for building polygons\n\t* Parameters:\n\t*\tsettings {object} path settings\n\t*/\n\tJSM.Path2D = function (settings)\n\t{\n\t\tthis.settings = {\n\t\t\tsegmentation : 10,\n\t\t\toffset : new JSM.Vector2D (0.0, 0.0),\n\t\t\tscale : new JSM.Coord2D (1.0, 1.0)\n\t\t};\n\t\tJSM.CopyObjectProperties (settings, this.settings, true);\n\t\t\n\t\tthis.position = new JSM.Coord2D (0.0, 0.0);\n\t\tthis.positionAdded = false;\n\t\tthis.polygons = [];\n\t\tthis.currentPolygon = null;\n\t};\n\n\t/**\n\t* Function: Path2D.MoveTo\n\t* Description: Moves the current position to the given position.\n\t* Parameters:\n\t*\tx {number} new x position\n\t*\ty {number} new y position\n\t*/\n\tJSM.Path2D.prototype.MoveTo = function (x, y)\n\t{\n\t\tthis.Close ();\n\t\tthis.position.Set (x, y);\n\t\tthis.positionAdded = false;\n\t};\n\n\t/**\n\t* Function: Path2D.LineTo\n\t* Description: Draws a line from current position to the given position.\n\t* Parameters:\n\t*\tx {number} line end x position\n\t*\ty {number} line end y position\n\t*/\n\tJSM.Path2D.prototype.LineTo = function (x, y)\n\t{\n\t\tif (!this.positionAdded) {\n\t\t\tthis.AddPolygonPoint (this.position.x, this.position.y);\n\t\t}\n\t\tthis.AddPolygonPoint (x, y);\n\t};\n\n\t/**\n\t* Function: Path2D.CubicBezierTo\n\t* Description: Draws a cubic bezier curve from the current position to the given position.\n\t* Parameters:\n\t*\tx {number} curve end x position\n\t*\ty {number} curve end y position\n\t*\tcp1x {number} first control point x position\n\t*\tcp1y {number} first control point y position\n\t*\tcp2x {number} second control point x position\n\t*\tcp2y {number} second control point y position\n\t*/\n\tJSM.Path2D.prototype.CubicBezierTo = function (x, y, cp1x, cp1y, cp2x, cp2y)\n\t{\n\t\tvar bezierPoints = JSM.GenerateCubicBezierCurve (\n\t\t\tnew JSM.Coord2D (this.position.x, this.position.y),\n\t\t\tnew JSM.Coord2D (cp1x, cp1y),\n\t\t\tnew JSM.Coord2D (cp2x, cp2y),\n\t\t\tnew JSM.Coord2D (x, y),\n\t\t\tthis.settings.segmentation\n\t\t);\n\t\tvar i;\n\t\tfor (i = 1; i < bezierPoints.length; i++) {\n\t\t\tthis.LineTo (bezierPoints[i].x, bezierPoints[i].y);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Path2D.Close\n\t* Description: Closes the current polygon.\n\t*/\n\tJSM.Path2D.prototype.Close = function ()\n\t{\n\t\tfunction CheckAndCorrectPolygon (polygon)\n\t\t{\n\t\t\tif (polygon.VertexCount () === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (polygon.GetVertex (0).IsEqual (polygon.GetVertex (polygon.VertexCount () - 1))) {\n\t\t\t\tpolygon.RemoveVertex (polygon.VertexCount () - 1);\n\t\t\t}\n\t\t\tif (polygon.VertexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction FindBasePolygon (polygons, polygon)\n\t\t{\n\t\t\tfunction IsBasePolygon (basePolygon, polygon)\n\t\t\t{\n\t\t\t\tbaseOrientation = baseContour.GetOrientation ();\n\t\t\t\tpolygonOrientation = polygon.GetOrientation ();\n\t\t\t\tif (baseOrientation !== polygonOrientation) {\n\t\t\t\t\tvar firstVertex = polygon.GetVertex (0);\n\t\t\t\t\tvar firstVertexPosition = baseContour.CoordPosition (firstVertex);\n\t\t\t\t\tif (firstVertexPosition == JSM.CoordPolygonPosition2D.Inside) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, baseContour, baseOrientation, polygonOrientation;\n\t\t\tfor (i = polygons.length - 1; i >= 0; i--) {\n\t\t\t\tbaseContour = polygons[i].GetContour (0);\n\t\t\t\tif (IsBasePolygon (baseContour, polygon)) {\n\t\t\t\t\treturn polygons[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.currentPolygon !== null) {\n\t\t\tif (CheckAndCorrectPolygon (this.currentPolygon)) {\n\t\t\t\tvar basePolygon = FindBasePolygon (this.polygons, this.currentPolygon);\n\t\t\t\tif (basePolygon === null) {\n\t\t\t\t\tvar contourPolygon = new JSM.ContourPolygon2D ();\n\t\t\t\t\tcontourPolygon.AddContour (this.currentPolygon);\n\t\t\t\t\tthis.polygons.push (contourPolygon);\n\t\t\t\t} else {\n\t\t\t\t\tbasePolygon.AddContour (this.currentPolygon);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.currentPolygon = null;\n\t\t}\n\t};\t\t\t\n\n\t/**\n\t* Function: Path2D.PolygonCount\n\t* Description: Returns the polygon count of the path.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Path2D.prototype.PolygonCount = function ()\n\t{\n\t\treturn this.polygons.length;\n\t};\n\n\t/**\n\t* Function: Path2D.GetPolygon\n\t* Description: Returns the polygons from the path at the given index.\n\t* Parameters:\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{ContourPolygon2D} the result\n\t*/\n\tJSM.Path2D.prototype.GetPolygon = function (index)\n\t{\n\t\treturn this.polygons[index];\n\t};\n\n\t/**\n\t* Function: Path2D.GetPolygons\n\t* Description: Returns the polygons from the path.\n\t* Returns:\n\t*\t{ContourPolygon2D[*]} the result\n\t*/\n\tJSM.Path2D.prototype.GetPolygons = function ()\n\t{\n\t\treturn this.polygons;\n\t};\n\n\t/**\n\t* Function: Path2D.GetCurrentPolygon\n\t* Description: Returns the current polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.Path2D.prototype.GetCurrentPolygon = function ()\n\t{\n\t\tif (this.currentPolygon === null) {\n\t\t\tthis.currentPolygon = new JSM.Polygon2D ();\n\t\t}\n\t\treturn this.currentPolygon;\n\t};\t\t\n\n\t/**\n\t* Function: Path2D.AddPolygonPoint\n\t* Description: Adds a point to the current polygon.\n\t* Parameters:\n\t*\tx {number} the x position of the point\n\t*\ty {number} the y position of the point\n\t*/\n\tJSM.Path2D.prototype.AddPolygonPoint = function (x, y)\n\t{\n\t\tvar polygon = this.GetCurrentPolygon ();\n\t\tvar polygonX = this.settings.offset.x + x * this.settings.scale.x;\n\t\tvar polygonY = this.settings.offset.y + y * this.settings.scale.y;\n\t\tpolygon.AddVertex (polygonX, polygonY);\n\t\tthis.position.Set (x, y);\n\t\tthis.positionAdded = true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/color',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: HexColorToRGBComponents\n\t* Description: Converts hex color strings to RGB components.\n\t* Parameters:\n\t*\thexColor {string} the hex color\n\t* Returns:\n\t*\t{integer[3]} the RGB components\n\t*/\n\tJSM.HexColorToRGBComponents = function (hexColor)\n\t{\n\t\tvar hexString = hexColor.toString (16);\n\t\twhile (hexString.length < 6) {\n\t\t\thexString = '0' + hexString;\n\t\t}\n\t\tvar r = parseInt (hexString.substr (0, 2), 16);\n\t\tvar g = parseInt (hexString.substr (2, 2), 16);\n\t\tvar b = parseInt (hexString.substr (4, 2), 16);\n\t\treturn [r, g, b];\n\t};\n\n\t/**\n\t* Function: HexColorToNormalizedRGBComponents\n\t* Description: Converts hex color strings to normalized (between 0.0 and 1.0) RGB components.\n\t* Parameters:\n\t*\thexColor {string} the hex color\n\t* Returns:\n\t*\t{number[3]} the RGB components\n\t*/\n\tJSM.HexColorToNormalizedRGBComponents = function (hexColor)\n\t{\n\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\treturn [rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0];\n\t};\n\n\t/**\n\t* Function: HexColorToRGBColor\n\t* Description: Converts hex color strings to RGB color.\n\t* Parameters:\n\t*\thexColor {string} the hex color string\n\t* Returns:\n\t*\t{integer} the RGB value\n\t*/\n\tJSM.HexColorToRGBColor = function (hexColor)\n\t{\n\t\tvar hexString = '0x' + hexColor;\n\t\treturn parseInt (hexString, 16);\n\t};\n\n\t/**\n\t* Function: RGBComponentsToHexColor\n\t* Description: Converts RGB components to hex color.\n\t* Parameters:\n\t*\tred {integer} the red component\n\t*\tgreen {integer} the green component\n\t*\tblue {integer} the blue component\n\t* Returns:\n\t*\t{integer} the hex value\n\t*/\n\tJSM.RGBComponentsToHexColor = function (red, green, blue)\n\t{\n\t\tfunction IntegerToHex (intString)\n\t\t{\n\t\t\tvar result = parseInt (intString, 10).toString (16);\n\t\t\twhile (result.length < 2) {\n\t\t\t\tresult = '0' + result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvar r = IntegerToHex (red);\n\t\tvar g = IntegerToHex (green);\n\t\tvar b = IntegerToHex (blue);\n\t\tvar hexString = '0x' + r + g + b;\n\t\treturn parseInt (hexString, 16);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/material',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Material\n\t* Description:\n\t*\tDefines a material. The parameter structure can contain the following values:\n\t*\tambient, diffuse, specular, shininess, opacity, texture, textureWidth, textureHeight.\n\t* Parameters:\n\t*\tparameters {object} parameters of the material\n\t*/\n\tJSM.Material = function (parameters)\n\t{\n\t\tthis.ambient = 0x00cc00;\n\t\tthis.diffuse = 0x00cc00;\n\t\tthis.specular = 0x000000;\n\t\tthis.shininess = 0.0;\n\t\tthis.opacity = 1.0;\n\t\tthis.reflection = 0.0;\n\t\tthis.singleSided = false;\n\t\tthis.pointSize = 0.1;\n\t\tthis.texture = null;\n\t\tthis.textureWidth = 1.0;\n\t\tthis.textureHeight = 1.0;\n\t\tJSM.CopyObjectProperties (parameters, this, true);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/materialset',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: MaterialSet\n\t* Description: Defines a material container.\n\t*/\n\tJSM.MaterialSet = function ()\n\t{\n\t\tthis.materials = [];\n\t\tthis.defaultMaterial = new JSM.Material ();\n\t};\n\n\t/**\n\t* Function: MaterialSet.AddMaterial\n\t* Description: Adds a material to the container.\n\t* Parameters:\n\t*\tmaterial {Material} the material\n\t* Returns:\n\t*\t{integer} the index of the newly added material\n\t*/\n\tJSM.MaterialSet.prototype.AddMaterial = function (material)\n\t{\n\t\tthis.materials.push (material);\n\t\treturn this.materials.length - 1;\n\t};\n\n\t/**\n\t* Function: MaterialSet.GetMaterial\n\t* Description: Returns a material from the container.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.MaterialSet.prototype.GetMaterial = function (index)\n\t{\n\t\tif (index < 0 || index >= this.materials.length) {\n\t\t\treturn this.defaultMaterial;\n\t\t}\n\t\treturn this.materials[index];\n\t};\n\n\t/**\n\t* Function: MaterialSet.GetDefaultMaterial\n\t* Description: Returns the default material from the container. It is always exists.\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.MaterialSet.prototype.GetDefaultMaterial = function ()\n\t{\n\t\treturn this.defaultMaterial;\n\t};\n\n\t/**\n\t* Function: MaterialSet.Count\n\t* Description: Returns the material count of the container.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.MaterialSet.prototype.Count = function ()\n\t{\n\t\treturn this.materials.length;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/body',[\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: BodyVertex\n\t* Description:\n\t*\tRepresents a vertex of a 3D body. The vertex contains\n\t*\tonly its position as a 3D coordinate.\n\t* Parameters:\n\t*\tposition {Coord} the position\n\t*/\n\tJSM.BodyVertex = function (position)\n\t{\n\t\tthis.position = position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.GetPosition\n\t* Description: Returns the position of the vertex.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.BodyVertex.prototype.GetPosition = function ()\n\t{\n\t\treturn this.position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.SetPosition\n\t* Description: Sets the position of the vertex.\n\t* Parameters:\n\t*\tposition {Coord} the position\n\t*/\n\tJSM.BodyVertex.prototype.SetPosition = function (position)\n\t{\n\t\tthis.position = position;\n\t};\n\n\t/**\n\t* Function: BodyVertex.Clone\n\t* Description: Clones the vertex.\n\t* Returns:\n\t*\t{BodyVertex} the cloned instance\n\t*/\n\tJSM.BodyVertex.prototype.Clone = function ()\n\t{\n\t\treturn new JSM.BodyVertex (this.position.Clone ());\n\t};\n\n\t/**\n\t* Class: BodyPoint\n\t* Description:\n\t*\tRepresents a point in a 3D body. The point contains the vertex index stored in its 3D body,\n\t*\tand a material index of a material defined outside of the body.\n\t* Parameters:\n\t*\tindex {integer} the vertex index stored in the body\n\t*/\n\tJSM.BodyPoint = function (index)\n\t{\n\t\tthis.vertex = index;\n\t\tthis.material = -1;\n\t};\n\n\t/**\n\t* Function: BodyPoint.GetVertexIndex\n\t* Description: Returns the body vertex index of the point.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyPoint.prototype.GetVertexIndex = function ()\n\t{\n\t\treturn this.vertex;\n\t};\n\n\t/**\n\t* Function: BodyPoint.SetVertexIndex\n\t* Description: Sets the vertex index of the point.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyPoint.prototype.SetVertexIndex = function (index)\n\t{\n\t\tthis.vertex = index;\n\t};\n\n\t/**\n\t* Function: BodyPoint.HasMaterialIndex\n\t* Description: Returns if the point has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPoint.prototype.HasMaterialIndex = function ()\n\t{\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPoint.GetMaterialIndex\n\t* Description: Returns the point material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPoint.prototype.GetMaterialIndex = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.SetMaterialIndex\n\t* Description: Sets the point material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyPoint.prototype.SetMaterialIndex = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.InheritAttributes\n\t* Description: Inherits attributes (material) from an another point.\n\t* Parameters:\n\t*\tsource {BodyPoint} the source point\n\t*/\n\tJSM.BodyPoint.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t};\n\n\t/**\n\t* Function: BodyPoint.Clone\n\t* Description: Clones the point.\n\t* Returns:\n\t*\t{BodyPoint} the cloned instance\n\t*/\n\tJSM.BodyPoint.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyPoint (this.vertex);\n\t\tresult.material = this.material;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: BodyLine\n\t* Description:\n\t*\tRepresents a line in a 3D body. The line contains begin and end indices of vertices\n\t*\tstored in its 3D body, and a material index of a material defined outside of the body.\n\t* Parameters:\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.BodyLine = function (beg, end)\t{\n\t\tthis.beg = beg;\n\t\tthis.end = end;\n\t\tthis.material = -1;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetBegVertexIndex\n\t* Description: Returns the body vertex index at the beginning of the line.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyLine.prototype.GetBegVertexIndex = function ()\t{\n\t\treturn this.beg;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetBegVertexIndex\n\t* Description: Sets the begin vertex index of the line.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyLine.prototype.SetBegVertexIndex = function (index)\t{\n\t\tthis.beg = index;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetEndVertexIndex\n\t* Description: Returns the body vertex index at the end of the line.\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyLine.prototype.GetEndVertexIndex = function ()\t{\n\t\treturn this.end;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetEndVertexIndex\n\t* Description: Sets the end vertex index of the line.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyLine.prototype.SetEndVertexIndex = function (index)\t{\n\t\tthis.end = index;\n\t};\n\n\t/**\n\t* Function: BodyLine.HasMaterialIndex\n\t* Description: Returns if the line has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyLine.prototype.HasMaterialIndex = function (){\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyLine.GetMaterialIndex\n\t* Description: Returns the line material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyLine.prototype.GetMaterialIndex = function (){\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyLine.SetMaterialIndex\n\t* Description: Sets the line material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyLine.prototype.SetMaterialIndex = function (material){\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyLine.InheritAttributes\n\t* Description: Inherits attributes (material) from an another line.\n\t* Parameters:\n\t*\tsource {BodyLine} the source line\n\t*/\n\tJSM.BodyLine.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t};\n\n\t/**\n\t* Function: BodyLine.Clone\n\t* Description: Clones the line.\n\t* Returns:\n\t*\t{BodyLine} the cloned instance\n\t*/\n\tJSM.BodyLine.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyLine (this.beg, this.end);\n\t\tresult.material = this.material;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: BodyPolygon\n\t* Description:\n\t*\tRepresents a polygon in a 3D body. The polygon contains indices of vertices stored in its body.\n\t*\tIt also contains a material index of a material defined outside of the body, and a curve\n\t*\tgroup index which defines its normal vector calculation in case of smooth surfaces.\n\t* Parameters:\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.BodyPolygon = function (vertices)\n\t{\n\t\tthis.vertices = vertices;\n\t\tthis.material = -1;\n\t\tthis.curved = -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.AddVertexIndex\n\t* Description: Adds a vertex index to the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.AddVertexIndex = function (index)\n\t{\n\t\tthis.vertices.push (index);\n\t};\n\n\t/**\n\t* Function: BodyPolygon.InsertVertexIndex\n\t* Description: Inserts a vertex index to given index in the polygon.\n\t* Parameters:\n\t*\tvertexIndex {integer} the vertex index\n\t*\tpolygonIndex {integer} the index in the polygon\n\t*/\n\tJSM.BodyPolygon.prototype.InsertVertexIndex = function (vertexIndex, polygonIndex)\n\t{\n\t\tthis.vertices.splice (polygonIndex, 0, vertexIndex);\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetVertexIndex\n\t* Description: Returns the body vertex index at the given polygon vertex index.\n\t* Parameters:\n\t*\tindex {integer} the polygon vertex index\n\t* Returns:\n\t*\t{integer} the stored vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.GetVertexIndex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetVertexIndex\n\t* Description: Sets the body vertex index at the given polygon vertex index.\n\t* Parameters:\n\t*\tindex {integer} the polygon vertex index\n\t*\tvertIndex {integer} the body vertex index\n\t*/\n\tJSM.BodyPolygon.prototype.SetVertexIndex = function (index, vertIndex)\n\t{\n\t\tthis.vertices[index] = vertIndex;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetVertexIndices\n\t* Description: Returns an array of the body vertex indices in the polygon.\n\t* Returns:\n\t*\t{integer[]} the stored vertex indices\n\t*/\n\tJSM.BodyPolygon.prototype.GetVertexIndices = function ()\n\t{\n\t\treturn this.vertices;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetVertexIndices\n\t* Description: Sets the vertex indices in the polygon.\n\t* Parameters:\n\t*\tvertices {integer[]} the new vertex indices\n\t*/\n\tJSM.BodyPolygon.prototype.SetVertexIndices = function (vertices)\n\t{\n\t\tthis.vertices = vertices;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.VertexIndexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.VertexIndexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.HasMaterialIndex\n\t* Description: Returns if the polygon has a material index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPolygon.prototype.HasMaterialIndex = function ()\n\t{\n\t\treturn this.material !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetMaterialIndex\n\t* Description: Returns the polygons material index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.GetMaterialIndex = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetMaterialIndex\n\t* Description: Sets the polygons material index.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.BodyPolygon.prototype.SetMaterialIndex = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.HasCurveGroup\n\t* Description: Returns if the polygon has a curve group index.\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.BodyPolygon.prototype.HasCurveGroup = function ()\n\t{\n\t\treturn this.curved !== -1;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.GetCurveGroup\n\t* Description: Returns the polygons curve group index.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BodyPolygon.prototype.GetCurveGroup = function ()\n\t{\n\t\treturn this.curved;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.SetCurveGroup\n\t* Description: Sets the polygons curve group index.\n\t* Parameters:\n\t*\tgroup {integer} the curve group index\n\t*/\n\tJSM.BodyPolygon.prototype.SetCurveGroup = function (group)\n\t{\n\t\tthis.curved = group;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.ReverseVertexIndices\n\t* Description: Reverses the order of vertex indices in the polygon.\n\t*/\n\tJSM.BodyPolygon.prototype.ReverseVertexIndices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t};\n\n\t/**\n\t* Function: BodyPolygon.InheritAttributes\n\t* Description: Inherits attributes (material and curve group index) from an another polygon.\n\t* Parameters:\n\t*\tsource {BodyPolygon} the source polygon\n\t*/\n\tJSM.BodyPolygon.prototype.InheritAttributes = function (source)\n\t{\n\t\tthis.material = source.material;\n\t\tthis.curved = source.curved;\n\t};\n\n\t/**\n\t* Function: BodyPolygon.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{BodyPolygon} the cloned instance\n\t*/\n\tJSM.BodyPolygon.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyPolygon ([]);\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.vertices.push (this.vertices[i]);\n\t\t}\n\t\tresult.material = this.material;\n\t\tresult.curved = this.curved;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Enum: TextureProjectionType\n\t* Description: Texture projection type.\n\t* Values:\n\t*\t{Planar} planar projection\n\t*\t{Cubic} cubic projection\n\t*\t{Cylindrical} cylindrical projection\n\t*/\n\tJSM.TextureProjectionType = {\n\t\tPlanar : 0,\n\t\tCubic : 1,\n\t\tCylindrical : 2\n\t};\n\n\t/**\n\t* Class: BodyTextureProjection\n\t* Description:\n\t*\tRepresents the texture projection of the body. It contains a projection type,\n\t*\tand a coordinate system for projection.\n\t*/\n\tJSM.BodyTextureProjection = function ()\n\t{\n\t\tthis.type = null;\n\t\tthis.coords = null;\n\t\tthis.SetCubic (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.GetType\n\t* Description: Returns the texture projection type.\n\t* Returns:\n\t*\t{TextureProjectionType} the result\n\t*/\n\tJSM.BodyTextureProjection.prototype.GetType = function ()\n\t{\n\t\treturn this.type;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.GetCoords\n\t* Description: Returns the texture projection coordinate system.\n\t* Returns:\n\t*\t{CoordSystem} the result\n\t*/\n\tJSM.BodyTextureProjection.prototype.GetCoords = function ()\n\t{\n\t\treturn this.coords;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetType\n\t* Description: Sets the texture projection type.\n\t* Parameters:\n\t*\ttype {TextureProjectionType} the type\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetType = function (type)\n\t{\n\t\tthis.type = type;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCoords\n\t* Description: Sets the texture projection coordinates.\n\t* Parameters:\n\t*\tcoords {CoordSystem} the coordinates\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCoords = function (coords)\n\t{\n\t\tthis.coords = coords;\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetPlanar\n\t* Description: Sets the texture projection to planar with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction of the projection plane\n\t*\tyDirection {Vector} y direction of the projection plane\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetPlanar = function (origo, xDirection, yDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Planar;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection,\n\t\t\tyDirection,\n\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCubic\n\t* Description: Sets the texture projection to cubic with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction (edge of the cube) of the projection\n\t*\tyDirection {Vector} y direction (edge of the cube) of the projection\n\t*\tzDirection {Vector} z direction (edge of the cube) of the projection\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCubic = function (origo, xDirection, yDirection, zDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Cubic;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection,\n\t\t\tyDirection,\n\t\t\tzDirection\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.SetCylindrical\n\t* Description: Sets the texture projection to cylindrical with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\tradius {number} radius of the cylinder\n\t*\txDirection {Vector} x direction (start point along perimeter) of the projection\n\t*\tzDirection {Vector} z direction (normal vector) of the projection\n\t*/\n\tJSM.BodyTextureProjection.prototype.SetCylindrical = function (origo, radius, xDirection, zDirection)\n\t{\n\t\tthis.type = JSM.TextureProjectionType.Cylindrical;\n\t\tthis.coords = new JSM.CoordSystem (\n\t\t\torigo,\n\t\t\txDirection.Clone ().SetLength (radius),\n\t\t\tJSM.VectorCross (zDirection, xDirection).SetLength (radius),\n\t\t\tzDirection\n\t\t);\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.Transform\n\t* Description: Transforms the texture projection coordinate system.\n\t* Parameters:\n\t*\ttransformation {Transformation} the transformation\n\t*/\n\tJSM.BodyTextureProjection.prototype.Transform = function (transformation)\n\t{\n\t\tthis.coords.ToAbsoluteCoords ();\n\t\tthis.coords.origo = transformation.Apply (this.coords.origo);\n\t\tthis.coords.e1 = transformation.Apply (this.coords.e1);\n\t\tthis.coords.e2 = transformation.Apply (this.coords.e2);\n\t\tthis.coords.e3 = transformation.Apply (this.coords.e3);\n\t\tthis.coords.ToDirectionVectors ();\n\t};\n\n\t/**\n\t* Function: BodyTextureProjection.Clone\n\t* Description: Clones the texture projection.\n\t* Returns:\n\t*\t{BodyTextureProjection} the cloned instance\n\t*/\n\tJSM.BodyTextureProjection.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.BodyTextureProjection ();\n\t\tresult.SetType (this.type);\n\t\tresult.SetCoords (this.coords.Clone ());\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: Body\n\t* Description:\n\t*\tRepresents a 3D body. The body contains vertices, polygons,\n\t*\tand a texture coordinate system.\n\t*/\n\tJSM.Body = function ()\n\t{\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Body.AddVertex\n\t* Description: Adds a vertex to the body.\n\t* Parameters:\n\t*\tvertex {BodyVertex} the vertex\n\t* Returns:\n\t*\t{integer} the index of the newly added vertex\n\t*/\n\tJSM.Body.prototype.AddVertex = function (vertex)\n\t{\n\t\tthis.vertices.push (vertex);\n\t\treturn this.vertices.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddPoint\n\t* Description: Adds a point to the body.\n\t* Parameters:\n\t*\tpoint {BodyPoint} the point\n\t* Returns:\n\t*\t{integer} the index of the newly added point\n\t*/\n\tJSM.Body.prototype.AddPoint = function (point)\n\t{\n\t\tthis.points.push (point);\n\t\treturn this.points.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddLine\n\t* Description: Adds a line to the body.\n\t* Parameters:\n\t*\tline {BodyLine} the line\n\t* Returns:\n\t*\t{integer} the index of the newly added line\n\t*/\n\tJSM.Body.prototype.AddLine = function (line)\n\t{\n\t\tthis.lines.push (line);\n\t\treturn this.lines.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.AddPolygon\n\t* Description: Adds a polygon to the body.\n\t* Parameters:\n\t*\tpolygon {BodyPolygon} the polygon\n\t* Returns:\n\t*\t{integer} the index of the newly added polygon\n\t*/\n\tJSM.Body.prototype.AddPolygon = function (polygon)\n\t{\n\t\tthis.polygons.push (polygon);\n\t\treturn this.polygons.length - 1;\n\t};\n\n\t/**\n\t* Function: Body.GetVertex\n\t* Description: Returns the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{BodyVertex} the result\n\t*/\n\tJSM.Body.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Body.GetVertexPosition\n\t* Description: Returns the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Body.prototype.GetVertexPosition = function (index)\n\t{\n\t\treturn this.vertices[index].position;\n\t};\n\n\t/**\n\t* Function: Body.SetVertexPosition\n\t* Description: Sets the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*\tposition {Coord} the new position\n\t*/\n\tJSM.Body.prototype.SetVertexPosition = function (index, position)\n\t{\n\t\tthis.vertices[index].position = position;\n\t};\n\n\t/**\n\t* Function: Body.GetPoint\n\t* Description: Returns the point at the given index.\n\t* Parameters:\n\t*\tindex {integer} the point index\n\t* Returns:\n\t*\t{BodyPoint} the result\n\t*/\n\tJSM.Body.prototype.GetPoint = function (index)\n\t{\n\t\treturn this.points[index];\n\t};\n\n\t/**\n\t* Function: Body.GetLine\n\t* Description: Returns the line at the given index.\n\t* Parameters:\n\t*\tindex {integer} the line index\n\t* Returns:\n\t*\t{BodyLine} the result\n\t*/\n\tJSM.Body.prototype.GetLine = function (index)\n\t{\n\t\treturn this.lines[index];\n\t};\n\n\t/**\n\t* Function: Body.GetPolygon\n\t* Description: Returns the polygon at the given index.\n\t* Parameters:\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{BodyPolygon} the result\n\t*/\n\tJSM.Body.prototype.GetPolygon = function (index)\n\t{\n\t\treturn this.polygons[index];\n\t};\n\n\t/**\n\t* Function: Body.SetPointsMaterialIndex\n\t* Description: Sets the material index for all points in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetPointsMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tthis.points[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetLinesMaterialIndex\n\t* Description: Sets the material index for all lines in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetLinesMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tthis.lines[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetPolygonsMaterialIndex\n\t* Description: Sets the material index for all polygons in the body.\n\t* Parameters:\n\t*\tmaterial {integer} the material index\n\t*/\n\tJSM.Body.prototype.SetPolygonsMaterialIndex = function (material)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tthis.polygons[i].SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.SetPolygonsCurveGroup\n\t* Description: Sets the curve group index for all polygons in the body.\n\t* Parameters:\n\t*\tgroup {integer} the curve group index\n\t*/\n\tJSM.Body.prototype.SetPolygonsCurveGroup = function (group)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tthis.polygons[i].SetCurveGroup (group);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.RemoveVertex\n\t* Description: Removes a vertex from the body. It also removes connected polygons.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Body.prototype.RemoveVertex = function (index)\n\t{\n\t\tvar pointsToDelete = [];\n\t\tvar linesToDelete = [];\n\t\tvar polygonsToDelete = [];\n\t\tvar i, j, point, line, polygon, bodyVertIndex;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tpoint = this.points[i];\n\t\t\tif (point.GetVertexIndex () == index) {\n\t\t\t\tpointsToDelete.push (i);\n\t\t\t} else if (point.GetVertexIndex () >= index) {\n\t\t\t\tpoint.SetVertexIndex (point.GetVertexIndex () - 1);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tline = this.lines[i];\n\t\t\tif (line.GetBegVertexIndex () == index || line.GetEndVertexIndex () == index) {\n\t\t\t\tlinesToDelete.push (i);\n\t\t\t} else {\n\t\t\t\tif (line.GetBegVertexIndex () >= index) {\n\t\t\t\t\tline.SetBegVertexIndex (line.GetBegVertexIndex () - 1);\n\t\t\t\t}\n\t\t\t\tif (line.GetEndVertexIndex () >= index) {\n\t\t\t\t\tline.SetEndVertexIndex (line.GetEndVertexIndex () - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tpolygon = this.polygons[i];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tbodyVertIndex = polygon.GetVertexIndex (j);\n\t\t\t\tif (polygon.GetVertexIndex (j) == index) {\n\t\t\t\t\tpolygonsToDelete.push (i);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (bodyVertIndex >= index) {\n\t\t\t\t\tpolygon.SetVertexIndex (j, bodyVertIndex - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < pointsToDelete.length; i++) {\n\t\t\tthis.RemovePoint (pointsToDelete[i] - i);\n\t\t}\n\t\tfor (i = 0; i < linesToDelete.length; i++) {\n\t\t\tthis.RemoveLine (linesToDelete[i] - i);\n\t\t}\n\t\tfor (i = 0; i < polygonsToDelete.length; i++) {\n\t\t\tthis.RemovePolygon (polygonsToDelete[i] - i);\n\t\t}\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemovePoint\n\t* Description: Removes a point from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the point\n\t*/\n\tJSM.Body.prototype.RemovePoint = function (index)\n\t{\n\t\tthis.points.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemoveLine\n\t* Description: Removes a line from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the line\n\t*/\n\tJSM.Body.prototype.RemoveLine = function (index)\n\t{\n\t\tthis.lines.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.RemovePolygon\n\t* Description: Removes a polygon from the body.\n\t* Parameters:\n\t*\tindex {integer} the index of the polygon\n\t*/\n\tJSM.Body.prototype.RemovePolygon = function (index)\n\t{\n\t\tthis.polygons.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Body.VertexCount\n\t* Description: Returns the vertex count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Body.PointCount\n\t* Description: Returns the point count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.PointCount = function ()\n\t{\n\t\treturn this.points.length;\n\t};\n\n\t/**\n\t* Function: Body.LineCount\n\t* Description: Returns the line count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.LineCount = function ()\n\t{\n\t\treturn this.lines.length;\n\t};\n\n\t/**\n\t* Function: Body.PolygonCount\n\t* Description: Returns the polygon count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Body.prototype.PolygonCount = function ()\n\t{\n\t\treturn this.polygons.length;\n\t};\n\n\t/**\n\t* Function: Body.GetTextureProjection\n\t* Description: Returns the texture projection of the body.\n\t* Returns:\n\t*\t{BodyTextureProjection} the result\n\t*/\n\tJSM.Body.prototype.GetTextureProjection = function ()\n\t{\n\t\treturn this.projection;\n\t};\n\n\t/**\n\t* Function: Body.SetTextureProjection\n\t* Description: Sets the texture projection of the body.\n\t* Parameters:\n\t*\tprojection {BodyTextureProjection} the new texture projection\n\t*/\n\tJSM.Body.prototype.SetTextureProjection = function (projection)\n\t{\n\t\tthis.projection = projection;\n\t};\n\n\t/**\n\t* Function: Body.SetPlanarTextureProjection\n\t* Description: Sets the texture projection to planar with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction of the projection plane\n\t*\tyDirection {Vector} y direction of the projection plane\n\t*/\n\tJSM.Body.prototype.SetPlanarTextureProjection = function (origo, xDirection, yDirection)\n\t{\n\t\tthis.projection.SetPlanar (origo, xDirection, yDirection);\n\t};\n\n\t/**\n\t* Function: Body.SetCubicTextureProjection\n\t* Description: Sets the texture projection to cubic with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\txDirection {Vector} x direction (edge of the cube) of the projection\n\t*\tyDirection {Vector} y direction (edge of the cube) of the projection\n\t*\tzDirection {Vector} z direction (edge of the cube) of the projection\n\t*/\n\tJSM.Body.prototype.SetCubicTextureProjection = function (origo, xDirection, yDirection, zDirection)\n\t{\n\t\tthis.projection.SetCubic (origo, xDirection, yDirection, zDirection);\n\t};\n\n\t/**\n\t* Function: Body.SetCylindricalTextureProjection\n\t* Description: Sets the texture projection to cylindrical with the given parameters.\n\t* Parameters:\n\t*\torigo {Coord} origo of the projection\n\t*\tradius {number} radius of the cylinder\n\t*\txDirection {Vector} x direction (start point along perimeter) of the projection\n\t*\tzDirection {Vector} z direction (normal vector) of the projection\n\t*/\n\tJSM.Body.prototype.SetCylindricalTextureProjection = function (origo, radius, xDirection, zDirection)\n\t{\n\t\tthis.projection.SetCylindrical (origo, radius, xDirection, zDirection);\n\t};\n\n\t/**\n\t* Function: Body.Transform\n\t* Description: Transforms the body.\n\t* Parameters:\n\t*\ttransformation {Transformation} the transformation\n\t*/\n\tJSM.Body.prototype.Transform = function (transformation)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tthis.vertices[i].position = transformation.Apply (this.vertices[i].position);\n\t\t}\n\t\tthis.projection.Transform (transformation);\n\t};\n\n\t/**\n\t* Function: Body.GetBoundingBox\n\t* Description: Returns the bounding box of the body.\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.Body.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i].position;\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\t\t\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\t/**\n\t* Function: Body.GetCenter\n\t* Description: Returns the center of the bounding box of the body.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.Body.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\t/**\n\t* Function: Body.GetBoundingSphere\n\t* Description: Returns the bounding sphere of the body.\n\t* Returns:\n\t*\t{Sphere} the result\n\t*/\n\tJSM.Body.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\t\t\n\t\tvar i, current;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcurrent = center.DistanceTo (this.vertices[i].position);\n\t\t\tif (JSM.IsGreater (current, radius)) {\n\t\t\t\tradius = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.Sphere (center, radius);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Body.OffsetToOrigo\n\t* Description: Offsets the body to the origo.\n\t*/\n\tJSM.Body.prototype.OffsetToOrigo = function ()\n\t{\n\t\tvar center = this.GetCenter ().Clone ();\n\t\tcenter.MultiplyScalar (-1.0);\n\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tthis.vertices[i].position = JSM.CoordAdd (this.vertices[i].position, center);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.Merge\n\t* Description: Merges an existing body to the body.\n\t* Parameters:\n\t*\tbody {Body} the body to merge\n\t*/\n\tJSM.Body.prototype.Merge = function (body)\n\t{\n\t\tvar oldVertexCount = this.vertices.length;\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tthis.vertices.push (body.GetVertex (i).Clone ());\n\t\t}\n\t\t\n\t\tvar newPoint;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tnewPoint = body.GetPoint (i).Clone ();\n\t\t\tnewPoint.SetVertexIndex (newPoint.GetVertexIndex () + oldVertexCount);\n\t\t\tthis.points.push (newPoint);\n\t\t}\t\n\t\t\n\t\tvar newLine;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tnewLine = body.GetLine (i).Clone ();\n\t\t\tnewLine.SetBegVertexIndex (newLine.GetBegVertexIndex () + oldVertexCount);\n\t\t\tnewLine.SetEndVertexIndex (newLine.GetEndVertexIndex () + oldVertexCount);\n\t\t\tthis.lines.push (newLine);\n\t\t}\n\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnewPolygon = body.GetPolygon (i).Clone ();\n\t\t\tfor (j = 0; j < newPolygon.VertexIndexCount (); j++) {\n\t\t\t\tnewPolygon.vertices[j] += oldVertexCount;\n\t\t\t}\n\t\t\tthis.polygons.push (newPolygon);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Body.Clear\n\t* Description: Makes the body empty.\n\t*/\n\tJSM.Body.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.points = [];\n\t\tthis.lines = [];\n\t\tthis.polygons = [];\n\t\tthis.projection = new JSM.BodyTextureProjection ();\n\t};\n\n\t/**\n\t* Function: Body.Clone\n\t* Description: Clones the body.\n\t* Returns:\n\t*\t{Body} the cloned instance\n\t*/\n\tJSM.Body.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.AddVertex (this.vertices[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tresult.AddPoint (this.points[i].Clone ());\n\t\t}\n\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tresult.AddLine (this.lines[i].Clone ());\n\t\t}\n\n\t\tfor (i = 0; i < this.polygons.length; i++) {\n\t\t\tresult.AddPolygon (this.polygons[i].Clone ());\n\t\t}\n\n\t\tresult.SetTextureProjection (this.projection.Clone ());\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/model',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Model\n\t* Description: Represents a 3D model. The model contains bodies.\n\t*/\n\tJSM.Model = function ()\n\t{\n\t\tthis.bodies = [];\n\t\tthis.materials = new JSM.MaterialSet ();\n\t};\n\n\t/**\n\t* Function: Model.AddBody\n\t* Description: Adds a body to the model.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer} the index of the newly added body\n\t*/\n\tJSM.Model.prototype.AddBody = function (body)\n\t{\n\t\tthis.bodies.push (body);\n\t\treturn this.bodies.length - 1;\n\t};\n\n\t/**\n\t* Function: Model.AddBodies\n\t* Description: Adds bodies to the model.\n\t* Parameters:\n\t*\tbodies {Body[*]} the body\n\t*/\n\tJSM.Model.prototype.AddBodies = function (bodies)\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < bodies.length; i++) {\n\t\t\tbody = bodies[i];\n\t\t\tthis.AddBody (body);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Model.GetBody\n\t* Description: Returns the stored body with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.Model.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\t/**\n\t* Function: Model.BodyCount\n\t* Description: Returns the body count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.BodyCount = function ()\n\t{\n\t\treturn this.bodies.length;\n\t};\n\n\t/**\n\t* Function: Model.AddMaterial\n\t* Description: Adds a material to the mode.\n\t* Parameters:\n\t*\tmaterial {Material} the material\n\t* Returns:\n\t*\t{integer} the index of the newly added material\n\t*/\n\tJSM.Model.prototype.AddMaterial = function (material)\n\t{\n\t\treturn this.materials.AddMaterial (material);\n\t};\n\n\t/**\n\t* Function: Model.GetMaterial\n\t* Description: Returns a material from the model.\n\t* Parameters:\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.Model.prototype.GetMaterial = function (index)\n\t{\n\t\treturn this.materials.GetMaterial (index);\n\t};\n\n\t/**\n\t* Function: Model.GetDefaultMaterial\n\t* Description: Returns the default material from the model. It is always exists.\n\t* Returns:\n\t*\t{Material} the result\n\t*/\n\tJSM.Model.prototype.GetDefaultMaterial = function ()\n\t{\n\t\treturn this.materials.GetDefaultMaterial ();\n\t};\n\n\t/**\n\t* Function: Model.GetMaterialSet\n\t* Description: Returns the material set of the model.\n\t* Returns:\n\t*\t{MaterialSet} the result\n\t*/\n\tJSM.Model.prototype.GetMaterialSet = function ()\n\t{\n\t\treturn this.materials;\n\t};\n\n\t/**\n\t* Function: Model.Count\n\t* Description: Returns the material count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.MaterialCount = function ()\n\t{\n\t\treturn this.materials.Count ();\n\t};\n\n\t/**\n\t* Function: Model.VertexCount\n\t* Description: Returns the vertex count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.VertexCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tcount += this.bodies[i].VertexCount ();\n\t\t}\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: Model.PolygonCount\n\t* Description: Returns the polygon count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Model.prototype.PolygonCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tcount += this.bodies[i].PolygonCount ();\n\t\t}\n\t\treturn count;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/adjacencyinfo',[\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: VertInfo\n\t* Description:\n\t*\tContains adjacency information for a body vertex. Contains arrays\n\t*\twith indices of connected edge and polygon info.\n\t*/\n\tJSM.VertInfo = function ()\n\t{\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\n\t};\n\n\t/**\n\t* Class: EdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body edge. Contains indices\n\t*\tof connected vertex and polygon info.\n\t*/\n\tJSM.EdgeInfo = function ()\n\t{\n\t\tthis.vert1 = -1;\n\t\tthis.vert2 = -1;\n\t\tthis.pgon1 = -1;\n\t\tthis.pgon2 = -1;\n\t};\n\n\t/**\n\t* Class: PolyEdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon edge. Contains an index\n\t*\tof an existing edge, and a flag which defines its direction.\n\t*/\n\tJSM.PolyEdgeInfo = function ()\n\t{\n\t\tthis.index = -1;\n\t\tthis.reverse = false;\n\t};\n\n\t/**\n\t* Class: PgonInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon. Contains arrays\n\t*\twith indices of connected vertex and poly edge info.\n\t*/\n\tJSM.PgonInfo = function ()\n\t{\n\t\tthis.verts = [];\n\t\tthis.pedges = [];\n\t};\n\n\t/**\n\t* Class: AdjacencyInfo\n\t* Description:\n\t*\tContains adjacency information for a body. Contains arrays\n\t*\twith vertex, edge and polygon info.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo = function (body)\n\t{\n\t\tthis.verts = null;\n\t\tthis.edges = null;\n\t\tthis.pgons = null;\n\t\tthis.Calculate (body);\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.Reset\n\t* Description: Calculates the adjacency information for a body.\n\t* Returns:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo.prototype.Calculate = function (body)\n\t{\n\t\tfunction AddVertex (adjacencyInfo)\n\t\t{\n\t\t\tvar vert = new JSM.VertInfo ();\n\t\t\tadjacencyInfo.verts.push (vert);\n\t\t}\n\t\t\n\t\tfunction AddPolygon (adjacencyInfo, body, polygonIndex)\n\t\t{\n\t\t\tfunction AddEdge (adjacencyInfo, pgonInfo, fromVertexIndex, toVertexIndex, polygonIndex)\n\t\t\t{\n\t\t\t\tfunction ConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo)\n\t\t\t\t{\n\t\t\t\t\tfunction ConnectPgonAndEdgeToVert (vert, pgonIndex, edgeIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (vert.edges.indexOf (edgeIndex) == -1) {\n\t\t\t\t\t\t\tvert.edges.push (edgeIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vert.pgons.indexOf (pgonIndex) == -1) {\n\t\t\t\t\t\t\tvert.pgons.push (pgonIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpgonInfo.verts.push (fromVertexIndex);\n\t\t\t\t\tpgonInfo.pedges.push (pedge);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[fromVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[toVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar pedge = new JSM.PolyEdgeInfo ();\n\t\t\t\n\t\t\t\tvar i, edge;\n\t\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\t\tif (edge.vert1 === fromVertexIndex && edge.vert2 === toVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t\t} else if (edge.vert1 === toVertexIndex && edge.vert2 === fromVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pedge.index === -1) {\n\t\t\t\t\tvar newEdge = new JSM.EdgeInfo ();\n\t\t\t\t\tnewEdge.vert1 = fromVertexIndex;\n\t\t\t\t\tnewEdge.vert2 = toVertexIndex;\n\t\t\t\t\tnewEdge.pgon1 = polygonIndex;\n\t\t\t\t\tnewEdge.pgon2 = -1;\n\t\t\t\t\tadjacencyInfo.edges.push (newEdge);\n\t\t\t\t\t\n\t\t\t\t\tpedge.index = adjacencyInfo.edges.length - 1;\n\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t} else {\n\t\t\t\t\tvar currEdge = adjacencyInfo.edges[pedge.index];\n\t\t\t\t\tif (currEdge.pgon1 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon1 = polygonIndex;\n\t\t\t\t\t} else if (currEdge.pgon1 !== polygonIndex && currEdge.pgon2 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon2 = polygonIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo);\n\t\t\t}\n\n\t\t\tvar polygon = body.GetPolygon (polygonIndex);\n\t\t\tvar pgon = new JSM.PgonInfo ();\n\t\t\t\n\t\t\tvar i, curr, next;\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = polygon.GetVertexIndex (i);\n\t\t\t\tnext = polygon.GetVertexIndex (i < count - 1 ? i + 1 : 0);\n\t\t\t\tAddEdge (adjacencyInfo, pgon, curr, next, polygonIndex);\n\t\t\t}\n\t\t\tadjacencyInfo.pgons.push (pgon);\n\t\t}\n\n\t\tthis.verts = [];\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\t\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (this);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (this, body, i);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourVertex\n\t* Description: Returns if the vertex has contour edge.\n\t* Parameters:\n\t*\tvert {VertInfo} the vertex info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourVertex = function (vert)\n\t{\n\t\tvar i, edge;\n\t\tfor (i = 0; i < vert.edges.length; i++) {\n\t\t\tedge = vert.edges[i];\n\t\t\tif (this.IsContourEdge (this.edges[edge])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourEdge\n\t* Description: Returns if the edge has only one polygon neighbour.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourEdge = function (edge)\n\t{\n\t\tvar pgonCount = this.GetEdgePolygonCount (edge);\n\t\treturn pgonCount == 1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetEdgePolygonCount\n\t* Description: Returns the neighbour polygon count of the edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetEdgePolygonCount = function (edge)\n\t{\n\t\tvar pgonCount = 0;\n\t\tif (edge.pgon1 != -1) {\n\t\t\tpgonCount += 1;\n\t\t}\n\t\tif (edge.pgon2 != -1) {\n\t\t\tpgonCount += 2;\n\t\t}\n\t\treturn pgonCount;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetAnotherPgonOfEdge\n\t* Description: Returns the polygon index which is next to the given polygon along an edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t*\tcurrentPgon {integer} the polygon index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetAnotherPgonOfEdge = function (edge, pgon)\n\t{\n\t\tif (edge.pgon1 != -1 && edge.pgon1 != pgon) {\n\t\t\treturn edge.pgon1;\n\t\t} else if (edge.pgon2 != -1 && edge.pgon2 != pgon) {\n\t\t\treturn edge.pgon2;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeStartVertex\n\t* Description: Returns the start vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeStartVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeEndVertex\n\t* Description: Returns the end vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeEndVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t}\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexToPolygon\n\t* Description:\n\t*\tCalculates an array which contains array of the connected polygon\n\t*\tindices for all vertex indices in the body. The result is an\n\t*\tarray of array of polygon indices.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexToPolygon = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.push ([]);\n\t\t}\n\t\t\n\t\tvar polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tresult[polygon.GetVertexIndex (j)].push (i);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IsSolidBody\n\t* Description:\n\t*\tReturns if a given body is solid. It means that every\n\t*\tedges of the body has two polygon neighbours.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tif (adjacencyInfo.edges.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar i, edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CheckSolidBody\n\t* Description:\n\t*\tReturns if a given body solid body is correct. It means that every\n\t*\tedges of the body has two polygon neighbours, and there are no edge\n\t*\tin the body which appears twice with the same direction.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar i, j, edge, pedge, found, pgon1, pgon2, pgon1Reverse, pgon2Reverse;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon1 = adjacencyInfo.pgons[edge.pgon1];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon1.pedges.length; j++) {\n\t\t\t\tpedge = pgon1.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon1Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon2 = adjacencyInfo.pgons[edge.pgon2];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon2.pedges.length; j++) {\n\t\t\t\tpedge = pgon2.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon2Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (pgon1Reverse == pgon2Reverse) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraversePgonsAlongEdges\n\t* Description:\n\t*\tTraverses polygons along edges. The given callback function called on every\n\t*\tfound polygon. The return value of the callback means if the traverse should\n\t*\tcontinue along the edges of the current polygon.\n\t* Parameters:\n\t*\tpgonIndex {integer} the polygon index to start from\n\t*\tadjacencyInfo {AdjacencyInfo} the adjacency info\n\t*\tonPgonFound {function} the callback\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.TraversePgonsAlongEdges = function (pgonIndex, adjacencyInfo, onPgonFound)\n\t{\n\t\tfunction AddNeighboursToStack (pgonIndex, adjacencyInfo, pgonStack)\n\t\t{\n\t\t\tvar pgon = adjacencyInfo.pgons[pgonIndex];\n\t\t\tvar i, edge, anotherPgon;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[pgon.pedges[i].index];\n\t\t\t\tanotherPgon = adjacencyInfo.GetAnotherPgonOfEdge (edge, pgonIndex);\n\t\t\t\tif (anotherPgon != -1) {\n\t\t\t\t\tpgonStack.push (anotherPgon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar pgonIsProcessed = {};\n\t\tvar pgonStack = [pgonIndex];\n\t\tvar currentPgonIndex;\n\t\twhile (pgonStack.length > 0) {\n\t\t\tcurrentPgonIndex = pgonStack.pop ();\n\t\t\tif (pgonIsProcessed[currentPgonIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpgonIsProcessed[currentPgonIndex] = true;\n\t\t\tif (onPgonFound (currentPgonIndex)) {\n\t\t\t\tAddNeighboursToStack (currentPgonIndex, adjacencyInfo, pgonStack);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/bodyutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: AddVertexToBody\n\t* Description: Adds a vertex to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.AddVertexToBody = function (body, x, y, z)\n\t{\n\t\treturn body.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t};\n\n\t/**\n\t* Function: AddPointToBody\n\t* Description: Adds a point to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertex {integer} the vertex index stored in the body\n\t*/\n\tJSM.AddPointToBody = function (body, vertex)\n\t{\n\t\treturn body.AddPoint (new JSM.BodyPoint (vertex));\n\t};\n\n\t/**\n\t* Function: AddLineToBody\n\t* Description: Adds a line to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.AddLineToBody = function (body, beg, end)\n\t{\n\t\treturn body.AddLine (new JSM.BodyLine (beg, end));\n\t};\n\n\t/**\n\t* Function: AddPolygonToBody\n\t* Description: Adds a polygon to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.AddPolygonToBody = function (body, vertices)\n\t{\n\t\treturn body.AddPolygon (new JSM.BodyPolygon (vertices));\n\t};\n\n\t/**\n\t* Function: CheckBody\n\t* Description:\n\t*\tChecks if the body is correct. It means that every polygon has at least three\n\t*\tvertices, and every point, line and polygon vertex index is valid.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckBody = function (body)\n\t{\n\t\tvar vertexCount = body.VertexCount ();\n\t\tvar i, j, point, line, polygon;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tpoint = body.GetPoint (i);\n\t\t\tif (point.GetVertexIndex () < 0 || point.GetVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tline = body.GetLine (i);\n\t\t\tif (line.GetBegVertexIndex () < 0 || line.GetBegVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (line.GetEndVertexIndex () < 0 || line.GetEndVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tif (polygon.VertexIndexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tif (polygon.GetVertexIndex (j) < 0 || polygon.GetVertexIndex (j) >= vertexCount) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormal\n\t* Description: Calculates a normal vector for a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormal = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = body.GetVertexPosition (polygon.GetVertexIndex (currentIndex));\n\t\t\t\tnext = body.GetVertexPosition (polygon.GetVertexIndex (nextIndex));\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormals\n\t* Description: Calculates polygon normal vectors for all polygons stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*]} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculateBodyPolygonNormal (body, i));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexNormals\n\t* Description:\n\t*\tCalculates vertex normal vectors for all vertices stored in the body.\n\t*\tThe result is an array of array with vertex normal vectors.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar vertexToPolygon = null;\n\t\t\n\t\tvar i, j, k, polygon, normal;\n\t\tvar average, count, neighbourPolygons, neighbourPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tresult[i] = [];\n\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\tif (vertexToPolygon === null) {\n\t\t\t\t\tvertexToPolygon = JSM.CalculateBodyVertexToPolygon (body);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\taverage = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\t\tcount = 0;\n\t\t\t\t\t\n\t\t\t\t\tneighbourPolygons = vertexToPolygon[polygon.GetVertexIndex (j)];\n\t\t\t\t\tfor (k = 0; k < neighbourPolygons.length; k++) {\n\t\t\t\t\t\tneighbourPolygon = body.GetPolygon (neighbourPolygons[k]);\n\t\t\t\t\t\tif (neighbourPolygon.GetCurveGroup () === polygon.GetCurveGroup ()) {\n\t\t\t\t\t\t\taverage = JSM.CoordAdd (average, polygonNormals[neighbourPolygons[k]]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\taverage.MultiplyScalar (1.0 / count);\n\t\t\t\t\taverage.Normalize ();\n\t\t\t\t\tresult[i].push (average);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnormal = polygonNormals[i];\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tresult[i].push (new JSM.Vector (normal.x, normal.y, normal.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCurveGroups\n\t* Description: Calculates the curve groups for a given polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon|Polygon2D} the polygon\n\t*\tcurveAngle {number} the curve angle\n\t* Returns:\n\t*\t{integer[*]} the curve groups\n\t*/\n\tJSM.CalculatePolygonCurveGroups = function (polygon, curveAngle)\n\t{\n\t\tvar curveGroups = [];\n\t\tvar count = polygon.VertexCount ();\n\n\t\tvar i, prev;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurveGroups.push (0);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = curveGroups[polygon.GetPrevVertex (i)];\n\t\t\tif (polygon.GetVertexAngle (i) > curveAngle) {\n\t\t\t\tcurveGroups[i] = prev;\n\t\t\t} else {\n\t\t\t\tcurveGroups[i] = prev + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar firstGroup = curveGroups[0];\n\t\tvar lastGroup = curveGroups[count - 1];\n\t\tif (firstGroup === 0 && firstGroup != lastGroup) {\n\t\t\tfor (i = 0; curveGroups[i] == firstGroup; i++) {\n\t\t\t\tcurveGroups[i] = lastGroup;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curveGroups;\n\t};\n\n\n\t/**\n\t* Function: CalculatePolygonCentroid\n\t* Description: Calculates the centroid of a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculatePolygonCentroid = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\t\t\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult = JSM.CoordAdd (result, body.GetVertexPosition (polygon.GetVertexIndex (i)));\n\t\t}\n\t\t\n\t\tresult.MultiplyScalar (1.0 / count);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MakeBodyInsideOut\n\t* Description: Reverses all polygons orientation in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.MakeBodyInsideOut = function (body)\n\t{\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tpolygon.ReverseVertexIndices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: SoftMoveBodyVertex\n\t* Description: Moves a vertex and its nearby vertices depending on gaussian function.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the vertex index to move\n\t*\tradius {number} the radius of the movement\n\t*\tdirection {Vector} the direction of the movement\n\t*\tdistance {number} the distance of the movement\n\t*/\n\tJSM.SoftMoveBodyVertex = function (body, index, radius, direction, distance)\n\t{\n\t\tvar referenceCoord = body.GetVertexPosition (index).Clone ();\n\n\t\tvar eps = 0.00001;\n\t\tvar a = distance;\n\t\tvar b = 0.0;\n\t\tvar c = JSM.GetGaussianCParameter (radius, a, b, eps);\n\n\t\tvar i, currentDistance, newDistance;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tcurrentDistance = referenceCoord.DistanceTo (body.GetVertex (i).position);\n\t\t\tif (JSM.IsGreater (currentDistance, radius)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewDistance = JSM.GetGaussianValue (currentDistance, distance, b, c);\n\t\t\tbody.GetVertexPosition (i).Offset (direction, newDistance);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateWireBody\n\t* Description: Generates a body which contains only the lines from the given body.\n\t* Parameters:\n\t*\tbody {Body} the original body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateWireBody = function (body)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.AddVertex (body.GetVertex (i).Clone ());\n\t\t}\n\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tJSM.AddLineToBody (result, edge.vert1, edge.vert2);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangulateWithCentroids\n\t* Description:\n\t*\tTriangulates all polygons of the body by connecting all polygon\n\t*\tvertices with the centroid vertex of the polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulateWithCentroids = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, centroidCoord, centroidIndex, oldPolygon, oldVertexCount, polygon, curr, next;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tcentroidCoord = JSM.CalculatePolygonCentroid (body, i);\n\t\t\tcentroidIndex = body.AddVertex (new JSM.BodyVertex (centroidCoord));\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\toldVertexCount = oldPolygon.VertexIndexCount ();\n\t\t\tfor (j = 0; j < oldVertexCount; j++) {\n\t\t\t\tcurr = oldPolygon.GetVertexIndex (j);\n\t\t\t\tnext = oldPolygon.GetVertexIndex (j < oldVertexCount - 1 ? j + 1 : 0);\n\t\t\t\tpolygon = new JSM.BodyPolygon ([curr, next, centroidIndex]);\n\t\t\t\tpolygon.InheritAttributes (oldPolygon);\n\t\t\t\tbody.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangulatePolygons\n\t* Description: Triangulates all polygons of the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulatePolygons = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, oldPolygon, polygon, coord, triangleIndices, triangle, bodyTriangle;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\tpolygon = new JSM.Polygon ();\n\t\t\tfor (j = 0; j < oldPolygon.VertexIndexCount (); j++) {\n\t\t\t\tcoord = body.GetVertexPosition (oldPolygon.GetVertexIndex (j));\n\t\t\t\tpolygon.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\ttriangleIndices = JSM.TriangulatePolygon (polygon);\n\t\t\tif (triangleIndices !== null) {\n\t\t\t\tfor (j = 0; j < triangleIndices.length; j++) {\n\t\t\t\t\ttriangle = triangleIndices[j];\n\t\t\t\t\tbodyTriangle = new JSM.BodyPolygon ([\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[0]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[1]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[2])\n\t\t\t\t\t]);\n\t\t\t\t\tbodyTriangle.InheritAttributes (oldPolygon);\n\t\t\t\t\tbody.AddPolygon (bodyTriangle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateRandomMaterials\n\t* Description: Generates random materials for a body. A seed number can be specified.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\tseeded {boolean} seeded random generation\n\t*/\n\tJSM.GenerateRandomMaterials = function (body, materials, seeded)\n\t{\n\t\tfunction GetRandomInt (seeded, seed)\n\t\t{\n\t\t\tvar minColor = 0;\n\t\t\tvar maxColor = 16777215;\n\t\t\tvar color = 0;\n\t\t\tif (seeded !== undefined && seeded) {\n\t\t\t\tcolor = JSM.SeededRandomInt (minColor, maxColor, seed + 1);\n\t\t\t} else {\n\t\t\t\tcolor = JSM.RandomInt (minColor, maxColor);\n\t\t\t}\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tvar i, color, material;\n\t\tvar seed = 0;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetLine (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPoint (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPolygon (i).SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AddBodyToBSPTree\n\t* Description: Adds a body to a BSP tree.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tid {anything} the id for added polygons\n\t*/\n\tJSM.AddBodyToBSPTree = function (body, bspTree, id)\n\t{\n\t\tfunction ConvertBodyPolygonToPolygon (body, index, userData)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tuserData.material = polygon.GetMaterialIndex ();\n\t\t\tvar result = new JSM.Polygon ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar i, polygon, userData;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tuserData = {\n\t\t\t\tid : id,\n\t\t\t\toriginalPolygon : i,\n\t\t\t\tmaterial : -1\n\t\t\t};\n\t\t\tpolygon = ConvertBodyPolygonToPolygon (body, i, userData);\n\t\t\tbspTree.AddPolygon (polygon, userData);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/textureutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CalculatePlanarTextureCoord\n\t* Description: Calculates the planar texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculatePlanarTextureCoord = function (coord, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e1 = system.e1.Clone ().Normalize ();\n\t\tvar e2 = system.e2.Clone ().Normalize ();\n\t\tvar e3 = JSM.VectorCross (system.e1, system.e2);\n\n\t\tvar xyPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e3);\n\t\tvar xzPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e2);\n\t\tvar yzPlane = JSM.GetPlaneFromCoordAndDirection (system.origo, e1);\n\t\t\n\t\tvar projected = xyPlane.ProjectCoord (coord);\n\t\tresult.x = yzPlane.CoordSignedDistance (projected);\n\t\tresult.y = xzPlane.CoordSignedDistance (projected);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateCubicTextureCoord\n\t* Description: Calculates the cubic texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnormal {Vector} the normal vector for calculation\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculateCubicTextureCoord = function (coord, normal, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e1 = system.e1.Clone ().Normalize ();\n\t\tvar e2 = system.e2.Clone ().Normalize ();\n\t\tvar e3 = system.e3.Clone ().Normalize ();\n\n\t\tvar correctPlane = -1;\n\t\tvar maxProduct = 0.0;\n\t\t\n\t\tvar i, currentDirection, product;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (i === 0) {\n\t\t\t\tcurrentDirection = e1;\n\t\t\t} else if (i === 1) {\n\t\t\t\tcurrentDirection = e2;\n\t\t\t} else if (i === 2) {\n\t\t\t\tcurrentDirection = e3;\n\t\t\t}\n\n\t\t\tproduct = Math.abs (JSM.VectorDot (normal, currentDirection));\n\t\t\tif (JSM.IsGreater (product, maxProduct)) {\n\t\t\t\tcorrectPlane = i;\n\t\t\t\tmaxProduct = product;\n\t\t\t}\n\t\t}\n\n\t\tif (correctPlane === -1) {\n\t\t\treturn result;\n\t\t}\n\n\t\tvar planeSystem = null;\n\t\tif (correctPlane === 0) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te2,\n\t\t\t\te3,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t} else if (correctPlane === 1) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te1,\n\t\t\t\te3,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t} else if (correctPlane === 2) {\n\t\t\tplaneSystem = new JSM.CoordSystem (\n\t\t\t\tsystem.origo,\n\t\t\t\te1,\n\t\t\t\te2,\n\t\t\t\tnew JSM.Coord (0.0, 0.0, 0.0)\n\t\t\t);\n\t\t}\n\t\t\n\t\tif (planeSystem === null) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn JSM.CalculatePlanarTextureCoord (coord, planeSystem);\n\t};\n\n\t/**\n\t* Function: CalculateCylindricalTextureCoord\n\t* Description: Calculates the cylindrical texture coordinate for a coordinate.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*\tnormal {Vector} the normal vector for calculation\n\t*\tsystem {CoordSystem} the coordinate system\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.CalculateCylindricalTextureCoord = function (coord, normal, system)\n\t{\n\t\tvar result = new JSM.Coord2D (0.0, 0.0);\n\n\t\tvar e3Direction = system.e3.Clone ().Normalize ();\n\t\tif (e3Direction.IsCollinearWith (normal)) {\n\t\t\tresult = JSM.CalculateCubicTextureCoord (coord, normal, system);\n\t\t\treturn [result, 0.0];\n\t\t}\n\n\t\tvar baseLine = new JSM.Line (system.origo, e3Direction);\n\t\tvar projectedCoord = baseLine.ProjectCoord (coord);\n\t\tvar projectedDistance = JSM.CoordSignedDistance (system.origo, projectedCoord, e3Direction);\n\n\t\tvar e1Direction = system.e1.Clone ().Normalize ();\n\t\tvar coordDirection = JSM.CoordSub (coord, projectedCoord);\n\t\tvar angle = JSM.GetVectorsFullAngle (coordDirection, e1Direction, e3Direction);\n\t\tvar radius = system.e1.Length ();\n\n\t\tresult.x = angle * radius;\n\t\tresult.y = projectedDistance;\n\t\treturn [result, angle];\n\t};\n\n\t/**\n\t* Function: CalculatePolygonPlanarTextureCoords\n\t* Description: Calculates the planar texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonPlanarTextureCoords = function (body, index)\n\t{\n\t\tvar result = [];\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\tresult.push (JSM.CalculatePlanarTextureCoord (coord, system));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCubicTextureCoords\n\t* Description: Calculates the cubic texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t*\tnormal {Vector} the normal vector for calculation\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonCubicTextureCoords = function (body, index, normal)\n\t{\n\t\tvar result = [];\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\tresult.push (JSM.CalculateCubicTextureCoord (coord, normal, system));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCylindricalTextureCoords\n\t* Description: Calculates the cylindrical texture coordinates for a polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t*\tnormal {Vector} the normal vector for calculation\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.CalculatePolygonCylindricalTextureCoords = function (body, index, normal)\n\t{\n\t\tvar result = [];\n\t\tvar angles = [];\n\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar system = body.GetTextureProjection ().GetCoords ();\n\n\t\tvar i, j, coord, textureValues;\n\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\ttextureValues = JSM.CalculateCylindricalTextureCoord (coord, normal, system);\n\t\t\tresult.push (textureValues[0]);\n\t\t\tangles.push (textureValues[1]);\n\t\t}\n\n\t\tvar e3Direction = system.e3.Clone ().Normalize ();\n\t\tif (e3Direction.IsCollinearWith (normal)) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar needRepair = false;\n\t\tfor (i = 0; i < angles.length; i++) {\n\t\t\tfor (j = i + 1; j < angles.length; j++) {\n\t\t\t\tif (JSM.IsGreater (Math.abs (angles[i] - angles[j]), Math.PI)) {\n\t\t\t\t\tneedRepair = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needRepair) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (needRepair) {\n\t\t\tvar radius = system.e1.Length ();\n\t\t\tfor (i = 0; i < angles.length; i++) {\n\t\t\t\tif (JSM.IsLower (angles[i], Math.PI)) {\n\t\t\t\t\tresult[i].x = radius * (angles[i] + 2.0 * Math.PI);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPlanarTextureCoords\n\t* Description: Calculates the planar texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyPlanarTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculatePolygonPlanarTextureCoords (body, i));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyCubicTextureCoords\n\t* Description: Calculates the cubic texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyCubicTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar i, normal;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnormal = polygonNormals[i];\n\t\t\tresult.push (JSM.CalculatePolygonCubicTextureCoords (body, i, normal));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyCylindricalTextureCoords\n\t* Description: Calculates the cylindrical texture coordinates for a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyCylindricalTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar i, normal;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tnormal = polygonNormals[i];\n\t\t\tresult.push (JSM.CalculatePolygonCylindricalTextureCoords (body, i, normal));\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyTextureCoords\n\t* Description:\n\t*\tCalculates the texture coordinates for a body. The result\n\t*\tis an array of arrays of texture coordinates.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Coord2D[*][*]} the result\n\t*/\n\tJSM.CalculateBodyTextureCoords = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar projection = body.GetTextureProjection ().GetType ();\n\t\tif (projection === JSM.TextureProjectionType.Planar) {\n\t\t\tresult = JSM.CalculateBodyPlanarTextureCoords (body);\n\t\t} else if (projection === JSM.TextureProjectionType.Cubic) {\n\t\t\tresult = JSM.CalculateBodyCubicTextureCoords (body);\n\t\t} else if (projection === JSM.TextureProjectionType.Cylindrical) {\n\t\t\tresult = JSM.CalculateBodyCylindricalTextureCoords (body);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/cututils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CutBodyByPlane\n\t* Description: Cuts a body by a plane.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CutBodyByPlane = function (body, plane)\n\t{\n\t\tfunction CutBodyPolygonByPlane (polygon, plane, indexTable)\n\t\t{\n\t\t\tfunction AddOriginalVertex (index, vertex, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\trawResult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\trawIndexTable.push (index);\n\t\t\t}\n\n\t\t\tfunction AddIntersectionVertex (from, to, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\tvar direction = JSM.CoordSub (polygon[to], polygon[from]).Normalize ();\n\t\t\t\tvar line = new JSM.Line (polygon[from], direction);\n\t\t\t\tvar intersection = plane.LineIntersection (line);\n\t\t\t\trawResult.push (new JSM.Coord (intersection.x, intersection.y, intersection.z));\n\t\t\t\trawIndexTable.push (-1);\n\t\t\t}\n\n\t\t\tvar hasIndexTable = (indexTable !== undefined && indexTable !== null);\n\t\t\tvar count = polygon.length;\n\t\t\tvar result = [];\n\t\t\tvar front = [];\n\t\t\t\n\t\t\tvar needCut = false;\n\t\t\tvar i, position, vertex;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tvertex = polygon[i];\n\t\t\t\tposition = plane.CoordPosition (vertex);\n\t\t\t\tfront.push (position !== JSM.CoordPlanePosition.CoordAtBackOfPlane);\n\t\t\t\tif (i > 0 && front[i - 1] !== front[i]) {\n\t\t\t\t\tneedCut = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!needCut) {\n\t\t\t\tif (front[0] === false) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\tvertex = polygon[i];\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tindexTable.push (i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tvar rawResult = [];\n\t\t\tvar rawIndexTable = [];\n\n\t\t\tvar from, to;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfrom = i - 1;\n\t\t\t\tto = i;\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tfrom = count - 1;\n\t\t\t\t}\n\n\t\t\t\tvertex = polygon[to];\n\t\t\t\tif (front[to]) {\n\t\t\t\t\tif (!front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t\tAddOriginalVertex (to, vertex, rawResult, rawIndexTable);\n\t\t\t\t} else {\n\t\t\t\t\tif (front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar currentVertex;\n\t\t\tvar currentIndex;\n\t\t\tvar lastVertex;\n\t\t\tvar lastIndex;\n\t\t\tfor (i = 0; i < rawResult.length; i++) {\n\t\t\t\tcurrentVertex = rawResult[i];\n\t\t\t\tlastVertex = result[result.length - 1];\n\t\t\t\tif (i === 0 || !lastVertex.IsEqual (currentVertex)) {\n\t\t\t\t\tresult.push (new JSM.Coord (currentVertex.x, currentVertex.y, currentVertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tindexTable.push (currentIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tlastIndex = rawIndexTable[i - 1];\n\t\t\t\t\t\tif (currentIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = currentIndex;\n\t\t\t\t\t\t} else if (lastIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = lastIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction GetInsertedVertexIndex (result, vertex, originalVertexCount)\n\t\t{\n\t\t\tvar index = -1;\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = originalVertexCount; i < result.VertexCount (); i++) {\n\t\t\t\tif (vertex.IsEqual (result.GetVertexPosition (i))) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (index === -1) {\n\t\t\t\tindex = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t\t\n\t\t\treturn index;\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar cuttedPolygons = [];\n\t\tvar cuttedIndexTables = [];\n\t\t\n\t\tvar remainsVertex = [];\n\t\tvar originalOldToNewIndex = [];\n\t\t\n\t\tvar i, j, polygon, polygon3D, vertexPosition;\n\t\tvar cuttedPolygon, indexTable;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\n\t\t\tpolygon3D = [];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tvertexPosition = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\tpolygon3D.push (new JSM.Coord (vertexPosition.x, vertexPosition.y, vertexPosition.z));\n\t\t\t}\n\t\t\t\n\t\t\tindexTable = [];\n\t\t\tcuttedPolygon = CutBodyPolygonByPlane (polygon3D, plane, indexTable);\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tremainsVertex[polygon.GetVertexIndex (indexTable[j])] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcuttedPolygons.push (cuttedPolygon);\n\t\t\tcuttedIndexTables.push (indexTable);\n\t\t}\n\n\t\tvar vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tif (remainsVertex[i]) {\n\t\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\t\toriginalOldToNewIndex[i] = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t}\n\n\t\tvar originalVertexCount = result.VertexCount ();\n\n\t\tvar newPolygon, newPolygonVertices;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tcuttedPolygon = cuttedPolygons[i];\n\t\t\tindexTable = cuttedIndexTables[i];\n\t\t\tif (indexTable.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewPolygonVertices = [];\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tnewPolygonVertices.push (originalOldToNewIndex[polygon.GetVertexIndex (indexTable[j])]);\n\t\t\t\t} else {\n\t\t\t\t\tvertex = cuttedPolygon[j];\n\t\t\t\t\tnewPolygonVertices.push (GetInsertedVertexIndex (result, vertex, originalVertexCount));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnewPolygon = new JSM.BodyPolygon (newPolygonVertices);\n\t\t\tnewPolygon.InheritAttributes (polygon);\n\t\t\tresult.AddPolygon (newPolygon);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/generator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateRectangle\n\t* Description: Generates a rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRectangle = function (xSize, ySize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, 0.0)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboid\n\t* Description: Generates a cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboid = function (xSize, ySize, zSize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboidSides\n\t* Description:\n\t*\tGenerates the specified sides of a cuboid. The last parameter is\n\t*\ta boolean array which defines sides visibility.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsides {boolean[]} sides visibility\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboidSides = function (xSize, ySize, zSize, sides)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tif (sides[0]) { result.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3])); }\n\t\tif (sides[1]) { result.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2])); }\n\t\tif (sides[2]) { result.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6])); }\n\t\tif (sides[3]) { result.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7])); }\n\t\tif (sides[4]) { result.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1])); }\n\t\tif (sides[5]) { result.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7])); }\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedRectangle\n\t* Description:\tGenerates a segmented rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\txSegmentation {integer} segmentation along x side\n\t*\tySegmentation {integer} segmentation along y side\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedRectangle = function (xSize, ySize, xSegmentation, ySegmentation)\n\t{\n\t\tfunction AddVertices ()\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, 0.0);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons ()\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar xSegment = xSize / xSegmentation;\n\t\tvar ySegment = ySize / ySegmentation;\n\t\t\n\t\tAddVertices ();\n\t\tAddPolygons ();\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedCuboid\n\t* Description:\tGenerates a segmented cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsegmentation {integer} segmentation of the sides\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedCuboid = function (xSize, ySize, zSize, segmentation)\n\t{\n\t\tfunction GetLevelOffset (level)\n\t\t{\n\t\t\tvar offset = 0;\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\toffset = (segmentation + 1) * (segmentation + 1) + (level - 1) * (segmentation * 4);\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction GetLevelSideVertices (level)\n\t\t{\n\t\t\tvar i;\n\t\t\t\n\t\t\tvar vertices = [];\n\t\t\tvar offset = GetLevelOffset (level);\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + (i + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (segmentation + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + i * (segmentation + 1));\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (3 * segmentation) + i - 1);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn vertices;\n\t\t}\n\n\t\tfunction AddVertices (level)\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tvar zCoord = level * zSegment;\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tif (i === 0 || i === segmentation || j === 0 || j === segmentation) {\n\t\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (level)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tvar offset = GetLevelOffset (level);\n\t\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\t\t\tcurrent = offset + i * (segmentation + 1) + j;\n\t\t\t\t\t\tnext = current + 1;\n\t\t\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, top, ntop, next]));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\tvar prevSideVertices = levelSideVertices [level - 1];\n\t\t\t\tvar currSideVertices = levelSideVertices [level];\n\t\t\t\tfor (i = 0; i < segmentation * 4; i++) {\n\t\t\t\t\tcurrent = prevSideVertices[i];\n\t\t\t\t\ttop = currSideVertices[i];\n\t\t\t\t\tif (i < segmentation * 4 - 1) {\n\t\t\t\t\t\tnext = prevSideVertices[i + 1];\n\t\t\t\t\t\tntop = currSideVertices[i + 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = prevSideVertices[0];\n\t\t\t\t\t\tntop = currSideVertices[0];\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar zStart = zSize / 2.0;\n\t\t\n\t\tvar xSegment = xSize / segmentation;\n\t\tvar ySegment = ySize / segmentation;\n\t\tvar zSegment = zSize / segmentation;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddVertices (i);\n\t\t}\n\t\t\n\t\tvar levelSideVertices = [];\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tlevelSideVertices.push (GetLevelSideVertices (i));\n\t\t}\n\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddPolygons (i);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCircle\n\t* Description:\tGenerates a circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {integer} the segmentation of the circle\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCircle = function (radius, segmentation)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar circlePoints = JSM.GenerateCirclePoints (radius, segmentation);\n\t\tvar i;\n\t\tfor (i = 0; i < circlePoints.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (circlePoints[i]));\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\ttopPolygon.AddVertexIndex (i);\n\t\t}\n\t\tresult.AddPolygon (topPolygon);\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSphere\n\t* Description: Generates a sphere.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\tsegmentation {integer} the segmentation of the sphere\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSphere = function (radius, segmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar segments = segmentation;\n\t\tvar circle = segments * 2;\n\n\t\tvar topIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, 0.0, 0.0)));\n\t\tvar step = Math.PI / segments;\n\t\tvar theta = step;\n\t\t\n\t\tvar i, j, phi;\n\t\tfor (i = 1; i < segments; i++) {\n\t\t\tphi = 0;\n\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, theta, phi)));\n\t\t\t\tphi += step;\n\t\t\t}\n\t\t\ttheta += step;\n\t\t}\n\t\tvar bottomIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (-radius, 0.0, 0.0)));\n\n\t\tvar offset, current, next, top, ntop, polygon;\n\t\tfor (i = 1; i <= segments; i++) {\n\t\t\tif (i === 1) {\n\t\t\t\toffset = 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, topIndex]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i < segments) {\n\t\t\t\toffset = (i - 1) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current - circle;\n\t\t\t\t\tntop = top + 1;\n\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t\tntop = offset - circle;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i === segments) {\n\t\t\t\toffset = (i - 2) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, bottomIndex, next]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTriangulatedSphere\n\t* Description: Generates a sphere from triangles.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\titerations {integer} the iteration number\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriangulatedSphere = function (radius, iterations, isCurved)\n\t{\n\t\tfunction GenerateIcosahedron () {\n\t\t\tvar result = new JSM.Body ();\n\n\t\t\tvar a = 1.0;\n\t\t\tvar b = 0.0;\n\t\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 9, 2]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 10, 3]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 9, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 10, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [4, 8, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [6, 11, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [5, 10, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [7, 9, 11]);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tvar result = GenerateIcosahedron ();\n\t\t\n\t\tvar currentRadius = result.GetVertexPosition (0).Length ();\n\t\tvar scale = radius / currentRadius;\n\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t}\n\t\t\n\t\tvar iteration, oldVertexCoord, oldBody, adjacencyInfo;\n\t\tvar currentEdge, edgeVertexIndices;\n\t\tvar currentPgon, polygonVertexIndices;\n\t\tvar edgeCoord, currentPolyEdge;\n\t\tfor (iteration = 0; iteration < iterations; iteration++) {\n\t\t\toldBody = result;\n\t\t\t\n\t\t\tresult = new JSM.Body ();\n\t\t\tadjacencyInfo = new JSM.AdjacencyInfo (oldBody);\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\toldVertexCoord = oldBody.GetVertexPosition (i);\n\t\t\t\tJSM.AddVertexToBody (result, oldVertexCoord.x, oldVertexCoord.y, oldVertexCoord.z);\n\t\t\t}\n\t\t\t\n\t\t\tedgeVertexIndices = [];\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tcurrentEdge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (oldBody.GetVertexPosition (currentEdge.vert1), oldBody.GetVertexPosition (currentEdge.vert2));\n\t\t\t\tedgeVertexIndices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord.SetLength (radius))));\n\t\t\t}\n\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tcurrentPgon = adjacencyInfo.pgons[i];\n\t\t\t\tpolygonVertexIndices = [];\n\t\t\t\tfor (j = 0; j < currentPgon.pedges.length; j++) {\n\t\t\t\t\tcurrentPolyEdge = currentPgon.pedges[j];\n\t\t\t\t\tpolygonVertexIndices.push (adjacencyInfo.GetPolyEdgeStartVertex (currentPolyEdge));\n\t\t\t\t\tpolygonVertexIndices.push (edgeVertexIndices[currentPolyEdge.index]);\n\t\t\t\t}\n\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[0], polygonVertexIndices[1], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[2], polygonVertexIndices[3]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[3], polygonVertexIndices[4], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[3], polygonVertexIndices[5]]);\n\t\t\t}\n\t\t}\n\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < result.PolygonCount (); i++) {\n\t\t\t\tresult.GetPolygon (i).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinder\n\t* Description: Generates a cylinder.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinder = function (radius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePie\n\t* Description: Generates a pie.\n\t* Parameters:\n\t*\tradius {number} the radius of the pie\n\t*\theight {number} the height of the pie\n\t*\tangle {number} the angle of the pie\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePie = function (radius, height, angle, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = angle;\n\t\tvar step = angle / (segments - 1);\n\t\t\n\t\tvar i;\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i <= segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved && i > 0 && i < segments) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i <= segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCone\n\t* Description: Generates a cone.\n\t* Parameters:\n\t*\ttopRadius {number} the top radius of the cone\n\t*\tbottomRadius {number} the bottom radius of the cone\n\t*\theight {number} the height of the cone\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCone = function (topRadius, bottomRadius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar topDegenerated = (JSM.IsZero (topRadius));\n\t\tvar bottomDegenerated = (JSM.IsZero (bottomRadius));\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\n\t\tif (topDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\t}\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (!topDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (topRadius, height / 2.0, theta)));\n\t\t\t}\n\t\t\tif (!bottomDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (bottomRadius, -height / 2.0, theta)));\n\t\t\t}\n\t\t\ttheta -= step;\n\t\t}\n\t\tif (bottomDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tcurrent = i + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 1;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([0, next, current]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\tcurrent = i;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, segments]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else {\n\t\t\t\tcurrent = 2 * i;\n\t\t\t\tnext = current + 2;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tvar topPolygon, bottomPolygon;\n\t\tif (withTopAndBottom) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\tbottomPolygon.AddVertexIndex (i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (segments - i - 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t} else {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t}\n\t\t}\n\n\t\tvar avgRadius = (topRadius + bottomRadius) / 2.0;\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), avgRadius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismGeometry\n\t* Description: Generates a prism defined by bottom and top vertices polygon.\n\t* Parameters:\n\t*\tbottomVertices {Coord[*]} bottom vertices\n\t*\ttopVertices {Coord[*]} top vertices\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismGeometry = function (bottomVertices, topVertices, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = bottomVertices.length;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (bottomVertices[i].Clone ()));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (topVertices[i].Clone ()));\n\t\t}\n\n\t\tvar current, next, bodyPolygon;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * (count - i - 1));\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismFromPolygon\n\t* Description: Generates a prism defined by a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the base polygon\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismFromPolygon = function (polygon, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i, vertex;\n\t\tvar count = polygon.VertexCount ();\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tbottomVertices.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\ttopVertices.push (new JSM.Coord (vertex.x, vertex.y, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = bottomVertices[0].Clone ();\n\t\tvar firtVertex = bottomVertices[1].Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrism\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The base polygon is an array\n\t*\tof coordinates which will be offseted in the given direction.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrism = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.FromArray (basePolygon);\n\t\tvar count = polygon.VertexCount ();\n\n\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tbottomVertices.push (polygon.GetVertex (i).Clone ());\n\t\t\ttopVertices.push (polygon.GetVertex (i).Clone ().Offset (direction, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\t\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = polygon.GetVertex (0).Clone ();\n\t\tvar firtVertex = polygon.GetVertex (1).Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismWithHole\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The polygon can contain null\n\t*\tvalues which defines the end of the current contour. The holes have\n\t*\tto be in reversed orientation than the main contour.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon which can contain null values\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismWithHole = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction AddVertices (contourPolygon, direction, height, result)\n\t\t{\n\t\t\tvar i, j, contour, vertex1, vertex2;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex1 = contour.GetVertex (j).Clone ();\n\t\t\t\t\tvertex2 = contour.GetVertex (j).Clone ().Offset (direction, height);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex1));\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddContours (contourPolygon, contourOffsets, curveAngle, result)\n\t\t{\n\t\t\tvar offset = 0;\n\n\t\t\tvar i, j, contour, vertexCount, current, next, bodyPolygon, curveGroups;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tcurveGroups = null;\n\t\t\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\t\t\tcurveGroups = JSM.CalculatePolygonCurveGroups (contour, curveAngle);\n\t\t\t\t}\t\t\n\t\t\t\tvertexCount = contour.VertexCount ();\n\t\t\t\tcontourOffsets.push (offset);\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tcurrent = 2 * offset + 2 * j;\n\t\t\t\t\tnext = current + 2;\n\t\t\t\t\tif (j == vertexCount - 1) {\n\t\t\t\t\t\tnext = 2 *  offset;\n\t\t\t\t\t}\n\t\t\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\t\tif (curveGroups !== null) {\n\t\t\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t\t\t}\n\t\t\t\toffset += vertexCount;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddTopBottomPolygons (contourPolygon, contourOffsets)\n\t\t{\n\t\t\tvar vertexMap = [];\n\t\t\tvar contourPolygon2D = contourPolygon.ToContourPolygon2D ();\n\t\t\tvar simplePolygon = JSM.ConvertContourPolygonToPolygon2D (contourPolygon2D, vertexMap);\n\t\t\tif (simplePolygon === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar triangles = JSM.TriangulatePolygon2D (simplePolygon);\n\t\t\tif (triangles === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, j, triangle, mapValue;\n\t\t\tvar topTriangle, bottomTriangle;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\ttriangle = triangles[i];\n\t\t\t\ttopTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\tmapValue = vertexMap[triangle[j]];\n\t\t\t\t\ttopTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1] + 1);\n\t\t\t\t\tmapValue = vertexMap[triangle[2 - j]];\n\t\t\t\t\tbottomTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1]);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topTriangle);\n\t\t\t\tresult.AddPolygon (bottomTriangle);\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar contourOffsets = [];\n\t\tvar contourPolygon = new JSM.ContourPolygon ();\n\t\tcontourPolygon.FromArray (basePolygon);\n\t\tAddVertices (contourPolygon, direction, height, result);\n\t\tAddContours (contourPolygon, contourOffsets, curveAngle, result);\n\n\t\tif (withTopAndBottom) {\n\t\t\tAddTopBottomPolygons (contourPolygon, contourOffsets);\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismsFromPath2D\n\t* Description: Generates a prism from the given path.\n\t* Parameters:\n\t*\tpath {Path2D} the path\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body[*]} the result\n\t*/\n\tJSM.GeneratePrismsFromPath2D = function (path, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction GetPrismPolygon (polygon)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i, j, contour, vertex;\n\t\t\tfor (i = 0; i < polygon.ContourCount (); i++) {\n\t\t\t\tcontour = polygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\t\t}\n\t\t\t\tif (i < polygon.ContourCount () - 1) {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar bodies = [];\n\t\tvar polygons = path.GetPolygons ();\n\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygon = polygons[i];\n\t\t\tif (polygon.ContourCount () === 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrism (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t} else if (polygon.ContourCount () > 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrismWithHole (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t}\n\t\t}\n\t\treturn bodies;\n\t};\n\n\t/**\n\t* Function: GeneratePrismShell\n\t* Description: Generates a prism with the given width of sides.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismShell = function (basePolygon, direction, height, width, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolygon.length;\n\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygon[i]));\n\t\t}\n\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.vertices = basePolygon;\n\t\tvar offsetedPolygon = JSM.OffsetPolygonContour (polygon, width);\n\t\tvar innerBasePolygon = offsetedPolygon.vertices;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolygon[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar curr, next, top, ntop;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t\tntop = 2 * count;\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t\tntop = count;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinderShell\n\t* Description: Generates a cylinder with the given width of sides.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\twidth {number} the width of the cylinder sides\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinderShell = function (radius, height, width, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tfunction GenerateCircle (radius, segmentation, bottom)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar step = 2.0 * Math.PI / segmentation;\n\t\t\tvar theta, cartesian;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttheta = i * step;\n\t\t\t\tcartesian = JSM.PolarToCartesian (radius, theta);\n\t\t\t\tresult.push (new JSM.Coord (cartesian.x, cartesian.y, bottom));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar circle = GenerateCircle (radius, segmentation, -height / 2.0);\n\t\tvar result = JSM.GeneratePrismShell (circle, normal, height, width, withTopAndBottom);\n\t\t\n\t\tvar i;\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\tresult.GetPolygon (2 * i).SetCurveGroup (0);\n\t\t\t\tresult.GetPolygon (2 * i + 1).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateLineShell\n\t* Description: Generates a polyline with width and height.\n\t* Parameters:\n\t*\tbasePolyLine {Coord[*]} the base polyline\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the shell\n\t*\twidth {number} the width of the shell\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLineShell = function (basePolyLine, direction, height, width, withStartAndEnd, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolyLine.length;\n\n\t\tvar angles = [];\n\t\t\n\t\tvar i, prev, curr, next;\n\t\tvar prevDir, nextDir, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (i === 0 || i === count - 1) {\n\t\t\t\tangle = Math.PI / 2.0;\n\t\t\t} else {\n\t\t\t\tprev = i - 1;\n\t\t\t\tcurr = i;\n\t\t\t\tnext = i + 1;\n\n\t\t\t\tnextDir = JSM.CoordSub (basePolyLine[next], basePolyLine[curr]);\n\t\t\t\tprevDir = JSM.CoordSub (basePolyLine[prev], basePolyLine[curr]);\n\t\t\t\tangle = nextDir.AngleTo (prevDir) / 2.0;\n\t\t\t\tif (JSM.CoordOrientation (basePolyLine[prev], basePolyLine[curr], basePolyLine[next], direction) == JSM.Orientation.Clockwise) {\n\t\t\t\t\tangle = Math.PI - angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tangles.push (angle);\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0, 0, 1);\n\t\tvar innerBasePolyLine = [];\n\t\tvar distance, innerCoord, offsetDirection;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tif (i === count - 1) {\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr - 1], basePolyLine[curr]);\n\t\t\t} else {\n\t\t\t\tnext = (i + 1) % count;\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr], basePolyLine[next]);\n\t\t\t}\n\n\t\t\tangle = angles[curr];\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\tinnerCoord = basePolyLine[curr].Clone ();\n\t\t\tinnerCoord.Offset (offsetDirection, distance);\n\t\t\tinnerCoord.Rotate (normal, -(Math.PI - angle), basePolyLine[curr]);\n\t\t\tinnerBasePolyLine.push (innerCoord);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolyLine[i]));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolyLine[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar top, ntop;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tcurr = 0;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\n\t\t\tcurr = count - 1;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolyLine[1], basePolyLine[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolyLine[0].x, basePolyLine[0].y, basePolyLine[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTorus\n\t* Description: Generates a torus.\n\t* Parameters:\n\t*\touterRadius {number} the outer radius of the torus\n\t*\tinnerRadius {number} the inner radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tinnerSegmentation {integer} the inner segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTorus = function (outerRadius, innerRadius, outerSegmentation, innerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar theta = 0.0;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = JSM.PolarToCartesian (innerRadius, theta);\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePolyTorus\n\t* Description: Generates a torus with a polygon cross section.\n\t* Parameters:\n\t*\tbasePolygon {Coord2D[*]} the cross section polygon of the torus\n\t*\touterRadius {number} the outer radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePolyTorus = function (basePolygon, outerRadius, outerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar innerSegmentation = basePolygon.length;\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = basePolygon[i];\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (j);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectors\n\t* Description: Generates a ruled surface between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectors = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateGrid\n\t* Description: Generates a planar grid.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\tySize {number} the y size\n\t*\txSegmentation {integer} the segmentation along x axis\n\t*\tySegmentation {integer} the segmentation along y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGrid = function (xSize, ySize, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tvar xSector = new JSM.Sector (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (xSize, 0.0, 0.0));\n\t\tvar ySector = new JSM.Sector (new JSM.Coord (0.0, ySize, 0.0), new JSM.Coord (xSize, ySize, 0.0));\n\t\treturn JSM.GenerateRuledFromSectors (xSector, ySector, xSegmentation, ySegmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateSquareGrid\n\t* Description: Generates a planar square grid.\n\t* Parameters:\n\t*\tsize {number} the size\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSquareGrid = function (size, segmentation, isCurved)\n\t{\n\t\treturn JSM.GenerateGrid (size, size, segmentation, segmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectorsWithHeight\n\t* Description: Generates a ruled surface with height between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\theight {height} the height\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectorsWithHeight = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved, height)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\t\t\n\t\tvar topVertexCount = result.VertexCount ();\n\n\t\tvar newVertex, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tnewVertex = new JSM.Coord (vertex.x, vertex.y, vertex.z);\n\t\t\tnewVertex.z -= height;\n\t\t\tresult.AddVertex (new JSM.BodyVertex (newVertex));\n\t\t}\n\n\t\tvar j, newpolygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tnewpolygonVertexIndices = [];\n\t\t\tfor (j = polygonVertexIndices.length - 1; j >= 0; j--) {\n\t\t\t\tnewpolygonVertexIndices.push (polygonVertexIndices[j] + topVertexCount);\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon (newpolygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tvar current, next, top, ntop;\n\t\t\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + (lineSegmentation * (meshSegmentation + 1)) + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = i * (meshSegmentation + 1) + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = (i + 1) * meshSegmentation + i + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromCoords\n\t* Description:\n\t*\tGenerates a ruled surface between two coordinate arrays.\n\t*\tThe two arrays should have the same length.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromCoords = function (aCoords, bCoords, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tvertices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (vertices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRevolved\n\t* Description:\n\t*\tGenerates a revolved surface by rotating a polyline around a given axis.\n\t*\tIf the angle is 360 degree, it can generate top and bottom polygons.\n\t* Parameters:\n\t*\tpolyLine {Coord[*]} the polyline\n\t*\taxis {Sector} the axis\n\t*\tangle {number} the angle\n\t*\tsegmentation {integer} the segmentation\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveMode {string} 'None', 'CurveSegments', or 'CurveAll'\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRevolved = function (polyLine, axis, angle, segmentation, withTopAndBottom, curveMode)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar circular = JSM.IsEqual (angle, 2.0 * Math.PI);\n\n\t\tvar count = polyLine.length;\n\t\tvar step = angle / segmentation;\n\t\tvar axisDir = JSM.CoordSub (axis.end, axis.beg);\n\t\t\n\t\tvar i, j, rotated;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\tif (circular && j === segmentation) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trotated = polyLine[i].Clone ().Rotate (axisDir, j * step, axis.beg);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar curveModeFlag = 0;\n\t\tif (curveMode == 'CurveSegments') {\n\t\t\tcurveModeFlag = 1;\n\t\t} else if (curveMode == 'CurveAll') {\n\t\t\tcurveModeFlag = 2;\n\t\t}\n\t\t\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\tcurrent = i * (segmentation + 1) + j;\n\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tif (circular) {\n\t\t\t\t\tcurrent = i * segmentation + j;\n\t\t\t\t\ttop = current + segmentation;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tif (j === segmentation - 1) {\n\t\t\t\t\t\tnext = i * segmentation;\n\t\t\t\t\t\tntop = (i + 1) * segmentation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (curveModeFlag == 1) {\n\t\t\t\t\tpolygon.SetCurveGroup (i);\n\t\t\t\t} else if (curveModeFlag == 2) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tif (circular && withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (segmentation * (count - 1) + i);\n\t\t\t\tbottomPolygon.AddVertexIndex (segmentation - i - 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tvar axisNormalDir = axisDir.Clone ().Normalize ();\n\t\tvar axisLine = new JSM.Line (axis.beg, axisNormalDir);\n\t\tvar avgRadius = 0.0;\n\t\tvar projected;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprojected = axisLine.ProjectCoord (polyLine[i]);\n\t\t\tavgRadius = avgRadius + projected.DistanceTo (polyLine[i]);\n\t\t}\n\t\tavgRadius = avgRadius / count;\n\t\t\n\t\tvar origo = new JSM.Coord (axis.beg.x, axis.beg.y, axis.beg.z);\n\t\tvar baseLine = new JSM.Line (origo, axisDir);\n\t\tvar projectedToBaseLine = baseLine.ProjectCoord (polyLine[0]);\n\t\tvar xDirection = JSM.CoordSub (polyLine[0], projectedToBaseLine).Normalize ();\n\t\t\n\t\tresult.SetCylindricalTextureProjection (origo, avgRadius, xDirection, axisNormalDir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTube\n\t* Description:\n\t*\tGenerates a tube from a given array of polygons. All of the\n\t*\tpolygons should have same number of vertices.\n\t* Parameters:\n\t*\tbasePolygons {Coord[*][*]} the array of polygons\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTube = function (basePolygons, withStartAndEnd)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar contourCount = basePolygons.length;\n\t\tvar count = basePolygons[0].length;\n\n\t\tvar i, j;\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tfor (i = 0; i < contourCount; i++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygons[i][j]));\n\t\t\t}\n\t\t}\n\n\t\tvar current, next;\n\t\tfor (j = 0; j < contourCount - 1; j++) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = j + contourCount * i;\n\t\t\t\tnext = current + contourCount;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, next + 1, current + 1]));\n\t\t\t}\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (contourCount * i + contourCount - 1);\n\t\t\t}\n\t\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\t\tbottomPolygon.AddVertexIndex (contourCount * i);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurface\n\t* Description: Generates the surface of a given function.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurface = function (function3D, intervalMin, intervalMax, segmentation, isCurved)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMin.y, 0.0), new JSM.Coord (intervalMax.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMax.y, 0.0), new JSM.Coord (intervalMax.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectors (aSector, bSector, segmentation, segmentation, isCurved);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurfaceSolid\n\t* Description: Generates the surface of a given function with a solid body.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tbottomZ {number} the bottom z coordinate of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurfaceSolid = function (function3D, intervalMin, intervalMax, segmentation, isCurved, bottomZ)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMin.y, 0.0), new JSM.Coord (intervalMin.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMax.y, 0.0), new JSM.Coord (intervalMin.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectorsWithHeight (aSector, bSector, segmentation, segmentation, isCurved, bottomZ);\n\n\t\tvar i, coord;\n\t\tvar topVertexCount = (segmentation + 1) * (segmentation + 1);\n\t\tfor (i = 0; i < topVertexCount; i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/camera',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: Camera\n\t* Description: Represents a camera.\n\t* Parameters:\n\t*\teye {Coord} the eye position\n\t*\tcenter {Coord} the center position\n\t*\tup {Vector} the up vector\n\t*\tfieldOfView {number} field of view in degree\n\t*\tnearClippingPlane {number} near clipping plane distance\n\t*\tfarClippingPlane {number} far clipping plane distance\n\t*/\n\tJSM.Camera = function (eye, center, up, fieldOfView, nearClippingPlane, farClippingPlane)\n\t{\n\t\tthis.eye = JSM.ValueOrDefault (eye, new JSM.Coord (1.0, 1.0, 1.0));\n\t\tthis.center = JSM.ValueOrDefault (center, new JSM.Coord (0.0, 0.0, 0.0));\n\t\tthis.up = JSM.ValueOrDefault (up, new JSM.Vector (0.0, 0.0, 1.0));\n\t\tthis.fieldOfView = JSM.ValueOrDefault (fieldOfView, 45.0);\n\t\tthis.nearClippingPlane = JSM.ValueOrDefault (nearClippingPlane, 0.1);\n\t\tthis.farClippingPlane = JSM.ValueOrDefault (farClippingPlane, 1000.0);\n\t};\n\n\t/**\n\t* Function: Camera.Set\n\t* Description: Sets the camera.\n\t* Parameters:\n\t*\teye {Coord} the eye position\n\t*\tcenter {Coord} the center position\n\t*\tup {Vector} the up vector\n\t*\tfieldOfView {number} field of view in degree\n\t*\tnearClippingPlane {number} near clipping plane distance\n\t*\tfarClippingPlane {number} far clipping plane distance\n\t*/\n\tJSM.Camera.prototype.Set = function (eye, center, up, fieldOfView, nearClippingPlane, farClippingPlane)\n\t{\n\t\tthis.eye = eye;\n\t\tthis.center = center;\n\t\tthis.up = up;\n\t\tthis.fieldOfView = JSM.ValueOrDefault (fieldOfView, 45.0);\n\t\tthis.nearClippingPlane = JSM.ValueOrDefault (nearClippingPlane, 0.1);\n\t\tthis.farClippingPlane = JSM.ValueOrDefault (farClippingPlane, 1000.0);\n\t};\n\n\t/**\n\t* Function: Camera.Clone\n\t* Description: Clones the camera.\n\t* Returns:\n\t*\t{Camera} a cloned instance\n\t*/\n\tJSM.Camera.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Camera ();\n\t\tresult.eye = this.eye;\n\t\tresult.center = this.center;\n\t\tresult.up = this.up;\n\t\tresult.fieldOfView = this.fieldOfView;\n\t\tresult.nearClippingPlane = this.nearClippingPlane;\n\t\tresult.farClippingPlane = this.farClippingPlane;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/explode',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ExplodeBody\n\t* Description:\n\t*\tExplodes a body to primitives. The function calls callback functions\n\t*\ton geometry start and end, and when a triangle or a line is created.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\texplodeData {object} the parameters and callback functions of explode\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ExplodeBody = function (body, materials, explodeData)\n\t{\n\t\tfunction SeparateByMaterial (materials, itemsByMaterial, itemsWithNoMaterial, callbacks)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\titemsByMaterial.push ([]);\n\t\t\t}\n\n\t\t\tvar itemCount = callbacks.itemCount ();\n\t\t\tvar material;\n\t\t\tfor (i = 0; i < itemCount; i++) {\n\t\t\t\tmaterial = callbacks.getMaterial (i);\n\t\t\t\tif (material !== -1) {\n\t\t\t\t\titemsByMaterial[material].push (i);\n\t\t\t\t} else {\n\t\t\t\t\titemsWithNoMaterial.push (i);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\tfunction ExplodePoints (body, materials, explodeData)\n\t\t{\n\t\t\tfunction ExplodePointsByMaterial (pointIndices, materialIndex, explodeData)\n\t\t\t{\n\t\t\t\tif (pointIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onPointGeometryStart !== undefined && explodeData.onPointGeometryStart !== null) {\n\t\t\t\t\texplodeData.onPointGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onPoint !== undefined && explodeData.onPoint !== null) {\n\t\t\t\t\tvar i, point, vertex;\n\t\t\t\t\tfor (i = 0; i < pointIndices.length; i++) {\n\t\t\t\t\t\tpoint = body.GetPoint (pointIndices[i]);\n\t\t\t\t\t\tvertex = body.GetVertexPosition (point.GetVertexIndex ());\n\t\t\t\t\t\texplodeData.onPoint (vertex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onPointGeometryEnd !== undefined && explodeData.onPointGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onPointGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.PointCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pointsByMaterial = [];\n\t\t\tvar pointsWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, pointsByMaterial, pointsWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.PointCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar point = body.GetPoint (index);\n\t\t\t\t\treturn point.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar i;\t\t\n\t\t\tfor (i = 0; i < pointsByMaterial.length; i++) {\n\t\t\t\tExplodePointsByMaterial (pointsByMaterial[i], i, explodeData);\n\t\t\t}\n\t\t\tExplodePointsByMaterial (pointsWithNoMaterial, -1, explodeData);\n\t\t}\n\n\t\tfunction ExplodeLines (body, materials, explodeData)\n\t\t{\n\t\t\tfunction ExplodeLinesByMaterial (lineIndices, materialIndex, explodeData)\n\t\t\t{\n\t\t\t\tif (lineIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onLineGeometryStart !== undefined && explodeData.onLineGeometryStart !== null) {\n\t\t\t\t\texplodeData.onLineGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onLine !== undefined && explodeData.onLine !== null) {\n\t\t\t\t\tvar i, line, beg, end;\n\t\t\t\t\tfor (i = 0; i < lineIndices.length; i++) {\n\t\t\t\t\t\tline = body.GetLine (lineIndices[i]);\n\t\t\t\t\t\tbeg = body.GetVertexPosition (line.GetBegVertexIndex ());\n\t\t\t\t\t\tend = body.GetVertexPosition (line.GetEndVertexIndex ());\n\t\t\t\t\t\texplodeData.onLine (beg, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onLineGeometryEnd !== undefined && explodeData.onLineGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onLineGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.LineCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar linesByMaterial = [];\n\t\t\tvar linesWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, linesByMaterial, linesWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.LineCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar line = body.GetLine (index);\n\t\t\t\t\treturn line.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar i;\t\t\n\t\t\tfor (i = 0; i < linesByMaterial.length; i++) {\n\t\t\t\tExplodeLinesByMaterial (linesByMaterial[i], i, explodeData);\n\t\t\t}\n\t\t\tExplodeLinesByMaterial (linesWithNoMaterial, -1, explodeData);\n\t\t}\n\n\t\tfunction ExplodePolygons (body, materials, explodeData)\n\t\t{\n\t\t\tfunction CalculatePolygonsDerivedData (body, materials)\n\t\t\t{\n\t\t\t\tvar vertexNormals = JSM.CalculateBodyVertexNormals (body);\n\n\t\t\t\tvar i, j;\n\t\t\t\tvar hasTextureCoords = false;\n\t\t\t\tif (materials !== undefined && materials !== null) {\n\t\t\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\t\t\tif (materials.GetMaterial (i).texture !== null) {\n\t\t\t\t\t\t\thasTextureCoords = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar textureCoords = null;\n\t\t\t\tvar polygon, material;\n\t\t\t\tif (hasTextureCoords) {\n\t\t\t\t\ttextureCoords = JSM.CalculateBodyTextureCoords (body);\n\t\t\t\t\tfor (i = 0; i < textureCoords.length; i++) {\n\t\t\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\t\t\tif (polygon.HasMaterialIndex ()) {\n\t\t\t\t\t\t\tmaterial = materials.GetMaterial (polygon.GetMaterialIndex ());\n\t\t\t\t\t\t\tfor (j = 0; j < textureCoords[i].length; j++) {\n\t\t\t\t\t\t\t\ttextureCoords[i][j].x /= material.textureWidth;\n\t\t\t\t\t\t\t\ttextureCoords[i][j].y /= -material.textureHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tvertexNormals : vertexNormals,\n\t\t\t\t\ttextureCoords : textureCoords\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tfunction ExplodePolygonsByMaterial (polygonIndices, materialIndex, derivedData, explodeData)\n\t\t\t{\n\t\t\t\tfunction ExplodePolygon (index, derivedData, explodeData)\n\t\t\t\t{\n\t\t\t\t\tfunction CreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (explodeData.onTriangle !== undefined && explodeData.onTriangle !== null) {\n\t\t\t\t\t\t\texplodeData.onTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\t\t\tif (count < 3) {\n\t\t\t\t\t\tJSM.Message ('Invalid polygon found.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar vertex1, vertex2, vertex3;\n\t\t\t\t\tvar normal1, normal2, normal3;\n\t\t\t\t\tvar uv1, uv2, uv3;\n\n\t\t\t\t\tvar convexPolygon = false;\n\t\t\t\t\tif (explodeData.hasConvexPolygons !== undefined && explodeData.hasConvexPolygons !== null) {\n\t\t\t\t\t\tconvexPolygon = explodeData.hasConvexPolygons;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i;\n\t\t\t\t\tif (count == 3 || convexPolygon) {\n\t\t\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\t\t\tvertex1 = body.GetVertexPosition (polygon.GetVertexIndex (0));\n\t\t\t\t\t\t\tvertex2 = body.GetVertexPosition (polygon.GetVertexIndex ((i + 1) % count));\n\t\t\t\t\t\t\tvertex3 = body.GetVertexPosition (polygon.GetVertexIndex ((i + 2) % count));\n\t\t\t\t\t\t\tnormal1 = derivedData.vertexNormals[index][0];\n\t\t\t\t\t\t\tnormal2 = derivedData.vertexNormals[index][(i + 1) % count];\n\t\t\t\t\t\t\tnormal3 = derivedData.vertexNormals[index][(i + 2) % count];\n\t\t\t\t\t\t\tuv1 = null;\n\t\t\t\t\t\t\tuv2 = null;\n\t\t\t\t\t\t\tuv3 = null;\n\t\t\t\t\t\t\tif (derivedData.textureCoords !== null) {\n\t\t\t\t\t\t\t\tuv1 = derivedData.textureCoords[index][0];\n\t\t\t\t\t\t\t\tuv2 = derivedData.textureCoords[index][(i + 1) % count];\n\t\t\t\t\t\t\t\tuv3 = derivedData.textureCoords[index][(i + 2) % count];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar polygon3D = new JSM.Polygon ();\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar vertex;\n\t\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\t\tvertex = body.GetVertexPosition (polygon.vertices[i]);\n\t\t\t\t\t\t\tpolygon3D.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar normal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\t\t\tvar triangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\t\t\tif (triangles !== null) {\n\t\t\t\t\t\t\tvar triangle;\n\t\t\t\t\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\t\t\t\t\ttriangle = triangles[i];\n\t\t\t\t\t\t\t\tvertex1 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[0]));\n\t\t\t\t\t\t\t\tvertex2 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[1]));\n\t\t\t\t\t\t\t\tvertex3 = body.GetVertexPosition (polygon.GetVertexIndex (triangle[2]));\n\t\t\t\t\t\t\t\tnormal1 = derivedData.vertexNormals[index][triangle[0]];\n\t\t\t\t\t\t\t\tnormal2 = derivedData.vertexNormals[index][triangle[1]];\n\t\t\t\t\t\t\t\tnormal3 = derivedData.vertexNormals[index][triangle[2]];\n\t\t\t\t\t\t\t\tuv1 = null;\n\t\t\t\t\t\t\t\tuv2 = null;\n\t\t\t\t\t\t\t\tuv3 = null;\n\t\t\t\t\t\t\t\tif (derivedData.textureCoords !== null) {\n\t\t\t\t\t\t\t\t\tuv1 = derivedData.textureCoords[index][triangle[0]];\n\t\t\t\t\t\t\t\t\tuv2 = derivedData.textureCoords[index][triangle[1]];\n\t\t\t\t\t\t\t\t\tuv3 = derivedData.textureCoords[index][triangle[2]];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tCreateTriangle (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tJSM.Message ('Triangulation failed.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (polygonIndices.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials.GetMaterial (materialIndex);\n\t\t\t\tif (explodeData.onGeometryStart !== undefined && explodeData.onGeometryStart !== null) {\n\t\t\t\t\texplodeData.onGeometryStart (material);\n\t\t\t\t}\n\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < polygonIndices.length; i++) {\n\t\t\t\t\tExplodePolygon (polygonIndices[i], derivedData, explodeData);\n\t\t\t\t}\n\n\t\t\t\tif (explodeData.onGeometryEnd !== undefined && explodeData.onGeometryEnd !== null) {\n\t\t\t\t\texplodeData.onGeometryEnd (material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body.PolygonCount () === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar polygonsByMaterial = [];\n\t\t\tvar polygonsWithNoMaterial = [];\n\t\t\tSeparateByMaterial (materials, polygonsByMaterial, polygonsWithNoMaterial, {\n\t\t\t\titemCount : function () {\n\t\t\t\t\treturn body.PolygonCount ();\n\t\t\t\t},\n\t\t\t\tgetMaterial : function (index) {\n\t\t\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\t\t\treturn polygon.GetMaterialIndex ();\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar derivedData = CalculatePolygonsDerivedData (body, materials);\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygonsByMaterial.length; i++) {\n\t\t\t\tExplodePolygonsByMaterial (polygonsByMaterial[i], i, derivedData, explodeData);\n\t\t\t}\n\t\t\tExplodePolygonsByMaterial (polygonsWithNoMaterial, -1, derivedData, explodeData);\n\t\t}\n\n\t\tif (explodeData === undefined || explodeData === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (materials === undefined || materials === null) {\n\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t}\t\n\t\t\n\t\tExplodePoints (body, materials, explodeData);\n\t\tExplodeLines (body, materials, explodeData);\n\t\tExplodePolygons (body, materials, explodeData);\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/exporter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ExportBodyContentToStl\n\t* Description: Exports a body content to stl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tname {string} name the body\n\t*\thasConvexPolygons {boolean} the body has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyContentToStl = function (body, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddTriangleToContent (normal, vertex1, vertex2, vertex3)\n\t\t{\n\t\t\tAddLineToContent ('\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z);\n\t\t\tAddLineToContent ('\\t\\touter loop');\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex1.x + ' ' + vertex1.y + ' ' + vertex1.z);\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex2.x + ' ' + vertex2.y + ' ' + vertex2.z);\n\t\t\tAddLineToContent ('\\t\\t\\tvertex ' + vertex3.x + ' ' + vertex3.y + ' ' + vertex3.z);\n\t\t\tAddLineToContent ('\\t\\tendloop');\n\t\t\tAddLineToContent ('\\tendfacet');\n\t\t}\n\t\t\n\t\tfunction AddPolygon (index)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tif (count < 3) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar vertex1, vertex2, vertex3;\n\t\t\tvar normal = null;\n\t\t\tif (count === 3) {\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (0)).position;\n\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex (1)).position;\n\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex (2)).position;\n\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t} else {\n\t\t\t\tvar useTriangulation = true;\n\t\t\t\tif (hasConvexPolygons !== undefined && hasConvexPolygons) {\n\t\t\t\t\tuseTriangulation = false;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar i;\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\t\tif (useTriangulation) {\n\t\t\t\t\tvar polygon3D = new JSM.Polygon ();\n\t\t\t\t\t\n\t\t\t\t\tvar vertex;\n\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\tvertex = body.GetVertex (polygon.vertices[i]);\n\t\t\t\t\t\tpolygon3D.AddVertex (vertex.position.x, vertex.position.y, vertex.position.z);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar triangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\t\tif (triangles !== null) {\n\t\t\t\t\t\tvar triangle;\n\t\t\t\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\t\t\t\ttriangle = triangles[i];\n\t\t\t\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (triangle[0])).position;\n\t\t\t\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex (triangle[1])).position;\n\t\t\t\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex (triangle[2])).position;\n\t\t\t\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\t\tvertex1 = body.GetVertex (polygon.GetVertexIndex (0)).position;\n\t\t\t\t\t\tvertex2 = body.GetVertex (polygon.GetVertexIndex ((i + 1) % count)).position;\n\t\t\t\t\t\tvertex3 = body.GetVertex (polygon.GetVertexIndex ((i + 2) % count)).position;\n\t\t\t\t\t\tAddTriangleToContent (normal, vertex1, vertex2, vertex3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar stlContent = '';\n\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (i);\n\t\t}\n\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToStl\n\t* Description: Exports a body to stl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tname {string} name the body\n\t*\thasConvexPolygons {boolean} the body has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToStl = function (body, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tvar stlContent = '';\n\t\t\n\t\tAddLineToContent ('solid ' + name);\n\t\tstlContent += JSM.ExportBodyContentToStl (body, name, hasConvexPolygons);\n\t\tAddLineToContent ('endsolid ' + name);\n\t\t\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportModelToStl\n\t* Description: Exports a model to stl.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t*\tname {string} name the model\n\t*\thasConvexPolygons {boolean} the model has only convex polygons\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToStl = function (model, name, hasConvexPolygons)\n\t{\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tstlContent += line + '\\n';\n\t\t}\n\n\t\tvar stlContent = '';\n\n\t\tAddLineToContent ('solid ' + name);\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tstlContent += JSM.ExportBodyContentToStl (body, name + (i + 1).toString (), hasConvexPolygons);\n\t\t}\n\t\tAddLineToContent ('endsolid ' + name);\n\n\t\treturn stlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyContentToObj\n\t* Description: Exports a body content to obj.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertexOffset {integer} vertex index offset\n\t*\tnormalOffset {integer} normal index offset\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyContentToObj = function (body, vertexOffset, normalOffset)\n\t{\n\t\tfunction AddToContent (line)\n\t\t{\n\t\t\tobjContent += line;\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tobjContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddVertex (index)\n\t\t{\n\t\t\tvar vertCoord = body.GetVertex (index).position;\n\t\t\tAddLineToContent ('v ' + vertCoord.x + ' ' + vertCoord.y + ' ' + vertCoord.z);\n\t\t}\n\n\t\tfunction AddNormal (index)\n\t\t{\n\t\t\tvar normalVector = JSM.CalculateBodyPolygonNormal (body, index);\n\t\t\tAddLineToContent ('vn ' + normalVector.x + ' ' + normalVector.y + ' ' + normalVector.z);\n\t\t}\n\n\t\tfunction AddPolygon (index)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\n\t\t\tAddToContent ('f ');\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tAddToContent ((vertexOffset + polygon.GetVertexIndex (i) + 1) + '//' + (normalOffset + index + 1) + ' ');\n\t\t\t}\n\t\t\t\n\t\t\tAddLineToContent ('');\n\t\t}\n\n\t\tvar objContent = '';\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (i);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddNormal (i);\n\t\t}\n\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (i);\n\t\t}\n\t\t\n\t\treturn objContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToObj\n\t* Description: Exports a body to obj.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToObj = function (body)\n\t{\n\t\treturn JSM.ExportBodyContentToObj (body, 0, 0);\n\t};\n\n\t/**\n\t* Function: ExportModelToObj\n\t* Description: Exports a model to obj.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToObj = function (model)\n\t{\n\t\tvar objContent = '';\n\t\t\n\t\tvar vertexOffset = 0;\n\t\tvar normalOffset = 0;\n\t\t\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tobjContent += JSM.ExportBodyContentToObj (body, vertexOffset, normalOffset);\n\t\t\tvertexOffset += body.VertexCount ();\n\t\t\tnormalOffset += body.PolygonCount ();\n\t\t}\n\n\t\treturn objContent;\n\t};\n\n\t/**\n\t* Function: ExportMaterialsToGdl\n\t* Description: Exports a material container to gdl.\n\t* Parameters:\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportMaterialsToGdl = function (materials)\n\t{\n\t\tfunction HexColorToRGBColorString (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = rgb[0] / 255.0 + ',' + rgb[1] / 255.0 + ',' + rgb[2] / 255.0;\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tgdlContent += line + '\\n';\n\t\t}\n\n\t\tfunction AddMaterial (material, index)\n\t\t{\n\t\t\tvar rgbString = HexColorToRGBColorString (material.diffuse);\n\t\t\tAddLineToContent ('define material \"material' + index + '\" 2, ' + rgbString + ' ! ' + index);\n\t\t}\n\t\t\n\t\tvar gdlContent = '';\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\twriteMaterials = true;\n\t\t}\n\n\t\tvar i;\n\t\tif (writeMaterials) {\n\t\t\tAddMaterial (materials.GetDefaultMaterial (), 1);\n\t\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\t\tAddMaterial (materials.GetMaterial (i), i + 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyGeometryToGdl\n\t* Description: Exports a body geometry to gdl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\twriteMaterials {boolean} write materials\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyGeometryToGdl = function (body, writeMaterials)\n\t{\n\t\tfunction AddToContent (line)\n\t\t{\n\t\t\tvar lineLengthLimit = 200;\n\t\t\tif (line.length > lineLengthLimit) {\n\t\t\t\tvar current = 0;\n\t\t\t\tvar i, character;\n\t\t\t\tfor (i = 0; i < line.length; i++) {\n\t\t\t\t\tcharacter = line[i];\n\t\t\t\t\tgdlContent += character;\n\t\t\t\t\tcurrent++;\n\t\t\t\t\tif (current > lineLengthLimit && character == ',') {\n\t\t\t\t\t\tgdlContent += '\\n';\n\t\t\t\t\t\tcurrent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgdlContent += line;\n\t\t\t}\n\t\t}\n\n\t\tfunction AddLineToContent (line)\n\t\t{\n\t\t\tAddToContent (line + '\\n');\n\t\t}\n\n\t\tfunction AddVertex (index)\n\t\t{\n\t\t\tvar vertCoord = body.GetVertex (index).position;\n\t\t\tAddLineToContent ('vert ' + vertCoord.x + ', ' + vertCoord.y + ', ' + vertCoord.z + ' ! ' + (index + 1));\n\t\t}\n\n\t\tfunction AddEdge (adjacencyInfo, index)\n\t\t{\n\t\t\tvar edge = adjacencyInfo.edges[index];\n\t\t\tvar status = 0;\n\t\t\tif (edge.pgon1 != -1 && edge.pgon2 != -1) {\n\t\t\t\tif (body.GetPolygon (edge.pgon1).HasCurveGroup () && body.GetPolygon (edge.pgon2).HasCurveGroup ()) {\n\t\t\t\t\tif (body.GetPolygon (edge.pgon1).GetCurveGroup () == body.GetPolygon (edge.pgon2).GetCurveGroup ()) {\n\t\t\t\t\t\tstatus = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tAddLineToContent ('edge ' + (edge.vert1 + 1) + ', ' + (edge.vert2 + 1) + ', -1, -1, ' + status + ' ! ' + (index + 1));\n\t\t}\n\n\t\tfunction AddPolygon (adjacencyInfo, index, lastMaterialIndex)\n\t\t{\n\t\t\tvar materialIndex = -1;\n\t\t\tif (writeMaterials) {\n\t\t\t\tmaterialIndex = body.GetPolygon (index).GetMaterialIndex () + 2;\n\t\t\t\tif (materialIndex != lastMaterialIndex) {\n\t\t\t\t\tAddLineToContent ('set material \"material' + materialIndex + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar pgon = adjacencyInfo.pgons[index];\n\t\t\tvar status = 0;\n\t\t\tif (body.GetPolygon (index).HasCurveGroup ()) {\n\t\t\t\tstatus = 2;\n\t\t\t}\n\t\t\tAddToContent ('pgon ' + pgon.pedges.length + ', 0, ' + status + ', ');\n\t\t\tvar pedgeList = '';\n\t\t\tvar i, pedge;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tpedge = pgon.pedges[i];\n\t\t\t\tif (!pedge.reverse) {\n\t\t\t\t\tpedgeList += (pedge.index + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpedgeList += (-(pedge.index + 1));\n\t\t\t\t}\n\t\t\t\tif (i < pgon.pedges.length - 1) {\n\t\t\t\t\tpedgeList += ', ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tAddToContent (pedgeList);\n\t\t\tAddToContent (' ! ' + (index + 1));\n\t\t\tAddLineToContent ('');\n\t\t\t\n\t\t\treturn materialIndex;\n\t\t}\n\n\t\tvar gdlContent = '';\n\n\t\tAddLineToContent ('base');\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\tAddVertex (i);\n\t\t}\n\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tAddEdge (adjacencyInfo, i);\n\t\t}\n\t\t\n\t\tvar lastMaterialIndex = -1;\n\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\tlastMaterialIndex = AddPolygon (adjacencyInfo, i, lastMaterialIndex);\n\t\t}\n\n\t\tAddLineToContent ('body -1');\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportBodyToGdl\n\t* Description: Exports a body to gdl.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportBodyToGdl = function (body, materials)\n\t{\n\t\tvar gdlContent = '';\n\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\tgdlContent += JSM.ExportMaterialsToGdl (materials);\n\t\t\twriteMaterials = true;\n\t\t}\n\n\t\tgdlContent += JSM.ExportBodyGeometryToGdl (body, writeMaterials);\n\t\treturn gdlContent;\n\t};\n\n\t/**\n\t* Function: ExportModelToGdl\n\t* Description: Exports a model to gdl.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t*\tmaterials {MaterialSet} the material container\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.ExportModelToGdl = function (model, materials)\n\t{\n\t\tvar gdlContent = '';\n\t\tvar writeMaterials = false;\n\t\tif (materials !== undefined && materials !== null) {\n\t\t\tgdlContent += JSM.ExportMaterialsToGdl (materials);\n\t\t\twriteMaterials = true;\n\t\t}\n\t\t\n\t\tvar i, body;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tgdlContent += JSM.ExportBodyGeometryToGdl (body, writeMaterials);\n\t\t}\n\n\t\treturn gdlContent;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/trianglebody',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: TriangleBody\n\t* Description: Represents a 3D body which contains only triangles.\n\t*/\n\tJSM.TriangleBody = function (name)\n\t{\n\t\tthis.name = name;\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.uvs = [];\n\t\tthis.triangles = [];\n\t\tthis.defaultUVIndex = -1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.SetName\n\t* Description: Sets the name of the body.\n\t* Parameters:\n\t*\tname {string} the name\n\t*/\n\tJSM.TriangleBody.prototype.SetName = function (name)\n\t{\n\t\tthis.name = name;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetName\n\t* Description: Returns the name of the body.\n\t* Returns:\n\t*\t{string} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetName = function ()\n\t{\n\t\treturn this.name;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddVertex\n\t* Description: Adds a vertex to the body.\n\t* Parameters:\n\t*\tx, y, z {number} the coordinates of the vertex\n\t* Returns:\n\t*\t{integer} the index of the added vertex\n\t*/\n\tJSM.TriangleBody.prototype.AddVertex = function (x, y, z)\n\t{\n\t\tthis.vertices.push (new JSM.Coord (x, y, z));\n\t\treturn this.vertices.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetVertex\n\t* Description: Returns the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.SetVertex\n\t* Description: Sets the position of the vertex at the given index.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t*\tx, y, z {number} the new coordinates of the vertex\n\t*/\n\tJSM.TriangleBody.prototype.SetVertex = function (index, x, y, z)\n\t{\n\t\tthis.vertices[index] = new JSM.Coord (x, y, z);\n\t};\n\n\t/**\n\t* Function: TriangleBody.VertexCount\n\t* Description: Returns the vertex count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddNormal\n\t* Description: Adds a normal vector to the body.\n\t* Parameters:\n\t*\tx, y, z {number} the coordinates of the normal vector\n\t* Returns:\n\t*\t{integer} the index of the added normal vector\n\t*/\n\tJSM.TriangleBody.prototype.AddNormal = function (x, y, z)\n\t{\n\t\tthis.normals.push (new JSM.Vector (x, y, z));\n\t\treturn this.normals.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetNormal\n\t* Description: Returns the normal vector at the given index.\n\t* Parameters:\n\t*\tindex {integer} the normal vector index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetNormal = function (index)\n\t{\n\t\treturn this.normals[index];\n\t};\n\n\n\t/**\n\t* Function: TriangleBody.GetTriangleNormal\n\t* Description: Returns the normal vector of a triangle at the given position.\n\t* Parameters:\n\t*\ttriangleIndex {integer} the triangle index\n\t*\tnormalPosition {Coord} the position of the normal inside the triangle\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetTriangleNormal = function (triangleIndex, normalPosition)\n\t{\n\t\tvar normal = null;\n\t\tvar triangle = this.triangles[triangleIndex];\n\t\tif (triangle.curve == -1) {\n\t\t\tnormal = this.GetNormal (triangle.n0);\n\t\t} else {\n\t\t\tvar v0 = this.GetVertex (triangle.v0);\n\t\t\tvar v1 = this.GetVertex (triangle.v1);\n\t\t\tvar v2 = this.GetVertex (triangle.v2);\n\t\t\tvar n0 = this.GetNormal (triangle.n0);\n\t\t\tvar n1 = this.GetNormal (triangle.n1);\n\t\t\tvar n2 = this.GetNormal (triangle.n2);\n\t\t\tnormal = JSM.BarycentricInterpolation (v0, v1, v2, n0, n1, n2, normalPosition);\n\t\t}\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: TriangleBody.NormalCount\n\t* Description: Returns the normal vector count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.NormalCount = function ()\n\t{\n\t\treturn this.normals.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddUV\n\t* Description: Adds a texture coordinate to the body.\n\t* Parameters:\n\t*\tx, y {number} the coordinates of the texture coordinate\n\t* Returns:\n\t*\t{integer} the index of the added texture coordinate\n\t*/\n\tJSM.TriangleBody.prototype.AddUV = function (x, y)\n\t{\n\t\tthis.uvs.push (new JSM.Coord2D (x, y));\n\t\treturn this.uvs.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddDefaultUV\n\t* Description:\n\t*\tAdds a default texture coordinate to the body.\n\t*\tThe default texture coordinate is stored only once.\n\t* Returns:\n\t*\t{integer} the index of the default texture coordinate\n\t*/\n\tJSM.TriangleBody.prototype.AddDefaultUV = function ()\n\t{\n\t\tif (this.defaultUVIndex != -1) {\n\t\t\treturn this.defaultUVIndex;\n\t\t}\n\t\t\n\t\tthis.defaultUVIndex = this.AddUV (0.0, 0.0);\n\t\treturn this.defaultUVIndex;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetUV\n\t* Description: Returns the texture coordinate at the given index.\n\t* Parameters:\n\t*\tindex {integer} the texture coordinate index\n\t* Returns:\n\t*\t{Coord2D} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetUV = function (index)\n\t{\n\t\treturn this.uvs[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.UVCount\n\t* Description: Returns the texture coordinate count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.UVCount = function ()\n\t{\n\t\treturn this.uvs.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.AddTriangle\n\t* Description: Adds a triangle to the body.\n\t* Parameters:\n\t*\tv0, v1, v2 {integer} the vertex indices of the triangle\n\t*\tn0, n1, n2 {integer} the normal vector indices of the triangle\n\t*\tu0, u1, u2 {integer} the texture coordinate indices of the triangle\n\t*\tmat {integer} the material index of the triangle\n\t*\tcurve {integer} the curve group index of the triangle\n\t* Returns:\n\t*\t{integer} the index of the added triangle\n\t*/\n\tJSM.TriangleBody.prototype.AddTriangle = function (v0, v1, v2, n0, n1, n2, u0, u1, u2, mat, curve)\n\t{\n\t\tthis.triangles.push ({\n\t\t\tv0 : v0,\n\t\t\tv1 : v1,\n\t\t\tv2 : v2,\n\t\t\tn0 : n0,\n\t\t\tn1 : n1,\n\t\t\tn2 : n2,\n\t\t\tu0 : u0,\n\t\t\tu1 : u1,\n\t\t\tu2 : u2,\n\t\t\tmat : mat,\n\t\t\tcurve : curve\n\t\t});\n\t\treturn this.triangles.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetTriangle\n\t* Description: Returns the triangle at the given index.\n\t* Parameters:\n\t*\tindex {integer} the triangle index\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetTriangle = function (index)\n\t{\n\t\treturn this.triangles[index];\n\t};\n\n\t/**\n\t* Function: TriangleBody.TriangleCount\n\t* Description: Returns the triangle count of the body.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleBody.prototype.TriangleCount = function ()\n\t{\n\t\treturn this.triangles.length;\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetBoundingBox\n\t* Description: Returns the bounding box of the body.\n\t* Returns:\n\t*\t{Box} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\t\t\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetCenter\n\t* Description: Returns the center of the bounding box of the body.\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\t/**\n\t* Function: TriangleBody.GetBoundingSphere\n\t* Description: Returns the bounding sphere of the body.\n\t* Returns:\n\t*\t{Sphere} the result\n\t*/\n\tJSM.TriangleBody.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\t\t\n\t\tvar i, current;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcurrent = center.DistanceTo (this.vertices[i]);\n\t\t\tif (JSM.IsGreater (current, radius)) {\n\t\t\t\tradius = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.Sphere (center, radius);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleBody.Finalize\n\t* Description:\n\t*\tFinalizes the body. This operation calculates normal vectors\n\t*\tand fixes the body if some data is missing from it.\n\t* Parameters:\n\t*\tmodel {TriangleModel} the triangle index\n\t*/\n\tJSM.TriangleBody.prototype.Finalize = function (model)\n\t{\n\t\tfunction FinalizeTriangle (body, triangleIndex, triangleNormals, vertexToTriangles)\n\t\t{\n\t\t\tfunction AddAverageNormal (body, vertexIndex, triangleIndex, triangleNormals, vertexToTriangles)\n\t\t\t{\n\t\t\t\tvar averageNormal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\tvar averageCount = 0;\n\t\t\t\t\n\t\t\t\tvar triangle = body.GetTriangle (triangleIndex);\n\t\t\t\tvar neighbourTriangles = vertexToTriangles[vertexIndex];\n\t\t\t\tvar i, neighbourTriangleIndex, neighbourTriangle;\n\t\t\t\tfor (i = 0; i < neighbourTriangles.length; i++) {\n\t\t\t\t\tneighbourTriangleIndex = neighbourTriangles[i];\n\t\t\t\t\tneighbourTriangle = body.GetTriangle (neighbourTriangleIndex);\n\t\t\t\t\tif (triangle.curve == neighbourTriangle.curve) {\n\t\t\t\t\t\taverageNormal = JSM.CoordAdd (averageNormal, triangleNormals[neighbourTriangleIndex]);\n\t\t\t\t\t\taverageCount = averageCount + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\taverageNormal.MultiplyScalar (1.0 / averageCount);\n\t\t\t\taverageNormal.Normalize ();\n\t\t\t\treturn body.AddNormal (averageNormal.x, averageNormal.y, averageNormal.z);\n\t\t\t}\n\t\t\n\t\t\tvar triangle = body.triangles[triangleIndex];\n\t\t\tif (triangle.mat === undefined || triangle.mat < 0) {\n\t\t\t\ttriangle.mat = model.GetDefaultMaterialIndex ();\n\t\t\t}\n\t\t\t\n\t\t\tvar normal, normalIndex;\n\t\t\tif (triangle.n0 === undefined || triangle.n1 === undefined || triangle.n2 === undefined) {\n\t\t\t\tif (triangle.curve === undefined || triangle.curve < 0) {\n\t\t\t\t\tnormal = triangleNormals[triangleIndex];\n\t\t\t\t\tnormalIndex = body.AddNormal (normal.x, normal.y, normal.z);\n\t\t\t\t\ttriangle.n0 = normalIndex;\n\t\t\t\t\ttriangle.n1 = normalIndex;\n\t\t\t\t\ttriangle.n2 = normalIndex;\n\t\t\t\t\ttriangle.curve = -1;\n\t\t\t\t} else {\n\t\t\t\t\ttriangle.n0 = AddAverageNormal (body, triangle.v0, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t\ttriangle.n1 = AddAverageNormal (body, triangle.v1, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t\ttriangle.n2 = AddAverageNormal (body, triangle.v2, triangleIndex, triangleNormals, vertexToTriangles);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (triangle.u0 === undefined || triangle.u1 === undefined || triangle.u2 === undefined) {\n\t\t\t\ttriangle.u0 = body.AddDefaultUV ();\n\t\t\t\ttriangle.u1 = body.AddDefaultUV ();\n\t\t\t\ttriangle.u2 = body.AddDefaultUV ();\n\t\t\t}\n\t\t}\n\n\t\tvar triangleNormals = [];\n\t\tvar vertexToTriangles = {};\n\n\t\tvar i;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertexToTriangles[i] = [];\n\t\t}\n\t\t\n\t\tvar triangle, normal;\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\ttriangle = this.triangles[i];\n\t\t\tnormal = JSM.CalculateTriangleNormal (this.vertices[triangle.v0], this.vertices[triangle.v1], this.vertices[triangle.v2]);\n\t\t\ttriangleNormals.push (normal);\n\t\t\tvertexToTriangles[triangle.v0].push (i);\n\t\t\tvertexToTriangles[triangle.v1].push (i);\n\t\t\tvertexToTriangles[triangle.v2].push (i);\n\t\t}\n\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\tFinalizeTriangle (this, i, triangleNormals, vertexToTriangles);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleBody.Clone\n\t* Description: Clones the body.\n\t* Returns:\n\t*\t{TriangleBody} a cloned instance\n\t*/\n\tJSM.TriangleBody.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.TriangleBody (this.name);\n\t\t\n\t\tvar i, triangle;\n\t\t\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tresult.vertices.push (this.vertices[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.normals.length; i++) {\n\t\t\tresult.normals.push (this.normals[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.uvs.length; i++) {\n\t\t\tresult.uvs.push (this.uvs[i].Clone ());\n\t\t}\n\t\t\n\t\tfor (i = 0; i < this.triangles.length; i++) {\n\t\t\ttriangle = this.triangles[i];\n\t\t\tresult.triangles.push ({\n\t\t\t\tv0 : triangle.v0,\n\t\t\t\tv1 : triangle.v1,\n\t\t\t\tv2 : triangle.v2,\n\t\t\t\tn0 : triangle.n0,\n\t\t\t\tn1 : triangle.n1,\n\t\t\t\tn2 : triangle.n2,\n\t\t\t\tu0 : triangle.u0,\n\t\t\t\tu1 : triangle.u1,\n\t\t\t\tu2 : triangle.u2,\n\t\t\t\tmat : triangle.mat,\n\t\t\t\tcurve : triangle.curve\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertTriangleBodyToOctree\n\t* Description: Converts a triangle body to triangle octree.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t* Returns:\n\t*\t{TriangleOctree} the result\n\t*/\n\tJSM.ConvertTriangleBodyToOctree = function (body)\n\t{\n\t\tvar result = new JSM.TriangleOctree (body.GetBoundingBox ());\n\t\tvar i, triangle, v0, v1, v2;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tresult.AddTriangle (v0, v1, v2, {\n\t\t\t\ttriangleIndex : i\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/trianglemodel',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: TriangleModel\n\t* Description: Represents a 3D model which contains only triangles.\n\t*/\n\tJSM.TriangleModel = function ()\n\t{\n\t\tthis.materials = [];\n\t\tthis.bodies = [];\n\t\tthis.defaultMaterial = -1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddMaterial\n\t* Description: Adds a material to the model.\n\t* Parameters:\n\t*\tmaterial {material} the parameters of the material\n\t* Returns:\n\t*\t{integer} the index of the added material\n\t*/\n\tJSM.TriangleModel.prototype.AddMaterial = function (material)\n\t{\n\t\tthis.materials.push (material);\n\t\treturn this.materials.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetMaterial\n\t* Description: Returns the material at the given index.\n\t* Parameters:\n\t*\tindex {integer} the material index\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetMaterial = function (index)\n\t{\n\t\treturn this.materials[index];\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddDefaultMaterial\n\t* Description: Adds a default material to the model. The default material is stored only once.\n\t* Returns:\n\t*\t{integer} the index of the default material\n\t*/\n\tJSM.TriangleModel.prototype.AddDefaultMaterial = function ()\n\t{\n\t\tif (this.defaultMaterial == -1) {\n\t\t\tthis.defaultMaterial = this.AddMaterial ({});\n\t\t}\n\t\treturn this.defaultMaterial;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetDefaultMaterialIndex\n\t* Description: Adds a default material, and returns the index of it.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetDefaultMaterialIndex = function ()\n\t{\n\t\treturn this.AddDefaultMaterial ();\n\t};\n\n\t/**\n\t* Function: TriangleModel.MaterialCount\n\t* Description: Returns the material count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.MaterialCount = function ()\n\t{\n\t\treturn this.materials.length;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddBody\n\t* Description: Adds a body to the model.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t* Returns:\n\t*\t{integer} the index of the added body\n\t*/\n\tJSM.TriangleModel.prototype.AddBody = function (body)\n\t{\n\t\tthis.bodies.push (body);\n\t\treturn this.bodies.length - 1;\n\t};\n\n\t/**\n\t* Function: TriangleModel.AddBodyToIndex\n\t* Description: Adds a body to the model to the given index.\n\t* Parameters:\n\t*\tbody {TriangleBody} the body\n\t*\tindex {integer} the index\n\t* Returns:\n\t*\t{integer} the index of the added body\n\t*/\n\tJSM.TriangleModel.prototype.AddBodyToIndex = function (body, index)\n\t{\n\t\tthis.bodies.splice (index, 0, body);\n\t\treturn index;\n\t};\n\n\t/**\n\t* Function: TriangleModel.GetBody\n\t* Description: Returns the body at the given index.\n\t* Parameters:\n\t*\tindex {integer} the body index\n\t* Returns:\n\t*\t{TriangleBody} the result\n\t*/\n\tJSM.TriangleModel.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\t/**\n\t* Function: TriangleModel.VertexCount\n\t* Description: Returns the vertex count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.VertexCount = function ()\n\t{\n\t\tvar result = 0;\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tresult += body.VertexCount ();\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleModel.TriangleCount\n\t* Description: Returns the triangle count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.TriangleCount = function ()\n\t{\n\t\tvar result = 0;\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tresult += body.TriangleCount ();\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangleModel.BodyCount\n\t* Description: Returns the body count of the model.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.TriangleModel.prototype.BodyCount = function ()\n\t{\n\t\treturn this.bodies.length;\n\t};\n\n\t/**\n\t* Function: TriangleModel.FinalizeMaterials\n\t* Description:\n\t*\tFinalizes the materials in the model. This fill every not\n\t*\tspecified material parameter with default values.\n\t*/\n\tJSM.TriangleModel.prototype.FinalizeMaterials = function ()\n\t{\n\t\tvar defaultMaterialData = {\n\t\t\tname : 'Default',\n\t\t\tambient : [0.5, 0.5, 0.5],\n\t\t\tdiffuse : [0.5, 0.5, 0.5],\n\t\t\tspecular : [0.1, 0.1, 0.1],\n\t\t\tshininess : 0.0,\n\t\t\topacity : 1.0,\n\t\t\treflection : 0.0,\n\t\t\ttexture : null,\n\t\t\toffset : null,\n\t\t\tscale : null,\n\t\t\trotation : null\n\t\t};\n\t\t\n\t\tvar i, material;\n\t\tfor (i = 0; i < this.materials.length; i++) {\n\t\t\tmaterial = this.materials[i];\n\t\t\tJSM.CopyObjectProperties (defaultMaterialData, material, false);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleModel.FinalizeBodies\n\t* Description: Finalizes all body in the model.\n\t*/\n\tJSM.TriangleModel.prototype.FinalizeBodies = function ()\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i];\n\t\t\tbody.Finalize (this);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangleModel.Finalize\n\t* Description: Finalizes the model. It finalizes materials and bodies.\n\t*/\n\tJSM.TriangleModel.prototype.Finalize = function ()\n\t{\n\t\tthis.FinalizeBodies ();\n\t\tthis.FinalizeMaterials ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/converter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: ConvertBodyToTriangleBody\n\t* Description: Converts a body to triangle body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{TriangleBody} the result\n\t*/\n\tJSM.ConvertBodyToTriangleBody = function (body)\n\t{\n\t\tfunction AddTriangle (result, polygon, v0, v1, v2)\n\t\t{\n\t\t\tvar triangleIndex = result.AddTriangle (v0, v1, v2);\n\t\t\tvar triangle = result.GetTriangle (triangleIndex);\n\t\t\tif (polygon.HasMaterialIndex ()) {\n\t\t\t\ttriangle.mat = polygon.GetMaterialIndex ();\n\t\t\t}\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\ttriangle.curve = polygon.GetCurveGroup ();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = new JSM.TriangleBody ();\n\t\t\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\tresult.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t}\n\t\t\n\t\tvar polygon, vertexCount;\n\t\tvar polygon3D, normal, triangle, triangles;\n\t\tvar v0, v1, v2;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tvertexCount = polygon.VertexIndexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tv0 = polygon.GetVertexIndex (0);\n\t\t\t\tv1 = polygon.GetVertexIndex (1);\n\t\t\t\tv2 = polygon.GetVertexIndex (2);\n\t\t\t\tAddTriangle (result, polygon, v0, v1, v2);\n\t\t\t} else {\n\t\t\t\tpolygon3D = new JSM.Polygon ();\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tvertex = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\t\tpolygon3D.AddVertex (vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnormal = JSM.CalculateBodyPolygonNormal (body, i);\n\t\t\t\ttriangles = JSM.TriangulatePolygon (polygon3D, normal);\n\t\t\t\tif (triangles !== null) {\n\t\t\t\t\tfor (j = 0; j < triangles.length; j++) {\n\t\t\t\t\t\ttriangle = triangles[j];\n\t\t\t\t\t\tv0 = polygon.GetVertexIndex (triangle[0]);\n\t\t\t\t\t\tv1 = polygon.GetVertexIndex (triangle[1]);\n\t\t\t\t\t\tv2 = polygon.GetVertexIndex (triangle[2]);\n\t\t\t\t\t\tAddTriangle (result, polygon, v0, v1, v2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertModelToTriangleModel\n\t* Description: Converts a model to triangle model.\n\t* Parameters:\n\t*\tmodel {Model} the model\n\t* Returns:\n\t*\t{TriangleModel} the result\n\t*/\n\tJSM.ConvertModelToTriangleModel = function (model)\n\t{\n\t\tvar result = new JSM.TriangleModel ();\n\t\tvar materials = model.GetMaterialSet ();\n\t\tvar i, material;\n\t\tfor (i = 0; i < materials.Count (); i++) {\n\t\t\tmaterial = materials.GetMaterial (i);\n\t\t\tresult.AddMaterial ({\n\t\t\t\tname : 'Material' + i,\n\t\t\t\tambient : JSM.HexColorToNormalizedRGBComponents (material.ambient),\n\t\t\t\tdiffuse : JSM.HexColorToNormalizedRGBComponents (material.diffuse),\n\t\t\t\tspecular : JSM.HexColorToNormalizedRGBComponents (material.specular),\n\t\t\t\tshininess : material.shininess,\n\t\t\t\topacity : material.opacity,\n\t\t\t\treflection : material.reflection\n\t\t\t});\n\t\t}\n\t\t\n\t\tvar body, triangleBody;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\ttriangleBody = JSM.ConvertBodyToTriangleBody (body);\n\t\t\tresult.AddBody (triangleBody);\n\t\t}\n\t\tresult.Finalize ();\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: ConvertTriangleModelToJsonData\n\t* Description: Converts a triangle model to json data.\n\t* Parameters:\n\t*\tmodel {TriangleModel} the model\n\t* Returns:\n\t*\t{object} the result data\n\t*/\n\tJSM.ConvertTriangleModelToJsonData = function (model)\n\t{\n\t\tfunction ConvertMaterials (model, materials)\n\t\t{\n\t\t\tvar i, material, jsonMaterial;\n\t\t\tfor (i = 0; i < model.MaterialCount (); i++) {\n\t\t\t\tmaterial = model.GetMaterial (i);\n\t\t\t\tjsonMaterial = {\n\t\t\t\t\tname : JSM.ValueOrDefault (material.name, ''),\n\t\t\t\t\tambient : material.ambient,\n\t\t\t\t\tdiffuse : material.diffuse,\n\t\t\t\t\tspecular : material.specular,\n\t\t\t\t\tshininess : material.shininess,\n\t\t\t\t\topacity : material.opacity\n\t\t\t\t};\n\t\t\t\tif (material.texture !== undefined && material.texture !== null) {\n\t\t\t\t\tjsonMaterial.texture = JSM.ValueOrDefault (material.texture, null);\n\t\t\t\t\tjsonMaterial.offset = material.offset;\n\t\t\t\t\tjsonMaterial.scale = material.scale;\n\t\t\t\t\tjsonMaterial.rotation = material.rotation;\n\t\t\t\t}\n\t\t\t\tmaterials.push (jsonMaterial);\n\t\t\t}\n\t\t}\n\n\t\tfunction ConvertBody (model, body, mesh)\n\t\t{\n\t\t\tvar trianglesByMaterial = [];\n\t\t\tvar materialCount = model.MaterialCount ();\n\t\t\t\n\t\t\tvar i, j, coord;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tcoord = body.GetVertex (i);\n\t\t\t\tmesh.vertices.push (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < body.NormalCount (); i++) {\n\t\t\t\tcoord = body.GetNormal (i);\n\t\t\t\tmesh.normals.push (coord.x, coord.y, coord.z);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < body.UVCount (); i++) {\n\t\t\t\tcoord = body.GetUV (i);\n\t\t\t\tmesh.uvs.push (coord.x, coord.y);\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < materialCount; i++) {\n\t\t\t\ttrianglesByMaterial.push ([]);\n\t\t\t}\n\n\t\t\tvar triangle;\n\t\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\t\ttriangle = body.GetTriangle (i);\n\t\t\t\tif (triangle.mat === undefined || triangle.mat < 0 || triangle.mat >= materialCount) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrianglesByMaterial[triangle.mat].push (i);\n\t\t\t}\n\n\t\t\tvar triangleCount = 0;\n\t\t\tvar triangles, jsonTriangles;\n\t\t\tfor (i = 0; i < trianglesByMaterial.length; i++) {\n\t\t\t\ttriangles = trianglesByMaterial[i];\n\t\t\t\tif (triangles.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjsonTriangles =  {\n\t\t\t\t\tmaterial : i,\n\t\t\t\t\tparameters : []\n\t\t\t\t};\n\t\t\t\tfor (j = 0; j < triangles.length; j++) {\n\t\t\t\t\ttriangle = body.GetTriangle (triangles[j]);\n\t\t\t\t\tjsonTriangles.parameters.push (\n\t\t\t\t\t\ttriangle.v0, triangle.v1, triangle.v2,\n\t\t\t\t\t\ttriangle.n0, triangle.n1, triangle.n2,\n\t\t\t\t\t\ttriangle.u0, triangle.u1, triangle.u2\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\ttriangleCount = triangleCount + triangles.length;\n\t\t\t\tmesh.triangles.push (jsonTriangles);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tversion : 1,\n\t\t\tmaterials : [],\n\t\t\tmeshes : []\n\t\t};\n\t\t\n\t\tConvertMaterials (model, result.materials);\n\t\t\n\t\tvar i, body, mesh;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tif (body.TriangleCount () === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmesh = {\n\t\t\t\tname : body.GetName (),\n\t\t\t\tvertices : [],\n\t\t\t\tnormals : [],\n\t\t\t\tuvs : [],\n\t\t\t\ttriangles : []\n\t\t\t};\n\t\t\tConvertBody (model, body, mesh);\n\t\t\tresult.meshes.push (mesh);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MergeJsonDataMeshes\n\t* Description: Merges meshes in json data.\n\t* Parameters:\n\t*\tjsonData {object} the original data\n\t* Returns:\n\t*\t{object} the result data\n\t*/\n\tJSM.MergeJsonDataMeshes = function (jsonData)\n\t{\n\t\tfunction MergeMesh (mesh, currentMesh, materialToTriangles)\n\t\t{\n\t\t\tfunction MergeAttributes (mesh, currentMesh)\n\t\t\t{\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < currentMesh.vertices.length; i++) {\n\t\t\t\t\tmesh.vertices.push (currentMesh.vertices[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < currentMesh.normals.length; i++) {\n\t\t\t\t\tmesh.normals.push (currentMesh.normals[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < currentMesh.uvs.length; i++) {\n\t\t\t\t\tmesh.uvs.push (currentMesh.uvs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction MergeTriangles (mesh, currentTriangles, materialToTriangles, vertexOffset, normalOffset, uvOffset)\n\t\t\t{\n\t\t\t\tvar material = currentTriangles.material;\n\t\t\t\tvar trianglesIndex = materialToTriangles[material];\n\t\t\t\tif (trianglesIndex === undefined) {\n\t\t\t\t\tmesh.triangles.push ({\n\t\t\t\t\t\tmaterial : material,\n\t\t\t\t\t\tparameters : []\n\t\t\t\t\t});\n\t\t\t\t\ttrianglesIndex = mesh.triangles.length - 1;\n\t\t\t\t\tmaterialToTriangles[material] = trianglesIndex;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar triangles = mesh.triangles[trianglesIndex];\n\t\t\t\tvar triangleParameters = triangles.parameters;\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < currentTriangles.parameters.length; i = i + 9) {\n\t\t\t\t\ttriangleParameters.push (\n\t\t\t\t\t\tcurrentTriangles.parameters[i] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 1] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 2] + vertexOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 3] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 4] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 5] + normalOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 6] + uvOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 7] + uvOffset,\n\t\t\t\t\t\tcurrentTriangles.parameters[i + 8] + uvOffset\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar vertexOffset = mesh.vertices.length / 3;\n\t\t\tvar normalOffset = mesh.normals.length / 3;\n\t\t\tvar uvOffset = mesh.uvs.length / 2;\n\t\t\tMergeAttributes (mesh, currentMesh);\n\n\t\t\tvar i, currentTriangles;\n\t\t\tfor (i = 0; i < currentMesh.triangles.length; i++) {\n\t\t\t\tcurrentTriangles = currentMesh.triangles[i];\n\t\t\t\tMergeTriangles (mesh, currentTriangles, materialToTriangles, vertexOffset, normalOffset, uvOffset);\n\t\t\t}\n\t\t}\n\n\t\tvar result = {\n\t\t\tversion : jsonData.version,\n\t\t\tmaterials : jsonData.materials,\n\t\t\tmeshes : []\n\t\t};\n\t\t\n\t\tvar mesh = {\n\t\t\tname : 'Merged',\n\t\t\tvertices : [],\n\t\t\tnormals : [],\n\t\t\tuvs : [],\n\t\t\ttriangles : []\n\t\t};\n\t\t\n\t\tvar materialToTriangles = {};\n\t\tvar i, currentMesh;\n\t\tfor (i = 0; i < jsonData.meshes.length; i++) {\n\t\t\tcurrentMesh = jsonData.meshes[i];\n\t\t\tMergeMesh (mesh, currentMesh, materialToTriangles);\n\t\t}\n\t\t\n\t\tresult.meshes.push (mesh);\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/modeler/rayutils',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: RayTriangleIntersection\n\t* Description: Calculates intersection between a ray and a triangle.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayTriangleIntersection = function (ray, v0, v1, v2)\n\t{\n\t\tvar rayOrigin = ray.GetOrigin ();\n\t\tvar rayDirection = ray.GetDirection ();\n\n\t\tvar edgeDir1 = JSM.CoordSub (v1, v0);\n\t\tvar edgeDir2 = JSM.CoordSub (v2, v0);\n\t\tvar pVector = JSM.VectorCross (rayDirection, edgeDir2);\n\n\t\tvar determinant = JSM.VectorDot (edgeDir1, pVector);\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar isFrontFacing = JSM.IsPositive (determinant);\n\t\tif (!isFrontFacing) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar invDeterminant = 1.0 / determinant;\n\n\t\tvar tVector = JSM.CoordSub (rayOrigin, v0);\n\t\tvar u = JSM.VectorDot (tVector, pVector) * invDeterminant;\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar qVector = JSM.VectorCross (tVector, edgeDir1);\n\t\tvar v = JSM.VectorDot (rayDirection, qVector) * invDeterminant;\n\t\tif (JSM.IsLower (v, 0.0) || JSM.IsGreater (u + v, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\t \n\t\tvar distance = JSM.VectorDot (edgeDir2, qVector) * invDeterminant;\n\t\tif (!JSM.IsPositive (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar scaledDirection = rayDirection.Clone ().MultiplyScalar (distance);\n\t\tvar intersection = {\n\t\t\tposition : JSM.CoordAdd (rayOrigin, scaledDirection),\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayBoxIntersection\n\t* Description: Calculates intersection between a ray and a box.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmin, max {Coord} the minimum and maximum points of the box\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayBoxIntersection = function (ray, min, max)\n\t{\n\t\tvar rayOriginVec = ray.GetOrigin ();\n\t\tvar rayDirectionVec = ray.GetDirection ();\n\n\t\tvar rayOrigin = JSM.CoordToArray (rayOriginVec);\n\t\tvar rayDirection = JSM.CoordToArray (rayDirectionVec);\n\t\tvar minB = JSM.CoordToArray (min);\n\t\tvar maxB = JSM.CoordToArray (max);\n\t\tvar quadrant = [0, 0, 0];\n\t\tvar candidatePlane = [0.0, 0.0, 0.0];\n\n\t\tvar originInBox = true;\n\t\tvar i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (JSM.IsLower (rayOrigin[i], minB[i])) {\n\t\t\t\tquadrant[i] = -1; // left\n\t\t\t\tcandidatePlane[i] = minB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else if (JSM.IsGreater (rayOrigin[i], maxB[i])) {\n\t\t\t\tquadrant[i] = 1; // right\n\t\t\t\tcandidatePlane[i] = maxB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else {\n\t\t\t\tquadrant[i] = 0; // middle\n\t\t\t}\n\t\t}\n\n\t\tvar intersection = null;\n\t\tif (originInBox) {\n\t\t\tintersection = {\n\t\t\t\tposition : rayOriginVec,\n\t\t\t\tdistance : 0.0\n\t\t\t};\n\t\t\treturn intersection;\n\t\t}\n\n\t\tvar maxT = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (quadrant[i] !== 0 && !JSM.IsZero (rayDirection[i])) {\n\t\t\t\tmaxT[i] = (candidatePlane[i] - rayOrigin[i]) / rayDirection[i];\n\t\t\t} else {\n\t\t\t\tmaxT[i] = -1.0;\n\t\t\t}\n\t\t}\n\n\t\tvar whichPlane = 0;\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (JSM.IsLower (maxT[whichPlane], maxT[i])) {\n\t\t\t\twhichPlane = i;\n\t\t\t}\n\t\t}\n\n\t\tif (JSM.IsNegative (maxT[whichPlane])) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar xCoord = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (whichPlane != i) {\n\t\t\t\txCoord[i] = rayOrigin[i] + maxT[whichPlane] * rayDirection[i];\n\t\t\t\tif (JSM.IsLower (xCoord[i], minB[i]) || JSM.IsGreater (xCoord[i], maxB[i])) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txCoord[i] = candidatePlane[i];\n\t\t\t}\n\t\t}\n\n\t\tvar intersectionCoord = JSM.CoordFromArray (xCoord);\n\t\tvar distance = rayOriginVec.DistanceTo (intersectionCoord);\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tintersection = {\n\t\t\tposition : intersectionCoord,\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayOctreeIntersection\n\t* Description: Calculates the nearest intersection between a ray and an octree.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\toctree {Octree} the octree\n\t*\tintersection {object} the result data (position, distance, userData)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayOctreeIntersection = function (ray, octree, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\n\t\tJSM.TraverseOctreeNodes (octree, function (node) {\n\t\t\tif (!calcMinIntersection && foundIntersection) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!JSM.RayBoxIntersection (ray, node.box.min, node.box.max)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < node.triangles.length; i++) {\n\t\t\t\tvar triangle = node.triangles[i];\n\t\t\t\tvar v0 = triangle.v0;\n\t\t\t\tvar v1 = triangle.v1;\n\t\t\t\tvar v2 = triangle.v2;\n\t\t\t\tvar currentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\tif (currentIntersection !== null) {\n\t\t\t\t\tfoundIntersection = true;\n\t\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\t\tminIntersection.userData = triangle.userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\t\n\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.userData = minIntersection.userData;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleBodyIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle body.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tbody {TriangleBody} the triangle body\n\t*\tintersection {object} the result data (position, distance, triangleIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleBodyIntersection = function (ray, body, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\t\n\t\tvar i, triangle, v0, v1, v2, currentIntersection;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tcurrentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\tif (currentIntersection !== null) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.triangleIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersection = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (JSM.RayTriangleBodyIntersection (ray, body, currentIntersection)) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersectionWithOctree\n\t* Description:\n\t*\tCalculates the nearest intersection between a ray and a triangle model.\n\t*\tCaches the octrees for all bodies in the model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersectionWithOctree = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, hasIntersection, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\thasIntersection = false;\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (body.TriangleCount () > 20) {\n\t\t\t\tif (body.octree === undefined) {\n\t\t\t\t\tbody.octree = JSM.ConvertTriangleBodyToOctree (body);\n\t\t\t\t}\n\t\t\t\thasIntersection = JSM.RayOctreeIntersection (ray, body.octree, currentIntersection);\n\t\t\t} else {\n\t\t\t\thasIntersection = JSM.RayTriangleBodyIntersection (ray, body, currentIntersection);\n\t\t\t}\n\t\t\t\n\t\t\tif (hasIntersection) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tif (currentIntersection.userData !== undefined) {\n\t\t\t\t\t\tminIntersection.triangleIndex = currentIntersection.userData.triangleIndex;\n\t\t\t\t\t}\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/binaryreader',[\"../core/jsm\"],function(JSM){\n\tJSM.BinaryReader = function (arrayBuffer, isLittleEndian)\n\t{\n\t\tthis.arrayBuffer = arrayBuffer;\n\t\tthis.dataView = new DataView (arrayBuffer);\n\t\tthis.isLittleEndian = isLittleEndian;\n\t\tthis.position = 0;\n\t};\n\n\tJSM.BinaryReader.prototype.GetPosition = function ()\n\t{\n\t\treturn this.position;\n\t};\n\n\tJSM.BinaryReader.prototype.GetByteLength = function ()\n\t{\n\t\treturn this.arrayBuffer.byteLength;\n\t};\n\n\tJSM.BinaryReader.prototype.Skip = function (bytes)\n\t{\n\t\tthis.position = this.position + bytes;\n\t};\n\n\tJSM.BinaryReader.prototype.End = function ()\n\t{\n\t\treturn this.position >= this.arrayBuffer.byteLength;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadBoolean = function ()\n\t{\n\t\tvar result = this.dataView.getInt8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result ? true : false;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadCharacter = function ()\n\t{\n\t\tvar result = this.dataView.getInt8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedCharacter = function ()\n\t{\n\t\tvar result = this.dataView.getUint8 (this.position);\n\t\tthis.position = this.position + 1;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadInteger16 = function ()\n\t{\n\t\tvar result = this.dataView.getInt16 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 2;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedInteger16 = function ()\n\t{\n\t\tvar result = this.dataView.getUint16 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 2;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadInteger32 = function ()\n\t{\n\t\tvar result = this.dataView.getInt32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadUnsignedInteger32 = function ()\n\t{\n\t\tvar result = this.dataView.getUint32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadFloat32 = function ()\n\t{\n\t\tvar result = this.dataView.getFloat32 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 4;\n\t\treturn result;\n\t};\n\n\tJSM.BinaryReader.prototype.ReadDouble64 = function ()\n\t{\n\t\tvar result = this.dataView.getFloat64 (this.position, this.isLittleEndian);\n\t\tthis.position = this.position + 8;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerutils',[\"../core/jsm\"],function(JSM){\n\tJSM.GetArrayBufferFromURL = function (url, callbacks)\n\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.open ('GET', url, true);\n\t\trequest.responseType = 'arraybuffer';\n\n\t\trequest.onload = function () {\n\t\t\tvar arrayBuffer = request.response;\n\t\t\tif (arrayBuffer && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (arrayBuffer);\n\t\t\t}\n\t\t};\n\t\t\n\t\trequest.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\trequest.send (null);\n\t};\n\n\tJSM.GetArrayBufferFromFile = function (file, callbacks)\n\t{\n\t\tvar reader = new FileReader ();\n\n\t\treader.onloadend = function (event) {\n\t\t\tif (event.target.readyState == FileReader.DONE && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (event.target.result);\n\t\t\t}\n\t\t};\n\t\t\n\t\treader.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\treader.readAsArrayBuffer (file);\n\t};\n\n\tJSM.GetStringBufferFromURL = function (url, callbacks)\n\t{\n\t\tvar request = new XMLHttpRequest ();\n\t\trequest.open ('GET', url, true);\n\t\trequest.responseType = 'text';\n\n\t\trequest.onload = function () {\n\t\t\tvar stringBuffer = request.response;\n\t\t\tif (stringBuffer && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (stringBuffer);\n\t\t\t}\n\t\t};\n\t\t\n\t\trequest.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\n\n\t\trequest.send (null);\n\t};\n\n\tJSM.GetStringBufferFromFile = function (file, callbacks)\n\t{\n\t\tvar reader = new FileReader ();\n\n\t\treader.onloadend = function (event) {\n\t\t\tif (event.target.readyState == FileReader.DONE && callbacks.onReady) {\n\t\t\t\tcallbacks.onReady (event.target.result);\n\t\t\t}\n\t\t};\n\n\t\treader.onerror = function () {\n\t\t\tif (callbacks.onError) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t};\t\n\t\t\n\t\treader.readAsText (file);\n\t};\n\n\tJSM.LoadMultipleBuffers = function (inputList, onReady)\n\t{\n\t\tfunction LoadMultipleBuffersInternal (inputList, index, result, onReady)\n\t\t{\n\t\t\tif (index >= inputList.length) {\n\t\t\t\tonReady (result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar currentInput = inputList[index];\n\t\t\tvar loaderFunction = null;\n\t\t\tif (currentInput.isFile) {\n\t\t\t\tif (currentInput.isArrayBuffer) {\n\t\t\t\t\tloaderFunction = JSM.GetArrayBufferFromFile;\n\t\t\t\t} else {\n\t\t\t\t\tloaderFunction = JSM.GetStringBufferFromFile;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentInput.isArrayBuffer) {\n\t\t\t\t\tloaderFunction = JSM.GetArrayBufferFromURL;\n\t\t\t\t} else {\n\t\t\t\t\tloaderFunction = JSM.GetStringBufferFromURL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tloaderFunction (currentInput.originalObject, {\n\t\t\t\tonReady : function (resultBuffer) {\n\t\t\t\t\tresult.push (resultBuffer);\n\t\t\t\t\tLoadMultipleBuffersInternal (inputList, index + 1, result, onReady);\n\t\t\t\t},\n\t\t\t\tonError : function () {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t\tLoadMultipleBuffersInternal (inputList, index + 1, result, onReady);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar result = [];\n\t\tLoadMultipleBuffersInternal (inputList, 0, result, function (result) {\n\t\t\tonReady (result);\n\t\t});\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importer3ds',[\"../core/jsm\"],function(JSM){\n\tJSM.Read3dsFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnLog (logText, logLevel)\n\t\t{\n\t\t\tif (callbacks.onLog !== undefined && callbacks.onLog !== null) {\n\t\t\t\tcallbacks.onLog (logText, logLevel);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterial (material)\n\t\t{\n\t\t\tif (callbacks.onMaterial !== undefined && callbacks.onMaterial !== null) {\n\t\t\t\tcallbacks.onMaterial (material);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMesh (objectName)\n\t\t{\n\t\t\tif (callbacks.onMesh !== undefined && callbacks.onMesh !== null) {\n\t\t\t\tcallbacks.onMesh (objectName);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTransformation (matrix)\n\t\t{\n\t\t\tif (callbacks.onTransformation !== undefined && callbacks.onTransformation !== null) {\n\t\t\t\tcallbacks.onTransformation (matrix);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnObjectNode (objectNode)\n\t\t{\n\t\t\tif (callbacks.onObjectNode !== undefined && callbacks.onObjectNode !== null) {\n\t\t\t\tcallbacks.onObjectNode (objectNode);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTextureVertex (x, y)\n\t\t{\n\t\t\tif (callbacks.onTextureVertex !== undefined && callbacks.onTextureVertex !== null) {\n\t\t\t\tcallbacks.onTextureVertex (x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (v0, v1, v2, flags)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, flags);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFaceMaterial (faceIndex, materialName)\n\t\t{\n\t\t\tif (callbacks.onFaceMaterial !== undefined && callbacks.onFaceMaterial !== null) {\n\t\t\t\tcallbacks.onFaceMaterial (faceIndex, materialName);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFaceSmoothingGroup (faceIndex, smoothingGroup)\n\t\t{\n\t\t\tif (callbacks.onFaceSmoothingGroup !== undefined && callbacks.onFaceSmoothingGroup !== null) {\n\t\t\t\tcallbacks.onFaceSmoothingGroup (faceIndex, smoothingGroup);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadChunk (reader, onReady)\n\t\t{\n\t\t\tvar chunkId = reader.ReadUnsignedInteger16 ();\n\t\t\tvar chunkLength = reader.ReadUnsignedInteger32 ();\n\t\t\tonReady (chunkId, chunkLength);\n\t\t}\n\t\t\n\t\tfunction SkipChunk (reader, length)\n\t\t{\n\t\t\treader.Skip (length - 6);\n\t\t}\n\t\t\n\t\tfunction GetChunkEnd (reader, length)\n\t\t{\n\t\t\treturn reader.GetPosition () + length - 6;\n\t\t}\n\t\t\n\t\tfunction ReadName (reader)\n\t\t{\n\t\t\tvar name = '';\n\t\t\tvar letter = 0;\n\t\t\tvar count = 0;\n\t\t\twhile (count < 64) {\n\t\t\t\tletter = reader.ReadCharacter ();\n\t\t\t\tif (letter === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname = name + String.fromCharCode (letter);\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction ReadChunks (reader, endByte, onReady)\n\t\t{\n\t\t\twhile (reader.GetPosition () <= endByte - 6) {\n\t\t\t\tReadChunk (reader, onReady);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadFile (reader, chunks)\n\t\t{\n\t\t\tfunction ReadColorChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tvar color = [0.0, 0.0, 0.0];\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar hasLinColor = false;\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_COLOR) {\n\t\t\t\t\t\tif (!hasLinColor) {\n\t\t\t\t\t\t\tcolor[0] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t\tcolor[1] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t\tcolor[2] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (chunkId == chunks.MAT_LIN_COLOR) {\n\t\t\t\t\t\tcolor[0] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\tcolor[1] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\tcolor[2] = reader.ReadUnsignedCharacter () / 255.0;\n\t\t\t\t\t\thasLinColor = true;\n\t\t\t\t\t} else if (chunkId == chunks.MAT_COLOR_F) {\n\t\t\t\t\t\tif (!hasLinColor) {\n\t\t\t\t\t\t\tcolor[0] = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcolor[1] = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcolor[2] = reader.ReadFloat32 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (chunkId == chunks.MAT_LIN_COLOR_F) {\n\t\t\t\t\t\tcolor[0] = reader.ReadFloat32 ();\n\t\t\t\t\t\tcolor[1] = reader.ReadFloat32 ();\n\t\t\t\t\t\tcolor[2] = reader.ReadFloat32 ();\n\t\t\t\t\t\thasLinColor = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn color;\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadPercentageChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tvar percentage = 0.0;\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.PERCENTAGE) {\n\t\t\t\t\t\tpercentage = reader.ReadUnsignedInteger16 () / 100.0;\n\t\t\t\t\t} else if (chunkId == chunks.PERCENTAGE_F) {\n\t\t\t\t\t\tpercentage = reader.ReadFloat32 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn percentage;\n\t\t\t}\n\n\t\t\tfunction ReadTextureMapChunk (reader, id, length, material)\n\t\t\t{\n\t\t\t\tmaterial.texture = null;\n\t\t\t\tmaterial.offset = [0.0, 0.0];\n\t\t\t\tmaterial.scale = [1.0, 1.0];\n\t\t\t\tmaterial.rotation = 0.0;\n\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_TEXMAP_NAME) {\n\t\t\t\t\t\tmaterial.texture = ReadName (reader);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_UOFFSET) {\n\t\t\t\t\t\tmaterial.offset[0] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_VOFFSET) {\n\t\t\t\t\t\tmaterial.offset[1] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_USCALE) {\n\t\t\t\t\t\tmaterial.scale[0] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_VSCALE) {\n\t\t\t\t\t\tmaterial.scale[1] = reader.ReadFloat32 ();\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP_ROTATION) {\n\t\t\t\t\t\tmaterial.rotation = reader.ReadFloat32 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadMaterialChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read material chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar material = {};\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.MAT_NAME) {\n\t\t\t\t\t\tOnLog ('Read material name chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.name = ReadName (reader);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_AMBIENT) {\n\t\t\t\t\t\tOnLog ('Read material ambient chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.ambient = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_DIFFUSE) {\n\t\t\t\t\t\tOnLog ('Read material diffuse chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.diffuse = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SPECULAR) {\n\t\t\t\t\t\tOnLog ('Read material specular chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.specular = ReadColorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SHININESS) {\n\t\t\t\t\t\tOnLog ('Read material shininess chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.shininess = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_SHININESS_STRENGTH) {\n\t\t\t\t\t\tOnLog ('Read material shininess strength chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.shininessStrength = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TRANSPARENCY) {\n\t\t\t\t\t\tOnLog ('Read material transparency chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tmaterial.transparency = ReadPercentageChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.MAT_TEXMAP) {\n\t\t\t\t\t\tOnLog ('Read material texture map chunk (' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\t\t\tReadTextureMapChunk (reader, chunkId, chunkLength, material);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tOnMaterial (material);\n\t\t\t}\n\n\t\t\tfunction ReadVerticesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read vertices chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar vertexCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, x, y, z;\n\t\t\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\t\t\tx = reader.ReadFloat32 ();\n\t\t\t\t\ty = reader.ReadFloat32 ();\n\t\t\t\t\tz = reader.ReadFloat32 ();\n\t\t\t\t\tOnVertex (x, y, z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadTextureVerticesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read texture vertices chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar texVertexCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, x, y;\n\t\t\t\tfor (i = 0; i < texVertexCount; i++) {\n\t\t\t\t\tx = reader.ReadFloat32 ();\n\t\t\t\t\ty = reader.ReadFloat32 ();\n\t\t\t\t\tOnTextureVertex (x, y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadFaceMaterialsChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read face materials chunk (' + id.toString (16) + ', ' + length + ')', 5);\n\t\t\t\t\n\t\t\t\tvar materialName = ReadName (reader);\n\t\t\t\tvar faceCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, faceIndex;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tfaceIndex = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tOnFaceMaterial (faceIndex, materialName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadFaceSmoothingGroupsChunk (reader, faceCount, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read face smoothing groups chunk (' + id.toString (16) + ', ' + length + ')', 5);\n\t\t\t\t\n\t\t\t\tvar i, smoothingGroup;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tsmoothingGroup = reader.ReadUnsignedInteger32 ();\n\t\t\t\t\tOnFaceSmoothingGroup (i, smoothingGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ReadFacesChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read faces chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar faceCount = reader.ReadUnsignedInteger16 ();\n\t\t\t\tvar i, v0, v1, v2, flags;\n\t\t\t\tfor (i = 0; i < faceCount; i++) {\n\t\t\t\t\tv0 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tv1 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tv2 = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tflags = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\tOnFace (v0, v1, v2, flags);\n\t\t\t\t}\n\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.TRI_MATERIAL) {\n\t\t\t\t\t\tReadFaceMaterialsChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_SMOOTH) {\n\t\t\t\t\t\tReadFaceSmoothingGroupsChunk (reader, faceCount,  chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 5);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadTransformationChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read transformation chunk (' + id.toString (16) + ', ' + length + ')', 4);\n\t\t\t\tvar matrix = [];\n\t\t\t\tvar i, j;\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\tmatrix.push (reader.ReadFloat32 ());\n\t\t\t\t\t}\n\t\t\t\t\tif (i < 3) {\n\t\t\t\t\t\tmatrix.push (0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatrix.push (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tOnTransformation (matrix);\n\t\t\t}\n\n\t\t\tfunction ReadMeshChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read mesh chunk (' + objectName + ', ' +  id.toString (16) + ', ' + length + ')', 3);\n\n\t\t\t\tOnMesh (objectName);\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.TRI_VERTEX) {\n\t\t\t\t\t\tReadVerticesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_TEXVERTEX) {\n\t\t\t\t\t\tReadTextureVerticesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_FACE) {\n\t\t\t\t\t\tReadFacesChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.TRI_TRANSFORMATION) {\n\t\t\t\t\t\tReadTransformationChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 4);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadLightChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Skip light chunk (' + objectName + ', ' + id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\tSkipChunk (reader, length);\n\t\t\t}\n\n\t\t\tfunction ReadCameraChunk (reader, objectName, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Skip camera chunk (' + objectName + ', ' +  id.toString (16) + ', ' + length + ')', 3);\n\t\t\t\tSkipChunk (reader, length);\n\t\t\t}\n\n\t\t\tfunction ReadObjectChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read object chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tvar objectName = ReadName (reader);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJ_TRIMESH) {\n\t\t\t\t\t\tReadMeshChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.OBJ_LIGHT) {\n\t\t\t\t\t\tReadLightChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.OBJ_CAMERA) {\n\t\t\t\t\t\tReadCameraChunk (reader, objectName, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadEditorChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read editor chunk (' + id.toString (16) + ', ' + length + ')', 1);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.EDIT_MATERIAL) {\n\t\t\t\t\t\tReadMaterialChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.EDIT_OBJECT) {\n\t\t\t\t\t\tReadObjectChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 2);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction ReadObjectNodeChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tfunction ReadTrackVector (reader, type)\n\t\t\t\t{\n\t\t\t\t\tvar result = [];\n\t\t\t\t\treader.Skip (10);\n\t\t\t\t\t\n\t\t\t\t\tvar i, flags, current, tmp;\n\t\t\t\t\tvar keyNum = reader.ReadInteger32 ();\n\t\t\t\t\tfor (i = 0; i < keyNum; i++) {\n\t\t\t\t\t\treader.ReadInteger32 ();\n\t\t\t\t\t\tflags = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t\tif (flags !== 0) {\n\t\t\t\t\t\t\treader.ReadFloat32 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurrent = null;\n\t\t\t\t\t\tif (type == chunks.OBJECT_ROTATION) {\n\t\t\t\t\t\t\ttmp = reader.ReadFloat32 ();\n\t\t\t\t\t\t\tcurrent = ReadVector (reader);\n\t\t\t\t\t\t\tcurrent[3] = tmp;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent = ReadVector (reader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push (current);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tOnLog ('Read object node chunk (' + id.toString (16) + ', ' + length + ')', 2);\n\t\t\t\t\n\t\t\t\tvar objectNode = {\n\t\t\t\t\tname : '',\n\t\t\t\t\tnodeId : -1,\n\t\t\t\t\tflags : -1,\n\t\t\t\t\tuserId : -1,\n\t\t\t\t\tpivot : [0.0, 0.0, 0.0],\n\t\t\t\t\tpositions : [],\n\t\t\t\t\trotations : [],\n\t\t\t\t\tscales : []\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJECT_HIERARCHY) {\n\t\t\t\t\t\tobjectNode.name = ReadName (reader);\n\t\t\t\t\t\tobjectNode.flags = reader.ReadUnsignedInteger32 ();\n\t\t\t\t\t\tobjectNode.userId = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_PIVOT) {\n\t\t\t\t\t\tobjectNode.pivot = ReadVector (reader);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_POSITION) {\n\t\t\t\t\t\tobjectNode.positions = ReadTrackVector (reader, chunks.OBJECT_POSITION);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_ROTATION) {\n\t\t\t\t\t\tobjectNode.rotations = ReadTrackVector (reader, chunks.OBJECT_ROTATION);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_SCALE) {\n\t\t\t\t\t\tobjectNode.scales = ReadTrackVector (reader, chunks.OBJECT_SCALE);\n\t\t\t\t\t} else if (chunkId == chunks.OBJECT_ID) {\n\t\t\t\t\t\tobjectNode.nodeId = reader.ReadUnsignedInteger16 ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 3);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tOnObjectNode (objectNode);\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadKeyFrameChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read keyframe chunk (' + id.toString (16) + ', ' + length + ')', 1);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.OBJECT_NODE) {\n\t\t\t\t\t\tReadObjectNodeChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 2);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction ReadMainChunk (reader, id, length)\n\t\t\t{\n\t\t\t\tOnLog ('Read main chunk (' + id.toString (16) + ', ' + length + ')', 0);\n\t\t\t\t\n\t\t\t\tvar endByte = GetChunkEnd (reader, length);\n\t\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\t\tif (chunkId == chunks.EDIT3DS) {\n\t\t\t\t\t\tReadEditorChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else if (chunkId == chunks.KF3DS) {\n\t\t\t\t\t\tReadKeyFrameChunk (reader, chunkId, chunkLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 1);\n\t\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\n\t\t\tvar endByte = reader.GetByteLength ();\n\t\t\tReadChunks (reader, endByte, function (chunkId, chunkLength) {\n\t\t\t\tif (chunkId == chunks.MAIN3DS) {\n\t\t\t\t\tReadMainChunk (reader, chunkId, chunkLength);\n\t\t\t\t} else {\n\t\t\t\t\tOnLog ('Skip chunk (' + chunkId.toString (16) + ', ' + chunkLength + ')', 0);\n\t\t\t\t\tSkipChunk (reader, chunkLength);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar chunks = {\n\t\t\tMAIN3DS : 0x4D4D,\n\t\t\tEDIT3DS : 0x3D3D,\n\t\t\tEDIT_MATERIAL : 0xAFFF,\n\t\t\tMAT_NAME : 0xA000,\n\t\t\tMAT_AMBIENT : 0xA010,\n\t\t\tMAT_DIFFUSE : 0xA020,\n\t\t\tMAT_SPECULAR : 0xA030,\n\t\t\tMAT_SHININESS : 0xA040,\n\t\t\tMAT_SHININESS_STRENGTH : 0xA041,\n\t\t\tMAT_TRANSPARENCY : 0xA050,\n\t\t\tMAT_COLOR_F : 0x0010,\n\t\t\tMAT_COLOR : 0x0011,\n\t\t\tMAT_LIN_COLOR : 0x0012,\n\t\t\tMAT_LIN_COLOR_F : 0x0013,\n\t\t\tMAT_TEXMAP : 0xA200,\n\t\t\tMAT_TEXMAP_NAME : 0xA300,\n\t\t\tMAT_TEXMAP_UOFFSET : 0xA358,\n\t\t\tMAT_TEXMAP_VOFFSET : 0xA35A,\n\t\t\tMAT_TEXMAP_USCALE : 0xA354,\n\t\t\tMAT_TEXMAP_VSCALE : 0xA356,\n\t\t\tMAT_TEXMAP_ROTATION : 0xA35C,\n\t\t\tPERCENTAGE : 0x0030,\n\t\t\tPERCENTAGE_F : 0x0031,\n\t\t\tEDIT_OBJECT : 0x4000,\n\t\t\tOBJ_TRIMESH : 0x4100,\n\t\t\tOBJ_LIGHT : 0x4600,\n\t\t\tOBJ_CAMERA : 0x4700,\n\t\t\tTRI_VERTEX : 0x4110,\n\t\t\tTRI_TEXVERTEX : 0x4140,\n\t\t\tTRI_FACE : 0x4120,\n\t\t\tTRI_TRANSFORMATION : 0x4160,\n\t\t\tTRI_MATERIAL : 0x4130,\n\t\t\tTRI_SMOOTH : 0x4150,\n\t\t\tKF3DS : 0xB000,\n\t\t\tOBJECT_NODE : 0xB002,\n\t\t\tOBJECT_HIERARCHY : 0xB010,\n\t\t\tOBJECT_PIVOT : 0xB013,\n\t\t\tOBJECT_POSITION : 0xB020,\n\t\t\tOBJECT_ROTATION : 0xB021,\n\t\t\tOBJECT_SCALE : 0xB022,\n\t\t\tOBJECT_ID : 0xB030\n\t\t};\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\tReadFile (reader, chunks);\n\t};\n\n\tJSM.Convert3dsToJsonData = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction FinalizeMeshes (nodeHierarcy, triangleModel, materialNameToIndex)\n\t\t{\n\t\t\tfunction ApplyTransformation (body, node, nodeHierarcy)\n\t\t\t{\n\t\t\t\tfunction MatrixScale (matrix, scale)\n\t\t\t\t{\n\t\t\t\t\tvar x = scale[0];\n\t\t\t\t\tvar y = scale[1];\n\t\t\t\t\tvar z = scale[2];\n\t\t\t\t\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\t\tmatrix[0 * 4 + i] *= x;\n\t\t\t\t\t\tmatrix[1 * 4 + i] *= y;\n\t\t\t\t\t\tmatrix[2 * 4 + i] *= z;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn matrix;\n\t\t\t\t}\n\n\t\t\t\tfunction MatrixTranslate (matrix, translation)\n\t\t\t\t{\n\t\t\t\t\tvar x = translation[0];\n\t\t\t\t\tvar y = translation[1];\n\t\t\t\t\tvar z = translation[2];\n\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tmatrix[3 * 4 + i] += matrix[0 * 4 + i] * x + matrix[1 * 4 + i] * y + matrix[2 * 4 + i] * z;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn matrix;\n\t\t\t\t}\n\n\t\t\t\tfunction MatrixRotate (matrix, quaternion)\n\t\t\t\t{\n\t\t\t\t\tvar rotation = JSM.MatrixRotationQuaternion (quaternion);\n\t\t\t\t\treturn JSM.MatrixMultiply (rotation, matrix);\n\t\t\t\t}\n\n\t\t\t\tfunction TransformBodyVertices (body, matrix)\n\t\t\t\t{\n\t\t\t\t\tvar i, vertex, transformedVertex;\n\t\t\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\t\t\ttransformedVertex = JSM.ApplyTransformation (matrix, vertex);\n\t\t\t\t\t\tbody.SetVertex (i, transformedVertex.x, transformedVertex.y, transformedVertex.z);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction FlipByXCoordinates (body, matrix, invMatrix)\t\n\t\t\t\t{\n\t\t\t\t\tvar determinant = JSM.MatrixDeterminant (matrix);\n\t\t\t\t\tif (!JSM.IsNegative (determinant)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar flippedMatrix = JSM.MatrixClone (matrix);\n\t\t\t\t\tMatrixScale (flippedMatrix, [-1.0, 1.0, 1.0]);\n\t\t\t\t\t\n\t\t\t\t\tvar finalMatrix = JSM.MatrixMultiply (invMatrix, flippedMatrix);\n\t\t\t\t\tTransformBodyVertices (body, finalMatrix);\n\t\t\t\t}\n\n\t\t\t\tfunction GetNodeTransformation (node, nodeHierarcy)\n\t\t\t\t{\n\t\t\t\t\tfunction GetNodePosition (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.positions.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node.positions[0];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tfunction GetNodeRotation (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tfunction GetQuatFromAxisAndAngle (quat)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar result = [0.0, 0.0, 0.0, 1.0];\n\t\t\t\t\t\t\tvar length = Math.sqrt (quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2]);\n\t\t\t\t\t\t\tif (JSM.IsPositive (length)) {\n\t\t\t\t\t\t\t\tvar omega = quat[3] * -0.5;\n\t\t\t\t\t\t\t\tvar si = Math.sin (omega) / length;\n\t\t\t\t\t\t\t\tresult = [si * quat[0], si * quat[1], si * quat[2], Math.cos (omega)];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (node.rotations.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar quat = node.rotations[0];\n\t\t\t\t\t\treturn GetQuatFromAxisAndAngle (quat);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction GetNodeScale (node)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.scales.length === 0) {\n\t\t\t\t\t\t\treturn [0.0, 0.0, 0.0, 0.0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node.scales[0];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (node.matrix !== undefined) {\n\t\t\t\t\t\treturn node.matrix;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar result = JSM.MatrixIdentity ();\n\t\t\t\t\tresult = MatrixTranslate (result, GetNodePosition (node));\n\t\t\t\t\tresult = MatrixRotate (result, GetNodeRotation (node));\n\t\t\t\t\tresult = MatrixScale (result, GetNodeScale (node));\n\t\t\t\t\t\n\t\t\t\t\tif (node.userId != 65535) {\n\t\t\t\t\t\tvar parentIndex = nodeHierarcy.nodeIdToIndex[node.userId];\n\t\t\t\t\t\tif (parentIndex !== undefined) {\n\t\t\t\t\t\t\tvar parentNode = nodeHierarcy.nodes[parentIndex];\n\t\t\t\t\t\t\tvar parentTransformation = GetNodeTransformation (parentNode, nodeHierarcy);\n\t\t\t\t\t\t\tresult = JSM.MatrixMultiply (result, parentTransformation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode.matrix = result;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tfunction GetNodePivotPoint (node)\n\t\t\t\t{\n\t\t\t\t\tif (node === undefined || node === null) {\n\t\t\t\t\t\treturn [0.0, 0.0, 0.0];\n\t\t\t\t\t}\n\t\t\t\t\treturn node.pivot;\n\t\t\t\t}\n\n\t\t\t\tfunction GetMeshTransformation (mesh)\n\t\t\t\t{\n\t\t\t\t\tif (mesh === undefined || mesh === null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn mesh.transformation;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar currentMeshData = body.meshData;\n\t\t\t\tvar meshTransformation = GetMeshTransformation (currentMeshData);\n\t\t\t\tif (meshTransformation === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar nodeTransformation = null;\n\t\t\t\tif (node !== null) {\n\t\t\t\t\tnodeTransformation = GetNodeTransformation (node, nodeHierarcy);\n\t\t\t\t} else {\n\t\t\t\t\tnodeTransformation = meshTransformation;\n\t\t\t\t}\n\n\t\t\t\tvar matrix = JSM.MatrixClone (nodeTransformation);\n\t\t\t\tvar meshMatrix = JSM.MatrixClone (meshTransformation);\n\t\t\t\tvar invMeshMatrix = JSM.MatrixInvert (meshMatrix);\n\t\t\t\tif (invMeshMatrix === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tFlipByXCoordinates (body, meshMatrix, invMeshMatrix);\n\n\t\t\t\tvar nodePivotPoint = GetNodePivotPoint (node);\n\t\t\t\tMatrixTranslate (matrix, [-nodePivotPoint[0], -nodePivotPoint[1], -nodePivotPoint[2]]);\n\t\t\t\tvar finalMatrix = JSM.MatrixMultiply (invMeshMatrix, matrix);\n\t\t\t\tTransformBodyVertices (body, finalMatrix);\n\t\t\t}\n\n\t\t\tfunction FinalizeMaterials (body, materialNameToIndex)\n\t\t\t{\n\t\t\t\tvar hasTextureCoordinates = (body.UVCount () == body.VertexCount ());\n\t\t\t\tvar currentMeshData = body.meshData;\n\t\t\t\tvar i, triangle, materialName, materialIndex, smoothingGroup;\n\t\t\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\t\t\ttriangle = body.GetTriangle (i);\n\t\t\t\t\tif (hasTextureCoordinates) {\n\t\t\t\t\t\ttriangle.u0 = triangle.v0;\n\t\t\t\t\t\ttriangle.u1 = triangle.v1;\n\t\t\t\t\t\ttriangle.u2 = triangle.v2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmaterialName = currentMeshData.faceToMaterial[i];\n\t\t\t\t\tif (materialName !== undefined) {\n\t\t\t\t\t\tmaterialIndex = materialNameToIndex[materialName];\n\t\t\t\t\t\tif (materialIndex !== undefined) {\n\t\t\t\t\t\t\ttriangle.mat = materialIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsmoothingGroup = currentMeshData.faceToSmoothingGroup[i];\n\t\t\t\t\tif (smoothingGroup !== undefined && smoothingGroup > 0) {\n\t\t\t\t\t\ttriangle.curve = smoothingGroup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction FinalizeMesh (body, node, materialNameToIndex, nodeHierarcy)\n\t\t\t{\n\t\t\t\tApplyTransformation (body, node, nodeHierarcy);\n\t\t\t\tFinalizeMaterials (body, materialNameToIndex);\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfunction DuplicateBody (model, body, bodyIndex, instanceIndex)\n\t\t\t{\n\t\t\t\tvar clonedBody = body.Clone ();\n\t\t\t\tclonedBody.SetName (clonedBody.GetName () + ' (' + instanceIndex + ')');\n\t\t\t\tif (bodyIndex < model.BodyCount ()) {\n\t\t\t\t\tmodel.AddBodyToIndex (clonedBody, bodyIndex);\n\t\t\t\t} else {\n\t\t\t\t\tmodel.AddBody (clonedBody);\n\t\t\t\t}\n\t\t\t\treturn clonedBody;\n\t\t\t}\n\n\t\t\tvar i, j, currentBody, currentMeshData, currentNode;\n\t\t\tvar firstNode, addedBody;\n\t\t\tfor (i = 0; i < triangleModel.BodyCount (); i++) {\n\t\t\t\tcurrentBody = triangleModel.GetBody (i);\n\t\t\t\tcurrentMeshData = currentBody.meshData;\n\t\t\t\tif (currentMeshData.objectNodes.length === 0) {\n\t\t\t\t\tFinalizeMesh (currentBody, null, materialNameToIndex, nodeHierarcy);\n\t\t\t\t} else {\n\t\t\t\t\tfirstNode = nodeHierarcy.nodes[currentMeshData.objectNodes[0]];\n\t\t\t\t\tfor (j = 1; j < currentMeshData.objectNodes.length; j++) {\n\t\t\t\t\t\tcurrentNode = nodeHierarcy.nodes[currentMeshData.objectNodes[j]];\n\t\t\t\t\t\taddedBody = DuplicateBody (triangleModel, currentBody, i + 1, j + 1);\n\t\t\t\t\t\taddedBody.meshData = currentBody.meshData;\n\t\t\t\t\t\tFinalizeMesh (addedBody, currentNode, materialNameToIndex, nodeHierarcy);\n\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tFinalizeMesh (currentBody, firstNode, materialNameToIndex, nodeHierarcy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar currentBody = null;\n\t\t\n\t\tvar materialNameToIndex = {};\n\t\tvar bodyNameToIndex = {};\n\n\t\tvar nodeHierarcy = {\n\t\t\tnodes : [],\n\t\t\tnodeIdToIndex : {}\n\t\t};\n\t\t\n\t\tJSM.Read3dsFile (arrayBuffer, {\n\t\t\tonMaterial : function (material) {\n\t\t\t\tfunction GetOpacity (transparency)\n\t\t\t\t{\n\t\t\t\t\tif (transparency === undefined || transparency === null) {\n\t\t\t\t\t\treturn 1.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1.0 - transparency;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetShininess (shininess, shininessStrength)\n\t\t\t\t{\n\t\t\t\t\tif (shininess === undefined || shininess === null) {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tif (shininessStrength === undefined || shininessStrength === null) {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn shininess * shininessStrength;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (materialNameToIndex[material.name] !== undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar index = triangleModel.AddMaterial ({\n\t\t\t\t\tname : material.name,\n\t\t\t\t\tambient : material.ambient,\n\t\t\t\t\tdiffuse : material.diffuse,\n\t\t\t\t\tspecular : material.specular,\n\t\t\t\t\tshininess : GetShininess (material.shininess, material.shininessStrength),\n\t\t\t\t\topacity : GetOpacity (material.transparency)\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar currentMaterial = triangleModel.GetMaterial (index);\n\t\t\t\tif (material.texture !== undefined && material.texture !== null) {\n\t\t\t\t\tvar textureBuffer = OnFileRequested (material.texture);\n\t\t\t\t\tif (textureBuffer !== null) {\n\t\t\t\t\t\tvar blob = new window.Blob ([textureBuffer]);\n\t\t\t\t\t\tvar blobURL = window.URL.createObjectURL (blob);\n\t\t\t\t\t\tcurrentMaterial.texture = blobURL;\n\t\t\t\t\t\tcurrentMaterial.offset = material.offset;\n\t\t\t\t\t\tcurrentMaterial.scale = material.scale;\n\t\t\t\t\t\tcurrentMaterial.rotation = -material.rotation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaterialNameToIndex[material.name] = index;\n\t\t\t},\n\t\t\tonMesh : function (meshName) {\n\t\t\t\tif (bodyNameToIndex[meshName] !== undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody (meshName));\n\t\t\t\tcurrentBody = triangleModel.GetBody (index);\n\t\t\t\tcurrentBody.meshData ={\n\t\t\t\t\tfaceToMaterial : {},\n\t\t\t\t\tfaceToSmoothingGroup : {},\n\t\t\t\t\tobjectNodes : [],\n\t\t\t\t\ttransformation : null\n\t\t\t\t};\n\t\t\t\tbodyNameToIndex[meshName] = index;\n\t\t\t},\n\t\t\tonTransformation : function (matrix) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.transformation = matrix;\n\t\t\t},\n\t\t\tonObjectNode : function (objectNode) {\n\t\t\t\tvar nodeIndex = nodeHierarcy.nodes.length;\n\t\t\t\tnodeHierarcy.nodes.push (objectNode);\n\t\t\t\tnodeHierarcy.nodeIdToIndex[objectNode.nodeId] = nodeIndex;\n\n\t\t\t\tvar bodyIndex = bodyNameToIndex[objectNode.name];\n\t\t\t\tif (bodyIndex === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar body = triangleModel.GetBody (bodyIndex);\n\t\t\t\tbody.meshData.objectNodes.push (nodeIndex);\n\t\t\t},\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonTextureVertex : function (x, y) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddUV (x, y);\n\t\t\t},\n\t\t\tonFace : function (v0, v1, v2) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t},\n\t\t\tonFaceMaterial : function (faceIndex, materialName) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.faceToMaterial[faceIndex] = materialName;\n\t\t\t},\n\t\t\tonFaceSmoothingGroup : function (faceIndex, smoothingGroup) {\n\t\t\t\tif (currentBody === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentBody.meshData.faceToSmoothingGroup[faceIndex] = smoothingGroup;\n\t\t\t},\n\t\t\tonFileRequested : OnFileRequested\n\t\t});\n\t\t\n\t\tFinalizeMeshes (nodeHierarcy, triangleModel, materialNameToIndex);\n\t\ttriangleModel.Finalize ();\n\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerobj',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadObjFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnNewMaterial (name)\n\t\t{\n\t\t\tif (callbacks.onNewMaterial !== undefined && callbacks.onNewMaterial !== null) {\n\t\t\t\tcallbacks.onNewMaterial (name);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialComponent (name, red, green, blue)\n\t\t{\n\t\t\tif (callbacks.onMaterialComponent !== undefined && callbacks.onMaterialComponent !== null) {\n\t\t\t\tcallbacks.onMaterialComponent (name, red, green, blue);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialParameter (name, value)\n\t\t{\n\t\t\tif (callbacks.onMaterialParameter !== undefined && callbacks.onMaterialParameter !== null) {\n\t\t\t\tcallbacks.onMaterialParameter (name, value);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMaterialTexture (textureName)\n\t\t{\n\t\t\tif (callbacks.onMaterialTexture !== undefined && callbacks.onMaterialTexture !== null) {\n\t\t\t\tcallbacks.onMaterialTexture (textureName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnUseMaterial (name)\n\t\t{\n\t\t\tif (callbacks.onUseMaterial !== undefined && callbacks.onUseMaterial !== null) {\n\t\t\t\tcallbacks.onUseMaterial (name);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnMesh (meshName)\n\t\t{\n\t\t\tif (callbacks.onMesh !== undefined && callbacks.onMesh !== null) {\n\t\t\t\tcallbacks.onMesh (meshName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnNormal (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onNormal !== undefined && callbacks.onNormal !== null) {\n\t\t\t\tcallbacks.onNormal (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnTexCoord (x, y)\n\t\t{\n\t\t\tif (callbacks.onTexCoord !== undefined && callbacks.onTexCoord !== null) {\n\t\t\t\tcallbacks.onTexCoord (x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices, normals, uvs)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices, normals, uvs);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction ProcessLine (line, objectCounter)\n\t\t{\n\t\t\tfunction GetIndex (index, count)\n\t\t\t{\n\t\t\t\tif (index > 0) {\n\t\t\t\t\treturn index - 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn count + index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction GetFileName (line, keyword)\n\t\t\t{\n\t\t\t\tvar fileNameIndex = line.indexOf (keyword) + keyword.length;\n\t\t\t\tvar fileName = line.substr (fileNameIndex, line.length - fileNameIndex);\n\t\t\t\treturn fileName.trim ();\n\t\t\t}\n\t\t\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar i, fileName;\n\t\t\tif (lineParts[0] == 'g') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar meshName = '';\n\t\t\t\tfor (i = 1; i < lineParts.length; i++) {\n\t\t\t\t\tmeshName += lineParts[i];\n\t\t\t\t\tif (i < lineParts.length - 1) {\n\t\t\t\t\t\tmeshName += ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOnMesh (meshName);\n\t\t\t} else if (lineParts[0] == 'v') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.vertexCount += 1;\n\t\t\t\tOnVertex (parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'vn') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.normalCount += 1;\n\t\t\t\tOnNormal (parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'vt') {\n\t\t\t\tif (lineParts.length < 3) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectCounter.uvCount += 1;\n\t\t\t\tOnTexCoord (parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t} else if (lineParts[0] == 'f') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar uvs = [];\n\t\t\t\t\n\t\t\t\tvar partSplitted;\n\t\t\t\tfor (i = 1; i < lineParts.length; i++) {\n\t\t\t\t\tpartSplitted = lineParts[i].split ('/');\n\t\t\t\t\tvertices.push (GetIndex (parseInt (partSplitted[0], 10), objectCounter.vertexCount));\n\t\t\t\t\tif (partSplitted.length > 1 && partSplitted[1].length > 0) {\n\t\t\t\t\t\tuvs.push (GetIndex (parseInt (partSplitted[1], 10), objectCounter.uvCount));\n\t\t\t\t\t}\n\t\t\t\t\tif (partSplitted.length > 2 && partSplitted[2].length > 0) {\n\t\t\t\t\t\tnormals.push (GetIndex (parseInt (partSplitted[2], 10), objectCounter.normalCount));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOnFace (vertices, normals, uvs);\n\t\t\t} else if (lineParts[0] == 'usemtl') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnUseMaterial (lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'newmtl') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnNewMaterial (lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'Ka' || lineParts[0] == 'Kd' || lineParts[0] == 'Ks') {\n\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnMaterialComponent (lineParts[0], parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3]));\n\t\t\t} else if (lineParts[0] == 'Ns' || lineParts[0] == 'Tr' || lineParts[0] == 'd') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tOnMaterialParameter (lineParts[0], lineParts[1]);\n\t\t\t} else if (lineParts[0] == 'map_Kd') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfileName = GetFileName (line, 'map_Kd');\n\t\t\t\tOnMaterialTexture (fileName);\n\t\t\t} else if (lineParts[0] == 'mtllib') {\n\t\t\t\tif (lineParts.length < 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileName = GetFileName (line, 'mtllib');\n\t\t\t\tvar fileStringBuffer = OnFileRequested (fileName.trim ());\n\t\t\t\tif (fileStringBuffer === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tProcessFile (fileStringBuffer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer, objectCounter)\n\t\t{\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, objectCounter);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar objectCounter = {\n\t\t\tvertexCount : 0,\n\t\t\tnormalCount : 0,\n\t\t\tuvCount : 0\n\t\t};\n\n\t\tProcessFile (stringBuffer, objectCounter);\n\t};\n\n\tJSM.ConvertObjToJsonData = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFileRequested (fileName)\n\t\t{\n\t\t\tif (callbacks.onFileRequested !== undefined && callbacks.onFileRequested !== null) {\n\t\t\t\treturn callbacks.onFileRequested (fileName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tvar materialNameToIndex = {};\n\t\tvar currentMaterial = null;\n\t\tvar currentMaterialIndex = null;\n\t\t\n\t\tvar globalVertices = [];\n\t\tvar globalNormals = [];\n\t\tvar globalUVs = [];\n\t\t\n\t\tvar globalToLocalVertices = {};\n\t\tvar globalToLocalNormals = {};\n\t\tvar globalToLocalUVs = {};\n\t\t\n\t\tJSM.ReadObjFile (stringBuffer, {\n\t\t\tonNewMaterial : function (name) {\n\t\t\t\tvar index = triangleModel.AddMaterial ({\n\t\t\t\t\tname : name\n\t\t\t\t});\n\t\t\t\tcurrentMaterial = triangleModel.GetMaterial (index);\n\t\t\t\tmaterialNameToIndex[name] = index;\n\t\t\t},\n\t\t\tonMaterialComponent : function (name, red, green, blue) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (name == 'Ka') {\n\t\t\t\t\tcurrentMaterial.ambient = [red, green, blue];\n\t\t\t\t} else if (name == 'Kd') {\n\t\t\t\t\tcurrentMaterial.diffuse = [red, green, blue];\n\t\t\t\t} else if (name == 'Ks') {\n\t\t\t\t\tcurrentMaterial.specular = [red, green, blue];\n\t\t\t\t}\n\t\t\t},\n\t\t\tonMaterialParameter : function (name, value) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (name == 'Ns') {\n\t\t\t\t\tcurrentMaterial.shininess = 0.0;\n\t\t\t\t\tif (JSM.IsPositive (value)) {\n\t\t\t\t\t\tcurrentMaterial.shininess = (Math.log2 (parseFloat (value)) - 1) / 10.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (name == 'Tr') {\n\t\t\t\t\tcurrentMaterial.opacity = 1.0 - parseFloat (value);\n\t\t\t\t} else if (name == 'd') {\n\t\t\t\t\tcurrentMaterial.opacity = parseFloat (value);\n\t\t\t\t}\t\t\t\n\t\t\t},\n\t\t\tonMaterialTexture : function (textureName) {\n\t\t\t\tif (currentMaterial === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar textureBuffer = OnFileRequested (textureName);\n\t\t\t\tif (textureBuffer === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar blob = new window.Blob ([textureBuffer]);\n\t\t\t\tvar blobURL = window.URL.createObjectURL (blob);\n\t\t\t\tcurrentMaterial.texture = blobURL;\n\t\t\t},\n\t\t\tonUseMaterial : function (name) {\n\t\t\t\tvar materialIndex = materialNameToIndex[name];\n\t\t\t\tif (materialIndex !== undefined) {\n\t\t\t\t\tcurrentMaterialIndex = materialIndex;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonMesh : function (meshName) {\n\t\t\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody (meshName));\n\t\t\t\tcurrentBody = triangleModel.GetBody (index);\n\t\t\t\tglobalToLocalVertices = {};\n\t\t\t\tglobalToLocalNormals = {};\n\t\t\t\tglobalToLocalUVs = {};\n\t\t\t},\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tglobalVertices.push (new JSM.Coord (x, y, z));\n\t\t\t},\n\t\t\tonNormal : function (x, y, z) {\n\t\t\t\tglobalNormals.push (new JSM.Coord (x, y, z));\n\t\t\t},\n\t\t\tonTexCoord : function (x, y) {\n\t\t\t\tglobalUVs.push (new JSM.Coord2D (x, y));\n\t\t\t},\n\t\t\tonFace : function (vertices, normals, uvs) {\n\t\t\t\tfunction GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, valueAdderFunc)\n\t\t\t\t{\n\t\t\t\t\tif (globalIndex < 0 || globalIndex >= globalValueArray.length) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\tvar result = globalToLocalIndices[globalIndex];\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tvar globalValue = globalValueArray[globalIndex];\n\t\t\t\t\t\tresult = valueAdderFunc (globalValue);\n\t\t\t\t\t\tglobalToLocalIndices[globalIndex] = result;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalVertexIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddVertex (val.x, val.y, val.z);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalNormalIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddNormal (val.x, val.y, val.z);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction GetLocalUVIndex (triangleBody, globalValueArray, globalToLocalIndices, globalIndex)\n\t\t\t\t{\n\t\t\t\t\treturn GetLocalIndex (globalValueArray, globalToLocalIndices, globalIndex, function (val) {\n\t\t\t\t\t\treturn triangleBody.AddUV (val.x, val.y);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar i, v0, v1, v2, triangle, triangleIndex;\n\t\t\t\tvar hasNormals = (normals.length == vertices.length);\n\t\t\t\tvar hasUVs = (uvs.length == vertices.length);\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[0]);\n\t\t\t\t\tv1 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[(i + 1) % count]);\n\t\t\t\t\tv2 = GetLocalVertexIndex (currentBody, globalVertices, globalToLocalVertices, vertices[(i + 2) % count]);\n\t\t\t\t\ttriangleIndex = currentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t\ttriangle = currentBody.GetTriangle (triangleIndex);\n\t\t\t\t\tif (hasNormals) {\n\t\t\t\t\t\ttriangle.n0 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[0]);\n\t\t\t\t\t\ttriangle.n1 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[(i + 1) % count]);\n\t\t\t\t\t\ttriangle.n2 = GetLocalNormalIndex (currentBody, globalNormals, globalToLocalNormals, normals[(i + 2) % count]);\n\t\t\t\t\t}\n\t\t\t\t\tif (hasUVs) {\n\t\t\t\t\t\ttriangle.u0 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[0]);\n\t\t\t\t\t\ttriangle.u1 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[(i + 1) % count]);\n\t\t\t\t\t\ttriangle.u2 = GetLocalUVIndex (currentBody, globalUVs, globalToLocalUVs, uvs[(i + 2) % count]);\n\t\t\t\t\t}\n\t\t\t\t\tif (currentMaterialIndex !== null) {\n\t\t\t\t\t\ttriangle.mat = currentMaterialIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonFileRequested : OnFileRequested\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importerstl',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadBinaryStlFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tvar i, v0, v1, v2, normal;\n\t\tfor (i = 0; i < triangleCount; i++) {\n\t\t\tnormal = ReadVector (reader);\n\t\t\tv0 = ReadVector (reader);\n\t\t\tv1 = ReadVector (reader);\n\t\t\tv2 = ReadVector (reader);\n\t\t\treader.Skip (2);\n\t\t\tOnFace (v0, v1, v2, normal);\n\t\t}\n\t};\n\n\tJSM.ReadAsciiStlFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (lines, lineIndex)\n\t\t{\n\t\t\tfunction GetLine (lines, lineIndex)\n\t\t\t{\n\t\t\t\treturn lines[lineIndex].trim ();\n\t\t\t}\n\t\t\n\t\t\tfunction GetVertices (lines, lineIndex, vertices)\n\t\t\t{\n\t\t\t\tvar currentLineIndex, currentLine, lineParts, vertex;\n\t\t\t\tfor (currentLineIndex = lineIndex; currentLineIndex < lines.length && vertices.length < 3; currentLineIndex++) {\n\t\t\t\t\tcurrentLine = GetLine (lines, currentLineIndex);\n\t\t\t\t\tif (currentLine.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlineParts = currentLine.split (/\\s+/);\n\t\t\t\t\tif (lineParts.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (lineParts[0] == 'vertex') {\n\t\t\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvertex = [parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3])];\n\t\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn currentLineIndex + 1;\n\t\t\t}\n\t\t\n\t\t\tvar line = GetLine (lines, lineIndex);\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\n\t\t\tif (lineParts[0] == 'solid') {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t} else if (lineParts[0] == 'facet' && lineParts[1] == 'normal') {\n\t\t\t\tif (lineParts.length < 5) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar normal = [parseFloat (lineParts[2]), parseFloat (lineParts[3]), parseFloat (lineParts[4])];\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar nextLineIndex = GetVertices (lines, lineIndex + 1, vertices);\n\t\t\t\tif (vertices.length != 3) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnFace (vertices[0], vertices[1], vertices[2], normal);\n\t\t\t\treturn nextLineIndex;\n\t\t\t}\n\n\t\t\treturn lineIndex + 1;\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar lineIndex = 0;\n\t\tvar lines = stringBuffer.split ('\\n');\n\t\twhile (lineIndex < lines.length && lineIndex != -1) {\n\t\t\tlineIndex = ProcessLine (lines, lineIndex);\n\t\t}\n\t};\n\n\tJSM.IsBinaryStlFile = function (arrayBuffer)\n\t{\n\t\tvar byteLength = arrayBuffer.byteLength;\n\t\tif (byteLength < 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tif (byteLength != triangleCount * 50 + 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.ConvertStlToJsonData = function (arrayBuffer, stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\n\t\tif (arrayBuffer !== null) {\n\t\t\tJSM.ReadBinaryStlFile (arrayBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (stringBuffer !== null) {\n\t\t\tJSM.ReadAsciiStlFile (stringBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importeroff',[\"../core/jsm\"],function(JSM){\n\tJSM.ReadOffFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (line, readState)\n\t\t{\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!readState.offHeaderFound) {\n\t\t\t\tif (lineParts.length == 1 && lineParts[0] == 'OFF') {\n\t\t\t\t\treadState.offHeaderFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (!readState.infoFound) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\treadState.vertexCount = parseInt (lineParts[0]);\n\t\t\t\t\treadState.faceCount = parseInt (lineParts[1]);\n\t\t\t\t\treadState.infoFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readVertices < readState.vertexCount) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\tOnVertex (parseFloat (lineParts[0]), parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t\t\treadState.readVertices += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readFaces < readState.faceCount) {\n\t\t\t\tvar vertexCount = parseInt (lineParts[0]);\n\t\t\t\tif (lineParts.length >= vertexCount + 1) {\n\t\t\t\t\tvar vertices = [];\n\t\t\t\t\tvar i, vertex;\n\t\t\t\t\tfor (i = 1; i < vertexCount + 1; i++) {\n\t\t\t\t\t\tvertex = parseInt (lineParts[i]);\n\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t}\n\t\t\t\t\tOnFace (vertices);\n\t\t\t\t\treadState.readFaces += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer)\n\t\t{\n\t\t\tvar readState = {\n\t\t\t\toffHeaderFound : false,\n\t\t\t\tinfoFound : false,\n\t\t\t\tvertexCount : 0,\n\t\t\t\tfaceCount : 0,\n\t\t\t\treadVertices : 0,\n\t\t\t\treadFaces : 0\n\t\t\t};\n\t\t\t\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, readState);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tProcessFile (stringBuffer);\n\t};\n\n\tJSM.ConvertOffToJsonData = function (stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tJSM.ReadOffFile (stringBuffer, {\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonFace : function (vertices) {\n\t\t\t\tvar i, v0, v1, v2;\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = vertices[0];\n\t\t\t\t\tv1 = vertices[i + 1];\n\t\t\t\t\tv2 = vertices[i + 2];\n\t\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/import/importercommon',[\"../core/jsm\"],function(JSM){\n\tJSM.ImportFileList = function ()\n\t{\n\t\tthis.descriptors = null;\n\t\tthis.isFile = null;\n\t};\n\n\tJSM.ImportFileList.prototype.InitFromFiles = function (fileList)\n\t{\n\t\tthis.descriptors = [];\n\t\tvar i, file, descriptor;\n\t\tfor (i = 0; i < fileList.length; i++) {\n\t\t\tfile = fileList[i];\n\t\t\tdescriptor = {\n\t\t\t\toriginalObject : file,\n\t\t\t\toriginalFileName : file.name,\n\t\t\t\tfileName : file.name.toUpperCase (),\n\t\t\t\textension : this.GetFileExtension (file.name).toUpperCase ()\n\t\t\t};\n\t\t\tthis.descriptors.push (descriptor);\n\t\t}\n\t\tthis.isFile = true;\n\t};\n\n\tJSM.ImportFileList.prototype.InitFromURLs = function (urlList)\n\t{\n\t\tthis.descriptors = [];\n\t\tvar i, url, fileName, descriptor;\n\t\tfor (i = 0; i < urlList.length; i++) {\n\t\t\turl = urlList[i];\n\t\t\tfileName = this.GetFileName (url);\n\t\t\tdescriptor = {\n\t\t\t\toriginalObject : url,\n\t\t\t\toriginalFileName : fileName,\n\t\t\t\tfileName : fileName.toUpperCase (),\n\t\t\t\textension : this.GetFileExtension (fileName).toUpperCase ()\n\t\t\t};\n\t\t\tthis.descriptors.push (descriptor);\n\t\t}\n\t\tthis.isFile = false;\n\t};\n\n\tJSM.ImportFileList.prototype.GetInputList = function ()\n\t{\n\t\tfunction IsArrayBuffer (descriptor)\n\t\t{\n\t\t\tif (descriptor.extension == '.OBJ' || descriptor.extension == '.MTL' || descriptor.extension == '.OFF') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tvar result = [];\n\t\tvar i, descriptor, inputListElem;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tinputListElem = {\n\t\t\t\toriginalObject : descriptor.originalObject,\n\t\t\t\tisFile : this.isFile,\n\t\t\t\tisArrayBuffer : IsArrayBuffer (descriptor)\n\t\t\t};\n\t\t\tresult.push (inputListElem);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileName = function (fullFileName)\n\t{\n\t\tvar splitted = fullFileName.split ('/');\n\t\tif (splitted.length == 1) {\n\t\t\tsplitted = fullFileName.split ('\\\\');\n\t\t}\n\t\tif (splitted.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tvar fileName = splitted[splitted.length - 1];\n\t\treturn decodeURI (fileName);\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileDescriptor = function (index)\n\t{\n\t\treturn this.descriptors[index];\n\t};\n\n\tJSM.ImportFileList.prototype.GetMainFileIndex = function ()\n\t{\n\t\tvar i, descriptor;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tif (this.IsSupportedExtension (descriptor.extension)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileIndexByName = function (fileName)\n\t{\n\t\tvar i, descriptor, currentFileName;\n\t\tfor (i = 0; i < this.descriptors.length; i++) {\n\t\t\tdescriptor = this.descriptors[i];\n\t\t\tcurrentFileName = this.GetFileName (fileName);\n\t\t\tif (descriptor.fileName == currentFileName.toUpperCase ()) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tJSM.ImportFileList.prototype.IsSupportedExtension = function (extension)\n\t{\n\t\tif (extension == '.3DS' || extension == '.OBJ' || extension == '.STL' || extension == '.OFF') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tJSM.ImportFileList.prototype.GetFileExtension = function (fileName)\n\t{\n\t\tvar lastPoint = fileName.lastIndexOf ('.');\n\t\tif (lastPoint == -1) {\n\t\t\treturn '';\n\t\t}\n\t\tvar extension = fileName.substr (lastPoint);\n\t\treturn extension;\n\t};\n\n\tJSM.ConvertImportFileListToJsonData = function (importFileList, callbacks)\n\t{\n\t\tfunction OnError ()\n\t\t{\n\t\t\tif (callbacks.onError !== undefined && callbacks.onError !== null) {\n\t\t\t\tcallbacks.onError ();\n\t\t\t}\n\t\t}\n\n\t\tfunction OnReady (fileNames, jsonData)\n\t\t{\n\t\t\tif (callbacks.onReady !== undefined && callbacks.onReady !== null) {\n\t\t\t\tcallbacks.onReady (fileNames, jsonData);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction FileRequested (importFileList, resultBuffers, fileName, fileNames)\n\t\t{\n\t\t\tvar requestedFileIndex = importFileList.GetFileIndexByName (fileName);\n\t\t\tvar currentFileName = importFileList.GetFileName (fileName);\n\t\t\tif (requestedFileIndex == -1) {\n\t\t\t\tfileNames.missing.push (currentFileName);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (fileNames.requested.indexOf (currentFileName) == -1) {\n\t\t\t\tfileNames.requested.push (currentFileName);\n\t\t\t}\n\t\t\treturn resultBuffers[requestedFileIndex];\t\n\t\t}\n\t\t\n\t\tvar mainFileIndex = importFileList.GetMainFileIndex ();\n\t\tif (mainFileIndex === -1) {\n\t\t\tOnError ();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar mainFile = importFileList.GetFileDescriptor (mainFileIndex);\n\t\tvar fileNames = {\n\t\t\tmain : mainFile.originalFileName,\n\t\t\trequested : [],\n\t\t\tmissing : []\n\t\t};\n\n\t\tvar inputList = importFileList.GetInputList ();\n\t\ttry {\n\t\t\tif (mainFile.extension == '.3DS') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.Convert3dsToJsonData (mainFileBuffer, {\n\t\t\t\t\t\t\tonFileRequested : function (fileName) {\n\t\t\t\t\t\t\t\treturn FileRequested (importFileList, resultBuffers, fileName, fileNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.OBJ') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.ConvertObjToJsonData (mainFileBuffer, {\n\t\t\t\t\t\t\tonFileRequested : function (fileName) {\n\t\t\t\t\t\t\t\treturn FileRequested (importFileList, resultBuffers, fileName, fileNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.STL') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (JSM.IsBinaryStlFile (mainFileBuffer)) {\n\t\t\t\t\t\t\tvar jsonData = JSM.ConvertStlToJsonData (mainFileBuffer, null);\n\t\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\tfor (i = 0; i < inputList.length; i++) {\n\t\t\t\t\t\t\t\tinputList[i].isArrayBuffer = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\t\t\t\tOnError ();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar jsonData = JSM.ConvertStlToJsonData (null, mainFileBuffer);\n\t\t\t\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (mainFile.extension == '.OFF') {\n\t\t\t\tJSM.LoadMultipleBuffers (inputList, function (resultBuffers) {\n\t\t\t\t\tvar mainFileBuffer = resultBuffers[mainFileIndex];\n\t\t\t\t\tif (mainFileBuffer === null) {\n\t\t\t\t\t\tOnError ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar jsonData = JSM.ConvertOffToJsonData (mainFileBuffer);\n\t\t\t\t\t\tOnReady (fileNames, jsonData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (exception) {\n\t\t\tOnError ();\n\t\t\treturn;\n\t\t}\n\t};\n\n\tJSM.ConvertFileListToJsonData = function (fileList, callbacks)\n\t{\n\t\tvar importFileList = new JSM.ImportFileList ();\n\t\timportFileList.InitFromFiles (fileList);\n\t\tJSM.ConvertImportFileListToJsonData (importFileList, callbacks);\n\t};\n\n\tJSM.ConvertURLListToJsonData = function (urlList, callbacks)\n\t{\n\t\tvar importFileList = new JSM.ImportFileList ();\n\t\timportFileList.InitFromURLs (urlList);\n\t\tJSM.ConvertImportFileListToJsonData (importFileList, callbacks);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/webglutils',[\"../core/jsm\"],function(JSM){\n\tJSM.IsPowerOfTwo = function (x)\n\t{\n\t\treturn (x & (x - 1) === 0);\n\t};\n\n\tJSM.NextPowerOfTwo = function (x)\n\t{\n\t\tif (JSM.IsPowerOfTwo (x)) {\n\t\t\treturn x;\n\t\t}\n\n\t\tvar result = 1;\n\t\twhile (result < x) {\n\t\t\tresult *= 2;\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.ResizeImageToPowerOfTwoSides = function (image)\n\t{\n\t\tif (JSM.IsPowerOfTwo (image.width) && !JSM.IsPowerOfTwo (image.height)) {\n\t\t\treturn image;\n\t\t}\n\t\t\n\t\tvar width = JSM.NextPowerOfTwo (image.width);\n\t\tvar height = JSM.NextPowerOfTwo (image.height);\n\n\t\tvar canvas = document.createElement ('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\t\n\t\tvar context = canvas.getContext ('2d');\n\t\tcontext.drawImage (image, 0, 0, width, height);\n\t\treturn context.getImageData (0, 0, width, height);\n\t};\n\n\tJSM.WebGLInitContext = function (canvas)\n\t{\n\t\tif (canvas === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (canvas.getContext === undefined) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar context = canvas.getContext ('webgl') || canvas.getContext ('experimental-webgl');\n\t\tif (context === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tcontext.viewport (0, 0, canvas.width, canvas.height);\n\t\tcontext.clearColor (1.0, 1.0, 1.0, 1.0);\n\t\treturn context;\n\t};\n\n\tJSM.WebGLInitShaderProgram = function (context, vertexShader, fragmentShader, onError)\n\t{\n\t\tfunction CompileShader (context, script, type, onError)\n\t\t{\n\t\t\tvar shader = context.createShader (type);\n\t\t\tcontext.shaderSource (shader, script);\n\t\t\tcontext.compileShader (shader);\n\t\t\tif (!context.getShaderParameter (shader, context.COMPILE_STATUS)) {\n\t\t\t\tif (onError !== undefined && onError !== null) {\n\t\t\t\t\tonError (context.getShaderInfoLog (shader));\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn shader;\n\t\t}\n\t\t\n\t\tfunction CreateShader (context, fragmentShaderScript, vertexShaderScript, onError)\n\t\t{\n\t\t\tvar fragmentShader = CompileShader (context, fragmentShaderScript, context.FRAGMENT_SHADER, onError);\n\t\t\tvar vertexShader = CompileShader (context, vertexShaderScript, context.VERTEX_SHADER, onError);\n\t\t\tif (fragmentShader === null || vertexShader === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar shaderProgram = context.createProgram ();\n\t\t\tcontext.attachShader (shaderProgram, vertexShader);\n\t\t\tcontext.attachShader (shaderProgram, fragmentShader);\n\t\t\tcontext.linkProgram (shaderProgram);\n\t\t\tif (!context.getProgramParameter (shaderProgram, context.LINK_STATUS)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn shaderProgram;\n\t\t}\n\t\t\n\t\tvar shader = CreateShader (context, fragmentShader, vertexShader, onError);\n\t\tif (shader === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tcontext.useProgram (shader);\n\t\treturn shader;\n\t};\n\n\tJSM.WebGLGetFloatTextureBufferSize = function (array)\n\t{\n\t\treturn JSM.NextPowerOfTwo (Math.ceil (Math.sqrt (array.length / 4.0)));\n\t};\n\n\tJSM.WebGLCreateFloatTextureBuffer = function (context, array, size)\n\t{\n\t\tvar floatArray = null;\n\t\tif (array !== null) {\n\t\t\twhile (array.length < size * size * 4) {\n\t\t\t\tarray.push (0.0);\n\t\t\t}\n\t\t\tfloatArray = new Float32Array (array);\n\t\t}\n\t\tvar textureBuffer = context.createTexture ();\n\t\tcontext.bindTexture (context.TEXTURE_2D, textureBuffer);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\n\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\n\t\tcontext.texImage2D (context.TEXTURE_2D, 0, context.RGBA, size, size, 0, context.RGBA, context.FLOAT, floatArray);\n\t\tcontext.bindTexture (context.TEXTURE_2D, null);\n\t\treturn textureBuffer;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderlight',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderAmbientLight = function (color)\n\t{\n\t\tthis.color = JSM.HexColorToNormalizedRGBComponents (color);\n\t};\n\n\tJSM.RenderDirectionalLight = function (diffuse, specular, direction)\n\t{\n\t\tthis.diffuse = JSM.HexColorToNormalizedRGBComponents (diffuse);\n\t\tthis.specular = JSM.HexColorToNormalizedRGBComponents (specular);\n\t\tthis.direction = direction.Clone ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/rendermaterial',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderMaterialFlags = {\n\t\tPoint : 1,\n\t\tLine : 2,\n\t\tTriangle : 4,\n\t\tTextured : 8,\n\t\tTransparent : 16\n\t};\n\n\tJSM.RenderMaterial = function (type, parameters)\n\t{\n\t\tthis.type = type;\n\t\tthis.ambient = [0.0, 0.8, 0.0];\n\t\tthis.diffuse = [0.0, 0.8, 0.0];\n\t\tthis.specular = [0.0, 0.0, 0.0];\n\t\tthis.shininess = 0.0;\n\t\tthis.opacity = 1.0;\n\t\tthis.reflection = 0.0;\n\t\tthis.singleSided = false;\n\t\tthis.pointSize = 0.1;\n\t\tthis.texture = null;\n\t\tJSM.CopyObjectProperties (parameters, this, true);\n\t};\n\n\tJSM.RenderMaterial.prototype.SetType = function (type)\n\t{\n\t\tthis.type = type;\n\t};\n\n\tJSM.RenderMaterial.prototype.SetBuffers = function (textureBuffer, textureImage)\n\t{\n\t\tthis.textureBuffer = textureBuffer;\n\t\tthis.textureImage = textureImage;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/rendermesh',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderMesh = function (material)\n\t{\n\t\tthis.material = material;\n\t\t\n\t\tthis.vertexArray = null;\n\t\tthis.normalArray = null;\n\t\tthis.uvArray = null;\n\t\t\n\t\tthis.vertexBuffer = null;\n\t\tthis.normalBuffer = null;\n\t\tthis.uvBuffer = null;\n\t};\n\n\tJSM.RenderMesh.prototype.SetMaterial = function (material)\n\t{\n\t\tthis.material = material;\n\t};\n\n\tJSM.RenderMesh.prototype.GetMaterial = function ()\n\t{\n\t\treturn this.material;\n\t};\n\n\tJSM.RenderMesh.prototype.SetVertexArray = function (vertices)\n\t{\n\t\tthis.vertexArray = new Float32Array (vertices);\n\t};\n\n\tJSM.RenderMesh.prototype.SetNormalArray = function (normals)\n\t{\n\t\tthis.normalArray = new Float32Array (normals);\n\t};\n\n\tJSM.RenderMesh.prototype.SetUVArray = function (uvs)\n\t{\n\t\tthis.uvArray = new Float32Array (uvs);\n\t};\n\n\tJSM.RenderMesh.prototype.HasVertexArray = function ()\n\t{\n\t\treturn this.vertexArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.HasNormalArray = function ()\n\t{\n\t\treturn this.normalArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.HasUVArray = function ()\n\t{\n\t\treturn this.uvArray !== null;\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertexArray = function ()\n\t{\n\t\treturn this.vertexArray;\n\t};\n\n\tJSM.RenderMesh.prototype.GetNormalArray = function ()\n\t{\n\t\treturn this.normalArray;\n\t};\n\n\tJSM.RenderMesh.prototype.GetUVArray = function ()\n\t{\n\t\treturn this.uvArray;\n\t};\n\n\tJSM.RenderMesh.prototype.SetBuffers = function (vertexBuffer, normalBuffer, uvBuffer)\n\t{\n\t\tthis.vertexBuffer = vertexBuffer;\n\t\tthis.normalBuffer = normalBuffer;\n\t\tthis.uvBuffer = uvBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertexBuffer = function ()\n\t{\n\t\treturn this.vertexBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetNormalBuffer = function ()\n\t{\n\t\treturn this.normalBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.GetUVBuffer = function ()\n\t{\n\t\treturn this.uvBuffer;\n\t};\n\n\tJSM.RenderMesh.prototype.VertexCount = function ()\n\t{\n\t\treturn parseInt (this.vertexArray.length / 3, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.NormalCount = function ()\n\t{\n\t\treturn parseInt (this.normalArray.length / 3, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.UVCount = function ()\n\t{\n\t\treturn parseInt (this.uvArray.length / 2, 10);\n\t};\n\n\tJSM.RenderMesh.prototype.GetVertex = function (index)\n\t{\n\t\treturn new JSM.Coord (this.vertexArray[3 * index], this.vertexArray[3 * index + 1], this.vertexArray[3 * index + 2]);\n\t};\n\n\tJSM.RenderMesh.prototype.GetTransformedVertex = function (index, transformation)\n\t{\n\t\tvar vertex = this.GetVertex (index);\n\t\treturn transformation.Apply (vertex);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderbody',[\"../core/jsm\"],function(JSM){\n\tJSM.RenderBody = function ()\n\t{\n\t\tthis.transformation = new JSM.Transformation ();\n\t\tthis.meshes = {};\n\t};\n\n\tJSM.RenderBody.prototype.AddMesh = function (mesh)\n\t{\n\t\tif (this.meshes[mesh.material.type] === undefined) {\n\t\t\tthis.meshes[mesh.material.type] = [];\n\t\t}\n\t\tthis.meshes[mesh.material.type].push (mesh);\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateMeshes = function (onMeshFound)\n\t{\n\t\tvar meshType;\n\t\tfor (meshType in this.meshes) {\n\t\t\tif (this.meshes.hasOwnProperty (meshType)) {\n\t\t\t\tthis.EnumerateTypedMeshes (meshType, onMeshFound);\n\t\t\t}\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.HasTypedMeshes = function (meshType)\n\t{\n\t\treturn this.meshes[meshType] !== undefined;\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateTypedMeshes = function (meshType, onMeshFound)\n\t{\n\t\tif (!this.HasTypedMeshes (meshType)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar typedMeshes = this.meshes[meshType];\n\t\tvar\ti, typedMesh;\n\t\tfor\t(i = 0; i < typedMeshes.length; i++) {\n\t\t\ttypedMesh = typedMeshes[i];\n\t\t\tonMeshFound (typedMesh);\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.EnumerateMeshesWithFlag = function (flag, onMeshFound)\n\t{\n\t\tvar meshType;\n\t\tfor (meshType in this.meshes) {\n\t\t\tif (this.meshes.hasOwnProperty (meshType) && (meshType & flag)) {\n\t\t\t\tthis.EnumerateTypedMeshes (meshType, onMeshFound);\n\t\t\t}\n\t\t}\n\t};\n\n\tJSM.RenderBody.prototype.GetTransformation = function ()\n\t{\n\t\treturn this.transformation;\n\t};\n\n\tJSM.RenderBody.prototype.GetTransformationMatrix = function ()\n\t{\n\t\treturn this.transformation.matrix;\n\t};\n\n\tJSM.RenderBody.prototype.SetTransformation = function (transformation)\n\t{\n\t\tthis.transformation = transformation;\n\t};\n\n\tJSM.RenderBody.prototype.AppendTransformation = function (transformation)\n\t{\n\t\tthis.transformation.Append (transformation);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/shaderprogram',[\"../core/jsm\"],function(JSM){\n\tJSM.ShaderType = {\n\t\tPoint : 0,\n\t\tLine : 1,\n\t\tTriangle : 2,\n\t\tTexturedTriangle : 3\n\t};\n\n\tJSM.ShaderProgram = function (context)\n\t{\n\t\tthis.context = context;\n\t\tthis.globalParams = null;\n\t\tthis.shaders = null;\n\t\tthis.currentShader = null;\n\t\tthis.currentType = null;\n\t\tthis.cullEnabled = null;\n\t};\n\n\tJSM.ShaderProgram.prototype.Init = function ()\n\t{\n\t\tif (!this.InitGlobalParams ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\t\n\t};\n\n\tJSM.ShaderProgram.prototype.GetMaxLightCount = function ()\n\t{\n\t\treturn this.globalParams.maxLightCount;\n\t};\n\n\tJSM.ShaderProgram.prototype.InitGlobalParams = function ()\n\t{\n\t\tvar noDirectionalLight = new JSM.RenderDirectionalLight (0x000000, 0x000000, new JSM.Vector (0.0, 0.0, 0.0));\n\t\tthis.globalParams = {\n\t\t\tnoDirectionalLight : noDirectionalLight,\n\t\t\tmaxLightCount : 4\n\t\t};\n\t\treturn true;\n\t};\n\n\tJSM.ShaderProgram.prototype.InitShaders = function ()\n\t{\n\t\tfunction GetFragmentShaderScript (shaderType, globalParams)\n\t\t{\n\t\t\tvar script = null;\n\t\t\tif (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define MAX_LIGHTS ' + globalParams.maxLightCount,\n\n\t\t\t\t\t'struct Light',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'};',\n\n\t\t\t\t\t'struct Material',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 ambientColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'};',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump vec3 uAmbientLightColor;',\n\t\t\t\t\t'uniform Light uLights[MAX_LIGHTS];',\n\t\t\t\t\t'uniform Material uMaterial;',\n\t\t\t\t\t\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmediump vec3 ambientComponent = uMaterial.ambientColor * uAmbientLightColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tfor (int i = 0; i < MAX_LIGHTS; i++) {',\n\t\t\t\t\t'\t\tdiffuseComponent += uMaterial.diffuseColor * uLights[i].diffuseColor;',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t'\tgl_FragColor = vec4 (ambientComponent + diffuseComponent, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t} else if (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Triangle ? 'NOTEXTURE' : 'USETEXTURE'),\n\t\t\t\t\t'#define MAX_LIGHTS ' + globalParams.maxLightCount,\n\t\t\t\t\t\n\t\t\t\t\t'struct Light',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'\tmediump vec3 specularColor;',\n\t\t\t\t\t'\tmediump vec3 direction;',\n\t\t\t\t\t'};',\n\n\t\t\t\t\t'struct Material',\n\t\t\t\t\t'{',\n\t\t\t\t\t'\tmediump vec3 ambientColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseColor;',\n\t\t\t\t\t'\tmediump vec3 specularColor;',\n\t\t\t\t\t'\tmediump float shininess;',\n\t\t\t\t\t'\tmediump float opacity;',\n\t\t\t\t\t'};',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump vec3 uAmbientLightColor;',\n\t\t\t\t\t'uniform Light uLights[MAX_LIGHTS];',\n\t\t\t\t\t'uniform Material uMaterial;',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\t\t\t\t\t'varying mediump vec3 vNormal;',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'varying mediump vec2 vUV;',\n\t\t\t\t\t'uniform sampler2D uSampler;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmediump vec3 N = normalize (vNormal);',\n\t\t\t\t\t'\tif (!gl_FrontFacing) {',\n\t\t\t\t\t'\t\tN = -N;',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t'\tmediump vec3 ambientComponent = uMaterial.ambientColor * uAmbientLightColor;',\n\t\t\t\t\t'\tmediump vec3 diffuseComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tmediump vec3 specularComponent = vec3 (0.0, 0.0, 0.0);',\n\t\t\t\t\t'\tmediump vec3 E = normalize (-vVertex);',\n\n\t\t\t\t\t'\tfor (int i = 0; i < MAX_LIGHTS; i++) {',\n\t\t\t\t\t'\t\tmediump vec3 L = normalize (-uLights[i].direction);',\n\t\t\t\t\t'\t\tmediump vec3 R = normalize (-reflect (L, N));',\n\t\t\t\t\t'\t\tdiffuseComponent += uMaterial.diffuseColor * uLights[i].diffuseColor * max (dot (N, L), 0.0);',\n\t\t\t\t\t'\t\tspecularComponent += uMaterial.specularColor * uLights[i].specularColor * pow (max (dot (R, E), 0.0), uMaterial.shininess);',\n\t\t\t\t\t'\t}',\n\t\t\t\t\t\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'\tmediump vec3 textureColor = texture2D (uSampler, vec2 (vUV.s, vUV.t)).xyz;',\n\t\t\t\t\t'\tambientComponent = ambientComponent * textureColor;',\n\t\t\t\t\t'\tdiffuseComponent = diffuseComponent * textureColor;',\n\t\t\t\t\t'\tspecularComponent = specularComponent * textureColor;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t\n\t\t\t\t\t'\tambientComponent = clamp (ambientComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tdiffuseComponent = clamp (diffuseComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tspecularComponent = clamp (specularComponent, 0.0, 1.0);',\n\t\t\t\t\t'\tgl_FragColor = vec4 (ambientComponent + diffuseComponent + specularComponent, uMaterial.opacity);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n\t\t\n\t\tfunction GetVertexShaderScript (shaderType)\n\t\t{\n\t\t\tvar script = null;\n\t\t\tif (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Triangle ? 'NOTEXTURE' : 'USETEXTURE'),\n\t\t\t\t\t'attribute mediump vec3 aVertexPosition;',\n\t\t\t\t\t'attribute mediump vec3 aVertexNormal;',\n\n\t\t\t\t\t'uniform mediump mat4 uViewMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uProjectionMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uTransformationMatrix;',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\t\t\t\t\t'varying mediump vec3 vNormal;',\n\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'attribute mediump vec2 aVertexUV;',\n\t\t\t\t\t'varying mediump vec2 vUV;',\n\t\t\t\t\t'#endif',\n\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmat4 modelViewMatrix = uViewMatrix * uTransformationMatrix;',\n\t\t\t\t\t'\tvVertex = vec3 (modelViewMatrix * vec4 (aVertexPosition, 1.0));',\n\t\t\t\t\t'\tvNormal = normalize (vec3 (modelViewMatrix * vec4 (aVertexNormal, 0.0)));',\n\t\t\t\t\t'#ifdef USETEXTURE',\n\t\t\t\t\t'\tvUV = aVertexUV;',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t} else if (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tscript = [\n\t\t\t\t\t'#define ' + (shaderType == JSM.ShaderType.Point ? 'POINT' : 'LINE'),\n\t\t\t\t\t'attribute mediump vec3 aVertexPosition;',\n\t\t\t\t\t\n\t\t\t\t\t'uniform mediump mat4 uViewMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uProjectionMatrix;',\n\t\t\t\t\t'uniform mediump mat4 uTransformationMatrix;',\n\t\t\t\t\t'#ifdef POINT',\n\t\t\t\t\t'uniform mediump float uPointSize;',\n\t\t\t\t\t'#endif',\n\n\t\t\t\t\t'varying mediump vec3 vVertex;',\n\n\t\t\t\t\t'void main (void) {',\n\t\t\t\t\t'\tmat4 modelViewMatrix = uViewMatrix * uTransformationMatrix;',\n\t\t\t\t\t'\tvVertex = vec3 (modelViewMatrix * vec4 (aVertexPosition, 1.0));',\n\t\t\t\t\t'#ifdef POINT',\n\t\t\t\t\t'\tconst mediump float scale = 200.0;',\n\t\t\t\t\t'\tgl_PointSize = uPointSize * (scale / length (vVertex));',\n\t\t\t\t\t'#endif',\n\t\t\t\t\t'\tgl_Position = uProjectionMatrix * vec4 (vVertex, 1.0);',\n\t\t\t\t\t'}'\n\t\t\t\t].join ('\\n');\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n\n\t\tfunction InitShaderParameters (context, shader, globalParams, shaderType)\n\t\t{\n\t\t\tif (shaderType == JSM.ShaderType.Triangle || shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tshader.vertexPositionAttribute = context.getAttribLocation (shader, 'aVertexPosition');\n\t\t\t\tshader.vertexNormalAttribute = context.getAttribLocation (shader, 'aVertexNormal');\n\n\t\t\t\tshader.ambientLightColorUniform = context.getUniformLocation (shader, 'uAmbientLightColor');\n\t\t\t\tshader.lightUniforms = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < globalParams.maxLightCount; i++) {\n\t\t\t\t\tshader.lightUniforms.push ({\n\t\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uLights[' + i + '].diffuseColor'),\n\t\t\t\t\t\tspecularColor : context.getUniformLocation (shader, 'uLights[' + i + '].specularColor'),\n\t\t\t\t\t\tdirection : context.getUniformLocation (shader, 'uLights[' + i + '].direction')\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tshader.materialUniforms = {\n\t\t\t\t\tambientColor : context.getUniformLocation (shader, 'uMaterial.ambientColor'),\n\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uMaterial.diffuseColor'),\n\t\t\t\t\tspecularColor : context.getUniformLocation (shader, 'uMaterial.specularColor'),\n\t\t\t\t\tshininess : context.getUniformLocation (shader, 'uMaterial.shininess'),\n\t\t\t\t\topacity : context.getUniformLocation (shader, 'uMaterial.opacity')\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tshader.vMatrixUniform = context.getUniformLocation (shader, 'uViewMatrix');\n\t\t\t\tshader.pMatrixUniform = context.getUniformLocation (shader, 'uProjectionMatrix');\n\t\t\t\tshader.tMatrixUniform = context.getUniformLocation (shader, 'uTransformationMatrix');\n\n\t\t\t\tif (shaderType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\t\tshader.vertexUVAttribute = context.getAttribLocation (shader, 'aVertexUV');\n\t\t\t\t\tshader.samplerUniform = context.getUniformLocation (shader, 'uSampler');\n\t\t\t\t}\n\t\t\t} else if (shaderType == JSM.ShaderType.Point || shaderType == JSM.ShaderType.Line) {\n\t\t\t\tshader.vertexPositionAttribute = context.getAttribLocation (shader, 'aVertexPosition');\n\n\t\t\t\tshader.ambientLightColorUniform = context.getUniformLocation (shader, 'uAmbientLightColor');\n\t\t\t\tshader.lightUniforms = [];\n\t\t\t\tfor (i = 0; i < globalParams.maxLightCount; i++) {\n\t\t\t\t\tshader.lightUniforms.push ({\n\t\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uLights[' + i + '].diffuseColor')\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tshader.materialUniforms = {\n\t\t\t\t\tambientColor : context.getUniformLocation (shader, 'uMaterial.ambientColor'),\n\t\t\t\t\tdiffuseColor : context.getUniformLocation (shader, 'uMaterial.diffuseColor'),\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tshader.vMatrixUniform = context.getUniformLocation (shader, 'uViewMatrix');\n\t\t\t\tshader.pMatrixUniform = context.getUniformLocation (shader, 'uProjectionMatrix');\n\t\t\t\tshader.tMatrixUniform = context.getUniformLocation (shader, 'uTransformationMatrix');\n\n\t\t\t\tif (shaderType == JSM.ShaderType.Point) {\n\t\t\t\t\tshader.pointSizeUniform = context.getUniformLocation (shader, 'uPointSize');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction InitShader (context, shaders, globalParams, shaderType)\n\t\t{\n\t\t\tvar vertexShaderScript = GetVertexShaderScript (shaderType);\n\t\t\tvar fragmentShaderScript = GetFragmentShaderScript (shaderType, globalParams);\n\t\t\tif (vertexShaderScript === null || fragmentShaderScript === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar shader = JSM.WebGLInitShaderProgram (context, vertexShaderScript, fragmentShaderScript, function (message) {\n\t\t\t\tJSM.Message (message);\n\t\t\t});\n\t\t\tif (shader === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tcontext.useProgram (shader);\n\t\t\tInitShaderParameters (context, shader, globalParams, shaderType);\n\t\t\tshaders[shaderType] = shader;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tthis.shaders = {};\n\t\t\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Point)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Line)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.Triangle)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!InitShader (this.context, this.shaders, this.globalParams, JSM.ShaderType.TexturedTriangle)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context.enable (this.context.DEPTH_TEST);\n\t\tthis.context.depthFunc (this.context.LEQUAL);\n\t\t\n\t\tthis.context.enable (this.context.BLEND);\n\t\tthis.context.blendEquation (this.context.FUNC_ADD);\n\t\tthis.context.blendFunc (this.context.SRC_ALPHA, this.context.ONE_MINUS_SRC_ALPHA);\n\n\t\tthis.context.disable (this.context.CULL_FACE);\n\t\tthis.cullEnabled = false;\n\n\t\treturn true;\n\t};\n\n\tJSM.ShaderProgram.prototype.CompileMaterial = function (material, textureLoaded)\n\t{\n\t\tif (material.texture !== null) {\n\t\t\tvar context = this.context;\n\t\t\tvar textureBuffer = context.createTexture ();\n\t\t\tvar textureImage = new Image ();\n\t\t\ttextureImage.src = material.texture;\n\t\t\ttextureImage.onload = function () {\n\t\t\t\tvar resizedImage = JSM.ResizeImageToPowerOfTwoSides (textureImage);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, textureBuffer);\n\t\t\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.LINEAR);\n\t\t\t\tcontext.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);\n\t\t\t\tcontext.texImage2D (context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, resizedImage);\n\t\t\t\tcontext.generateMipmap (context.TEXTURE_2D);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, null);\n\t\t\t\tif (textureLoaded !== undefined && textureLoaded !== null) {\n\t\t\t\t\ttextureLoaded ();\n\t\t\t\t}\n\t\t\t};\n\t\t\tmaterial.SetBuffers (textureBuffer, textureImage);\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.CompileMesh = function (mesh)\n\t{\n\t\tvar context = this.context;\n\t\tvar vertexBuffer = context.createBuffer ();\n\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetVertexArray (), context.STATIC_DRAW);\n\t\tvertexBuffer.itemSize = 3;\n\t\tvertexBuffer.numItems = mesh.VertexCount ();\n\n\t\tvar normalBuffer = null;\n\t\tif (mesh.HasNormalArray ()) {\n\t\t\tnormalBuffer = context.createBuffer ();\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, normalBuffer);\n\t\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetNormalArray (), context.STATIC_DRAW);\n\t\t\tnormalBuffer.itemSize = 3;\n\t\t\tnormalBuffer.numItems = mesh.NormalCount ();\n\t\t}\n\n\t\tvar uvBuffer = null;\n\t\tif (mesh.HasUVArray ()) {\n\t\t\tuvBuffer = context.createBuffer ();\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, uvBuffer);\n\t\t\tcontext.bufferData (context.ARRAY_BUFFER, mesh.GetUVArray (), context.STATIC_DRAW);\n\t\t\tuvBuffer.itemSize = 2;\n\t\t\tuvBuffer.numItems = mesh.UVCount ();\n\t\t}\n\t\t\n\t\tmesh.SetBuffers (vertexBuffer, normalBuffer, uvBuffer);\n\t};\n\n\tJSM.ShaderProgram.prototype.GetShader = function (shaderType)\n\t{\n\t\treturn this.shaders[shaderType];\n\t};\n\n\tJSM.ShaderProgram.prototype.UseShader = function (shaderType)\n\t{\n\t\tthis.currentShader = this.GetShader (shaderType);\n\t\tthis.currentType = shaderType;\n\t\tthis.context.useProgram (this.currentShader);\n\t};\n\n\tJSM.ShaderProgram.prototype.SetParameters = function (ambientLight, directionalLights, viewMatrix, projectionMatrix)\n\t{\n\t\tfunction GetLight (directionalLights, index, noDirectionalLight)\n\t\t{\n\t\t\tif (index < directionalLights.length) {\n\t\t\t\treturn directionalLights[index];\n\t\t\t}\n\n\t\t\treturn noDirectionalLight;\n\t\t}\n\t\t\n\t\tvar context = this.context;\n\t\tvar shader = this.currentShader;\n\t\t\n\t\tvar i, light, lightDirection;\n\t\tif (this.currentType == JSM.ShaderType.Triangle || this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\tcontext.uniform3f (shader.ambientLightColorUniform, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);\n\t\t\tfor (i = 0; i < this.globalParams.maxLightCount; i++) {\n\t\t\t\tlight = GetLight (directionalLights, i, this.globalParams.noDirectionalLight);\n\t\t\t\tlightDirection = JSM.ApplyRotation (viewMatrix, light.direction);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].diffuseColor, light.diffuse[0], light.diffuse[1], light.diffuse[2]);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].specularColor, light.specular[0], light.specular[1], light.specular[2]);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].direction, lightDirection.x, lightDirection.y, lightDirection.z);\n\t\t\t}\n\t\t\tcontext.uniformMatrix4fv (shader.pMatrixUniform, false, projectionMatrix);\n\t\t\tcontext.uniformMatrix4fv (shader.vMatrixUniform, false, viewMatrix);\n\t\t} else if (this.currentType == JSM.ShaderType.Point || this.currentType == JSM.ShaderType.Line) {\n\t\t\tcontext.uniform3f (shader.ambientLightColorUniform, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);\n\t\t\tfor (i = 0; i < this.globalParams.maxLightCount; i++) {\n\t\t\t\tlight = GetLight (directionalLights, i, this.globalParams.noDirectionalLight);\n\t\t\t\tcontext.uniform3f (shader.lightUniforms[i].diffuseColor, light.diffuse[0], light.diffuse[1], light.diffuse[2]);\n\t\t\t}\n\t\t\tcontext.uniformMatrix4fv (shader.pMatrixUniform, false, projectionMatrix);\n\t\t\tcontext.uniformMatrix4fv (shader.vMatrixUniform, false, viewMatrix);\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.SetCullEnabled = function (enable)\n\t{\n\t\tif (enable && !this.cullEnabled) {\n\t\t\tthis.context.enable (this.context.CULL_FACE);\n\t\t\tthis.cullEnabled = true;\n\t\t} else if (!enable && this.cullEnabled) {\n\t\t\tthis.context.disable (this.context.CULL_FACE);\n\t\t\tthis.cullEnabled = false;\n\t\t}\n\t};\n\n\tJSM.ShaderProgram.prototype.DrawArrays = function (material, matrix, vertexBuffer, normalBuffer, uvBuffer)\n\t{\n\t\tvar context = this.context;\n\t\tvar shader = this.currentShader;\n\t\tthis.SetCullEnabled (material.singleSided);\n\t\t\n\t\tif (this.currentType == JSM.ShaderType.Triangle || this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\tcontext.uniform3f (shader.materialUniforms.ambientColor, material.ambient[0], material.ambient[1], material.ambient[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.diffuseColor, material.diffuse[0], material.diffuse[1], material.diffuse[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.specularColor, material.specular[0], material.specular[1], material.specular[2]);\n\t\t\tcontext.uniform1f (shader.materialUniforms.shininess, material.shininess);\n\t\t\tcontext.uniform1f (shader.materialUniforms.opacity, material.opacity);\n\n\t\t\tcontext.uniformMatrix4fv (shader.tMatrixUniform, false, matrix);\n\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexPositionAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexPositionAttribute, vertexBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, normalBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexNormalAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexNormalAttribute, normalBuffer.itemSize, context.FLOAT, false, 0, 0);\n\n\t\t\tif (this.currentType == JSM.ShaderType.TexturedTriangle) {\n\t\t\t\tcontext.activeTexture (context.TEXTURE0);\n\t\t\t\tcontext.bindTexture (context.TEXTURE_2D, material.textureBuffer);\n\t\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, uvBuffer);\n\t\t\t\tcontext.enableVertexAttribArray (shader.vertexUVAttribute);\n\t\t\t\tcontext.vertexAttribPointer (shader.vertexUVAttribute, uvBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\tcontext.uniform1i (shader.samplerUniform, 0);\n\t\t\t}\n\t\t\t\n\t\t\tcontext.drawArrays (context.TRIANGLES, 0, vertexBuffer.numItems);\n\t\t} else if (this.currentType == JSM.ShaderType.Point || this.currentType == JSM.ShaderType.Line) {\n\t\t\tcontext.uniform3f (shader.materialUniforms.ambientColor, material.ambient[0], material.ambient[1], material.ambient[2]);\n\t\t\tcontext.uniform3f (shader.materialUniforms.diffuseColor, material.diffuse[0], material.diffuse[1], material.diffuse[2]);\n\t\t\t\n\t\t\tcontext.uniformMatrix4fv (shader.tMatrixUniform, false, matrix);\n\t\t\t\n\t\t\tcontext.bindBuffer (context.ARRAY_BUFFER, vertexBuffer);\n\t\t\tcontext.enableVertexAttribArray (shader.vertexPositionAttribute);\n\t\t\tcontext.vertexAttribPointer (shader.vertexPositionAttribute, vertexBuffer.itemSize, context.FLOAT, false, 0, 0);\n\t\t\t\n\t\t\tif (this.currentType == JSM.ShaderType.Point) {\n\t\t\t\tcontext.uniform1f (shader.pointSizeUniform, material.pointSize);\n\t\t\t\tcontext.drawArrays (context.POINTS, 0, vertexBuffer.numItems);\n\t\t\t} else if (this.currentType == JSM.ShaderType.Line) {\n\t\t\t\tcontext.drawArrays (context.LINES, 0, vertexBuffer.numItems);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderer',[\"../core/jsm\"],function(JSM){\n\tJSM.Renderer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.shader = null;\n\t\t\n\t\tthis.ambientLight = null;\n\t\tthis.directionalLights = null;\n\t\tthis.bodies = null;\n\t};\n\n\tJSM.Renderer.prototype.Init = function (canvas)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitContext (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitView ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\tif (!this.InitBodies ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitContext = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (this.canvas === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas.getContext === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = this.canvas.getContext ('webgl') || this.canvas.getContext ('experimental-webgl');\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = JSM.WebGLInitContext (canvas);\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitShaders = function ()\n\t{\n\t\tthis.shader = new JSM.ShaderProgram (this.context);\n\t\treturn this.shader.Init ();\n\t};\n\n\tJSM.Renderer.prototype.InitLights = function ()\n\t{\n\t\tthis.ambientLight = new JSM.RenderAmbientLight (0x000000);\n\t\tthis.directionalLights = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.InitView = function ()\n\t{\n\t\tthis.directionalLights = [];\n\t\treturn true;\n\t};\n\n\tJSM.Renderer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.context.clearColor (red, green, blue, 1.0);\n\t};\n\n\tJSM.Renderer.prototype.SetAmbientLight = function (light)\n\t{\n\t\tthis.ambientLight = light;\n\t};\n\n\tJSM.Renderer.prototype.AddLight = function (light)\n\t{\n\t\tvar maxLightCount = this.shader.GetMaxLightCount ();\n\t\tif (this.directionalLights.length >= maxLightCount) {\n\t\t\treturn -1;\n\t\t}\n\t\tthis.directionalLights.push (light);\n\t\treturn this.directionalLights.length - 1;\n\t};\n\n\tJSM.Renderer.prototype.RemoveLight = function (light)\n\t{\n\t\tvar index = this.directionalLights.indexOf (light);\n\t\tif (index != -1) {\n\t\t\tthis.directionalLights.splice (index, 1);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveLights = function ()\n\t{\n\t\tthis.directionalLights = [];\n\t};\n\n\tJSM.Renderer.prototype.GetLight = function (index)\n\t{\n\t\treturn this.directionalLights[index];\n\t};\n\n\tJSM.Renderer.prototype.AddBody = function (renderBody, textureLoaded)\n\t{\n\t\tvar shader = this.shader;\n\t\trenderBody.EnumerateMeshes (function (mesh) {\n\t\t\tshader.CompileMaterial (mesh.GetMaterial (), textureLoaded);\n\t\t\tshader.CompileMesh (mesh);\n\t\t});\n\t\tthis.bodies.push (renderBody);\n\t};\n\n\tJSM.Renderer.prototype.AddBodies = function (renderBodies, textureLoaded)\n\t{\n\t\tvar i, body;\n\t\tfor (i = 0; i < renderBodies.length; i++) {\n\t\t\tbody = renderBodies[i];\n\t\t\tthis.AddBody (body, textureLoaded);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.EnumerateBodies = function (onBodyFound)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tonBodyFound (this.bodies[i]);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveBody = function (body)\n\t{\n\t\tvar index = this.bodies.indexOf (body);\n\t\tif (index != -1) {\n\t\t\tthis.bodies.splice (index, 1);\n\t\t}\n\t};\n\n\tJSM.Renderer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t};\n\n\tJSM.Renderer.prototype.GetBody = function (index)\n\t{\n\t\treturn this.bodies[index];\n\t};\n\n\tJSM.Renderer.prototype.Resize = function ()\n\t{\n\t\tthis.context.viewport (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\tJSM.Renderer.prototype.FindObjects = function (camera, screenX, screenY)\n\t{\n\t\tvar screenCoord = new JSM.Coord (screenX, this.canvas.height - screenY, 0.5);\n\t\tvar aspectRatio = this.canvas.width / this.canvas.height;\n\t\tvar viewPort = [0, 0, this.canvas.width, this.canvas.height];\n\t\tvar unprojected = JSM.Unproject (screenCoord, camera.eye, camera.center, camera.up, camera.fieldOfView * JSM.DegRad, aspectRatio, camera.nearClippingPlane, camera.farClippingPlane, viewPort);\n\t\tvar ray = new JSM.Ray (camera.eye, JSM.CoordSub (unprojected, camera.eye), null);\n\t\t\n\t\tvar result = [];\n\t\tthis.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshesWithFlag (JSM.RenderMaterialFlags.Triangle, function (mesh) {\n\t\t\t\tvar vertexCount = mesh.VertexCount ();\n\t\t\t\tvar i, v0, v1, v2, intersection;\n\t\t\t\tfor (i = 0; i < vertexCount; i += 3) {\n\t\t\t\t\tv0 = mesh.GetTransformedVertex (i + 0, transformation);\n\t\t\t\t\tv1 = mesh.GetTransformedVertex (i + 1, transformation);\n\t\t\t\t\tv2 = mesh.GetTransformedVertex (i + 2, transformation);\n\t\t\t\t\tintersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\t\tif (intersection !== null) {\n\t\t\t\t\t\tresult.push ({\n\t\t\t\t\t\t\trenderBody : body,\n\t\t\t\t\t\t\trenderMesh : mesh,\n\t\t\t\t\t\t\ttriangleIndex : parseInt (i / 3, 10),\n\t\t\t\t\t\t\tintersection : intersection\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tresult.sort (function (a, b) {\n\t\t\treturn a.intersection.distance - b.intersection.distance;\n\t\t});\n\t\treturn result;\n\t};\n\n\tJSM.Renderer.prototype.Render = function (camera)\n\t{\n\t\tfunction DrawMeshes (renderer, materialType, viewMatrix, projectionMatrix)\n\t\t{\n\t\t\tfunction MaterialTypeToShaderType (materialType)\n\t\t\t{\n\t\t\t\tfunction HasFlag (type, flag)\n\t\t\t\t{\n\t\t\t\t\treturn type & flag;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (HasFlag (materialType, JSM.RenderMaterialFlags.Triangle)) {\n\t\t\t\t\tif (HasFlag (materialType, JSM.RenderMaterialFlags.Textured)) {\n\t\t\t\t\t\treturn JSM.ShaderType.TexturedTriangle;\n\t\t\t\t\t} else if (!HasFlag (materialType, JSM.RenderMaterialFlags.Textured)) {\n\t\t\t\t\t\treturn JSM.ShaderType.Triangle;\n\t\t\t\t\t}\n\t\t\t\t} else if (HasFlag (materialType, JSM.RenderMaterialFlags.Line)) {\n\t\t\t\t\treturn JSM.ShaderType.Line;\n\t\t\t\t} else if (HasFlag (materialType, JSM.RenderMaterialFlags.Point)) {\n\t\t\t\t\treturn JSM.ShaderType.Point;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar shaderType = null;\n\t\t\trenderer.EnumerateBodies (function (body) {\n\t\t\t\tif (body.HasTypedMeshes (materialType)) {\n\t\t\t\t\tvar matrix = body.GetTransformationMatrix ();\n\t\t\t\t\tbody.EnumerateTypedMeshes (materialType, function (mesh) {\n\t\t\t\t\t\tif (shaderType === null) {\n\t\t\t\t\t\t\tshaderType = MaterialTypeToShaderType (materialType);\n\t\t\t\t\t\t\trenderer.shader.UseShader (shaderType);\n\t\t\t\t\t\t\trenderer.shader.SetParameters (renderer.ambientLight, renderer.directionalLights, viewMatrix, projectionMatrix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar material = mesh.GetMaterial ();\n\t\t\t\t\t\tvar vertexBuffer = mesh.GetVertexBuffer ();\n\t\t\t\t\t\tvar normalBuffer = mesh.GetNormalBuffer ();\n\t\t\t\t\t\tvar uvBuffer = mesh.GetUVBuffer ();\n\t\t\t\t\t\trenderer.shader.DrawArrays (material, matrix, vertexBuffer, normalBuffer, uvBuffer);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.context.clear (this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n\t\t\n\t\tvar viewMatrix = JSM.MatrixView (camera.eye, camera.center, camera.up);\n\t\tvar projectionMatrix = JSM.MatrixPerspective (camera.fieldOfView * JSM.DegRad, this.canvas.width / this.canvas.height, camera.nearClippingPlane, camera.farClippingPlane);\n\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Textured, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Line, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Point, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Transparent, viewMatrix, projectionMatrix);\n\t\tDrawMeshes (this, JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Transparent + JSM.RenderMaterialFlags.Textured, viewMatrix, projectionMatrix);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/pointcloudrenderer',[\"../core/jsm\"],function(JSM){\n\tJSM.PointCloudRenderer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.context = null;\n\t\tthis.shader = null;\n\t\t\n\t\tthis.camera = null;\n\t\tthis.points = null;\n\t\tthis.pointSize = null;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitContext (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitShaders ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitBuffers ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitView (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitContext = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (this.canvas === null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas.getContext === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context = this.canvas.getContext ('experimental-webgl');\n\t\tif (this.context === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.context.clearColor (1.0, 1.0, 1.0, 1.0);\n\t\tthis.context.enable (this.context.DEPTH_TEST);\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitShaders = function ()\n\t{\n\t\tfunction CreateShaderFromScript (context, script, type)\n\t\t{\n\t\t\tvar shader = context.createShader (type);\n\t\t\tcontext.shaderSource (shader, script);\n\t\t\tcontext.compileShader (shader);\n\t\t\tif (!context.getShaderParameter (shader, context.COMPILE_STATUS)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn shader;\n\t\t}\n\n\t\tvar fragmentShaderScript = [\n\t\t\t'varying highp vec3 vColor;',\n\t\t\t'void main (void) {',\n\t\t\t'\tgl_FragColor = vec4 (vColor, 1.0);',\n\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\n\t\tvar vertexShaderScript = [\n\t\t\t'attribute highp vec3 aVertexPosition;',\n\t\t\t'attribute highp vec3 aVertexColor;',\n\n\t\t\t'uniform highp mat4 uViewMatrix;',\n\t\t\t'uniform highp mat4 uProjectionMatrix;',\n\n\t\t\t'uniform highp float uPointSize;',\n\t\t\t\n\t\t\t'varying highp vec3 vColor;',\n\t\t\t\n\t\t\t'void main (void) {',\n\t\t\t'\tvColor = aVertexColor;',\n\t\t\t'\tgl_PointSize = uPointSize;',\n\t\t\t'\tgl_Position = uProjectionMatrix * uViewMatrix * vec4 (aVertexPosition, 1.0);',\n\t\t\t'}'\n\t\t\t].join('\\n');\n\t\t\n\t\tvar fragmentShader = CreateShaderFromScript (this.context, fragmentShaderScript, this.context.FRAGMENT_SHADER);\n\t\tvar vertexShader = CreateShaderFromScript (this.context, vertexShaderScript, this.context.VERTEX_SHADER);\n\t\tif (fragmentShader === null || vertexShader === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.shader = this.context.createProgram ();\n\t\tthis.context.attachShader (this.shader, vertexShader);\n\t\tthis.context.attachShader (this.shader, fragmentShader);\n\t\tthis.context.linkProgram (this.shader);\n\t\tif (!this.context.getProgramParameter (this.shader, this.context.LINK_STATUS)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.context.useProgram (this.shader);\n\n\t\tthis.shader.vertexPositionAttribute = this.context.getAttribLocation (this.shader, 'aVertexPosition');\n\t\tthis.context.enableVertexAttribArray (this.shader.vertexPositionAttribute);\n\n\t\tthis.shader.vertexColorAttribute = this.context.getAttribLocation (this.shader, 'aVertexColor');\n\t\tthis.context.enableVertexAttribArray (this.shader.vertexColorAttribute);\n\n\t\tthis.shader.pMatrixUniform = this.context.getUniformLocation (this.shader, 'uProjectionMatrix');\n\t\tthis.shader.vMatrixUniform = this.context.getUniformLocation (this.shader, 'uViewMatrix');\n\t\t\n\t\tthis.shader.pointSizeUniform = this.context.getUniformLocation (this.shader, 'uPointSize');\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitBuffers = function ()\n\t{\n\t\tthis.points = [];\n\t\tthis.pointSize = 1.0;\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.InitView = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.context.clearColor (red, green, blue, 1.0);\n\t};\n\n\tJSM.PointCloudRenderer.prototype.SetPointSize = function (pointSize)\n\t{\n\t\tthis.pointSize = pointSize;\n\t};\n\n\tJSM.PointCloudRenderer.prototype.AddPoints = function (points, colors)\n\t{\n\t\tvar pointBuffer = this.context.createBuffer ();\n\t\tvar pointArray = new Float32Array (points);\n\n\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, pointBuffer);\n\t\tthis.context.bufferData (this.context.ARRAY_BUFFER, pointArray, this.context.STATIC_DRAW);\n\t\tpointBuffer.itemSize = 3;\n\t\tpointBuffer.numItems = parseInt (pointArray.length / 3, 10);\n\t\t\n\t\tvar colorBuffer = this.context.createBuffer ();\n\t\tvar colorArray = new Float32Array (colors);\n\n\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, colorBuffer);\n\t\tthis.context.bufferData (this.context.ARRAY_BUFFER, colorArray, this.context.STATIC_DRAW);\n\t\tcolorBuffer.itemSize = 3;\n\t\tcolorBuffer.numItems = parseInt (colorArray.length / 3, 10);\n\n\t\tthis.points.push ({pointArray : pointArray, pointBuffer : pointBuffer, colorBuffer : colorBuffer});\n\t};\n\n\tJSM.PointCloudRenderer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.points = [];\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Resize = function ()\n\t{\n\t\tthis.context.viewport (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\tJSM.PointCloudRenderer.prototype.Render = function ()\n\t{\n\t\tthis.context.clear (this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n\t\t\n\t\tvar projectionMatrix = JSM.MatrixPerspective (this.camera.fieldOfView * JSM.DegRad, this.canvas.width / this.canvas.height, this.camera.nearClippingPlane, this.camera.farClippingPlane);\n\t\tthis.context.uniformMatrix4fv (this.shader.pMatrixUniform, false, projectionMatrix);\n\n\t\tvar viewMatrix = JSM.MatrixView (this.camera.eye, this.camera.center, this.camera.up);\n\t\tthis.context.uniformMatrix4fv (this.shader.vMatrixUniform, false, viewMatrix);\n\n\t\tthis.context.uniform1f (this.shader.pointSizeUniform, this.pointSize);\n\t\t\n\t\tvar i, pointBuffer, colorBuffer;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tpointBuffer = this.points[i].pointBuffer;\n\t\t\tcolorBuffer = this.points[i].colorBuffer;\n\t\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, pointBuffer);\n\t\t\tthis.context.vertexAttribPointer (this.shader.vertexPositionAttribute, pointBuffer.itemSize, this.context.FLOAT, false, 0, 0);\n\t\t\tthis.context.bindBuffer (this.context.ARRAY_BUFFER, colorBuffer);\n\t\t\tthis.context.vertexAttribPointer (this.shader.vertexColorAttribute, colorBuffer.itemSize, this.context.FLOAT, false, 0, 0);\n\t\t\tthis.context.drawArrays (this.context.POINTS, 0, pointBuffer.numItems);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/renderer/renderconverter',[\"../core/jsm\"],function(JSM){\n\tJSM.ConvertBodyToRenderBody = function (body, materials, parameters)\n\t{\n\t\tfunction MaterialToRenderMaterial (material, materialType)\n\t\t{\n\t\t\tvar renderAmbient = JSM.HexColorToNormalizedRGBComponents (material.ambient);\n\t\t\tvar renderDiffuse = JSM.HexColorToNormalizedRGBComponents (material.diffuse);\n\t\t\tvar renderSpecular = JSM.HexColorToNormalizedRGBComponents (material.specular);\n\t\t\tvar renderMaterial = new JSM.RenderMaterial (materialType, {\n\t\t\t\tambient : renderAmbient,\n\t\t\t\tdiffuse : renderDiffuse,\n\t\t\t\tspecular : renderSpecular,\n\t\t\t\tshininess : material.shininess,\n\t\t\t\topacity : material.opacity,\n\t\t\t\tsingleSided : material.singleSided,\n\t\t\t\tpointSize : material.pointSize,\n\t\t\t\ttexture : material.texture\n\t\t\t});\n\t\t\treturn renderMaterial;\n\t\t}\n\t\t\n\t\tvar hasConvexPolygons = false;\n\t\tif (parameters !== undefined && parameters !== null) {\n\t\t\tif (parameters.hasConvexPolygons !== undefined && parameters.hasConvexPolygons !== null) {\n\t\t\t\thasConvexPolygons = parameters.hasConvexPolygons;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar renderBody = new JSM.RenderBody ();\n\t\t\n\t\tvar vertices = null;\n\t\tvar normals = null;\n\t\tvar uvs = null;\n\t\t\n\t\tvar explodeData = {\n\t\t\thasConvexPolygons : hasConvexPolygons,\n\t\t\tonPointGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = null;\n\t\t\t\tuvs = null;\n\t\t\t},\t\t\n\t\t\tonPointGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Point;\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonPoint : function (vertex) {\n\t\t\t\tvertices.push (vertex.x, vertex.y, vertex.z);\n\t\t\t},\t\t\n\t\t\tonLineGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = null;\n\t\t\t\tuvs = null;\n\t\t\t},\n\t\t\tonLineGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Line;\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonLine : function (begVertex, endVertex) {\n\t\t\t\tvertices.push (begVertex.x, begVertex.y, begVertex.z);\n\t\t\t\tvertices.push (endVertex.x, endVertex.y, endVertex.z);\n\t\t\t},\t\t\n\t\t\tonGeometryStart : function () {\n\t\t\t\tvertices = [];\n\t\t\t\tnormals = [];\n\t\t\t\tuvs = [];\n\t\t\t},\n\t\t\tonGeometryEnd : function (material) {\n\t\t\t\tvar materialType = JSM.RenderMaterialFlags.Triangle;\n\t\t\t\tif (material.texture !== null) {\n\t\t\t\t\tmaterialType += JSM.RenderMaterialFlags.Textured;\n\t\t\t\t}\n\t\t\t\tif (material.opacity < 1.0) {\n\t\t\t\t\tmaterialType += JSM.RenderMaterialFlags.Transparent;\n\t\t\t\t}\n\n\t\t\t\tvar renderMaterial = MaterialToRenderMaterial (material, materialType);\n\t\t\t\tvar mesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tmesh.SetVertexArray (vertices);\n\t\t\t\tmesh.SetNormalArray (normals);\n\t\t\t\tif (material.texture !== null) {\n\t\t\t\t\tmesh.SetUVArray (uvs);\n\t\t\t\t}\n\n\t\t\t\trenderBody.AddMesh (mesh);\n\t\t\t},\n\t\t\tonTriangle : function (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3) {\n\t\t\t\tvertices.push (vertex1.x, vertex1.y, vertex1.z);\n\t\t\t\tvertices.push (vertex2.x, vertex2.y, vertex2.z);\n\t\t\t\tvertices.push (vertex3.x, vertex3.y, vertex3.z);\n\t\t\t\t\n\t\t\t\tnormals.push (normal1.x, normal1.y, normal1.z);\n\t\t\t\tnormals.push (normal2.x, normal2.y, normal2.z);\n\t\t\t\tnormals.push (normal3.x, normal3.y, normal3.z);\n\t\t\t\t\n\t\t\t\tif (uv1 !== null && uv2 !== null && uv3 !== null) {\n\t\t\t\t\tuvs.push (uv1.x, uv1.y);\n\t\t\t\t\tuvs.push (uv2.x, uv2.y);\n\t\t\t\t\tuvs.push (uv3.x, uv3.y);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tJSM.ExplodeBody (body, materials, explodeData);\n\t\treturn renderBody;\n\t};\n\n\tJSM.ConvertModelToRenderBodies = function (model, parameters)\n\t{\n\t\tvar bodies = [];\n\t\tvar materials = model.GetMaterialSet ();\n\t\tvar i, body, renderBody;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\trenderBody = JSM.ConvertBodyToRenderBody (body, materials, parameters);\n\t\t\tbodies.push (renderBody);\n\t\t}\n\t\treturn bodies;\n\t};\n\n\tJSM.ConvertJSONDataToRenderBodies = function (jsonData, asyncCallbacks)\n\t{\n\t\tfunction ConvertMeshToRenderBody (mesh, materials)\n\t\t{\n\t\t\tfunction ConvertTrianglesToRenderMesh (mesh, triangles, materials)\n\t\t\t{\n\t\t\t\tfunction GetTextureCoordinate (u, v, offset, scale, rotation)\n\t\t\t\t{\n\t\t\t\t\tvar result = new JSM.Vector2D (u, v);\n\t\t\t\t\tif (!JSM.IsZero (rotation)) {\n\t\t\t\t\t\tvar si = Math.sin (rotation * JSM.DegRad);\n\t\t\t\t\t\tvar co = Math.cos (rotation * JSM.DegRad);\n\t\t\t\t\t\tresult.x = co * u - si * v;\n\t\t\t\t\t\tresult.y = si * u + co * v;\n\t\t\t\t\t}\n\t\t\t\t\tresult.x = offset[0] + result.x * scale[0];\n\t\t\t\t\tresult.y = offset[1] + result.y * scale[1];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tfunction AppendTriangleCoords (targetArray, sourceArray, indexArray, startIndex, componentCount)\n\t\t\t\t{\n\t\t\t\t\tvar vertexIndex, sourceVertexIndex, componentIndex;\n\t\t\t\t\tfor (vertexIndex = 0; vertexIndex < 3; vertexIndex++) {\n\t\t\t\t\t\tsourceVertexIndex = indexArray[startIndex + vertexIndex];\n\t\t\t\t\t\tfor (componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n\t\t\t\t\t\t\ttargetArray.push (sourceArray[sourceVertexIndex * componentCount + componentIndex]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = materials[triangles.material];\n\t\t\t\tvar renderMaterial = new JSM.RenderMaterial (JSM.RenderMaterialFlags.Triangle, {\n\t\t\t\t\tambient : material.ambient || [1.0, 1.0, 1.0],\n\t\t\t\t\tdiffuse : material.diffuse || [1.0, 1.0, 1.0],\n\t\t\t\t\tspecular : material.specular || [1.0, 1.0, 1.0],\n\t\t\t\t\tshininess : material.shininess || 0.0,\n\t\t\t\t\topacity : material.opacity || 1.0,\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar hasTexture = (material.texture !== undefined && material.texture !== null);\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\trenderMaterial.SetType (JSM.RenderMaterialFlags.Triangle + JSM.RenderMaterialFlags.Textured);\n\t\t\t\t\trenderMaterial.texture = material.texture;\n\t\t\t\t\trenderMaterial.ambient = [1.0, 1.0, 1.0];\n\t\t\t\t\trenderMaterial.diffuse = [1.0, 1.0, 1.0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar renderMesh = new JSM.RenderMesh (renderMaterial);\n\t\t\t\tvar vertexArray = [];\n\t\t\t\tvar normalArray = [];\n\t\t\t\tvar uvArray = [];\n\t\t\t\t\n\t\t\t\tvar i;\n\t\t\t\tfor\t(i = 0; i < triangles.parameters.length; i += 9) {\n\t\t\t\t\tAppendTriangleCoords (vertexArray, mesh.vertices, triangles.parameters, i, 3);\n\t\t\t\t\tAppendTriangleCoords (normalArray, mesh.normals, triangles.parameters, i + 3, 3);\n\t\t\t\t\tAppendTriangleCoords (uvArray, mesh.uvs, triangles.parameters, i + 6, 2);\n\t\t\t\t}\n\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\tvar offset = material.offset || [0.0, 0.0];\n\t\t\t\t\tvar scale = material.scale || [1.0, 1.0];\n\t\t\t\t\tvar rotation = material.rotation || 0.0;\n\t\t\t\t\tvar transformedUV;\n\t\t\t\t\tfor\t(i = 0; i < uvArray.length; i += 2) {\n\t\t\t\t\t\ttransformedUV = GetTextureCoordinate (uvArray[i + 0], uvArray[i + 1], offset, scale, rotation);\n\t\t\t\t\t\tuvArray[i + 0] = transformedUV.x;\n\t\t\t\t\t\tuvArray[i + 1] = -transformedUV.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trenderMesh.SetVertexArray (vertexArray);\n\t\t\t\trenderMesh.SetNormalArray (normalArray);\n\t\t\t\trenderMesh.SetUVArray (uvArray);\n\t\t\t\treturn renderMesh;\n\t\t\t}\n\t\t\t\n\t\t\tvar renderBody = new JSM.RenderBody ();\n\t\t\tvar i, triangles, renderMesh;\n\t\t\tfor (i = 0; i < mesh.triangles.length; i++) {\n\t\t\t\ttriangles = mesh.triangles[i];\n\t\t\t\trenderMesh = ConvertTrianglesToRenderMesh (mesh, triangles, materials);\n\t\t\t\trenderBody.AddMesh (renderMesh);\n\t\t\t}\n\t\t\treturn renderBody;\n\t\t}\n\t\t\n\t\tfunction AddMesh (meshes, materials, meshIndex, resultBodies)\n\t\t{\n\t\t\tvar renderBody = ConvertMeshToRenderBody (meshes[meshIndex], materials);\n\t\t\tresultBodies.push (renderBody);\n\t\t}\n\t\t\n\t\tvar resultBodies = [];\n\n\t\tvar materials = jsonData.materials;\n\t\tif (materials === undefined) {\n\t\t\treturn resultBodies;\n\t\t}\n\t\t\n\t\tvar meshes = jsonData.meshes;\n\t\tif (meshes === undefined) {\n\t\t\treturn resultBodies;\n\t\t}\n\t\t\n\t\tvar meshIndex = 0;\n\t\tJSM.AsyncRunTask (\n\t\t\tfunction () {\n\t\t\t\tAddMesh (meshes, materials, meshIndex, resultBodies);\n\t\t\t\tmeshIndex = meshIndex + 1;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tasyncCallbacks,\n\t\t\tmeshes.length, 0, resultBodies\n\t\t);\n\n\t\treturn resultBodies;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/mouse',[\"../core/jsm\"],function(JSM){\n\tJSM.Mouse = function ()\n\t{\n\t\tthis.down = false;\n\t\tthis.button = 0;\n\t\tthis.shift = false;\n\t\tthis.ctrl = false;\n\t\tthis.alt = false;\n\t\tthis.prev = new JSM.Coord2D (0, 0);\n\t\tthis.curr = new JSM.Coord2D (0, 0);\n\t\tthis.diff = new JSM.Coord2D (0, 0);\n\t};\n\n\tJSM.Mouse.prototype.Down = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\n\t\tthis.down = true;\n\t\tthis.button = event.which;\n\t\tthis.shift = event.shiftKey;\n\t\tthis.ctrl = event.ctrlKey;\n\t\tthis.alt = event.altKey;\n\t\t\n\t\tthis.SetCurrent (eventParameters, div);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Mouse.prototype.Move = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.shift = event.shiftKey;\n\t\tthis.ctrl = event.ctrlKey;\n\t\tthis.alt = event.altKey;\n\t\t\n\t\tthis.SetCurrent (eventParameters, div);\n\t\tthis.diff = JSM.CoordSub2D (this.curr, this.prev);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Mouse.prototype.Up = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.down = false;\n\t\tthis.SetCurrent (eventParameters, div);\n\t};\n\n\tJSM.Mouse.prototype.Out = function (event, div)\n\t{\n\t\tvar eventParameters = event || window.event;\n\t\t\n\t\tthis.down = false;\n\t\tthis.SetCurrent (eventParameters, div);\n\t};\n\n\tJSM.Mouse.prototype.SetCurrent = function (eventParameters, div)\n\t{\n\t\tvar currX = eventParameters.clientX;\n\t\tvar currY = eventParameters.clientY;\n\t\tif (div.getBoundingClientRect !== undefined) {\n\t\t\tvar clientRect = div.getBoundingClientRect ();\n\t\t\tcurrX -= clientRect.left;\n\t\t\tcurrY -= clientRect.top;\n\t\t}\n\t\tif (window.pageXOffset !== undefined && window.pageYOffset !== undefined) {\n\t\t\tcurrX += window.pageXOffset;\n\t\t\tcurrY += window.pageYOffset;\n\t\t}\n\t\tthis.curr = new JSM.Coord2D (currX, currY);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/touch',[\"../core/jsm\"],function(JSM){\n\tJSM.Touch = function ()\n\t{\n\t\tthis.down = false;\n\t\tthis.fingers = 0;\n\t\tthis.prev = new JSM.Coord2D ();\n\t\tthis.curr = new JSM.Coord2D ();\n\t\tthis.diff = new JSM.Coord2D ();\n\t};\n\n\tJSM.Touch.prototype.Start = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.down = true;\n\t\tthis.fingers = event.touches.length;\n\n\t\tthis.SetCurrent (event, div);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Touch.prototype.Move = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fingers = event.touches.length;\n\n\t\tthis.SetCurrent (event, div);\n\t\tthis.diff = JSM.CoordSub2D (this.curr, this.prev);\n\t\tthis.prev = this.curr.Clone ();\n\t};\n\n\tJSM.Touch.prototype.End = function (event, div)\n\t{\n\t\tif (event.touches.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.down = false;\n\t\tthis.SetCurrent (event, div);\n\t};\n\n\tJSM.Touch.prototype.SetCurrent = function (event, div)\n\t{\n\t\tfunction GetEventCoord (touch, div)\n\t\t{\n\t\t\tvar currX = touch.pageX;\n\t\t\tvar currY = touch.pageY;\n\t\t\tif (div.getBoundingClientRect !== undefined) {\n\t\t\t\tvar clientRect = div.getBoundingClientRect ();\n\t\t\t\tcurrX -= clientRect.left;\n\t\t\t\tcurrY -= clientRect.top;\n\t\t\t}\n\t\t\tif (window.pageXOffset !== undefined && window.pageYOffset !== undefined) {\n\t\t\t\tcurrX += window.pageXOffset;\n\t\t\t\tcurrY += window.pageYOffset;\n\t\t\t}\n\t\t\treturn new JSM.Coord2D (currX, currY);\n\t\t}\n\t\t\n\t\tif (event.touches.length == 1 || event.touches.length == 3) {\n\t\t\tthis.curr = GetEventCoord (event.touches[0], div);\n\t\t} else if (event.touches.length == 2) {\n\t\t\tvar distance = GetEventCoord (event.touches[0], div).DistanceTo (GetEventCoord (event.touches[1], div));\n\t\t\tthis.curr = new JSM.Coord2D (distance, distance);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/painter',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: OrderPolygons\n\t* Description: Order body polygons from front to back depending on the eye position.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\teye {Coord} the camera eye position\n\t*\tcenter {Coord} the camera center position\n\t* Returns:\n\t*\t{integer[]} the ordered polygon indices\n\t*/\n\tJSM.OrderPolygons = function (body, eye, center)\n\t{\n\t\tfunction SwapArrayValues (array, from, to)\n\t\t{\n\t\t\tvar temp = array[from];\n\t\t\tarray[from] = array[to];\n\t\t\tarray[to] = temp;\n\t\t}\n\n\t\tfunction GetPolygonCenter (p)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (p);\n\t\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult = JSM.CoordAdd (result, coord);\n\t\t\t}\n\t\t\t\n\t\t\tresult.MultiplyScalar (1.0 / polygon.VertexIndexCount ());\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction CalculatePolygonValues ()\n\t\t{\n\t\t\tvar viewDirection = JSM.CoordSub (center, eye).Normalize ();\n\t\t\tvar cameraPlane = JSM.GetPlaneFromCoordAndDirection (eye, viewDirection);\n\t\t\t\n\t\t\tvar i, j, polygon, coord, distance, minDistance, maxDistance;\n\t\t\tvar polygonCenter, polygonCenterDistance;\n\t\t\tvar polygonNormal, polygonViewVector, polygonDirection, polygonPlane;\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tminDistance = JSM.Inf;\n\t\t\t\tmaxDistance = -JSM.Inf;\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\t\tdistance = cameraPlane.CoordDistance (coord);\n\t\t\t\t\tif (JSM.IsLower (distance, minDistance)) {\n\t\t\t\t\t\tminDistance = distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (JSM.IsGreater (distance, maxDistance)) {\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tminViewDistances.push (minDistance);\n\t\t\t\tmaxViewDistances.push (maxDistance);\n\t\t\t\t\n\t\t\t\tpolygonCenter = GetPolygonCenter (i);\n\t\t\t\tpolygonCenterDistance = cameraPlane.CoordDistance (polygonCenter);\n\t\t\t\tpolygonCenters.push (polygonCenter);\n\t\t\t\tpolygonCenterDistances.push (polygonCenterDistance);\n\n\t\t\t\tpolygonNormal = JSM.CalculateBodyPolygonNormal (body, i);\n\t\t\t\tpolygonViewVector = JSM.CoordSub (polygonCenter, eye).Normalize ();\n\t\t\t\tpolygonDirection = JSM.VectorDot (polygonNormal, polygonViewVector);\n\t\t\t\tif (JSM.IsGreaterOrEqual (polygonDirection, 0.0)) {\n\t\t\t\t\tpolygonNormal.MultiplyScalar (-1);\n\t\t\t\t}\n\n\t\t\t\tpolygonPlane = JSM.GetPlaneFromCoordAndDirection (polygonCenter, polygonNormal);\n\t\t\t\tpolygonPlanes.push (polygonPlane);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction PolygonViewOverlap (s, p)\n\t\t{\n\t\t\treturn JSM.IsLowerOrEqual (minViewDistances[s], maxViewDistances[p]);\n\t\t}\n\n\t\tfunction PolygonIsFrontOfPlane (s, p)\n\t\t{\n\t\t\tvar sPlane = polygonPlanes[s];\n\t\t\tvar pPlane = polygonPlanes[p];\n\n\t\t\tvar i, coord;\n\n\t\t\tvar isSBehindP = true;\n\t\t\tvar sPolygon = body.GetPolygon (s);\n\t\t\tfor (i = 0; i < sPolygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (sPolygon.GetVertexIndex (i));\n\t\t\t\tif (pPlane.CoordPosition (coord) === JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tisSBehindP = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (isSBehindP) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar isPFrontOfS = true;\n\t\t\tvar pPolygon = body.GetPolygon (p);\n\t\t\tfor (i = 0; i < pPolygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (pPolygon.GetVertexIndex (i));\n\t\t\t\tif (sPlane.CoordPosition (coord) === JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tisPFrontOfS = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (isPFrontOfS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction HasLowerDistance (s, p)\n\t\t{\n\t\t\tif (JSM.IsLower (maxViewDistances[s], maxViewDistances[p])) {\n\t\t\t\treturn true;\n\t\t\t} else if (JSM.IsEqual (maxViewDistances[s], maxViewDistances[p])) {\n\t\t\t\tif (JSM.IsLower (polygonCenterDistances[s], polygonCenterDistances[p])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction OrderPolygonsByMaxViewDistance ()\n\t\t{\n\t\t\tvar count = ordered.length;\n\t\t\t\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tfor (j = 0; j < count - i - 1; j++) {\n\t\t\t\t\tif (HasLowerDistance (ordered[j], ordered[j + 1])) {\n\t\t\t\t\t\tSwapArrayValues (ordered, j, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction NeedToChangeOrder (s, p)\n\t\t{\n\t\t\tif (needToChangeOrderCache[s][p] !== null) {\n\t\t\t\treturn needToChangeOrderCache[s][p];\n\t\t\t}\n\n\t\t\tif (PolygonViewOverlap (s, p)) {\n\t\t\t\tif (PolygonIsFrontOfPlane (s, p)) {\n\t\t\t\t\tneedToChangeOrderCache[s][p] = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tneedToChangeOrderCache[s][p] = false;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction ReorderPolygons ()\n\t\t{\n\t\t\tvar count = ordered.length;\n\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tfor (j = 0; j < count - i - 1; j++) {\n\t\t\t\t\tif (NeedToChangeOrder (ordered[j], ordered[j + 1])) {\n\t\t\t\t\t\tSwapArrayValues (ordered, j, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar result = [];\n\t\t\n\t\tvar minViewDistances = [];\n\t\tvar maxViewDistances = [];\n\t\tvar polygonCenters = [];\n\t\tvar polygonCenterDistances = [];\n\t\tvar polygonPlanes = [];\n\t\t\n\t\tvar ordered = [];\n\t\tvar needToChangeOrderCache = [];\n\t\tvar count = body.PolygonCount ();\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tordered.push (i);\n\t\t\tneedToChangeOrderCache.push ([]);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tneedToChangeOrderCache[i].push (null);\n\t\t\t}\n\t\t}\n\n\t\tCalculatePolygonValues ();\n\t\tOrderPolygonsByMaxViewDistance ();\n\t\tReorderPolygons ();\n\t\t\n\t\tresult = ordered;\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/drawing',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: CanvasDrawer\n\t* Description: Represents an object which can draw primitives to a canvas.\n\t* Parameters:\n\t*\tcanvas {html canvas element} the destination element\n\t*/\n\tJSM.CanvasDrawer = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tthis.context = this.canvas.getContext ('2d');\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.GetWidth\n\t* Description: Returns the width of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.CanvasDrawer.prototype.GetWidth = function ()\n\t{\n\t\treturn this.canvas.width;\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.GetHeight\n\t* Description: Returns the height of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.CanvasDrawer.prototype.GetHeight = function ()\n\t{\n\t\treturn this.canvas.height;\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.Clear\n\t* Description: Clears the target.\n\t*/\n\tJSM.CanvasDrawer.prototype.Clear = function ()\n\t{\n\t\tthis.context.clearRect (0, 0, this.canvas.width, this.canvas.height);\n\t\tthis.context.fillStyle = '#ffffff';\n\t\tthis.context.fillRect (0, 0, this.canvas.width, this.canvas.height);\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.DrawLine\n\t* Description: Draws a line to the target.\n\t* Parameters:\n\t*\tfrom {Coord2D} the start of the line\n\t*\tto {Coord2D} the end of the line\n\t*/\n\tJSM.CanvasDrawer.prototype.DrawLine = function (from, to)\n\t{\n\t\tthis.context.beginPath ();\n\t\tthis.context.moveTo (from.x, this.canvas.height - from.y);\n\t\tthis.context.lineTo (to.x, this.canvas.height - to.y);\n\t\tthis.context.stroke ();\n\t};\n\n\t/**\n\t* Function: CanvasDrawer.DrawPolygon\n\t* Description: Draws a polygon to the target.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tcolor {string} the hex color string\n\t*\tcontour {boolean} need to draw contour\n\t*/\n\tJSM.CanvasDrawer.prototype.DrawPolygon = function (polygon, color, contour)\n\t{\n\t\tfunction HexColorToHTMLColor (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tthis.context.fillStyle = HexColorToHTMLColor (color);\n\t\tthis.context.beginPath ();\n\n\t\tvar i, vertex, nextVertex;\n\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tif (i === 0) {\n\t\t\t\tthis.context.moveTo (vertex.x, this.canvas.height - vertex.y);\n\t\t\t} else {\n\t\t\t\tthis.context.lineTo (vertex.x, this.canvas.height - vertex.y);\n\t\t\t}\n\t\t}\n\n\t\tthis.context.closePath ();\n\t\tthis.context.fill ();\n\n\t\tif (contour) {\n\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\tnextVertex = polygon.GetVertex (i < polygon.VertexCount () - 1 ? i + 1 : 0);\n\t\t\t\tthis.DrawLine (vertex, nextVertex);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Class: SVGDrawer\n\t* Description: Represents an object which can draw primitives to an svg.\n\t* Parameters:\n\t*\tsvgObject {html svg element} the destination element\n\t*/\n\tJSM.SVGDrawer = function (svgObject)\n\t{\n\t\tthis.svgObject = svgObject;\n\t\tthis.svgNameSpace = 'http://www.w3.org/2000/svg';\n\t};\n\n\t/**\n\t* Function: SVGDrawer.GetWidth\n\t* Description: Returns the width of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SVGDrawer.prototype.GetWidth = function ()\n\t{\n\t\treturn this.svgObject.getAttribute ('width');\n\t};\n\n\t/**\n\t* Function: SVGDrawer.GetHeight\n\t* Description: Returns the height of the target.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SVGDrawer.prototype.GetHeight = function ()\n\t{\n\t\treturn this.svgObject.getAttribute ('height');\n\t};\n\n\t/**\n\t* Function: SVGDrawer.Clear\n\t* Description: Clears the target.\n\t*/\n\tJSM.SVGDrawer.prototype.Clear = function ()\n\t{\n\t\twhile (this.svgObject.lastChild) {\n\t\t\tthis.svgObject.removeChild (this.svgObject.lastChild);\n\t\t}\n\t};\n\n\t/**\n\t* Function: SVGDrawer.DrawLine\n\t* Description: Draws a line to the target.\n\t* Parameters:\n\t*\tfrom {Coord2D} the start of the line\n\t*\tto {Coord2D} the end of the line\n\t*/\n\tJSM.SVGDrawer.prototype.DrawLine = function (from, to)\n\t{\n\t\tvar svgLine = document.createElementNS (this.svgNameSpace, 'line');\n\t\tvar height = this.GetHeight ();\n\t\tsvgLine.setAttributeNS (null, 'stroke', 'black');\n\t\tsvgLine.setAttributeNS (null, 'x1', from.x);\n\t\tsvgLine.setAttributeNS (null, 'y1', height - from.y);\n\t\tsvgLine.setAttributeNS (null, 'x2', to.x);\n\t\tsvgLine.setAttributeNS (null, 'y2', height - to.y);\n\t\tthis.svgObject.appendChild (svgLine);\n\t};\n\n\t/**\n\t* Function: SVGDrawer.DrawPolygon\n\t* Description: Draws a polygon to the target.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tcolor {string} the hex color string\n\t*\tcontour {boolean} need to draw contour\n\t*/\n\tJSM.SVGDrawer.prototype.DrawPolygon = function (polygon, color/*, contour*/)\n\t{\n\t\tfunction HexColorToHTMLColor (hexColor)\n\t\t{\n\t\t\tvar rgb = JSM.HexColorToRGBComponents (hexColor);\n\t\t\tvar result = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';\n\t\t\treturn result;\n\t\t}\n\n\t\tvar pointsString = '';\n\t\tvar height = this.GetHeight ();\n\t\t\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tpointsString = pointsString + vertex.x + ', ' + (height - vertex.y);\n\t\t\tif (i < polygon.VertexCount () - 1) {\n\t\t\t\tpointsString = pointsString + ', ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar svgPolyon = document.createElementNS (this.svgNameSpace, 'polygon');\n\t\tsvgPolyon.setAttributeNS (null, 'points', pointsString);\n\t\tsvgPolyon.setAttributeNS (null, 'fill', HexColorToHTMLColor (color));\n\t\tsvgPolyon.setAttributeNS (null, 'fill-opacity', '1.0');\n\t\tsvgPolyon.setAttributeNS (null, 'stroke', 'black');\n\t\tthis.svgObject.appendChild (svgPolyon);\n\t};\n\n\t/**\n\t* Function: DrawProjectedBody\n\t* Description: Draws a projected body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the material container\n\t*\tcamera {Camera} the camera for projection\n\t*\tdrawMode {string} draw mode ('HiddenLinePainter', 'HiddenLineFrontFacing' or 'Wireframe')\n\t*\tneedClear {boolean} clear the display before draw\n\t*\tdrawer {drawer object} the drawer object\n\t*/\n\tJSM.DrawProjectedBody = function (body, materials, camera, drawMode, needClear, drawer)\n\t{\n\t\tfunction AddProjectedCoord (projectedPolygon, coord)\n\t\t{\n\t\t\tvar projected = JSM.Project (coord, eye, center, up, fieldOfView * JSM.DegRad, aspectRatio, nearPlane, farPlane, viewPort);\n\t\t\tprojectedPolygon.AddVertex (projected.x, projected.y);\n\t\t}\n\n\t\tfunction GetProjectedPolygonFromBody (polygon)\n\t\t{\n\t\t\tvar projectedPolygon = new JSM.Polygon2D ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tAddProjectedCoord (projectedPolygon, coord);\n\t\t\t}\n\t\t\treturn projectedPolygon;\n\t\t}\n\n\t\tfunction GetProjectedPolygonFromPolygon (polygon)\n\t\t{\n\t\t\tvar projectedPolygon = new JSM.Polygon2D ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\tAddProjectedCoord (projectedPolygon, coord);\n\t\t\t}\n\t\t\treturn projectedPolygon;\n\t\t}\n\n\t\tif (needClear) {\n\t\t\tdrawer.Clear ();\n\t\t}\n\n\t\tvar width = drawer.GetWidth ();\n\t\tvar height = drawer.GetHeight ();\n\t\t\n\t\tvar eye = camera.eye;\n\t\tvar center = camera.center;\n\t\tvar up = camera.up;\n\t\tvar fieldOfView = camera.fieldOfView;\n\t\tvar aspectRatio = width / height;\n\t\tvar nearPlane = camera.nearClippingPlane;\n\t\tvar farPlane = camera.farClippingPlane;\n\t\tvar viewPort = [0, 0, width, height];\n\n\t\tvar i, j, polygon, coord, projected, materialIndex, color;\n\t\tif (drawMode == 'HiddenLinePainter') {\n\t\t\tvar orderedPolygons = JSM.OrderPolygons (body, eye, center);\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\t\t\tfor (i = 0; i < orderedPolygons.length; i++) {\n\t\t\t\tpolygon = body.GetPolygon (orderedPolygons[i]);\n\t\t\t\tprojected = GetProjectedPolygonFromBody (polygon);\n\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t}\n\t\t} else if (drawMode == 'HiddenLineBSPTree') {\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\n\t\t\tvar bspTree = new JSM.BSPTree ();\n\t\t\tJSM.AddBodyToBSPTree (body, bspTree);\n\n\t\t\tJSM.TraverseBSPTreeForEyePosition (bspTree, camera.eye, function (node) {\n\t\t\t\tprojected = GetProjectedPolygonFromPolygon (node.polygon);\n\t\t\t\tpolygon = body.GetPolygon (node.userData.originalPolygon);\n\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t});\t\t\n\t\t} else if (drawMode == 'HiddenLineFrontFacing') {\n\t\t\tif (materials === undefined || materials === null) {\n\t\t\t\tmaterials = new JSM.MaterialSet ();\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tprojected = GetProjectedPolygonFromBody (polygon);\n\t\t\t\tif (projected.GetOrientation () == JSM.Orientation.CounterClockwise) {\n\t\t\t\t\tmaterialIndex = polygon.GetMaterialIndex ();\n\t\t\t\t\tcolor = materials.GetMaterial (materialIndex).diffuse;\n\t\t\t\t\tdrawer.DrawPolygon (projected, color, true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (drawMode == 'Wireframe') {\n\t\t\tvar vertexCount, currentCoord, currentVertex, vertex;\n\t\t\tvar drawedLines = [];\n\t\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\t\tcurrentCoord = null;\n\t\t\t\tcurrentVertex = null;\n\t\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\tvertexCount = polygon.VertexIndexCount ();\n\t\t\t\tfor (j = 0; j <= vertexCount; j++) {\n\t\t\t\t\tvertex = polygon.GetVertexIndex (j % vertexCount);\n\t\t\t\t\tcoord = body.GetVertexPosition (vertex);\n\t\t\t\t\tprojected = JSM.Project (coord, eye, center, up, fieldOfView * JSM.DegRad, aspectRatio, nearPlane, farPlane, viewPort);\n\t\t\t\t\tif (currentCoord !== null && currentVertex !== null && drawedLines[[currentVertex, vertex]] === undefined) {\n\t\t\t\t\t\tdrawer.DrawLine (currentCoord, projected);\n\t\t\t\t\t\tdrawedLines[[currentVertex, vertex]] = true;\n\t\t\t\t\t\tdrawedLines[[vertex, currentVertex]] = true;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentVertex = vertex;\n\t\t\t\t\tcurrentCoord = projected;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/navigation',[\"../core/jsm\"],function(JSM){\n\tJSM.Navigation = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.drawCallback = null;\n\t\tthis.resizeCallback = null;\n\t\t\n\t\tthis.mouse = null;\n\t\tthis.touch = null;\n\t\t\n\t\tthis.cameraFixUp = null;\n\t\tthis.cameraEnableOrbit = null;\n\t\tthis.cameraEnablePan = null;\n\t\tthis.cameraEnableZoom = null;\n\t\tthis.cameraNearDistanceLimit = null;\n\t\tthis.cameraFarDistanceLimit = null;\n\t\t\n\t\tthis.orbitCenter = null;\n\t\tthis.fullscreen = null;\n\t};\n\n\tJSM.Navigation.prototype.Init = function (canvas, camera, drawCallback, resizeCallback)\n\t{\n\t\tthis.canvas = canvas;\n\t\tthis.camera = camera;\n\t\tthis.drawCallback = drawCallback;\n\t\tthis.resizeCallback = resizeCallback;\n\n\t\tthis.mouse = new JSM.Mouse ();\n\t\tthis.touch = new JSM.Touch ();\n\t\t\n\t\tthis.cameraFixUp = true;\n\t\tthis.cameraEnableOrbit = true;\n\t\tthis.cameraEnablePan = true;\n\t\tthis.cameraEnableZoom = true;\n\t\t\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t\tthis.fullscreen = false;\n\n\t\tvar myThis = this;\n\t\tif (document.addEventListener) {\n\t\t\tdocument.addEventListener ('mousemove', function (event) {myThis.OnMouseMove (event);});\n\t\t\tdocument.addEventListener ('mouseup', function (event) {myThis.OnMouseUp (event);});\n\t\t}\n\t\tif (this.canvas.addEventListener) {\n\t\t\tthis.canvas.addEventListener ('mousedown', function (event) {myThis.OnMouseDown (event);}, false);\n\t\t\tthis.canvas.addEventListener ('DOMMouseScroll', function (event) {myThis.OnMouseWheel (event);}, false);\n\t\t\tthis.canvas.addEventListener ('mousewheel', function (event) {myThis.OnMouseWheel (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchstart', function (event) {myThis.OnTouchStart (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchmove', function (event) {myThis.OnTouchMove (event);}, false);\n\t\t\tthis.canvas.addEventListener ('touchend', function (event) {myThis.OnTouchEnd (event);}, false);\n\t\t\tthis.canvas.addEventListener ('contextmenu', function (event) {myThis.OnContextMenu (event);}, false);\n\t\t}\n\t\tif (window.addEventListener) {\n\t\t\twindow.addEventListener ('resize', function (event) {myThis.OnResize (event);}, false);\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.Navigation.prototype.SetCamera = function (eye, center, up)\n\t{\n\t\tthis.camera.Set (eye, center, up);\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t};\n\n\tJSM.Navigation.prototype.EnableFixUp = function (enable)\n\t{\n\t\tthis.cameraFixUp = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnableOrbit = function (enable)\n\t{\n\t\tthis.cameraEnableOrbit = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnablePan = function (enable)\n\t{\n\t\tthis.cameraEnablePan = enable;\n\t};\n\n\tJSM.Navigation.prototype.EnableZoom = function (enable)\n\t{\n\t\tthis.cameraEnableZoom = enable;\n\t};\n\n\tJSM.Navigation.prototype.SetNearDistanceLimit = function (limit)\n\t{\n\t\tthis.cameraNearDistanceLimit = limit;\n\t};\n\n\tJSM.Navigation.prototype.SetFarDistanceLimit = function (limit)\n\t{\n\t\tthis.cameraFarDistanceLimit = limit;\n\t};\n\n\tJSM.Navigation.prototype.SetOrbitCenter = function (orbitCenter)\n\t{\n\t\tthis.orbitCenter = orbitCenter;\n\t};\n\n\tJSM.Navigation.prototype.FitInWindow = function (center, radius)\n\t{\n\t\tif (JSM.IsZero (radius)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar offsetToOrigo = JSM.CoordSub (this.camera.center, center);\n\t\tthis.camera.center = center;\n\t\tthis.camera.eye = JSM.CoordSub (this.camera.eye, offsetToOrigo);\n\t\t\n\t\tvar centerEyeDirection = JSM.CoordSub (this.camera.eye, this.camera.center).Normalize ();\n\t\tvar fieldOfView = this.camera.fieldOfView / 2.0;\n\t\tif (this.canvas.width < this.canvas.height) {\n\t\t\tfieldOfView = fieldOfView * this.canvas.width / this.canvas.height;\n\t\t}\n\t\tvar distance = radius / Math.sin (fieldOfView * JSM.DegRad);\n\t\t\n\t\tthis.camera.eye = this.camera.center.Clone ().Offset (centerEyeDirection, distance);\n\t\tthis.orbitCenter = this.camera.center.Clone ();\n\t};\n\n\tJSM.Navigation.prototype.SetFullscreen = function (fullscreen)\n\t{\n\t\tthis.fullscreen = fullscreen;\n\t\tthis.ResizeCallback ();\n\t};\n\n\tJSM.Navigation.prototype.Orbit = function (angleX, angleY)\n\t{\n\t\tvar radAngleX = angleX * JSM.DegRad;\n\t\tvar radAngleY = angleY * JSM.DegRad;\n\t\t\n\t\tvar viewDirection = JSM.CoordSub (this.camera.center, this.camera.eye).Normalize ();\n\t\tvar horizontalDirection = JSM.VectorCross (viewDirection, this.camera.up).Normalize ();\n\t\tvar differentCenter = !this.orbitCenter.IsEqual (this.camera.center);\n\t\t\n\t\tif (this.cameraFixUp) {\n\t\t\tvar originalAngle = viewDirection.AngleTo (this.camera.up);\n\t\t\tvar newAngle = originalAngle + radAngleY;\n\t\t\tif (JSM.IsGreater (newAngle, 0.0) && JSM.IsLower (newAngle, Math.PI)) {\n\t\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\tif (differentCenter) {\n\t\t\t\t\tthis.camera.center.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.camera.eye.Rotate (this.camera.up, -radAngleX, this.orbitCenter);\n\t\t\tif (differentCenter) {\n\t\t\t\tthis.camera.center.Rotate (this.camera.up, -radAngleX, this.orbitCenter);\n\t\t\t}\n\t\t} else {\n\t\t\tvar verticalDirection = JSM.VectorCross (horizontalDirection, viewDirection).Normalize ();\n\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\tthis.camera.eye.Rotate (verticalDirection, -radAngleX, this.orbitCenter);\n\t\t\tif (differentCenter) {\n\t\t\t\tthis.camera.center.Rotate (horizontalDirection, -radAngleY, this.orbitCenter);\n\t\t\t\tthis.camera.center.Rotate (verticalDirection, -radAngleX, this.orbitCenter);\n\t\t\t}\n\t\t\tthis.camera.up = verticalDirection;\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.Pan = function (moveX, moveY)\n\t{\n\t\tvar viewDirection = JSM.CoordSub (this.camera.center, this.camera.eye).Normalize ();\n\t\tvar horizontalDirection = JSM.VectorCross (viewDirection, this.camera.up).Normalize ();\n\t\tvar verticalDirection = JSM.VectorCross (horizontalDirection, viewDirection).Normalize ();\n\t\t\n\t\tthis.camera.eye.Offset (horizontalDirection, -moveX);\n\t\tthis.camera.center.Offset (horizontalDirection, -moveX);\n\n\t\tthis.camera.eye.Offset (verticalDirection, moveY);\n\t\tthis.camera.center.Offset (verticalDirection, moveY);\n\t};\n\n\tJSM.Navigation.prototype.Zoom = function (ratio)\n\t{\n\t\tvar direction = JSM.CoordSub (this.camera.center, this.camera.eye);\n\t\tvar distance = direction.Length ();\n\t\tvar zoomIn = ratio > 0;\n\t\tif (zoomIn && this.cameraNearDistanceLimit !== null && distance < this.cameraNearDistanceLimit) {\n\t\t\treturn 0;\n\t\t} else if (!zoomIn && this.cameraFarDistanceLimit !== null && distance > this.cameraFarDistanceLimit) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar move = distance * ratio;\n\t\tthis.camera.eye.Offset (direction, move);\n\t};\n\n\tJSM.Navigation.prototype.DrawCallback = function ()\n\t{\n\t\tif (this.drawCallback !== undefined && this.drawCallback !== null) {\n\t\t\tthis.drawCallback ();\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.ResizeCallback = function ()\n\t{\n\t\tif (this.resizeCallback !== undefined && this.resizeCallback !== null) {\n\t\t\tif (this.fullscreen) {\n\t\t\t\tthis.canvas.width = window.innerWidth;\n\t\t\t\tthis.canvas.height = window.innerHeight;\n\t\t\t}\n\t\t\tthis.resizeCallback ();\n\t\t}\n\t};\n\n\tJSM.Navigation.prototype.OnMouseDown = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Down (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseMove = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Move (event, this.canvas);\n\t\tif (!this.mouse.down) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ratio = 0.0;\n\t\tif (this.mouse.button == 1) {\n\t\t\tif (!this.cameraEnableOrbit) {\n\t\t\t\treturn;\n\t\t\t}\t\t\n\t\t\tratio = 0.5;\n\t\t\tthis.Orbit (this.mouse.diff.x * ratio, this.mouse.diff.y * ratio);\n\t\t} else if (this.mouse.button == 3) {\n\t\t\tif (!this.cameraEnablePan) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar eyeCenterDistance = this.camera.eye.DistanceTo (this.camera.center);\n\t\t\tratio = 0.001 * eyeCenterDistance;\n\t\t\tthis.Pan (this.mouse.diff.x * ratio, this.mouse.diff.y * ratio);\n\t\t}\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnMouseUp = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Up (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseOut = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.mouse.Out (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnMouseWheel = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tif (!this.cameraEnableZoom) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar eventParameters = event;\n\t\tif (eventParameters === null) {\n\t\t\teventParameters = window.event;\n\t\t}\n\t\t\n\t\tvar delta = 0;\n\t\tif (eventParameters.detail) {\n\t\t\tdelta = -eventParameters.detail;\n\t\t} else if (eventParameters.wheelDelta) {\n\t\t\tdelta = eventParameters.wheelDelta / 40;\n\t\t}\n\n\t\tvar ratio = 0.1;\n\t\tif (delta < 0) {\n\t\t\tratio = ratio * -1.0;\n\t\t}\n\n\t\tthis.Zoom (ratio);\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnTouchStart = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.Start (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnTouchMove = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.Move (event, this.canvas);\n\t\tif (!this.touch.down) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ratio = 0.0;\n\t\tif (this.touch.fingers == 1) {\n\t\t\tif (!this.cameraEnableOrbit) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tratio = 0.5;\n\t\t\tthis.Orbit (this.touch.diff.x * ratio, this.touch.diff.y * ratio);\n\t\t} else if (this.touch.fingers == 2) {\n\t\t\tif (!this.cameraEnableZoom) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tratio = 0.005;\n\t\t\tthis.Zoom (this.touch.diff.x * ratio);\n\t\t} else if (this.touch.fingers == 3) {\n\t\t\tif (!this.cameraEnablePan) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar eyeCenterDistance = this.camera.eye.DistanceTo (this.camera.center);\n\t\t\tratio = 0.001 * eyeCenterDistance;\n\t\t\tthis.Pan (this.touch.diff.x * ratio, this.touch.diff.y * ratio);\n\t\t}\n\t\tthis.DrawCallback ();\n\t};\n\n\tJSM.Navigation.prototype.OnTouchEnd = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.touch.End (event, this.canvas);\n\t};\n\n\tJSM.Navigation.prototype.OnContextMenu = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t};\n\n\tJSM.Navigation.prototype.OnResize = function (event)\n\t{\n\t\tevent.preventDefault ();\n\t\tthis.ResizeCallback ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/softwareviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.SoftwareViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.bodies = null;\n\t\tthis.drawer = null;\n\t\tthis.drawMode = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.SoftwareViewer.prototype.Start = function (canvas, camera)\n\t{\n\t\tif (!this.InitCanvas (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.InitCanvas = function (canvas)\n\t{\n\t\tthis.bodies = [];\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.canvas instanceof (HTMLCanvasElement)) {\n\t\t\tthis.drawer = new JSM.CanvasDrawer (this.canvas);\n\t\t} else if (this.canvas instanceof (SVGSVGElement)) {\n\t\t\tthis.drawer = new JSM.SVGDrawer (this.canvas);\n\t\t}\n\t\t\n\t\tif (!this.drawer) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.drawMode = 'Wireframe';\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.InitCamera = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SoftwareViewer.prototype.AddBody = function (body, materials)\n\t{\n\t\tthis.bodies.push ([body, materials]);\n\t};\n\n\tJSM.SoftwareViewer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.bodies = [];\n\t};\n\n\tJSM.SoftwareViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, j, body, vertex;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i][0];\n\t\t\tfor (j = 0; j < body.VertexCount (); j++) {\n\t\t\t\tvertex = body.GetVertex (j);\n\t\t\t\tmin.x = JSM.Minimum (min.x, vertex.position.x);\n\t\t\t\tmin.y = JSM.Minimum (min.y, vertex.position.y);\n\t\t\t\tmin.z = JSM.Minimum (min.z, vertex.position.z);\n\t\t\t\tmax.x = JSM.Maximum (max.x, vertex.position.x);\n\t\t\t\tmax.y = JSM.Maximum (max.y, vertex.position.y);\n\t\t\t\tmax.z = JSM.Maximum (max.z, vertex.position.z);\n\t\t\t}\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.SoftwareViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, j, body, vertex, distance;\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbody = this.bodies[i][0];\n\t\t\tfor (j = 0; j < body.VertexCount (); j++) {\n\t\t\t\tvertex = body.GetVertex (j);\n\t\t\t\tdistance = center.DistanceTo (vertex.position);\n\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\tradius = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.SoftwareViewer.prototype.Resize = function ()\n\t{\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SoftwareViewer.prototype.Draw = function ()\n\t{\n\t\tvar i, bodyAndMaterials;\n\t\tthis.drawer.Clear ();\n\t\t\n\t\tfor (i = 0; i < this.bodies.length; i++) {\n\t\t\tbodyAndMaterials = this.bodies[i];\n\t\t\tJSM.DrawProjectedBody (bodyAndMaterials[0], bodyAndMaterials[1], this.camera, this.drawMode, false, this.drawer);\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/spriteviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.SpriteViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.camera = null;\n\t\tthis.callbacks = null;\n\t\tthis.points = null;\n\t\tthis.projected = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.SpriteViewer.prototype.Start = function (canvas, camera, callbacks)\n\t{\n\t\tif (!this.InitCanvas (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCallbacks (callbacks)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCanvas = function (canvas)\n\t{\n\t\tthis.points = [];\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCamera = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.camera, this.Draw.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.InitCallbacks = function (callbacks)\n\t{\n\t\tthis.callbacks = {\n\t\t\tonPointDraw : null\n\t\t};\n\n\t\tif (callbacks !== undefined) {\n\t\t\tif (callbacks.onDrawStart !== undefined) { this.callbacks.onDrawStart = callbacks.onDrawStart; }\n\t\t\tif (callbacks.onPointDraw !== undefined) { this.callbacks.onPointDraw = callbacks.onPointDraw; }\n\t\t\tif (callbacks.onDrawEnd !== undefined) { this.callbacks.onDrawEnd = callbacks.onDrawEnd; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.SpriteViewer.prototype.AddPoint = function (point)\n\t{\n\t\tthis.points.push (point);\n\t};\n\n\tJSM.SpriteViewer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.points = [];\n\t};\n\n\tJSM.SpriteViewer.prototype.Resize = function ()\n\t{\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderPosition = function (maxDistance, x, y)\n\t{\n\t\tvar position = new JSM.Coord2D (x, y);\n\t\t\n\t\tvar minIndex = -1;\n\t\tvar minDistance = JSM.Inf;\n\t\tvar i, projected, distance;\n\t\tfor (i = 0; i < this.projected.length; i++) {\n\t\t\tprojected = this.projected[i];\n\t\t\tdistance = position.DistanceTo (new JSM.Coord2D (projected.position.x, projected.position.y));\n\t\t\tif (JSM.IsLower (distance, maxDistance) && JSM.IsLower (distance, minDistance)) {\n\t\t\t\tminIndex = projected.originalIndex;\n\t\t\t\tminDistance = distance;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn minIndex;\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderMouse = function (maxDistance)\n\t{\n\t\treturn this.NearestPointUnderPosition (maxDistance, this.navigation.mouse.curr.x, this.navigation.mouse.curr.y);\n\t};\n\n\tJSM.SpriteViewer.prototype.NearestPointUnderTouch = function (maxDistance)\n\t{\n\t\treturn this.NearestPointUnderPosition (maxDistance, this.navigation.touch.curr.x, this.navigation.touch.curr.y);\n\t};\n\n\tJSM.SpriteViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.SpriteViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.SpriteViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.SpriteViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, coord, distance;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tdistance = center.DistanceTo (coord);\n\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\tradius = distance;\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.SpriteViewer.prototype.Draw = function ()\n\t{\n\t\tif (this.callbacks.onDrawStart !== null) {\n\t\t\tthis.callbacks.onDrawStart (this.canvas);\n\t\t}\n\n\t\tvar aspectRatio = this.canvas.width / this.canvas.height;\n\t\tvar viewPort = [0, 0, this.canvas.width, this.canvas.height];\n\t\tthis.projected = [];\n\t\t\n\t\tvar i, coord, projected;\n\t\tfor (i = 0; i < this.points.length; i++) {\n\t\t\tcoord = this.points[i];\n\t\t\tprojected = JSM.Project (coord, this.camera.eye, this.camera.center, this.camera.up, this.camera.fieldOfView * JSM.DegRad, aspectRatio, this.camera.nearClippingPlane, this.camera.farClippingPlane, viewPort);\n\t\t\tprojected.y = this.canvas.height - projected.y;\n\t\t\tif (projected !== null) {\n\t\t\t\tthis.projected.push ({position : projected, originalIndex : i});\n\t\t\t}\n\t\t}\n\n\t\tthis.projected.sort (function (a, b) {\n\t\t\tif (a.position.z > b.position.z) {\n\t\t\t\treturn -1;\n\t\t\t} else if (a.position.z < b.position.z) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\tfor (i = 0; i < this.projected.length; i++) {\n\t\t\tif (this.callbacks.onPointDraw !== null) {\n\t\t\t\tthis.callbacks.onPointDraw (this.canvas, this.projected[i].originalIndex, this.projected[i].position);\n\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks.onDrawEnd !== null) {\n\t\t\tthis.callbacks.onDrawEnd (this.canvas);\n\t\t}\n\t\treturn true;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/viewer',[\"../core/jsm\"],function(JSM){\n\tJSM.Viewer = function ()\n\t{\n\t\tthis.camera = null;\n\t\tthis.renderer = null;\n\t\tthis.navigation = null;\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!this.InitRenderer (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitNavigation (camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.Reset = function ()\n\t{\n\t\tthis.RemoveBodies ();\n\t\tthis.RemoveLights ();\n\t\tthis.SetAmbientLight (new JSM.RenderAmbientLight (0x7f7f7f));\n\t\tthis.EnableCameraLight ();\n\t};\n\n\tJSM.Viewer.prototype.InitRenderer = function (canvas)\n\t{\n\t\tthis.renderer = new JSM.Renderer ();\n\t\tif (!this.renderer.Init (canvas)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.InitNavigation = function (camera)\n\t{\n\t\tthis.camera = JSM.ValueOrDefault (camera, new JSM.Camera ());\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.renderer.canvas, this.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.InitLights = function ()\n\t{\n\t\tthis.SetAmbientLight (new JSM.RenderAmbientLight (0x7f7f7f));\n\t\tthis.EnableCameraLight ();\n\t\treturn true;\n\t};\n\n\tJSM.Viewer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.renderer.SetClearColor (red, green, blue);\n\t};\n\n\tJSM.Viewer.prototype.EnableCameraLight = function ()\n\t{\n\t\tif (this.cameraLight !== null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cameraLight = new JSM.RenderDirectionalLight (0x7f7f7f, 0xffffff, new JSM.Vector (1.0, 0.0, 0.0));\n\t\tthis.AddLight (this.cameraLight);\n\t};\n\n\tJSM.Viewer.prototype.DisableCameraLight = function ()\n\t{\n\t\tif (this.cameraLight === null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.RemoveLight (this.cameraLight);\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.GetCameraLight = function ()\n\t{\n\t\treturn this.cameraLight;\n\t};\n\n\tJSM.Viewer.prototype.SetAmbientLight = function (light)\n\t{\n\t\tthis.renderer.SetAmbientLight (light);\n\t};\n\n\tJSM.Viewer.prototype.AddLight = function (light)\n\t{\n\t\tthis.renderer.AddLight (light);\n\t};\n\n\tJSM.Viewer.prototype.RemoveLight = function (light)\n\t{\n\t\tthis.renderer.RemoveLight (light);\n\t};\n\n\tJSM.Viewer.prototype.RemoveLights = function ()\n\t{\n\t\tthis.renderer.RemoveLights ();\n\t\tthis.cameraLight = null;\n\t};\n\n\tJSM.Viewer.prototype.AddBody = function (renderBody)\n\t{\n\t\tthis.renderer.AddBody (renderBody, this.Draw.bind (this));\n\t};\n\n\tJSM.Viewer.prototype.AddBodies = function (renderBodies)\n\t{\n\t\tthis.renderer.AddBodies (renderBodies, this.Draw.bind (this));\n\t};\n\n\tJSM.Viewer.prototype.RemoveBody = function (body)\n\t{\n\t\tthis.renderer.RemoveBody (body);\n\t};\n\n\tJSM.Viewer.prototype.RemoveBodies = function ()\n\t{\n\t\tthis.renderer.RemoveBodies ();\n\t};\n\n\tJSM.Viewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t};\n\n\tJSM.Viewer.prototype.SetFullscreen = function (fullscreen)\n\t{\n\t\tthis.navigation.SetFullscreen (fullscreen);\n\t};\n\n\tJSM.Viewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.Viewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tthis.renderer.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshes (function (mesh) {\n\t\t\t\tvar i, vertex;\n\t\t\t\tfor (i = 0; i < mesh.VertexCount (); i++) {\n\t\t\t\t\tvertex = mesh.GetTransformedVertex (i, transformation);\n\t\t\t\t\tmin.x = JSM.Minimum (min.x, vertex.x);\n\t\t\t\t\tmin.y = JSM.Minimum (min.y, vertex.y);\n\t\t\t\t\tmin.z = JSM.Minimum (min.z, vertex.z);\n\t\t\t\t\tmax.x = JSM.Maximum (max.x, vertex.x);\n\t\t\t\t\tmax.y = JSM.Maximum (max.y, vertex.y);\n\t\t\t\t\tmax.z = JSM.Maximum (max.z, vertex.z);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.Viewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tthis.renderer.EnumerateBodies (function (body) {\n\t\t\tvar transformation = body.GetTransformation ();\n\t\t\tbody.EnumerateMeshes (function (mesh) {\n\t\t\t\tvar i, vertex, distance;\n\t\t\t\tfor (i = 0; i < mesh.VertexCount (); i++) {\n\t\t\t\t\tvertex = mesh.GetTransformedVertex (i, transformation);\n\t\t\t\t\tdistance = center.DistanceTo (vertex);\n\t\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\t\tradius = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.Viewer.prototype.FindObjects = function (screenX, screenY)\n\t{\n\t\treturn this.renderer.FindObjects (this.camera, screenX, screenY);\n\t};\n\n\tJSM.Viewer.prototype.Resize = function ()\n\t{\n\t\tthis.renderer.Resize ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.Viewer.prototype.Draw = function ()\n\t{\n\t\tvar camera = this.camera;\n\t\tvar cameraLight = this.GetCameraLight ();\n\t\tif (cameraLight !== null) {\n\t\t\tcameraLight.direction = JSM.CoordSub (camera.center, camera.eye).Normalize ();\n\t\t}\n\t\tthis.renderer.Render (camera);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/viewer/pointcloudviewer',[\"../core/jsm\"],function(JSM){\n\tJSM.PointCloudViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\tthis.renderer = null;\n\t\tthis.navigation = null;\n\t};\n\n\tJSM.PointCloudViewer.prototype.Init = function (canvas, camera)\n\t{\n\t\tif (!this.InitRenderer (canvas, camera)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitNavigation ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.InitRenderer = function (canvas, camera)\n\t{\n\t\tthis.renderer = new JSM.PointCloudRenderer ();\n\t\tif (!this.renderer.Init (canvas, camera)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.InitNavigation = function ()\n\t{\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.renderer.canvas, this.renderer.camera, this.Draw.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tJSM.PointCloudViewer.prototype.SetClearColor = function (red, green, blue)\n\t{\n\t\tthis.renderer.SetClearColor (red, green, blue);\n\t};\n\n\tJSM.PointCloudViewer.prototype.SetPointSize = function (pointSize)\n\t{\n\t\tthis.renderer.SetPointSize (pointSize);\n\t};\n\n\tJSM.PointCloudViewer.prototype.AddPoints = function (points, colors)\n\t{\n\t\tthis.renderer.AddPoints (points, colors);\n\t};\n\n\tJSM.PointCloudViewer.prototype.RemovePoints = function ()\n\t{\n\t\tthis.renderer.RemovePoints ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.FitInWindow = function ()\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.Draw ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar boundingBox = this.GetBoundingBox ();\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar i, j, points, point;\n\t\tfor (i = 0; i < this.renderer.points.length; i++) {\n\t\t\tpoints = this.renderer.points[i].pointArray;\n\t\t\tfor (j = 0; j < points.length; j = j + 3) {\n\t\t\t\tpoint = new JSM.Coord (points[j], points[j + 1], points[j + 2]);\n\t\t\t\tmin.x = JSM.Minimum (min.x, point.x);\n\t\t\t\tmin.y = JSM.Minimum (min.y, point.y);\n\t\t\t\tmin.z = JSM.Minimum (min.z, point.z);\n\t\t\t\tmax.x = JSM.Maximum (max.x, point.x);\n\t\t\t\tmax.y = JSM.Maximum (max.y, point.y);\n\t\t\t\tmax.z = JSM.Maximum (max.z, point.z);\n\t\t\t}\n\t\t}\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.PointCloudViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar center = this.GetCenter ();\n\t\tvar radius = 0.0;\n\n\t\tvar i, j, points, point, distance;\n\t\tfor (i = 0; i < this.renderer.points.length; i++) {\n\t\t\tpoints = this.renderer.points[i].pointArray;\n\t\t\tfor (j = 0; j < points.length; j = j + 3) {\n\t\t\t\tpoint = new JSM.Coord (points[j], points[j + 1], points[j + 2]);\n\t\t\t\tdistance = center.DistanceTo (point);\n\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\tradius = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.PointCloudViewer.prototype.Resize = function ()\n\t{\n\t\tthis.renderer.Resize ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.PointCloudViewer.prototype.Draw = function ()\n\t{\n\t\tthis.renderer.Render ();\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/solidgenerator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSolidWithRadius\n\t* Description: Generates a special solid with the given radius.\n\t* Parameters:\n\t*\tsolidName {string} the name of the solid\n\t*\tradius {number} the radius of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSolidWithRadius = function (solidName, radius)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar equalRadius = true;\n\t\t\n\t\tif (solidName === 'Tetrahedron') {\n\t\t\tresult = JSM.GenerateTetrahedron ();\n\t\t} else if (solidName === 'Hexahedron') {\n\t\t\tresult = JSM.GenerateHexahedron ();\n\t\t} else if (solidName === 'Octahedron') {\n\t\t\tresult = JSM.GenerateOctahedron ();\n\t\t} else if (solidName === 'Dodecahedron') {\n\t\t\tresult = JSM.GenerateDodecahedron ();\n\t\t} else if (solidName === 'Icosahedron') {\n\t\t\tresult = JSM.GenerateIcosahedron ();\n\t\t} else if (solidName === 'TruncatedTetrahedron') {\n\t\t\tresult = JSM.GenerateTruncatedTetrahedron ();\n\t\t} else if (solidName === 'Cuboctahedron') {\n\t\t\tresult = JSM.GenerateCuboctahedron ();\n\t\t} else if (solidName === 'TruncatedCube') {\n\t\t\tresult = JSM.GenerateTruncatedCube ();\n\t\t} else if (solidName === 'TruncatedOctahedron') {\n\t\t\tresult = JSM.GenerateTruncatedOctahedron ();\n\t\t} else if (solidName === 'Rhombicuboctahedron') {\n\t\t\tresult = JSM.GenerateRhombicuboctahedron ();\n\t\t} else if (solidName === 'TruncatedCuboctahedron') {\n\t\t\tresult = JSM.GenerateTruncatedCuboctahedron ();\n\t\t} else if (solidName === 'SnubCube') {\n\t\t\tresult = JSM.GenerateSnubCube ();\n\t\t} else if (solidName === 'Icosidodecahedron') {\n\t\t\tresult = JSM.GenerateIcosidodecahedron ();\n\t\t} else if (solidName === 'TruncatedDodecahedron') {\n\t\t\tresult = JSM.GenerateTruncatedDodecahedron ();\n\t\t} else if (solidName === 'TruncatedIcosahedron') {\n\t\t\tresult = JSM.GenerateTruncatedIcosahedron ();\n\t\t} else if (solidName === 'Rhombicosidodecahedron') {\n\t\t\tresult = JSM.GenerateRhombicosidodecahedron ();\n\t\t} else if (solidName === 'TruncatedIcosidodecahedron') {\n\t\t\tresult = JSM.GenerateTruncatedIcosidodecahedron ();\n\t\t} else if (solidName === 'SnubDodecahedron') {\n\t\t\tresult = JSM.GenerateSnubDodecahedron ();\n\t\t} else if (solidName === 'TetrakisHexahedron') {\n\t\t\tresult = JSM.GenerateTetrakisHexahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'RhombicDodecahedron') {\n\t\t\tresult = JSM.GenerateRhombicDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'PentakisDodecahedron') {\n\t\t\tresult = JSM.GeneratePentakisDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallStellatedDodecahedron') {\n\t\t\tresult = JSM.GenerateSmallStellatedDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'GreatDodecahedron') {\n\t\t\tresult = JSM.GenerateGreatDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallTriambicIcosahedron') {\n\t\t\tresult = JSM.GenerateSmallTriambicIcosahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'GreatStellatedDodecahedron') {\n\t\t\tresult = JSM.GenerateGreatStellatedDodecahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'SmallTriakisOctahedron') {\n\t\t\tresult = JSM.GenerateSmallTriakisOctahedron ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'StellaOctangula') {\n\t\t\tresult = JSM.GenerateStellaOctangula ();\n\t\t\tequalRadius = false;\n\t\t} else if (solidName === 'TriakisTetrahedron') {\n\t\t\tresult = JSM.GenerateTriakisTetrahedron ();\n\t\t\tequalRadius = false;\n\t\t}\n\n\t\tif (result.VertexCount () > 0) {\n\t\t\tvar i;\n\t\t\n\t\t\tvar maxRadius = 0.0;\n\t\t\tif (equalRadius) {\n\t\t\t\tmaxRadius = result.GetVertexPosition (0).Length ();\n\t\t\t} else {\n\t\t\t\tvar currentRadius;\n\t\t\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\t\t\tcurrentRadius = result.GetVertexPosition (i).Length ();\n\t\t\t\t\tif (JSM.IsGreater (currentRadius, maxRadius)) {\n\t\t\t\t\t\tmaxRadius = currentRadius;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar scale = radius / maxRadius;\n\t\t\t\n\t\t\tvar vertex;\n\t\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\t\tvertex = result.GetVertex (i);\n\t\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTetrahedron\n\t* Description: Generates a tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTetrahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, +a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, -a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, +a, -a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, -a, -a)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 2, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 3, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 2, 3]));\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateHexahedron\n\t* Description: Generates a hexahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateHexahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 1, 5, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 2, 3, 1]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 7, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 5, 7, 6]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateOctahedron\n\t* Description: Generates an octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateOctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +b);\n\t\tJSM.AddVertexToBody (result, -a, +b, +b);\n\t\tJSM.AddVertexToBody (result, +b, +a, +b);\n\t\tJSM.AddVertexToBody (result, +b, -a, +b);\n\t\tJSM.AddVertexToBody (result, +b, +b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 3, 5]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 3]);\n\t\tJSM.AddPolygonToBody (result, [0, 5, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 2, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 3]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateDodecahedron\n\t* Description: Generates a dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\t\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +d, +c);\n\t\tJSM.AddVertexToBody (result, +b, +d, -c);\n\t\tJSM.AddVertexToBody (result, +b, -d, +c);\n\t\tJSM.AddVertexToBody (result, +b, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +b);\n\t\tJSM.AddVertexToBody (result, +d, -c, +b);\n\t\tJSM.AddVertexToBody (result, -d, +c, +b);\n\t\tJSM.AddVertexToBody (result, -d, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +d);\n\t\tJSM.AddVertexToBody (result, -c, +b, +d);\n\t\tJSM.AddVertexToBody (result, +c, +b, -d);\n\t\tJSM.AddVertexToBody (result, -c, +b, -d);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 10, 2, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 16, 18, 1, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 12, 14, 3, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5, 14, 12]);\n\t\tJSM.AddPolygonToBody (result, [1, 18, 4, 11, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6, 15, 13]);\n\t\tJSM.AddPolygonToBody (result, [2, 13, 4, 18, 16]);\n\t\tJSM.AddPolygonToBody (result, [3, 14, 5, 19, 17]);\n\t\tJSM.AddPolygonToBody (result, [3, 17, 6, 10, 8]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 15, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 11, 7, 19]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 19, 7, 15]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateIcosahedron\n\t* Description: Generates an icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateIcosahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 6, 10]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [0, 10, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [4, 8, 9]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 8]);\n\t\tJSM.AddPolygonToBody (result, [6, 11, 10]);\n\t\tJSM.AddPolygonToBody (result, [7, 10, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedTetrahedron\n\t* Description: Generates a truncated tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedTetrahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 3.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 7]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 6, 5, 9, 8]);\n\t\tJSM.AddPolygonToBody (result, [0, 4, 7, 11, 10, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 7, 4, 8, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 6, 10, 11, 3]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboctahedron\n\t* Description: Generates a cuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 5, 11]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 7, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 6]);\n\t\tJSM.AddPolygonToBody (result, [3, 6, 8]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 7]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 4, 1, 5]);\n\t\tJSM.AddPolygonToBody (result, [0, 11, 3, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 2, 9]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 3, 7]);\n\t\tJSM.AddPolygonToBody (result, [4, 8, 6, 10]);\n\t\tJSM.AddPolygonToBody (result, [5, 9, 7, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedCube\n\t* Description: Generates a truncated cube.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedCube = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = Math.sqrt (2.0) - 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, -b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 21, 13]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 1, 17, 21, 5, 3, 19, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 10, 2, 4, 12, 9, 1]);\n\t\tJSM.AddPolygonToBody (result, [2, 18, 22, 6, 7, 23, 20, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 5, 13, 15, 7, 6, 14, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 16, 19, 11, 14, 22, 18, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 20, 23, 15, 13, 21, 17]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedOctahedron\n\t* Description: Generates a truncated octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedOctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, +b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddVertexToBody (result, +c, +a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, -a, +b);\n\n\t\tJSM.AddPolygonToBody (result, [0, 10, 2, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 3, 11]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [5, 15, 7, 13]);\n\t\tJSM.AddPolygonToBody (result, [16, 22, 18, 20]);\n\t\tJSM.AddPolygonToBody (result, [17, 21, 19, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 4, 14, 21, 17, 10]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 16, 20, 12, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 6, 12, 20, 18, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 19, 21, 14, 6]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 13, 22, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 17, 23, 15, 5]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 15, 23, 19, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 9, 18, 22, 13, 7]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRhombicuboctahedron\n\t* Description: Generates a rhombicuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 1.0 + Math.sqrt (2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, -a, -b);\n\t\tJSM.AddVertexToBody (result, -a, +a, -b);\n\t\tJSM.AddVertexToBody (result, -a, -a, +b);\n\t\tJSM.AddVertexToBody (result, -a, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, +b, -a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, -a);\n\t\tJSM.AddVertexToBody (result, -a, +b, -a);\n\t\tJSM.AddVertexToBody (result, -a, -b, +a);\n\t\tJSM.AddVertexToBody (result, -a, -b, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, -a);\n\t\tJSM.AddVertexToBody (result, +b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\t\tJSM.AddVertexToBody (result, +b, -a, -a);\n\t\tJSM.AddVertexToBody (result, -b, +a, -a);\n\t\tJSM.AddVertexToBody (result, -b, -a, +a);\n\t\tJSM.AddVertexToBody (result, -b, -a, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 9, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 10, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 21, 13]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 18, 16]);\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [0, 8, 11, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 13, 9]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 20, 4]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 22, 6]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 15, 7]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 23, 21]);\n\t\tJSM.AddPolygonToBody (result, [8, 9, 13, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 16, 17, 9]);\n\t\tJSM.AddPolygonToBody (result, [10, 12, 20, 18]);\n\t\tJSM.AddPolygonToBody (result, [10, 14, 15, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 13, 21, 19]);\n\t\tJSM.AddPolygonToBody (result, [14, 22, 23, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 18, 20, 17]);\n\t\tJSM.AddPolygonToBody (result, [19, 21, 23, 22]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedCuboctahedron\n\t* Description: Generates a truncated cuboctahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedCuboctahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 1.0 + Math.sqrt (2.0);\n\t\tvar c = 1.0 + 2.0 * Math.sqrt (2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, +a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, +a, -b, -c);\n\t\tJSM.AddVertexToBody (result, -a, +b, -c);\n\t\tJSM.AddVertexToBody (result, -a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, -b, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, +a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, -b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, -b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\t\tJSM.AddVertexToBody (result, -b, -a, +c);\n\t\tJSM.AddVertexToBody (result, -b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, -b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, +a);\n\t\tJSM.AddVertexToBody (result, +b, -c, -a);\n\t\tJSM.AddVertexToBody (result, -b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, +c, +a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, +a, -b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, +a, -b);\n\t\tJSM.AddVertexToBody (result, -c, -a, +b);\n\t\tJSM.AddVertexToBody (result, +c, -a, -b);\n\t\tJSM.AddVertexToBody (result, -c, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, -b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, -b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\t\tJSM.AddVertexToBody (result, +c, -b, -a);\n\t\tJSM.AddVertexToBody (result, -c, -b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 11, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 13, 9]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 15, 7]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 35, 32]);\n\t\tJSM.AddPolygonToBody (result, [17, 34, 38, 21]);\n\t\tJSM.AddPolygonToBody (result, [18, 33, 37, 22]);\n\t\tJSM.AddPolygonToBody (result, [23, 39, 36, 20]);\n\t\tJSM.AddPolygonToBody (result, [24, 40, 43, 27]);\n\t\tJSM.AddPolygonToBody (result, [25, 29, 46, 42]);\n\t\tJSM.AddPolygonToBody (result, [26, 30, 45, 41]);\n\t\tJSM.AddPolygonToBody (result, [28, 44, 47, 31]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 16, 32, 40, 24, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 27, 43, 34, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 9, 25, 42, 35, 19]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 26, 41, 33, 18]);\n\t\tJSM.AddPolygonToBody (result, [4, 21, 38, 46, 29, 12]);\n\t\tJSM.AddPolygonToBody (result, [5, 20, 36, 45, 30, 14]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 37, 44, 28, 13]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 31, 47, 39, 23]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 18, 22, 6, 2, 19, 16]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 21, 4, 7, 23, 20, 5]);\n\t\tJSM.AddPolygonToBody (result, [8, 24, 27, 10, 14, 30, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [9, 13, 28, 31, 15, 12, 29, 25]);\n\t\tJSM.AddPolygonToBody (result, [32, 35, 42, 46, 38, 34, 43, 40]);\n\t\tJSM.AddPolygonToBody (result, [33, 41, 45, 36, 39, 47, 44, 37]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSnubCube\n\t* Description: Generates a snub cube.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSnubCube = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = (1.0 / 3.0) * (Math.pow (17 + 3.0 * Math.sqrt (33.0), 1.0 / 3.0) - Math.pow (-17 + 3.0 * Math.sqrt (33.0), 1.0 / 3.0) - 1.0);\n\t\tvar c = 1.0 / b;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, -c);\n\t\tJSM.AddVertexToBody (result, +a, -b, +c);\n\t\tJSM.AddVertexToBody (result, -a, +b, +c);\n\t\tJSM.AddVertexToBody (result, -a, -b, -c);\n\n\t\tJSM.AddVertexToBody (result, +b, -c, +a);\n\t\tJSM.AddVertexToBody (result, -b, +c, +a);\n\t\tJSM.AddVertexToBody (result, +b, +c, -a);\n\t\tJSM.AddVertexToBody (result, -b, -c, -a);\n\n\t\tJSM.AddVertexToBody (result, -c, +a, +b);\n\t\tJSM.AddVertexToBody (result, +c, +a, -b);\n\t\tJSM.AddVertexToBody (result, +c, -a, +b);\n\t\tJSM.AddVertexToBody (result, -c, -a, -b);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, -b);\n\t\tJSM.AddVertexToBody (result, -a, +c, -b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, -b, +a, -c);\n\t\tJSM.AddVertexToBody (result, -b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, -b, +a);\n\t\tJSM.AddVertexToBody (result, +c, -b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\tJSM.AddPolygonToBody (result, [0, 9, 22]);\n\t\tJSM.AddPolygonToBody (result, [0, 17, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 22, 19]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 20]);\n\t\tJSM.AddPolygonToBody (result, [1, 18, 4]);\n\t\tJSM.AddPolygonToBody (result, [1, 20, 16]);\n\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\tJSM.AddPolygonToBody (result, [2, 8, 21]);\n\t\tJSM.AddPolygonToBody (result, [2, 16, 5]);\n\t\tJSM.AddPolygonToBody (result, [2, 21, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\tJSM.AddPolygonToBody (result, [3, 11, 23]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 7]);\n\t\tJSM.AddPolygonToBody (result, [3, 23, 17]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 10]);\n\t\tJSM.AddPolygonToBody (result, [4, 18, 15]);\n\t\tJSM.AddPolygonToBody (result, [5, 14, 8]);\n\t\tJSM.AddPolygonToBody (result, [5, 16, 12]);\n\t\tJSM.AddPolygonToBody (result, [6, 12, 9]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 15, 11]);\n\t\tJSM.AddPolygonToBody (result, [7, 19, 13]);\n\t\tJSM.AddPolygonToBody (result, [8, 14, 23]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 20]);\n\t\tJSM.AddPolygonToBody (result, [10, 13, 22]);\n\t\tJSM.AddPolygonToBody (result, [11, 15, 21]);\n\t\tJSM.AddPolygonToBody (result, [12, 16, 20]);\n\t\tJSM.AddPolygonToBody (result, [13, 19, 22]);\n\t\tJSM.AddPolygonToBody (result, [14, 17, 23]);\n\t\tJSM.AddPolygonToBody (result, [15, 18, 21]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 19, 3, 17]);\n\t\tJSM.AddPolygonToBody (result, [1, 16, 2, 18]);\n\t\tJSM.AddPolygonToBody (result, [4, 15, 7, 13]);\n\t\tJSM.AddPolygonToBody (result, [5, 12, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [8, 23, 11, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 20, 10, 22]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateIcosidodecahedron\n\t* Description: Generates an icosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateIcosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = 1.0 / 2.0;\n\t\tvar d = b / 2.0;\n\t\tvar e = (1.0 + b) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +b);\n\t\tJSM.AddVertexToBody (result, +a, +a, -b);\n\t\tJSM.AddVertexToBody (result, +a, +b, +a);\n\t\tJSM.AddVertexToBody (result, +a, -b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +a, +a);\n\t\tJSM.AddVertexToBody (result, -b, +a, +a);\n\n\t\tJSM.AddVertexToBody (result, +c, +d, +e);\n\t\tJSM.AddVertexToBody (result, +c, +d, -e);\n\t\tJSM.AddVertexToBody (result, +c, -d, +e);\n\t\tJSM.AddVertexToBody (result, -c, +d, +e);\n\t\tJSM.AddVertexToBody (result, +c, -d, -e);\n\t\tJSM.AddVertexToBody (result, -c, +d, -e);\n\t\tJSM.AddVertexToBody (result, -c, -d, +e);\n\t\tJSM.AddVertexToBody (result, -c, -d, -e);\n\n\t\tJSM.AddVertexToBody (result, +d, +e, +c);\n\t\tJSM.AddVertexToBody (result, +d, -e, +c);\n\t\tJSM.AddVertexToBody (result, -d, +e, +c);\n\t\tJSM.AddVertexToBody (result, +d, +e, -c);\n\t\tJSM.AddVertexToBody (result, -d, -e, +c);\n\t\tJSM.AddVertexToBody (result, +d, -e, -c);\n\t\tJSM.AddVertexToBody (result, -d, +e, -c);\n\t\tJSM.AddVertexToBody (result, -d, -e, -c);\n\n\t\tJSM.AddVertexToBody (result, +e, +c, +d);\n\t\tJSM.AddVertexToBody (result, -e, +c, +d);\n\t\tJSM.AddVertexToBody (result, +e, +c, -d);\n\t\tJSM.AddVertexToBody (result, +e, -c, +d);\n\t\tJSM.AddVertexToBody (result, -e, +c, -d);\n\t\tJSM.AddVertexToBody (result, -e, -c, +d);\n\t\tJSM.AddVertexToBody (result, +e, -c, -d);\n\t\tJSM.AddVertexToBody (result, -e, -c, -d);\n\n\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\tJSM.AddPolygonToBody (result, [0, 12, 8]);\n\t\tJSM.AddPolygonToBody (result, [1, 10, 13]);\n\t\tJSM.AddPolygonToBody (result, [1, 11, 7]);\n\t\tJSM.AddPolygonToBody (result, [2, 14, 17]);\n\t\tJSM.AddPolygonToBody (result, [2, 20, 16]);\n\t\tJSM.AddPolygonToBody (result, [3, 18, 21]);\n\t\tJSM.AddPolygonToBody (result, [3, 19, 15]);\n\t\tJSM.AddPolygonToBody (result, [4, 22, 25]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 24]);\n\t\tJSM.AddPolygonToBody (result, [5, 26, 29]);\n\t\tJSM.AddPolygonToBody (result, [5, 27, 23]);\n\t\tJSM.AddPolygonToBody (result, [6, 22, 14]);\n\t\tJSM.AddPolygonToBody (result, [7, 17, 24]);\n\t\tJSM.AddPolygonToBody (result, [8, 15, 25]);\n\t\tJSM.AddPolygonToBody (result, [9, 16, 23]);\n\t\tJSM.AddPolygonToBody (result, [10, 28, 19]);\n\t\tJSM.AddPolygonToBody (result, [11, 26, 20]);\n\t\tJSM.AddPolygonToBody (result, [12, 27, 18]);\n\t\tJSM.AddPolygonToBody (result, [13, 21, 29]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 8, 25, 22, 6]);\n\t\tJSM.AddPolygonToBody (result, [0, 9, 23, 27, 12]);\n\t\tJSM.AddPolygonToBody (result, [1, 7, 24, 28, 10]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 29, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [2, 16, 9, 6, 14]);\n\t\tJSM.AddPolygonToBody (result, [2, 17, 7, 11, 20]);\n\t\tJSM.AddPolygonToBody (result, [3, 15, 8, 12, 18]);\n\t\tJSM.AddPolygonToBody (result, [3, 21, 13, 10, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 24, 17, 14, 22]);\n\t\tJSM.AddPolygonToBody (result, [4, 25, 15, 19, 28]);\n\t\tJSM.AddPolygonToBody (result, [5, 23, 16, 20, 26]);\n\t\tJSM.AddPolygonToBody (result, [5, 29, 21, 18, 27]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedDodecahedron\n\t* Description: Generates a truncated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 2.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\t\tvar e = 2.0 + c;\n\t\tvar f = 2.0 * c;\n\t\tvar g = Math.pow (c, 2.0);\n\n\t\tJSM.AddVertexToBody (result, +a, +d, +e);\n\t\tJSM.AddVertexToBody (result, +a, +d, -e);\n\t\tJSM.AddVertexToBody (result, +a, -d, +e);\n\t\tJSM.AddVertexToBody (result, +a, -d, -e);\n\n\t\tJSM.AddVertexToBody (result, +e, +a, +d);\n\t\tJSM.AddVertexToBody (result, -e, +a, +d);\n\t\tJSM.AddVertexToBody (result, +e, +a, -d);\n\t\tJSM.AddVertexToBody (result, -e, +a, -d);\n\n\t\tJSM.AddVertexToBody (result, +d, +e, +a);\n\t\tJSM.AddVertexToBody (result, +d, -e, +a);\n\t\tJSM.AddVertexToBody (result, -d, +e, +a);\n\t\tJSM.AddVertexToBody (result, -d, -e, +a);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +g);\n\t\tJSM.AddVertexToBody (result, +c, +b, -g);\n\t\tJSM.AddVertexToBody (result, +c, -b, +g);\n\t\tJSM.AddVertexToBody (result, -c, +b, +g);\n\t\tJSM.AddVertexToBody (result, +c, -b, -g);\n\t\tJSM.AddVertexToBody (result, -c, +b, -g);\n\t\tJSM.AddVertexToBody (result, -c, -b, +g);\n\t\tJSM.AddVertexToBody (result, -c, -b, -g);\n\n\t\tJSM.AddVertexToBody (result, +g, +c, +b);\n\t\tJSM.AddVertexToBody (result, +g, +c, -b);\n\t\tJSM.AddVertexToBody (result, +g, -c, +b);\n\t\tJSM.AddVertexToBody (result, -g, +c, +b);\n\t\tJSM.AddVertexToBody (result, +g, -c, -b);\n\t\tJSM.AddVertexToBody (result, -g, +c, -b);\n\t\tJSM.AddVertexToBody (result, -g, -c, +b);\n\t\tJSM.AddVertexToBody (result, -g, -c, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +g, +c);\n\t\tJSM.AddVertexToBody (result, +b, +g, -c);\n\t\tJSM.AddVertexToBody (result, +b, -g, +c);\n\t\tJSM.AddVertexToBody (result, -b, +g, +c);\n\t\tJSM.AddVertexToBody (result, +b, -g, -c);\n\t\tJSM.AddVertexToBody (result, -b, +g, -c);\n\t\tJSM.AddVertexToBody (result, -b, -g, +c);\n\t\tJSM.AddVertexToBody (result, -b, -g, -c);\n\n\t\tJSM.AddPolygonToBody (result, [0, 12, 15]);\n\t\tJSM.AddPolygonToBody (result, [1, 17, 13]);\n\t\tJSM.AddPolygonToBody (result, [2, 18, 14]);\n\t\tJSM.AddPolygonToBody (result, [3, 16, 19]);\n\t\tJSM.AddPolygonToBody (result, [4, 20, 22]);\n\t\tJSM.AddPolygonToBody (result, [5, 26, 23]);\n\t\tJSM.AddPolygonToBody (result, [6, 24, 21]);\n\t\tJSM.AddPolygonToBody (result, [7, 25, 27]);\n\t\tJSM.AddPolygonToBody (result, [8, 28, 29]);\n\t\tJSM.AddPolygonToBody (result, [9, 32, 30]);\n\t\tJSM.AddPolygonToBody (result, [10, 33, 31]);\n\t\tJSM.AddPolygonToBody (result, [11, 34, 35]);\n\t\tJSM.AddPolygonToBody (result, [36, 44, 52]);\n\t\tJSM.AddPolygonToBody (result, [37, 53, 45]);\n\t\tJSM.AddPolygonToBody (result, [38, 54, 46]);\n\t\tJSM.AddPolygonToBody (result, [39, 55, 47]);\n\t\tJSM.AddPolygonToBody (result, [40, 48, 56]);\n\t\tJSM.AddPolygonToBody (result, [41, 49, 57]);\n\t\tJSM.AddPolygonToBody (result, [42, 50, 58]);\n\t\tJSM.AddPolygonToBody (result, [43, 59, 51]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 14, 38, 46, 22, 20, 44, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 15, 39, 47, 23, 26, 50, 42, 18, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 19, 43, 51, 27, 25, 49, 41, 17]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 37, 45, 21, 24, 48, 40, 16, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 6, 21, 45, 53, 29, 28, 52, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [4, 22, 46, 54, 30, 32, 56, 48, 24, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 27, 51, 59, 35, 34, 58, 50, 26]);\n\t\tJSM.AddPolygonToBody (result, [5, 23, 47, 55, 31, 33, 57, 49, 25, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 31, 55, 39, 15, 12, 36, 52, 28]);\n\t\tJSM.AddPolygonToBody (result, [8, 29, 53, 37, 13, 17, 41, 57, 33, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 11, 35, 59, 43, 19, 16, 40, 56, 32]);\n\t\tJSM.AddPolygonToBody (result, [9, 30, 54, 38, 14, 18, 42, 58, 34, 11]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedIcosahedron\n\t* Description: Generates a truncated icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedIcosahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 1.0;\n\t\tvar c = 2.0;\n\t\tvar d = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar e = 3.0 * d;\n\t\tvar f = 1.0 + 2.0 * d;\n\t\tvar g = 2.0 + d;\n\t\tvar h = 2.0 * d;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +e);\n\t\tJSM.AddVertexToBody (result, +a, +b, -e);\n\t\tJSM.AddVertexToBody (result, +a, -b, +e);\n\t\tJSM.AddVertexToBody (result, +a, -b, -e);\n\n\t\tJSM.AddVertexToBody (result, +b, +e, +a);\n\t\tJSM.AddVertexToBody (result, +b, -e, +a);\n\t\tJSM.AddVertexToBody (result, -b, +e, +a);\n\t\tJSM.AddVertexToBody (result, -b, -e, +a);\n\n\t\tJSM.AddVertexToBody (result, +e, +a, +b);\n\t\tJSM.AddVertexToBody (result, -e, +a, +b);\n\t\tJSM.AddVertexToBody (result, +e, +a, -b);\n\t\tJSM.AddVertexToBody (result, -e, +a, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +b, +g, +h);\n\t\tJSM.AddVertexToBody (result, +b, +g, -h);\n\t\tJSM.AddVertexToBody (result, +b, -g, +h);\n\t\tJSM.AddVertexToBody (result, -b, +g, +h);\n\t\tJSM.AddVertexToBody (result, +b, -g, -h);\n\t\tJSM.AddVertexToBody (result, -b, +g, -h);\n\t\tJSM.AddVertexToBody (result, -b, -g, +h);\n\t\tJSM.AddVertexToBody (result, -b, -g, -h);\n\n\t\tJSM.AddVertexToBody (result, +g, +h, +b);\n\t\tJSM.AddVertexToBody (result, +g, -h, +b);\n\t\tJSM.AddVertexToBody (result, -g, +h, +b);\n\t\tJSM.AddVertexToBody (result, +g, +h, -b);\n\t\tJSM.AddVertexToBody (result, -g, -h, +b);\n\t\tJSM.AddVertexToBody (result, +g, -h, -b);\n\t\tJSM.AddVertexToBody (result, -g, +h, -b);\n\t\tJSM.AddVertexToBody (result, -g, -h, -b);\n\n\t\tJSM.AddVertexToBody (result, +h, +b, +g);\n\t\tJSM.AddVertexToBody (result, -h, +b, +g);\n\t\tJSM.AddVertexToBody (result, +h, +b, -g);\n\t\tJSM.AddVertexToBody (result, +h, -b, +g);\n\t\tJSM.AddVertexToBody (result, -h, +b, -g);\n\t\tJSM.AddVertexToBody (result, -h, -b, +g);\n\t\tJSM.AddVertexToBody (result, +h, -b, -g);\n\t\tJSM.AddVertexToBody (result, -h, -b, -g);\n\n\t\tJSM.AddPolygonToBody (result, [0, 28, 36, 39, 29]);\n\t\tJSM.AddPolygonToBody (result, [1, 32, 41, 37, 30]);\n\t\tJSM.AddPolygonToBody (result, [2, 33, 42, 38, 31]);\n\t\tJSM.AddPolygonToBody (result, [3, 34, 40, 43, 35]);\n\t\tJSM.AddPolygonToBody (result, [4, 12, 44, 47, 13]);\n\t\tJSM.AddPolygonToBody (result, [5, 16, 49, 45, 14]);\n\t\tJSM.AddPolygonToBody (result, [6, 17, 50, 46, 15]);\n\t\tJSM.AddPolygonToBody (result, [7, 18, 48, 51, 19]);\n\t\tJSM.AddPolygonToBody (result, [8, 20, 52, 55, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 24, 57, 53, 22]);\n\t\tJSM.AddPolygonToBody (result, [10, 25, 58, 54, 23]);\n\t\tJSM.AddPolygonToBody (result, [11, 26, 56, 59, 27]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 31, 55, 52, 28]);\n\t\tJSM.AddPolygonToBody (result, [0, 29, 53, 57, 33, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 3, 35, 59, 56, 32]);\n\t\tJSM.AddPolygonToBody (result, [1, 30, 54, 58, 34, 3]);\n\t\tJSM.AddPolygonToBody (result, [4, 6, 15, 39, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [4, 13, 37, 41, 17, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 19, 43, 40, 16]);\n\t\tJSM.AddPolygonToBody (result, [5, 14, 38, 42, 18, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 23, 47, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [8, 21, 45, 49, 25, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 11, 27, 51, 48, 24]);\n\t\tJSM.AddPolygonToBody (result, [9, 22, 46, 50, 26, 11]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 28, 52, 20, 44]);\n\t\tJSM.AddPolygonToBody (result, [13, 47, 23, 54, 30, 37]);\n\t\tJSM.AddPolygonToBody (result, [14, 45, 21, 55, 31, 38]);\n\t\tJSM.AddPolygonToBody (result, [15, 46, 22, 53, 29, 39]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 34, 58, 25, 49]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 32, 56, 26, 50]);\n\t\tJSM.AddPolygonToBody (result, [18, 42, 33, 57, 24, 48]);\n\t\tJSM.AddPolygonToBody (result, [19, 51, 27, 59, 35, 43]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRhombicosidodecahedron\n\t* Description: Generates a rhombicosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 0.0;\n\t\tvar b = 1.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = Math.pow (c, 2.0);\n\t\tvar e = Math.pow (c, 3.0);\n\t\tvar f = 2.0 * c;\n\t\tvar g = 2.0 + c;\n\n\t\tJSM.AddVertexToBody (result, +b, +b, +e);\n\t\tJSM.AddVertexToBody (result, +b, +b, -e);\n\t\tJSM.AddVertexToBody (result, +b, -b, +e);\n\t\tJSM.AddVertexToBody (result, -b, +b, +e);\n\t\tJSM.AddVertexToBody (result, +b, -b, -e);\n\t\tJSM.AddVertexToBody (result, -b, +b, -e);\n\t\tJSM.AddVertexToBody (result, -b, -b, +e);\n\t\tJSM.AddVertexToBody (result, -b, -b, -e);\n\n\t\tJSM.AddVertexToBody (result, +e, +b, +b);\n\t\tJSM.AddVertexToBody (result, +e, +b, -b);\n\t\tJSM.AddVertexToBody (result, +e, -b, +b);\n\t\tJSM.AddVertexToBody (result, -e, +b, +b);\n\t\tJSM.AddVertexToBody (result, +e, -b, -b);\n\t\tJSM.AddVertexToBody (result, -e, +b, -b);\n\t\tJSM.AddVertexToBody (result, -e, -b, +b);\n\t\tJSM.AddVertexToBody (result, -e, -b, -b);\n\n\t\tJSM.AddVertexToBody (result, +b, +e, +b);\n\t\tJSM.AddVertexToBody (result, +b, +e, -b);\n\t\tJSM.AddVertexToBody (result, +b, -e, +b);\n\t\tJSM.AddVertexToBody (result, -b, +e, +b);\n\t\tJSM.AddVertexToBody (result, +b, -e, -b);\n\t\tJSM.AddVertexToBody (result, -b, +e, -b);\n\t\tJSM.AddVertexToBody (result, -b, -e, +b);\n\t\tJSM.AddVertexToBody (result, -b, -e, -b);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, +c, -f);\n\t\tJSM.AddVertexToBody (result, +d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, +c, +f);\n\t\tJSM.AddVertexToBody (result, +d, -c, -f);\n\t\tJSM.AddVertexToBody (result, -d, +c, -f);\n\t\tJSM.AddVertexToBody (result, -d, -c, +f);\n\t\tJSM.AddVertexToBody (result, -d, -c, -f);\n\n\t\tJSM.AddVertexToBody (result, +f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, +d, -c);\n\t\tJSM.AddVertexToBody (result, +f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, +d, +c);\n\t\tJSM.AddVertexToBody (result, +f, -d, -c);\n\t\tJSM.AddVertexToBody (result, -f, +d, -c);\n\t\tJSM.AddVertexToBody (result, -f, -d, +c);\n\t\tJSM.AddVertexToBody (result, -f, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, +f, -d);\n\t\tJSM.AddVertexToBody (result, +c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, +f, +d);\n\t\tJSM.AddVertexToBody (result, +c, -f, -d);\n\t\tJSM.AddVertexToBody (result, -c, +f, -d);\n\t\tJSM.AddVertexToBody (result, -c, -f, +d);\n\t\tJSM.AddVertexToBody (result, -c, -f, -d);\n\n\t\tJSM.AddVertexToBody (result, +g, +a, +d);\n\t\tJSM.AddVertexToBody (result, +g, +a, -d);\n\t\tJSM.AddVertexToBody (result, -g, +a, +d);\n\t\tJSM.AddVertexToBody (result, -g, +a, -d);\n\n\t\tJSM.AddVertexToBody (result, +d, +g, +a);\n\t\tJSM.AddVertexToBody (result, -d, +g, +a);\n\t\tJSM.AddVertexToBody (result, +d, -g, +a);\n\t\tJSM.AddVertexToBody (result, -d, -g, +a);\n\n\t\tJSM.AddVertexToBody (result, +a, +d, +g);\n\t\tJSM.AddVertexToBody (result, +a, -d, +g);\n\t\tJSM.AddVertexToBody (result, +a, +d, -g);\n\t\tJSM.AddVertexToBody (result, +a, -d, -g);\n\n\t\tJSM.AddPolygonToBody (result, [0, 56, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 58]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 57]);\n\t\tJSM.AddPolygonToBody (result, [4, 59, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 48, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 49]);\n\t\tJSM.AddPolygonToBody (result, [11, 14, 50]);\n\t\tJSM.AddPolygonToBody (result, [13, 51, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 52, 17]);\n\t\tJSM.AddPolygonToBody (result, [18, 20, 54]);\n\t\tJSM.AddPolygonToBody (result, [19, 21, 53]);\n\t\tJSM.AddPolygonToBody (result, [22, 55, 23]);\n\t\tJSM.AddPolygonToBody (result, [24, 32, 40]);\n\t\tJSM.AddPolygonToBody (result, [25, 41, 33]);\n\t\tJSM.AddPolygonToBody (result, [26, 42, 34]);\n\t\tJSM.AddPolygonToBody (result, [27, 43, 35]);\n\t\tJSM.AddPolygonToBody (result, [28, 36, 44]);\n\t\tJSM.AddPolygonToBody (result, [29, 37, 45]);\n\t\tJSM.AddPolygonToBody (result, [30, 38, 46]);\n\t\tJSM.AddPolygonToBody (result, [31, 47, 39]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [0, 24, 40, 56]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [1, 58, 41, 25]);\n\t\tJSM.AddPolygonToBody (result, [2, 57, 42, 26]);\n\t\tJSM.AddPolygonToBody (result, [3, 56, 43, 27]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 44, 59]);\n\t\tJSM.AddPolygonToBody (result, [5, 29, 45, 58]);\n\t\tJSM.AddPolygonToBody (result, [6, 30, 46, 57]);\n\t\tJSM.AddPolygonToBody (result, [7, 59, 47, 31]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 12, 9]);\n\t\tJSM.AddPolygonToBody (result, [8, 32, 24, 48]);\n\t\tJSM.AddPolygonToBody (result, [9, 49, 25, 33]);\n\t\tJSM.AddPolygonToBody (result, [10, 48, 26, 34]);\n\t\tJSM.AddPolygonToBody (result, [11, 13, 15, 14]);\n\t\tJSM.AddPolygonToBody (result, [11, 50, 27, 35]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 28, 49]);\n\t\tJSM.AddPolygonToBody (result, [13, 37, 29, 51]);\n\t\tJSM.AddPolygonToBody (result, [14, 38, 30, 50]);\n\t\tJSM.AddPolygonToBody (result, [15, 51, 31, 39]);\n\t\tJSM.AddPolygonToBody (result, [16, 17, 21, 19]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 32, 52]);\n\t\tJSM.AddPolygonToBody (result, [17, 52, 33, 41]);\n\t\tJSM.AddPolygonToBody (result, [18, 22, 23, 20]);\n\t\tJSM.AddPolygonToBody (result, [18, 54, 34, 42]);\n\t\tJSM.AddPolygonToBody (result, [19, 53, 35, 43]);\n\t\tJSM.AddPolygonToBody (result, [20, 44, 36, 54]);\n\t\tJSM.AddPolygonToBody (result, [21, 45, 37, 53]);\n\t\tJSM.AddPolygonToBody (result, [22, 46, 38, 55]);\n\t\tJSM.AddPolygonToBody (result, [23, 55, 39, 47]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 26, 48, 24]);\n\t\tJSM.AddPolygonToBody (result, [1, 25, 49, 28, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 27, 50, 30, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 31, 51, 29]);\n\t\tJSM.AddPolygonToBody (result, [8, 9, 33, 52, 32]);\n\t\tJSM.AddPolygonToBody (result, [10, 34, 54, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 35, 53, 37, 13]);\n\t\tJSM.AddPolygonToBody (result, [14, 15, 39, 55, 38]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 43, 56, 40]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 58, 45, 21]);\n\t\tJSM.AddPolygonToBody (result, [18, 42, 57, 46, 22]);\n\t\tJSM.AddPolygonToBody (result, [20, 23, 47, 59, 44]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTruncatedIcosidodecahedron\n\t* Description: Generates a truncated icosidodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTruncatedIcosidodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 2.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = 1.0 / b;\n\t\tvar d = 3.0 + b;\n\t\tvar e = 2.0 / b;\n\t\tvar f = 1 + 2.0 * b;\n\t\tvar g = Math.pow (b, 2.0);\n\t\tvar h = -1.0 + 3.0 * b;\n\t\tvar i = -1.0 + 2.0 * b;\n\t\tvar j = 2.0 + b;\n\t\tvar k = 3.0;\n\t\tvar l = 2.0 * b;\n\n\t\tJSM.AddVertexToBody (result, +c, +c, +d);\n\t\tJSM.AddVertexToBody (result, +c, +c, -d);\n\t\tJSM.AddVertexToBody (result, +c, -c, +d);\n\t\tJSM.AddVertexToBody (result, -c, +c, +d);\n\t\tJSM.AddVertexToBody (result, +c, -c, -d);\n\t\tJSM.AddVertexToBody (result, -c, +c, -d);\n\t\tJSM.AddVertexToBody (result, -c, -c, +d);\n\t\tJSM.AddVertexToBody (result, -c, -c, -d);\n\n\t\tJSM.AddVertexToBody (result, +c, +d, +c);\n\t\tJSM.AddVertexToBody (result, +c, -d, +c);\n\t\tJSM.AddVertexToBody (result, -c, +d, +c);\n\t\tJSM.AddVertexToBody (result, +c, +d, -c);\n\t\tJSM.AddVertexToBody (result, -c, -d, +c);\n\t\tJSM.AddVertexToBody (result, +c, -d, -c);\n\t\tJSM.AddVertexToBody (result, -c, +d, -c);\n\t\tJSM.AddVertexToBody (result, -c, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +c);\n\t\tJSM.AddVertexToBody (result, -d, +c, +c);\n\t\tJSM.AddVertexToBody (result, +d, +c, -c);\n\t\tJSM.AddVertexToBody (result, +d, -c, +c);\n\t\tJSM.AddVertexToBody (result, -d, +c, -c);\n\t\tJSM.AddVertexToBody (result, -d, -c, +c);\n\t\tJSM.AddVertexToBody (result, +d, -c, -c);\n\t\tJSM.AddVertexToBody (result, -d, -c, -c);\n\n\t\tJSM.AddVertexToBody (result, +e, +b, +f);\n\t\tJSM.AddVertexToBody (result, +e, +b, -f);\n\t\tJSM.AddVertexToBody (result, +e, -b, +f);\n\t\tJSM.AddVertexToBody (result, -e, +b, +f);\n\t\tJSM.AddVertexToBody (result, +e, -b, -f);\n\t\tJSM.AddVertexToBody (result, -e, +b, -f);\n\t\tJSM.AddVertexToBody (result, -e, -b, +f);\n\t\tJSM.AddVertexToBody (result, -e, -b, -f);\n\n\t\tJSM.AddVertexToBody (result, +b, +f, +e);\n\t\tJSM.AddVertexToBody (result, +b, -f, +e);\n\t\tJSM.AddVertexToBody (result, -b, +f, +e);\n\t\tJSM.AddVertexToBody (result, +b, +f, -e);\n\t\tJSM.AddVertexToBody (result, -b, -f, +e);\n\t\tJSM.AddVertexToBody (result, +b, -f, -e);\n\t\tJSM.AddVertexToBody (result, -b, +f, -e);\n\t\tJSM.AddVertexToBody (result, -b, -f, -e);\n\n\t\tJSM.AddVertexToBody (result, +f, +e, +b);\n\t\tJSM.AddVertexToBody (result, -f, +e, +b);\n\t\tJSM.AddVertexToBody (result, +f, +e, -b);\n\t\tJSM.AddVertexToBody (result, +f, -e, +b);\n\t\tJSM.AddVertexToBody (result, -f, +e, -b);\n\t\tJSM.AddVertexToBody (result, -f, -e, +b);\n\t\tJSM.AddVertexToBody (result, +f, -e, -b);\n\t\tJSM.AddVertexToBody (result, -f, -e, -b);\n\n\t\tJSM.AddVertexToBody (result, +c, +g, +h);\n\t\tJSM.AddVertexToBody (result, +c, +g, -h);\n\t\tJSM.AddVertexToBody (result, +c, -g, +h);\n\t\tJSM.AddVertexToBody (result, -c, +g, +h);\n\t\tJSM.AddVertexToBody (result, +c, -g, -h);\n\t\tJSM.AddVertexToBody (result, -c, +g, -h);\n\t\tJSM.AddVertexToBody (result, -c, -g, +h);\n\t\tJSM.AddVertexToBody (result, -c, -g, -h);\n\n\t\tJSM.AddVertexToBody (result, +g, +h, +c);\n\t\tJSM.AddVertexToBody (result, +g, -h, +c);\n\t\tJSM.AddVertexToBody (result, -g, +h, +c);\n\t\tJSM.AddVertexToBody (result, +g, +h, -c);\n\t\tJSM.AddVertexToBody (result, -g, -h, +c);\n\t\tJSM.AddVertexToBody (result, +g, -h, -c);\n\t\tJSM.AddVertexToBody (result, -g, +h, -c);\n\t\tJSM.AddVertexToBody (result, -g, -h, -c);\n\n\t\tJSM.AddVertexToBody (result, +h, +c, +g);\n\t\tJSM.AddVertexToBody (result, -h, +c, +g);\n\t\tJSM.AddVertexToBody (result, +h, +c, -g);\n\t\tJSM.AddVertexToBody (result, +h, -c, +g);\n\t\tJSM.AddVertexToBody (result, -h, +c, -g);\n\t\tJSM.AddVertexToBody (result, -h, -c, +g);\n\t\tJSM.AddVertexToBody (result, +h, -c, -g);\n\t\tJSM.AddVertexToBody (result, -h, -c, -g);\n\n\t\tJSM.AddVertexToBody (result, +i, +a, +j);\n\t\tJSM.AddVertexToBody (result, +i, +a, -j);\n\t\tJSM.AddVertexToBody (result, +i, -a, +j);\n\t\tJSM.AddVertexToBody (result, -i, +a, +j);\n\t\tJSM.AddVertexToBody (result, +i, -a, -j);\n\t\tJSM.AddVertexToBody (result, -i, +a, -j);\n\t\tJSM.AddVertexToBody (result, -i, -a, +j);\n\t\tJSM.AddVertexToBody (result, -i, -a, -j);\n\n\t\tJSM.AddVertexToBody (result, +a, +j, +i);\n\t\tJSM.AddVertexToBody (result, +a, -j, +i);\n\t\tJSM.AddVertexToBody (result, -a, +j, +i);\n\t\tJSM.AddVertexToBody (result, +a, +j, -i);\n\t\tJSM.AddVertexToBody (result, -a, -j, +i);\n\t\tJSM.AddVertexToBody (result, +a, -j, -i);\n\t\tJSM.AddVertexToBody (result, -a, +j, -i);\n\t\tJSM.AddVertexToBody (result, -a, -j, -i);\n\n\t\tJSM.AddVertexToBody (result, +j, +i, +a);\n\t\tJSM.AddVertexToBody (result, -j, +i, +a);\n\t\tJSM.AddVertexToBody (result, +j, +i, -a);\n\t\tJSM.AddVertexToBody (result, +j, -i, +a);\n\t\tJSM.AddVertexToBody (result, -j, +i, -a);\n\t\tJSM.AddVertexToBody (result, -j, -i, +a);\n\t\tJSM.AddVertexToBody (result, +j, -i, -a);\n\t\tJSM.AddVertexToBody (result, -j, -i, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +k, +l);\n\t\tJSM.AddVertexToBody (result, +b, +k, -l);\n\t\tJSM.AddVertexToBody (result, +b, -k, +l);\n\t\tJSM.AddVertexToBody (result, -b, +k, +l);\n\t\tJSM.AddVertexToBody (result, +b, -k, -l);\n\t\tJSM.AddVertexToBody (result, -b, +k, -l);\n\t\tJSM.AddVertexToBody (result, -b, -k, +l);\n\t\tJSM.AddVertexToBody (result, -b, -k, -l);\n\n\t\tJSM.AddVertexToBody (result, +k, +l, +b);\n\t\tJSM.AddVertexToBody (result, +k, -l, +b);\n\t\tJSM.AddVertexToBody (result, -k, +l, +b);\n\t\tJSM.AddVertexToBody (result, +k, +l, -b);\n\t\tJSM.AddVertexToBody (result, -k, -l, +b);\n\t\tJSM.AddVertexToBody (result, +k, -l, -b);\n\t\tJSM.AddVertexToBody (result, -k, +l, -b);\n\t\tJSM.AddVertexToBody (result, -k, -l, -b);\n\n\t\tJSM.AddVertexToBody (result, +l, +b, +k);\n\t\tJSM.AddVertexToBody (result, -l, +b, +k);\n\t\tJSM.AddVertexToBody (result, +l, +b, -k);\n\t\tJSM.AddVertexToBody (result, +l, -b, +k);\n\t\tJSM.AddVertexToBody (result, -l, +b, -k);\n\t\tJSM.AddVertexToBody (result, -l, -b, +k);\n\t\tJSM.AddVertexToBody (result, +l, -b, -k);\n\t\tJSM.AddVertexToBody (result, -l, -b, -k);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 6, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 4, 7, 5]);\n\t\tJSM.AddPolygonToBody (result, [8, 11, 14, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 12, 15, 13]);\n\t\tJSM.AddPolygonToBody (result, [16, 19, 22, 18]);\n\t\tJSM.AddPolygonToBody (result, [17, 20, 23, 21]);\n\t\tJSM.AddPolygonToBody (result, [24, 72, 96, 48]);\n\t\tJSM.AddPolygonToBody (result, [25, 49, 97, 73]);\n\t\tJSM.AddPolygonToBody (result, [26, 50, 98, 74]);\n\t\tJSM.AddPolygonToBody (result, [27, 51, 99, 75]);\n\t\tJSM.AddPolygonToBody (result, [28, 76, 100, 52]);\n\t\tJSM.AddPolygonToBody (result, [29, 77, 101, 53]);\n\t\tJSM.AddPolygonToBody (result, [30, 78, 102, 54]);\n\t\tJSM.AddPolygonToBody (result, [31, 55, 103, 79]);\n\t\tJSM.AddPolygonToBody (result, [32, 80, 104, 56]);\n\t\tJSM.AddPolygonToBody (result, [33, 57, 105, 81]);\n\t\tJSM.AddPolygonToBody (result, [34, 58, 106, 82]);\n\t\tJSM.AddPolygonToBody (result, [35, 59, 107, 83]);\n\t\tJSM.AddPolygonToBody (result, [36, 84, 108, 60]);\n\t\tJSM.AddPolygonToBody (result, [37, 85, 109, 61]);\n\t\tJSM.AddPolygonToBody (result, [38, 86, 110, 62]);\n\t\tJSM.AddPolygonToBody (result, [39, 63, 111, 87]);\n\t\tJSM.AddPolygonToBody (result, [40, 88, 112, 64]);\n\t\tJSM.AddPolygonToBody (result, [41, 65, 113, 89]);\n\t\tJSM.AddPolygonToBody (result, [42, 66, 114, 90]);\n\t\tJSM.AddPolygonToBody (result, [43, 67, 115, 91]);\n\t\tJSM.AddPolygonToBody (result, [44, 92, 116, 68]);\n\t\tJSM.AddPolygonToBody (result, [45, 93, 117, 69]);\n\t\tJSM.AddPolygonToBody (result, [46, 94, 118, 70]);\n\t\tJSM.AddPolygonToBody (result, [47, 71, 119, 95]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 24, 48, 51, 27, 3]);\n\t\tJSM.AddPolygonToBody (result, [1, 5, 29, 53, 49, 25]);\n\t\tJSM.AddPolygonToBody (result, [2, 6, 30, 54, 50, 26]);\n\t\tJSM.AddPolygonToBody (result, [4, 28, 52, 55, 31, 7]);\n\t\tJSM.AddPolygonToBody (result, [8, 32, 56, 59, 35, 11]);\n\t\tJSM.AddPolygonToBody (result, [9, 13, 37, 61, 57, 33]);\n\t\tJSM.AddPolygonToBody (result, [10, 14, 38, 62, 58, 34]);\n\t\tJSM.AddPolygonToBody (result, [12, 36, 60, 63, 39, 15]);\n\t\tJSM.AddPolygonToBody (result, [16, 40, 64, 67, 43, 19]);\n\t\tJSM.AddPolygonToBody (result, [17, 21, 45, 69, 65, 41]);\n\t\tJSM.AddPolygonToBody (result, [18, 22, 46, 70, 66, 42]);\n\t\tJSM.AddPolygonToBody (result, [20, 44, 68, 71, 47, 23]);\n\t\tJSM.AddPolygonToBody (result, [72, 112, 88, 104, 80, 96]);\n\t\tJSM.AddPolygonToBody (result, [73, 97, 83, 107, 90, 114]);\n\t\tJSM.AddPolygonToBody (result, [74, 98, 81, 105, 91, 115]);\n\t\tJSM.AddPolygonToBody (result, [75, 99, 82, 106, 89, 113]);\n\t\tJSM.AddPolygonToBody (result, [76, 118, 94, 109, 85, 100]);\n\t\tJSM.AddPolygonToBody (result, [78, 117, 93, 108, 84, 102]);\n\t\tJSM.AddPolygonToBody (result, [79, 103, 87, 111, 95, 119]);\n\t\tJSM.AddPolygonToBody (result, [86, 101, 77, 116, 92, 110]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 2, 26, 74, 115, 67, 64, 112, 72, 24]);\n\t\tJSM.AddPolygonToBody (result, [1, 25, 73, 114, 66, 70, 118, 76, 28, 4]);\n\t\tJSM.AddPolygonToBody (result, [3, 27, 75, 113, 65, 69, 117, 78, 30, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 7, 31, 79, 119, 71, 68, 116, 77, 29]);\n\t\tJSM.AddPolygonToBody (result, [8, 10, 34, 82, 99, 51, 48, 96, 80, 32]);\n\t\tJSM.AddPolygonToBody (result, [9, 33, 81, 98, 50, 54, 102, 84, 36, 12]);\n\t\tJSM.AddPolygonToBody (result, [11, 35, 83, 97, 49, 53, 101, 86, 38, 14]);\n\t\tJSM.AddPolygonToBody (result, [13, 15, 39, 87, 103, 55, 52, 100, 85, 37]);\n\t\tJSM.AddPolygonToBody (result, [16, 18, 42, 90, 107, 59, 56, 104, 88, 40]);\n\t\tJSM.AddPolygonToBody (result, [17, 41, 89, 106, 58, 62, 110, 92, 44, 20]);\n\t\tJSM.AddPolygonToBody (result, [19, 43, 91, 105, 57, 61, 109, 94, 46, 22]);\n\t\tJSM.AddPolygonToBody (result, [21, 23, 47, 95, 111, 63, 60, 108, 93, 45]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSnubDodecahedron\n\t* Description: Generates a snub dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSnubDodecahedron = function ()\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 2.0;\n\t\tvar b = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar c = Math.pow (b / 2.0 + (1.0 / 2.0) * Math.sqrt (b - (5.0 / 27.0)), 1.0 / 3.0) + Math.pow (b / 2.0 - (1.0 / 2.0) * Math.sqrt (b - (5.0 / 27.0)), 1.0 / 3.0);\n\t\tvar d = c - (1.0 / c);\n\t\tvar e = c * b + Math.pow (b, 2.0) + b / c;\n\t\tvar f = 2.0 * d;\n\t\tvar g = 2.0 * e;\n\t\tvar h = d + (e / b) + b;\n\t\tvar i = -(d * b) + e + (1.0 / b);\n\t\tvar j = (d / b) + (e * b) - 1.0;\n\t\tvar k = -(d / b) + (e * b) + 1.0;\n\t\tvar l = -d + (e / b) - b;\n\t\tvar m = (d * b) + e - (1.0 / b);\n\t\tvar n = -(d / b) + (e * b) - 1.0;\n\t\tvar o = d - (e / b) - b;\n\t\tvar p = (d * b) + e + (1.0 / b);\n\t\tvar q = d + (e / b) - b;\n\t\tvar r = (d * b) - e + (1.0 / b);\n\t\tvar s = (d / b) + (e * b) + 1.0;\n\n\t\tJSM.AddVertexToBody (result, +f, +a, -g);\n\t\tJSM.AddVertexToBody (result, +f, -a, +g);\n\t\tJSM.AddVertexToBody (result, -f, +a, +g);\n\t\tJSM.AddVertexToBody (result, -f, -a, -g);\n\n\t\tJSM.AddVertexToBody (result, +a, -g, +f);\n\t\tJSM.AddVertexToBody (result, -a, +g, +f);\n\t\tJSM.AddVertexToBody (result, +a, +g, -f);\n\t\tJSM.AddVertexToBody (result, -a, -g, -f);\n\n\t\tJSM.AddVertexToBody (result, -g, +f, +a);\n\t\tJSM.AddVertexToBody (result, +g, +f, -a);\n\t\tJSM.AddVertexToBody (result, +g, -f, +a);\n\t\tJSM.AddVertexToBody (result, -g, -f, -a);\n\n\t\tJSM.AddVertexToBody (result, +h, +i, -j);\n\t\tJSM.AddVertexToBody (result, +h, -i, +j);\n\t\tJSM.AddVertexToBody (result, -h, +i, +j);\n\t\tJSM.AddVertexToBody (result, -h, -i, -j);\n\n\t\tJSM.AddVertexToBody (result, +i, -j, +h);\n\t\tJSM.AddVertexToBody (result, -i, +j, +h);\n\t\tJSM.AddVertexToBody (result, +i, +j, -h);\n\t\tJSM.AddVertexToBody (result, -i, -j, -h);\n\n\t\tJSM.AddVertexToBody (result, -j, +h, +i);\n\t\tJSM.AddVertexToBody (result, +j, +h, -i);\n\t\tJSM.AddVertexToBody (result, +j, -h, +i);\n\t\tJSM.AddVertexToBody (result, -j, -h, -i);\n\n\t\tJSM.AddVertexToBody (result, +k, +l, -m);\n\t\tJSM.AddVertexToBody (result, +k, -l, +m);\n\t\tJSM.AddVertexToBody (result, -k, +l, +m);\n\t\tJSM.AddVertexToBody (result, -k, -l, -m);\n\n\t\tJSM.AddVertexToBody (result, +l, -m, +k);\n\t\tJSM.AddVertexToBody (result, -l, +m, +k);\n\t\tJSM.AddVertexToBody (result, +l, +m, -k);\n\t\tJSM.AddVertexToBody (result, -l, -m, -k);\n\n\t\tJSM.AddVertexToBody (result, -m, +k, +l);\n\t\tJSM.AddVertexToBody (result, +m, +k, -l);\n\t\tJSM.AddVertexToBody (result, +m, -k, +l);\n\t\tJSM.AddVertexToBody (result, -m, -k, -l);\n\n\t\tJSM.AddVertexToBody (result, +n, +o, -p);\n\t\tJSM.AddVertexToBody (result, +n, -o, +p);\n\t\tJSM.AddVertexToBody (result, -n, +o, +p);\n\t\tJSM.AddVertexToBody (result, -n, -o, -p);\n\n\t\tJSM.AddVertexToBody (result, +o, -p, +n);\n\t\tJSM.AddVertexToBody (result, -o, +p, +n);\n\t\tJSM.AddVertexToBody (result, +o, +p, -n);\n\t\tJSM.AddVertexToBody (result, -o, -p, -n);\n\n\t\tJSM.AddVertexToBody (result, -p, +n, +o);\n\t\tJSM.AddVertexToBody (result, +p, +n, -o);\n\t\tJSM.AddVertexToBody (result, +p, -n, +o);\n\t\tJSM.AddVertexToBody (result, -p, -n, -o);\n\n\t\tJSM.AddVertexToBody (result, +q, +r, -s);\n\t\tJSM.AddVertexToBody (result, +q, -r, +s);\n\t\tJSM.AddVertexToBody (result, -q, +r, +s);\n\t\tJSM.AddVertexToBody (result, -q, -r, -s);\n\n\t\tJSM.AddVertexToBody (result, +r, -s, +q);\n\t\tJSM.AddVertexToBody (result, -r, +s, +q);\n\t\tJSM.AddVertexToBody (result, +r, +s, -q);\n\t\tJSM.AddVertexToBody (result, -r, -s, -q);\n\n\t\tJSM.AddVertexToBody (result, -s, +q, +r);\n\t\tJSM.AddVertexToBody (result, +s, +q, -r);\n\t\tJSM.AddVertexToBody (result, +s, -q, +r);\n\t\tJSM.AddVertexToBody (result, -s, -q, -r);\n\n\t\tJSM.AddPolygonToBody (result, [0, 3, 51]);\n\t\tJSM.AddPolygonToBody (result, [0, 30, 12]);\n\t\tJSM.AddPolygonToBody (result, [0, 48, 3]);\n\t\tJSM.AddPolygonToBody (result, [0, 51, 30]);\n\t\tJSM.AddPolygonToBody (result, [1, 2, 50]);\n\t\tJSM.AddPolygonToBody (result, [1, 28, 13]);\n\t\tJSM.AddPolygonToBody (result, [1, 49, 2]);\n\t\tJSM.AddPolygonToBody (result, [1, 50, 28]);\n\t\tJSM.AddPolygonToBody (result, [2, 29, 14]);\n\t\tJSM.AddPolygonToBody (result, [2, 49, 29]);\n\t\tJSM.AddPolygonToBody (result, [3, 31, 15]);\n\t\tJSM.AddPolygonToBody (result, [3, 48, 31]);\n\t\tJSM.AddPolygonToBody (result, [4, 7, 55]);\n\t\tJSM.AddPolygonToBody (result, [4, 34, 16]);\n\t\tJSM.AddPolygonToBody (result, [4, 52, 7]);\n\t\tJSM.AddPolygonToBody (result, [4, 55, 34]);\n\t\tJSM.AddPolygonToBody (result, [5, 6, 54]);\n\t\tJSM.AddPolygonToBody (result, [5, 32, 17]);\n\t\tJSM.AddPolygonToBody (result, [5, 53, 6]);\n\t\tJSM.AddPolygonToBody (result, [5, 54, 32]);\n\t\tJSM.AddPolygonToBody (result, [6, 33, 18]);\n\t\tJSM.AddPolygonToBody (result, [6, 53, 33]);\n\t\tJSM.AddPolygonToBody (result, [7, 35, 19]);\n\t\tJSM.AddPolygonToBody (result, [7, 52, 35]);\n\t\tJSM.AddPolygonToBody (result, [8, 11, 59]);\n\t\tJSM.AddPolygonToBody (result, [8, 26, 20]);\n\t\tJSM.AddPolygonToBody (result, [8, 56, 11]);\n\t\tJSM.AddPolygonToBody (result, [8, 59, 26]);\n\t\tJSM.AddPolygonToBody (result, [9, 10, 58]);\n\t\tJSM.AddPolygonToBody (result, [9, 24, 21]);\n\t\tJSM.AddPolygonToBody (result, [9, 57, 10]);\n\t\tJSM.AddPolygonToBody (result, [9, 58, 24]);\n\t\tJSM.AddPolygonToBody (result, [10, 25, 22]);\n\t\tJSM.AddPolygonToBody (result, [10, 57, 25]);\n\t\tJSM.AddPolygonToBody (result, [11, 27, 23]);\n\t\tJSM.AddPolygonToBody (result, [11, 56, 27]);\n\t\tJSM.AddPolygonToBody (result, [12, 18, 21]);\n\t\tJSM.AddPolygonToBody (result, [12, 21, 24]);\n\t\tJSM.AddPolygonToBody (result, [12, 30, 18]);\n\t\tJSM.AddPolygonToBody (result, [13, 16, 22]);\n\t\tJSM.AddPolygonToBody (result, [13, 22, 25]);\n\t\tJSM.AddPolygonToBody (result, [13, 28, 16]);\n\t\tJSM.AddPolygonToBody (result, [14, 17, 20]);\n\t\tJSM.AddPolygonToBody (result, [14, 20, 26]);\n\t\tJSM.AddPolygonToBody (result, [14, 29, 17]);\n\t\tJSM.AddPolygonToBody (result, [15, 19, 23]);\n\t\tJSM.AddPolygonToBody (result, [15, 23, 27]);\n\t\tJSM.AddPolygonToBody (result, [15, 31, 19]);\n\t\tJSM.AddPolygonToBody (result, [16, 34, 22]);\n\t\tJSM.AddPolygonToBody (result, [17, 32, 20]);\n\t\tJSM.AddPolygonToBody (result, [18, 33, 21]);\n\t\tJSM.AddPolygonToBody (result, [19, 35, 23]);\n\t\tJSM.AddPolygonToBody (result, [24, 58, 36]);\n\t\tJSM.AddPolygonToBody (result, [25, 57, 37]);\n\t\tJSM.AddPolygonToBody (result, [26, 59, 38]);\n\t\tJSM.AddPolygonToBody (result, [27, 56, 39]);\n\t\tJSM.AddPolygonToBody (result, [28, 50, 40]);\n\t\tJSM.AddPolygonToBody (result, [29, 49, 41]);\n\t\tJSM.AddPolygonToBody (result, [30, 51, 42]);\n\t\tJSM.AddPolygonToBody (result, [31, 48, 43]);\n\t\tJSM.AddPolygonToBody (result, [32, 54, 44]);\n\t\tJSM.AddPolygonToBody (result, [33, 53, 45]);\n\t\tJSM.AddPolygonToBody (result, [34, 55, 46]);\n\t\tJSM.AddPolygonToBody (result, [35, 52, 47]);\n\t\tJSM.AddPolygonToBody (result, [36, 43, 48]);\n\t\tJSM.AddPolygonToBody (result, [36, 46, 43]);\n\t\tJSM.AddPolygonToBody (result, [36, 58, 46]);\n\t\tJSM.AddPolygonToBody (result, [37, 41, 49]);\n\t\tJSM.AddPolygonToBody (result, [37, 45, 41]);\n\t\tJSM.AddPolygonToBody (result, [37, 57, 45]);\n\t\tJSM.AddPolygonToBody (result, [38, 40, 50]);\n\t\tJSM.AddPolygonToBody (result, [38, 47, 40]);\n\t\tJSM.AddPolygonToBody (result, [38, 59, 47]);\n\t\tJSM.AddPolygonToBody (result, [39, 42, 51]);\n\t\tJSM.AddPolygonToBody (result, [39, 44, 42]);\n\t\tJSM.AddPolygonToBody (result, [39, 56, 44]);\n\t\tJSM.AddPolygonToBody (result, [40, 47, 52]);\n\t\tJSM.AddPolygonToBody (result, [41, 45, 53]);\n\t\tJSM.AddPolygonToBody (result, [42, 44, 54]);\n\t\tJSM.AddPolygonToBody (result, [43, 46, 55]);\n\n\t\tJSM.AddPolygonToBody (result, [0, 12, 24, 36, 48]);\n\t\tJSM.AddPolygonToBody (result, [1, 13, 25, 37, 49]);\n\t\tJSM.AddPolygonToBody (result, [2, 14, 26, 38, 50]);\n\t\tJSM.AddPolygonToBody (result, [3, 15, 27, 39, 51]);\n\t\tJSM.AddPolygonToBody (result, [4, 16, 28, 40, 52]);\n\t\tJSM.AddPolygonToBody (result, [5, 17, 29, 41, 53]);\n\t\tJSM.AddPolygonToBody (result, [6, 18, 30, 42, 54]);\n\t\tJSM.AddPolygonToBody (result, [7, 19, 31, 43, 55]);\n\t\tJSM.AddPolygonToBody (result, [8, 20, 32, 44, 56]);\n\t\tJSM.AddPolygonToBody (result, [9, 21, 33, 45, 57]);\n\t\tJSM.AddPolygonToBody (result, [10, 22, 34, 46, 58]);\n\t\tJSM.AddPolygonToBody (result, [11, 23, 35, 47, 59]);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: AddCumulatedPolygonToBody\n\t* Description: Adds polygons to a body by cumulating the original polygons vertex index array.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} the vertices of the original polygon\n\t*\theight {number} the height of the cumulation\n\t*/\n\tJSM.AddCumulatedPolygonToBody = function (body, vertices, height)\n\t{\n\t\tfunction CalculatePolygonCentroidAndNormal (vertices, centroidCoord, normalVector)\n\t\t{\n\t\t\tvar vertexCoords = [];\n\t\t\t\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\t\tvertexCoords.push (body.GetVertexPosition (vertices[i]));\n\t\t\t}\n\t\t\t\n\t\t\tvar centroid = JSM.CalculateCentroid (vertexCoords);\n\t\t\tvar normal = JSM.CalculateNormal (vertexCoords);\n\n\t\t\tcentroidCoord.Set (centroid.x, centroid.y, centroid.z);\n\t\t\tnormalVector.Set (normal.x, normal.y, normal.z);\n\t\t}\n\n\t\tvar centroidCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar normalVector = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tCalculatePolygonCentroidAndNormal (vertices, centroidCoord, normalVector);\n\t\tcentroidCoord.Offset (normalVector, height);\n\t\t\n\t\tvar centroid = body.VertexCount ();\n\t\tJSM.AddVertexToBody (body, centroidCoord.x, centroidCoord.y, centroidCoord.z);\n\n\t\tvar count = vertices.length;\n\n\t\tvar i, curr, next;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = vertices[i];\n\t\t\tnext = vertices [i < count - 1 ? i + 1 : 0];\n\t\t\tJSM.AddPolygonToBody (body, [curr, next, centroid]);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedTetrahedron\n\t* Description: Generates a cumulated tetrahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedTetrahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, +a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, -a, +a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-a, +a, -a)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (+a, -a, -a)));\n\n\t\tvar edgeLength = 2.0 * Math.sqrt (2.0);\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 1, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 1], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 2, 3], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedHexahedron\n\t* Description: Generates a cumulated hexahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedHexahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tvar edgeLength = 2.0;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 1, 5, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 4, 1], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 6, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 7, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 6, 7, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 5, 7, 6], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedOctahedron\n\t* Description: Generates a cumulated octahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedOctahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\n\t\tJSM.AddVertexToBody (result, +a, +b, +b);\n\t\tJSM.AddVertexToBody (result, -a, +b, +b);\n\t\tJSM.AddVertexToBody (result, +b, +a, +b);\n\t\tJSM.AddVertexToBody (result, +b, -a, +b);\n\t\tJSM.AddVertexToBody (result, +b, +b, +a);\n\t\tJSM.AddVertexToBody (result, +b, +b, -a);\n\n\t\tvar edgeLength = Math.sqrt (2.0);\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 3, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 4, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 5, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 2, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 3, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 5, 3], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedDodecahedron\n\t* Description: Generates a cumulated dodecahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedDodecahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\t\tvar d = 1.0 / c;\n\n\t\tJSM.AddVertexToBody (result, +a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, +a, -a);\n\t\tJSM.AddVertexToBody (result, +a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, +a, +a);\n\t\tJSM.AddVertexToBody (result, +a, -a, -a);\n\t\tJSM.AddVertexToBody (result, -a, +a, -a);\n\t\tJSM.AddVertexToBody (result, -a, -a, +a);\n\t\tJSM.AddVertexToBody (result, -a, -a, -a);\n\n\t\tJSM.AddVertexToBody (result, +b, +d, +c);\n\t\tJSM.AddVertexToBody (result, +b, +d, -c);\n\t\tJSM.AddVertexToBody (result, +b, -d, +c);\n\t\tJSM.AddVertexToBody (result, +b, -d, -c);\n\n\t\tJSM.AddVertexToBody (result, +d, +c, +b);\n\t\tJSM.AddVertexToBody (result, +d, -c, +b);\n\t\tJSM.AddVertexToBody (result, -d, +c, +b);\n\t\tJSM.AddVertexToBody (result, -d, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +d);\n\t\tJSM.AddVertexToBody (result, -c, +b, +d);\n\t\tJSM.AddVertexToBody (result, +c, +b, -d);\n\t\tJSM.AddVertexToBody (result, -c, +b, -d);\n\n\t\tvar edgeLength = Math.sqrt (5.0) - 1.0;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\t\t\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 8, 10, 2, 16], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 16, 18, 1, 12], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 12, 14, 3, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 9, 5, 14, 12], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 18, 4, 11, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 10, 6, 15, 13], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 13, 4, 18, 16], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 14, 5, 19, 17], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 17, 6, 10, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [4, 13, 15, 7, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [5, 9, 11, 7, 19], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [6, 17, 19, 7, 15], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCumulatedIcosahedron\n\t* Description: Generates a cumulated icosahedron.\n\t* Parameters:\n\t*\tpyramidUnitHeight {number} the unit height of pyramids\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCumulatedIcosahedron = function (pyramidUnitHeight)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar a = 1.0;\n\t\tvar b = 0.0;\n\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\tvar edgeLength = 2;\n\t\tvar height = edgeLength * pyramidUnitHeight;\n\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 2, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 4, 6], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 6, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 8, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [0, 9, 2], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 3, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 4, 10], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 6, 4], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 10, 3], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [1, 11, 6], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 5, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 7, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [2, 9, 7], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 5, 7], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 7, 11], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [3, 10, 5], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [4, 8, 10], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [6, 11, 9], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [5, 10, 8], height);\n\t\tJSM.AddCumulatedPolygonToBody (result, [7, 9, 11], height);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTetrakisHexahedron\n\t* Description: Generates a tetrakis hexahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTetrakisHexahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = 1.0 / 4.0;\n\t\treturn JSM.GenerateCumulatedHexahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateRhombicDodecahedron\n\t* Description: Generates a rhombic dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRhombicDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = 1.0 / 2.0;\n\t\treturn JSM.GenerateCumulatedHexahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GeneratePentakisDodecahedron\n\t* Description: Generates a pentakis dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePentakisDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt ((65.0 + 22.0 * Math.sqrt (5.0)) / 5.0) / 19.0;\n\t\treturn JSM.GenerateCumulatedDodecahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallStellatedDodecahedron\n\t* Description: Generates a small stellated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallStellatedDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt ((5.0 + 2.0 * Math.sqrt (5.0)) / 5.0);\n\t\treturn JSM.GenerateCumulatedDodecahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateGreatDodecahedron\n\t* Description: Generates a great dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGreatDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = (Math.sqrt (3.0) * (Math.sqrt (5.0) - 3.0)) / 6.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallTriambicIcosahedron\n\t* Description: Generates a small triambic icosahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallTriambicIcosahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (15.0) / 15.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateGreatStellatedDodecahedron\n\t* Description: Generates a great stellated dodecahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGreatStellatedDodecahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = (Math.sqrt (3.0) * (3.0 + Math.sqrt (5.0))) / 6.0;\n\t\treturn JSM.GenerateCumulatedIcosahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateSmallTriakisOctahedron\n\t* Description: Generates a small triakis octahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSmallTriakisOctahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (3.0) - 2.0 * Math.sqrt (6.0) / 3.0;\n\t\treturn JSM.GenerateCumulatedOctahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateStellaOctangula\n\t* Description: Generates a stella octangula.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateStellaOctangula = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (6.0) / 3.0;\n\t\treturn JSM.GenerateCumulatedOctahedron (pyramidUnitHeight);\n\t};\n\n\t/**\n\t* Function: GenerateTriakisTetrahedron\n\t* Description: Generates a triakis tetrahedron.\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriakisTetrahedron = function ()\n\t{\n\t\tvar pyramidUnitHeight = Math.sqrt (6.0) / 15.0;\n\t\treturn JSM.GenerateCumulatedTetrahedron (pyramidUnitHeight);\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/extgenerator',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: LegoDimensions\n\t* Description: Class that contains lego brick dimensions.\n\t*/\n\tJSM.LegoDimensions = function ()\n\t{\n\t\tthis.legoWidth = 0.78;\n\t\tthis.legoSmallHeight = 0.32;\n\t\tthis.legoLargeHeight = 0.96;\n\t\tthis.legoWallWidth = 0.16;\n\t\tthis.legoCylinderWidth = 0.5;\n\t\tthis.legoCylinderHeight = 0.17;\n\t\tthis.legoBottomSmallCylinderWidth = 0.3;\n\t\tthis.legoBottomLargeCylinderWidth = 0.6;\n\t\tthis.legoBottomLargeCylinderWallWidth = 0.1;\n\t};\n\n\t/**\n\t* Function: GenerateLegoBrick\n\t* Description: Generates a lego brick.\n\t* Parameters:\n\t*\trows {integer} the row count\n\t*\tcolumns {integer} the columns count\n\t*\tisLarge {boolean} the brick is large\n\t*\thasTopCylinders {boolean} the brick has top cylinders\n\t*\thasBottomCylinders {boolean} the brick has bottom cylinders\n\t*\tsegmentation {integer} the segmentation of cylinders\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLegoBrick = function (rows, columns, isLarge, hasTopCylinders, hasBottomCylinders, segmentation, isCurved)\n\t{\n\t\tfunction OffsetBody (body, offset)\n\t\t{\n\t\t\tvar i, vertex;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\tvertex.position = JSM.CoordAdd (vertex.position, offset);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar legoDimensions = new JSM.LegoDimensions ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar unitWidth = legoDimensions.legoWidth;\n\t\tvar unitHeight = legoDimensions.legoLargeHeight;\n\t\tif (!isLarge) {\n\t\t\tunitHeight = legoDimensions.legoSmallHeight;\n\t\t}\n\t\tvar wallWidth = legoDimensions.legoWallWidth;\n\t\tvar topCylinderWidth = legoDimensions.legoCylinderWidth;\n\t\tvar topCylinderHeight = legoDimensions.legoCylinderHeight;\n\t\tvar bottomSmallCylinderWidth = legoDimensions.legoBottomSmallCylinderWidth;\n\t\tvar bottomLargeCylinderWidth = legoDimensions.legoBottomLargeCylinderWidth;\n\t\tvar bottomLargeCylinderWallWidth = legoDimensions.legoBottomLargeCylinderWallWidth;\n\n\t\tvar basePolygon = [];\n\t\tbasePolygon.push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, unitWidth * columns, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (0.0, unitWidth * columns, 0.0));\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar walls = JSM.GeneratePrismShell (basePolygon, normal, unitHeight - wallWidth, wallWidth, true);\n\t\tresult.Merge (walls);\n\t\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbasePolygon[i].z = unitHeight - wallWidth;\n\t\t}\n\t\t\n\t\tvar top = JSM.GeneratePrism (basePolygon, normal, wallWidth, true, null);\n\t\tresult.Merge (top);\n\t\t\n\t\tvar cylinderCenter, cylinder;\n\t\tif (hasTopCylinders) {\n\t\t\tfor (i = 0; i < rows; i++) {\n\t\t\t\tfor (j = 0; j < columns; j++) {\n\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * i + unitWidth / 2.0, unitWidth * j + unitWidth / 2.0, unitHeight + topCylinderHeight / 2.0);\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (topCylinderWidth / 2.0, topCylinderHeight, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasBottomCylinders) {\n\t\t\tvar circle, bigger, columnWise;\n\t\t\tif ((rows === 1 && columns > 1) || (columns === 1 && rows > 1)) {\n\t\t\t\tbigger = columns;\n\t\t\t\tcolumnWise = true;\n\t\t\t\tif (rows > columns) {\n\t\t\t\t\tbigger = rows;\n\t\t\t\t\tcolumnWise = false;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < bigger - 1; i++) {\n\t\t\t\t\tif (columnWise) {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth / 2.0, unitWidth * (i + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth / 2.0, (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t}\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (bottomSmallCylinderWidth / 2.0, unitHeight - wallWidth, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t} else if (rows > 1 && columns > 1) {\n\t\t\t\tfor (i = 0; i < rows - 1; i++) {\n\t\t\t\t\tfor (j = 0; j < columns - 1; j++) {\n\t\t\t\t\t\tcircle = [];\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth * (j + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t\tcylinder = JSM.GenerateCylinderShell (bottomLargeCylinderWidth / 2.0, unitHeight - wallWidth, bottomLargeCylinderWallWidth, segmentation, true, isCurved);\n\t\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateConvexHullBody\n\t* Description: Generates a convex hull body from the given coordinates.\n\t* Parameters:\n\t*\tcoord {Coord[*]} the coordinates\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateConvexHullBody = function (coords)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar convexHull = JSM.ConvexHull3D (coords);\n\t\t\n\t\tvar oldToNewIndexTable = {};\n\t\tvar i, j, current, index;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tif (!(index in oldToNewIndexTable)) {\n\t\t\t\t\toldToNewIndexTable[index] = result.VertexCount ();\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coords[index]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tnewPolygon = [];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tnewPolygon.push (oldToNewIndexTable[index]);\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon (newPolygon));\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSuperShape\n\t* Description: Generates a supershape.\n\t* Parameters:\n\t*\tparameters {12 numbers} the supershape parameters\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSuperShape = function (\taLon, bLon, mLon, n1Lon, n2Lon, n3Lon,\n\t\t\t\t\t\t\t\t\t\taLat, bLat, mLat, n1Lat, n2Lat, n3Lat,\n\t\t\t\t\t\t\t\t\t\tsegmentation, isCurved)\n\t{\n\t\tfunction CartesianToSpherical (coord)\n\t\t{\n\t\t\tvar radius = Math.sqrt (coord.x * coord.x + coord.y * coord.y + coord.z * coord.z);\n\t\t\tvar phi = Math.asin (coord.z / radius);\n\t\t\tvar theta = Math.atan2 (coord.y, coord.x);\n\t\t\treturn [radius, phi, theta];\n\t\t}\n\n\t\tfunction CalculateSuperFormula (p, a, b, m, n1, n2, n3)\n\t\t{\n\t\t\tvar abs1 = Math.abs (Math.cos (m * p / 4.0) / a);\n\t\t\tvar abs2 = Math.abs (Math.sin (m * p / 4.0) / b);\n\t\t\treturn Math.pow (Math.pow (abs1, n2) + Math.pow (abs2, n3), -1.0 / n1);\n\t\t}\n\n\t\tfunction CalculateSuperFormulaCoordinate (phi, theta)\n\t\t{\n\t\t\tvar coord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tvar rPhi = CalculateSuperFormula (phi, aLat, bLat, mLat, n1Lat, n2Lat, n3Lat);\n\t\t\tvar rTheta = CalculateSuperFormula (theta, aLon, bLon, mLon, n1Lon, n2Lon, n3Lon);\n\t\t\tcoord.x = rTheta * Math.cos (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.y = rTheta * Math.sin (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.z = rPhi * Math.sin (phi);\n\t\t\treturn coord;\n\t\t}\n\n\t\tvar result = JSM.GenerateSphere (1.0, segmentation, isCurved);\n\n\t\tvar i, vertex, coord, spherical, newCoord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tcoord = vertex.position;\n\t\t\tspherical = CartesianToSpherical (coord);\n\t\t\tnewCoord = CalculateSuperFormulaCoordinate (spherical[1], spherical[2]);\n\t\t\tvertex.SetPosition (newCoord);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/subdivision',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CatmullClarkSubdivisionOneIteration\n\t* Description: Runs one iteration of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivisionOneIteration = function (body)\n\t{\n\t\tfunction AddOriginalVertices (body, result, adjacencyInfo)\n\t\t{\n\t\t\tvar i, vertCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvertCoord = body.GetVertexPosition (i);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertCoord.Clone ()));\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tvar i, j, pgon, vertCoord, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tpgonCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j < pgon.verts.length; j++) {\n\t\t\t\t\tvertCoord = body.GetVertexPosition (pgon.verts[j]);\n\t\t\t\t\tpgonCoord = JSM.CoordAdd (pgonCoord, vertCoord);\n\t\t\t\t}\n\n\t\t\t\tpgonCoord.MultiplyScalar (1.0 / pgon.verts.length);\n\t\t\t\tpgonVertices.push (result.AddVertex (new JSM.BodyVertex (pgonCoord)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar i, j, edge, edgeCoord1, edgeCoord2, edgeCoord, pgonIndex, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord1 = body.GetVertexPosition (edge.vert1);\n\t\t\t\tedgeCoord2 = body.GetVertexPosition (edge.vert2);\n\t\t\t\tif (adjacencyInfo.IsContourEdge (edge)) {\n\t\t\t\t\tedgeCoord = JSM.MidCoord (edgeCoord1, edgeCoord2);\n\t\t\t\t} else {\n\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord1, edgeCoord2);\n\t\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t\tpgonIndex = (j === 0 ? edge.pgon1 : edge.pgon2);\n\t\t\t\t\t\tpgonCoord = result.GetVertexPosition (pgonVertices[pgonIndex]);\n\t\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord, pgonCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeCoord.MultiplyScalar (1.0 / 4.0);\n\t\t\t\t}\n\t\t\t\tedgeVertices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord)));\n\t\t\t}\n\t\t}\n\n\t\tfunction MoveOriginalVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tfunction MoveContourVertex (newVertCoord, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = newVertCoord.x;\n\t\t\t\tvertCoord.y = newVertCoord.y;\n\t\t\t\tvertCoord.z = newVertCoord.z;\n\t\t\t}\t\t\n\t\t\t\n\t\t\tfunction MoveVertex (pgonAverage, edgeAverage, vertEdgeCount, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = (pgonAverage.x + 2.0 * edgeAverage.x + (vertEdgeCount - 3) * vertCoord.x) / vertEdgeCount;\n\t\t\t\tvertCoord.y = (pgonAverage.y + 2.0 * edgeAverage.y + (vertEdgeCount - 3) * vertCoord.y) / vertEdgeCount;\n\t\t\t\tvertCoord.z = (pgonAverage.z + 2.0 * edgeAverage.z + (vertEdgeCount - 3) * vertCoord.z) / vertEdgeCount;\n\t\t\t}\n\t\t\n\t\t\tvar edgeMidCoords = [];\n\t\t\t\n\t\t\tvar edge, edgeCoord;\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (body.GetVertexPosition (edge.vert1), body.GetVertexPosition (edge.vert2));\n\t\t\t\tedgeMidCoords.push (edgeCoord);\n\t\t\t}\n\t\t\n\t\t\tvar vert, pgon, vertCoord, currentVertCoord;\n\t\t\tvar pgonAverage, edgeAverage, edgeCountForAverage;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvert = adjacencyInfo.verts[i];\n\t\t\t\tvertCoord = result.GetVertexPosition (i);\n\t\t\t\tif (adjacencyInfo.IsContourVertex (vert)) {\n\t\t\t\t\tedgeCountForAverage = 0;\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tif (adjacencyInfo.IsContourEdge (adjacencyInfo.edges[edge])) {\n\t\t\t\t\t\t\tedgeCoord = edgeMidCoords [vert.edges[j]];\n\t\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.Add (vertCoord);\n\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / edgeCountForAverage);\n\t\t\t\t\tMoveContourVertex (edgeAverage, vertCoord);\n\t\t\t\t} else {\n\t\t\t\t\tpgonAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < vert.pgons.length; j++) {\n\t\t\t\t\t\tpgon = vert.pgons[j];\n\t\t\t\t\t\tcurrentVertCoord = result.GetVertexPosition (pgonVertices[pgon]);\n\t\t\t\t\t\tpgonAverage.Add (currentVertCoord);\n\t\t\t\t\t}\n\t\t\t\t\tpgonAverage.MultiplyScalar (1.0 / vert.pgons.length);\n\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tedgeCoord = edgeMidCoords [edge];\n\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / vert.edges.length);\n\t\t\t\t\tMoveVertex (pgonAverage, edgeAverage, vert.edges.length, vertCoord);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar edgeCount, currentEdge, nextEdge;\n\t\t\tvar centroid, currentEdgeVertex, originalVertex, nextEdgeVertex;\n\t\t\tvar polygon, oldPolygon;\n\t\t\tvar i, j, pgon;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tedgeCount = pgon.verts.length;\n\t\t\t\tfor (j = 0; j < edgeCount; j++) {\n\t\t\t\t\tcurrentEdge = pgon.pedges[j];\n\t\t\t\t\tnextEdge = pgon.pedges[(j + 1) % edgeCount];\n\n\t\t\t\t\tcentroid = pgonVertices[i];\n\t\t\t\t\tcurrentEdgeVertex = edgeVertices[currentEdge.index];\n\t\t\t\t\toriginalVertex = adjacencyInfo.GetPolyEdgeStartVertex (nextEdge);\n\t\t\t\t\tnextEdgeVertex = edgeVertices[nextEdge.index];\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([centroid, currentEdgeVertex, originalVertex, nextEdgeVertex]);\n\t\t\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\t\t\tpolygon.material = oldPolygon.material;\n\t\t\t\t\tpolygon.curved = oldPolygon.curved;\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\n\t\tvar pgonVertices = [];\n\t\tvar edgeVertices = [];\n\n\t\tAddOriginalVertices (body, result, adjacencyInfo);\n\t\tAddPolygonVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\n\t\tMoveOriginalVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CatmullClarkSubdivision\n\t* Description: Runs multiple iterations of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\titerations {integer} the iteration number\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivision = function (body, iterations)\n\t{\n\t\tvar result = body;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < iterations; i++) {\n\t\t\tresult = JSM.CatmullClarkSubdivisionOneIteration (result);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/csg',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: BooleanOperation\n\t* Description: Makes a boolean operation on the given bodies.\n\t* Parameters:\n\t*\toperation {string} the operation ('Union', 'Difference', or 'Intersection')\n\t*\taBody {Body} the first body\n\t*\tbBody {Body} the second body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.BooleanOperation = function (operation, aBody, bBody)\n\t{\n\t\tfunction AddPolygonToBody (polygon, body, octree, reversed)\n\t\t{\n\t\t\tfunction AddBodyVertex (coord, octree)\n\t\t\t{\n\t\t\t\tvar merge = false;\n\t\t\t\tif (merge) {\n\t\t\t\t\tvar index = octree.FindCoord (coord);\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\tindex = body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\toctree.AddCoord (coord);\n\t\t\t\t\t}\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t}\n\n\t\t\tvar bodyPolygon = new JSM.BodyPolygon ([]);\n\n\t\t\tvar i, vertexIndex;\n\t\t\tif (!reversed) {\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (polygon.userData !== undefined) {\n\t\t\t\tbodyPolygon.SetMaterialIndex (polygon.userData.material);\n\t\t\t}\n\t\t\tbody.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tfunction AddPolygonsToBody (polygons, body, octree, reversed)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tAddPolygonToBody (polygons[i], body, octree, reversed);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ClipNodePolygonsWithTree (nodes, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t\t{\n\t\t\tfunction SetPolygonsUserData (polygons, userData)\n\t\t\t{\n\t\t\t\tvar i, polygon;\n\t\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\t\tpolygon = polygons[i];\n\t\t\t\t\tif (polygon.userData === undefined) {\n\t\t\t\t\t\tpolygon.userData = userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < nodes.length; i++) {\n\t\t\t\tnode = nodes[i];\n\t\t\t\tJSM.ClipPolygonWithBSPTree (node.polygon, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons);\n\t\t\t\tSetPolygonsUserData (frontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (backPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarFrontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarBackPolygons, node.userData);\n\t\t\t}\n\t\t}\n\n\t\tvar aTree = new JSM.BSPTree ();\n\t\tvar bTree = new JSM.BSPTree ();\n\t\tJSM.AddBodyToBSPTree (aBody, aTree, 'a');\n\t\tJSM.AddBodyToBSPTree (bBody, bTree, 'b');\n\n\t\tvar aFrontPolygons = [];\n\t\tvar aBackPolygons = [];\n\t\tvar aPlanarFrontPolygons = [];\n\t\tvar aPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (aTree.GetNodes (), bTree, aFrontPolygons, aBackPolygons, aPlanarFrontPolygons, aPlanarBackPolygons);\n\n\t\tvar bFrontPolygons = [];\n\t\tvar bBackPolygons = [];\n\t\tvar bPlanarFrontPolygons = [];\n\t\tvar bPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (bTree.GetNodes (), aTree, bFrontPolygons, bBackPolygons, bPlanarFrontPolygons, bPlanarBackPolygons);\n\n\t\tvar result = new JSM.Body ();\n\t\tvar resultOctree = new JSM.Octree (JSM.BoxUnion (aBody.GetBoundingBox (), bBody.GetBoundingBox ()));\n\t\t\n\t\tif (operation == 'Union') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bPlanarFrontPolygons, result, resultOctree, false);\n\t\t} else if (operation == 'Difference') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, true);\n\t\t} else if (operation == 'Intersection') {\n\t\t\tAddPolygonsToBody (aBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, false);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extras/surfaces',[\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSurface\n\t* Description: Generates a parametric surface.\n\t* Parameters:\n\t*\txRange {number[2]} the from-to range on x axis\n\t*\tyRange {number[2]} the from-to range on y axis\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tuseTriangles {boolean} generate triangles instead of quadrangles\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tgetPointCallback {function} callback function which returns the point for a position\n\t*\tuserData {anything} user data which will be passed to getPointCallback\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSurface = function (xRange, yRange, xSegmentation, ySegmentation, useTriangles, isCurved, getPointCallback, userData)\n\t{\n\t\tfunction AddVertices (result, xStart, yStart, xSegment, ySegment)\n\t\t{\n\t\t\tvar i, j, u, v, coord;\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tu = xStart + j * xSegment;\n\t\t\t\t\tv = yStart + i * ySegment;\n\t\t\t\t\tcoord = getPointCallback (i, j, u, v, userData);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (result)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\tvar polygon;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (useTriangles) {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xRange[0];\n\t\tvar yStart = yRange[0];\n\t\tvar xDiff = xRange[1] - xRange[0];\n\t\tvar yDiff = yRange[1] - yRange[0];\n\t\tvar xSegment = xDiff / xSegmentation;\n\t\tvar ySegment = yDiff / ySegmentation;\n\t\t\n\t\tAddVertices (result, xStart, yStart, xSegment, ySegment);\n\t\tAddPolygons (result);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: SurfaceControlPoints\n\t* Description: Represents control points for surface generation.\n\t* Parameters:\n\t*\tn {integer} the first dimension\n\t*\tm {integer} the second dimension\n\t*/\n\tJSM.SurfaceControlPoints = function (n, m)\n\t{\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\tthis.points = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tthis.points.push ([]);\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tthis.points[i].push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetNValue\n\t* Description: Returns the n value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetNValue = function ()\n\t{\n\t\treturn this.n;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetMValue\n\t* Description: Returns the m value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetMValue = function ()\n\t{\n\t\treturn this.m;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetControlPoint\n\t* Description: Returns a control point.\n\t* Parameters:\n\t*\ti {integer} the first dimension\n\t*\tj {integer} the second dimension\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetControlPoint = function (i, j)\n\t{\n\t\treturn this.points[i][j];\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.InitPlanar\n\t* Description: Inits planar control points.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\txSize {number} the y size\n\t*/\n\tJSM.SurfaceControlPoints.prototype.InitPlanar = function (xSize, ySize)\n\t{\n\t\tvar iStep = xSize / this.n;\n\t\tvar jStep = ySize / this.m;\n\n\t\tvar i, j, point;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tpoint = this.points[i][j];\n\t\t\t\tpoint.x = i * iStep;\n\t\t\t\tpoint.y = j * jStep;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateBezierSurface\n\t* Description: Generates a bezier surface base on the given control points.\n\t* Parameters:\n\t*\tsurfaceControlPoints {SurfaceControlPoints} the control points\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateBezierSurface = function (surfaceControlPoints, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tfunction GetBezierSurfacePoint (uIndex, vIndex, u, v, surfaceControlPoints)\n\t\t{\n\t\t\tvar i, j, result, tmp1, tmp2, scalar;\n\t\t\tvar n = surfaceControlPoints.GetNValue ();\n\t\t\tvar m = surfaceControlPoints.GetMValue ();\n\t\t\t\n\t\t\tresult = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tfor (i = 0; i <= n; i++) {\n\t\t\t\ttmp1 = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j <= m; j++) {\n\t\t\t\t\tscalar = JSM.BernsteinPolynomial (i, n, u) * JSM.BernsteinPolynomial (j, m, v);\n\t\t\t\t\ttmp2 = surfaceControlPoints.GetControlPoint (i, j).Clone ().MultiplyScalar (scalar);\n\t\t\t\t\ttmp1 = JSM.CoordAdd (tmp1, tmp2);\n\t\t\t\t}\n\t\t\t\tresult = JSM.CoordAdd (result, tmp1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = JSM.GenerateSurface ([0, 1], [0, 1], xSegmentation, ySegmentation, false, isCurved, GetBezierSurfacePoint, surfaceControlPoints);\n\t\treturn body;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/svgtomodel/svgtomodel',[\"../../core/jsm\"],function(JSM){\n\t/**\n\t* Function: SvgToModel\n\t* Description: Converts an svg objects rect, path and polygon elements to a body.\n\t* Parameters:\n\t*\tsvgObject {html svg element} the svg element\n\t*\theight {number} the height of the result body\n\t*\tsegmentLength {number} the maximum length of curved segments\n\t*\tcurveAngle {number} if not null, defines the curve angle of the model\n\t* Returns:\n\t*\t{Model} the result\n\t*/\n\tJSM.SvgToModel = function (svgObject, height, segmentLength, curveAngle)\n\t{\n\t\tfunction SegmentElem (elem, segmentLength)\n\t\t{\n\t\t\tfunction AddTransformedVertex (dummySVG, result, elem, x, y)\n\t\t\t{\n\t\t\t\tvar point = dummySVG.createSVGPoint ();\n\t\t\t\tpoint.x = x;\n\t\t\t\tpoint.y = y;\n\t\t\t\t\n\t\t\t\tvar transformed = point;\n\t\t\t\tvar matrix = elem.getCTM ();\n\t\t\t\tif (matrix !== undefined && matrix !== null) {\n\t\t\t\t\ttransformed = point.matrixTransform (matrix);\t\t\t\t\n\t\t\t\t}\n\t\t\t\tvar transformedCoord = new JSM.Coord2D (transformed.x, transformed.y);\n\t\t\t\tvar resultCoord = new JSM.Coord2D (x, y);\n\t\t\t\t\n\t\t\t\tvar contour = result.GetLastContour ();\n\t\t\t\tvar contourVertexCount = contour.VertexCount ();\n\t\t\t\tif (contourVertexCount > 0) {\n\t\t\t\t\tif (contour.GetVertex (contourVertexCount - 1).IsEqualWithEps (transformedCoord, 0.1)) {\n\t\t\t\t\t\treturn resultCoord;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontour.AddVertex (transformed.x, transformed.y);\n\t\t\t\treturn resultCoord;\n\t\t\t}\n\n\t\t\tfunction SegmentCurve (dummySVG, originalPath, segmentLength, lastCoord, items, result)\n\t\t\t{\n\t\t\t\tfunction CreatePath (items)\n\t\t\t\t{\n\t\t\t\t\tfunction GenerateMoveCommand (x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 'M ' + x + ' ' + y + ' ';\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tvar svgNameSpace = 'http://www.w3.org/2000/svg';\n\t\t\t\t\tvar path = document.createElementNS (svgNameSpace, 'path');\n\n\t\t\t\t\tvar commandString = GenerateMoveCommand (lastCoord.x, lastCoord.y);\n\t\t\t\t\tvar i, item, command, largeArcFlag, sweepFlag;\n\t\t\t\t\tfor (i = 0; i < items.length; i++) {\n\t\t\t\t\t\titem = items[i];\n\t\t\t\t\t\tif (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ||\n\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL) {\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ? 'C' : 'c');\n\t\t\t\t\t\t\tcommandString += command + ' ' + item.x1 + ' ' + item.y1 + ' ' + item.x2 + ' ' + item.y2 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ? 'Q' : 'q');\n\t\t\t\t\t\t\tcommandString += command + ' ' + item.x1 + ' ' + item.y1 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ? 'A' : 'a');\n\t\t\t\t\t\t\tlargeArcFlag = (item.largeArcFlag ? 1 : 0);\n\t\t\t\t\t\t\tsweepFlag = (item.sweepFlag ? 1 : 0);\n\t\t\t\t\t\t\tcommandString +=  command + ' ' + item.r1 + ' ' + item.r2 + ' ' + item.angle + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else if (\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL){\n\t\t\t\t\t\t\tcommand = (item.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ? 'S' : 's');\n\t\t\t\t\t\t\tcommandString +=  command + ' ' + item.x2 + ' ' + item.y2 + ' ' + item.x + ' ' + item.y + ' ';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// unknown segment type\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpath.setAttributeNS (null, 'd', commandString);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar path = CreatePath (items);\n\t\t\t\tvar pathLength = path.getTotalLength ();\n\n\t\t\t\tvar segmentation = 0;\n\t\t\t\tif (segmentLength > 0) {\n\t\t\t\t\tsegmentation = parseInt (pathLength / segmentLength, 10);\n\t\t\t\t}\n\t\t\t\tif (segmentation < 3) {\n\t\t\t\t\tsegmentation = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar step = pathLength / segmentation;\n\t\t\t\tvar i, point;\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tpoint = path.getPointAtLength (i * step);\n\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, originalPath, point.x, point.y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn lastCoord;\n\t\t\t}\n\t\t\t\n\t\t\tfunction IsCurvedItem (item)\n\t\t\t{\n\t\t\t\treturn\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_ARC_REL ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\t\t\t}\n\t\t\t\n\t\t\tfunction IsSmoothItem (item)\n\t\t\t{\n\t\t\t\treturn\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS ||\n\t\t\t\t\t\titem.pathSegType == SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\t\t\t}\n\n\t\t\tfunction RemoveEqualEndVertices (polygon)\n\t\t\t{\n\t\t\t\tvar contour = polygon.GetLastContour ();\n\t\t\t\tvar vertexCount = contour.VertexCount ();\n\t\t\t\tif (vertexCount === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar firstCoord = contour.GetVertex (0);\n\t\t\t\tvar lastCoord = contour.GetVertex (vertexCount - 1);\n\t\t\t\tif (firstCoord.IsEqualWithEps (lastCoord, 0.1)) {\n\t\t\t\t\t// TODO: Do not access vertices directly\n\t\t\t\t\tcontour.vertices.pop ();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction StartNewContour (result)\n\t\t\t{\n\t\t\t\tif (result.GetLastContour ().VertexCount () > 0) {\n\t\t\t\t\tRemoveEqualEndVertices (result);\n\t\t\t\t\tresult.AddContour ();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfunction SVGColorToHex (path)\n\t\t\t{\n\t\t\t\tvar svgColor = '';\n\t\t\t\tvar target = path;\n\t\t\t\twhile (target !== null && target !== undefined && svgColor.length === 0) {\n\t\t\t\t\tsvgColor = target.getAttribute ('fill');\n\t\t\t\t\tif (svgColor === null) {\n\t\t\t\t\t\tsvgColor = target.style.fill;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = target.parentElement;\n\t\t\t\t}\n\n\t\t\t\tvar result = 0x000000;\n\t\t\t\tif (svgColor.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (svgColor[0] == '#') {\n\t\t\t\t\tresult = JSM.HexColorToRGBColor (svgColor.substring (1));\n\t\t\t\t} else {\n\t\t\t\t\tvar firstBracket = svgColor.indexOf ('(');\n\t\t\t\t\tvar secondBracket = svgColor.indexOf (')');\n\t\t\t\t\tif (firstBracket == -1 || secondBracket == -1) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar numbers = svgColor.substring (firstBracket + 1, secondBracket);\n\t\t\t\t\tvar rgb = numbers.split (', ');\n\t\t\t\t\tif (rgb.length != 3) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tresult = JSM.RGBComponentsToHexColor (rgb[0], rgb[1], rgb[2]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\n\t\t\tvar result = new JSM.ContourPolygon2D ();\n\t\t\tresult.AddContour ();\n\n\t\t\tvar dummySVG = document.createElementNS ('http://www.w3.org/2000/svg', 'svg');\n\n\t\t\tvar i, j;\n\t\t\tif (elem instanceof SVGPathElement) {\n\t\t\t\tvar lastCoord = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lastMoveCoord = new JSM.Coord2D (0.0, 0.0);\n\n\t\t\t\tvar currentSegmentLength = segmentLength;\n\t\t\t\tif (elem.hasAttribute ('segmentlength')) {\n\t\t\t\t\tcurrentSegmentLength = parseFloat (elem.getAttribute ('segmentlength'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar item, items, currentItem;\n\t\t\t\tfor (i = 0; i < elem.pathSegList.numberOfItems; i++) {\n\t\t\t\t\titem = elem.pathSegList.getItem (i);\n\t\t\t\t\tif (item.pathSegType == SVGPathSeg.PATHSEG_CLOSEPATH) {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_MOVETO_ABS) {\n\t\t\t\t\t\tStartNewContour (result);\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, item.y);\n\t\t\t\t\t\tlastMoveCoord = lastCoord.Clone ();\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_MOVETO_REL) {\n\t\t\t\t\t\tStartNewContour (result);\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastMoveCoord.x + item.x, lastMoveCoord.y + item.y);\n\t\t\t\t\t\tlastMoveCoord = lastCoord.Clone ();\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x + item.x, lastCoord.y + item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, item.x, lastCoord.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x, item.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x + item.x, lastCoord.y);\n\t\t\t\t\t} else if (item.pathSegType == SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL) {\n\t\t\t\t\t\tlastCoord = AddTransformedVertex (dummySVG, result, elem, lastCoord.x, lastCoord.y + item.y);\n\t\t\t\t\t} else if (IsCurvedItem (item)) {\n\t\t\t\t\t\titems = [];\n\t\t\t\t\t\tif (IsSmoothItem (item)) {\n\t\t\t\t\t\t\tfor (j = i; j < elem.pathSegList.numberOfItems; j++) {\n\t\t\t\t\t\t\t\tcurrentItem = elem.pathSegList.getItem (j);\n\t\t\t\t\t\t\t\tif (!IsSmoothItem (currentItem)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titems.push (currentItem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti = j - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems.push (item);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastCoord = SegmentCurve (dummySVG, elem, currentSegmentLength, lastCoord, items, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unknown segment type\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRemoveEqualEndVertices (result);\n\t\t\t} else if (elem instanceof SVGRectElement) {\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value, elem.y.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value + elem.width.baseVal.value, elem.y.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value + elem.width.baseVal.value, elem.y.baseVal.value + elem.height.baseVal.value);\n\t\t\t\tAddTransformedVertex (dummySVG, result, elem, elem.x.baseVal.value, elem.y.baseVal.value + elem.height.baseVal.value);\n\t\t\t} else if (elem instanceof SVGPolygonElement) {\n\t\t\t\tvar point;\n\t\t\t\tfor (i = 0; i < elem.points.numberOfItems; i++) {\n\t\t\t\t\tpoint = elem.points.getItem (i);\n\t\t\t\t\tAddTransformedVertex (dummySVG, result, elem, point.x, point.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.color = SVGColorToHex (elem);\n\t\t\tresult.originalElem = elem;\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction SegmentPaths (svgObject, segmentLength)\n\t\t{\n\t\t\tfunction AddElemType (svgObject, elemType, result)\n\t\t\t{\n\t\t\t\tvar elems = svgObject.getElementsByTagName (elemType);\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\t\t\tresult.push (elems[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar result = [];\n\t\t\tvar elems = [];\n\t\t\tAddElemType (svgObject, 'path', elems);\n\t\t\tAddElemType (svgObject, 'rect', elems);\n\t\t\tAddElemType (svgObject, 'polygon', elems);\n\t\t\t\n\t\t\tvar currentSegmentLength = segmentLength;\n\t\t\tif (svgObject.hasAttribute ('segmentlength')) {\n\t\t\t\tcurrentSegmentLength = parseFloat (svgObject.getAttribute ('segmentlength'));\n\t\t\t}\n\n\t\t\tvar i, current;\n\t\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\t\tcurrent = SegmentElem (elems[i], currentSegmentLength);\n\t\t\t\tresult.push (current);\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction ContourPolygonToPrisms (polygon, height, curveAngle)\n\t\t{\n\t\t\tfunction AppendPolygonVertices (polygon, vertexArray, reversed)\n\t\t\t{\n\t\t\t\tvar i, coord;\n\t\t\t\tif (!reversed) {\n\t\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\t\t\tvertexArray.push (new JSM.Coord (coord.x, -coord.y, 0.0));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\t\tcoord = polygon.GetVertex (i);\n\t\t\t\t\t\tvertexArray.push (new JSM.Coord (coord.x, -coord.y, 0.0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction CreateBasePolygon (polygon)\n\t\t\t{\n\t\t\t\tvar basePolygon = [];\n\t\t\t\tvar orientation = polygon.GetOrientation ();\n\t\t\t\tvar reversed = (orientation == JSM.Orientation.CounterClockwise);\n\t\t\t\tAppendPolygonVertices (polygon, basePolygon, reversed);\n\t\t\t\treturn basePolygon;\n\t\t\t}\n\t\t\n\t\t\tfunction AddHoleToBasePolygon (basePolygon, holePolygon)\n\t\t\t{\n\t\t\t\tbasePolygon.push (null);\n\t\t\t\tvar orientation = holePolygon.GetOrientation ();\n\t\t\t\tvar reversed = (orientation == JSM.Orientation.Clockwise);\n\t\t\t\tAppendPolygonVertices (holePolygon, basePolygon, reversed);\n\t\t\t}\n\n\t\t\tvar prisms = [];\n\t\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\t\t\n\t\t\tvar currentHeight = height;\n\t\t\tif (polygon.originalElem !== undefined) {\n\t\t\t\tif (polygon.originalElem.hasAttribute ('modelheight')) {\n\t\t\t\t\tcurrentHeight = parseFloat (polygon.originalElem.getAttribute ('modelheight'));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar basePolygon, baseOrientation, prism;\n\t\t\tvar contourCount = polygon.ContourCount ();\n\t\t\tif (contourCount === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif (contourCount == 1) {\n\t\t\t\tbaseOrientation = polygon.GetContour (0).GetOrientation ();\n\t\t\t\tbasePolygon = CreateBasePolygon (polygon.GetContour (0));\n\t\t\t\tprism = JSM.GeneratePrism (basePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\tprisms.push (prism);\n\t\t\t} else if (contourCount > 1) {\n\t\t\t\tbaseOrientation = polygon.GetContour (0).GetOrientation ();\n\t\t\t\tvar holeBasePolygon = CreateBasePolygon (polygon.GetContour (0));\n\t\t\t\tvar hasHoles = false;\n\t\t\t\t\n\t\t\t\tvar i, orientation;\n\t\t\t\tfor (i = 1; i < polygon.ContourCount (); i++) {\n\t\t\t\t\torientation = polygon.GetContour (i).GetOrientation ();\n\t\t\t\t\tif (orientation == baseOrientation) {\n\t\t\t\t\t\tbasePolygon = CreateBasePolygon (polygon.GetContour (i));\n\t\t\t\t\t\tprism = JSM.GeneratePrism (basePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\t\tprisms.push (prism);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAddHoleToBasePolygon (holeBasePolygon, polygon.GetContour (i));\n\t\t\t\t\t\thasHoles = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasHoles) {\n\t\t\t\t\tprism = JSM.GeneratePrism (holeBasePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\tprisms.push (prism);\n\t\t\t\t} else {\n\t\t\t\t\tprism = JSM.GeneratePrismWithHole (holeBasePolygon, direction, currentHeight, true, curveAngle);\n\t\t\t\t\tprisms.push (prism);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar material = new JSM.Material ({ambient : polygon.color, diffuse : polygon.color});\n\t\t\treturn [prisms, material];\n\t\t}\n\t\t\n\t\tvar model = new JSM.Model ();\n\t\tvar polygons = SegmentPaths (svgObject, segmentLength);\n\n\t\tvar currentHeight = height;\n\t\tif (svgObject.hasAttribute ('modelheight')) {\n\t\t\tcurrentHeight = parseFloat (svgObject.getAttribute ('modelheight'));\n\t\t}\n\t\t\n\t\tvar i, j, prismsAndMaterial, currentPrisms, currentPrism, currentMaterial;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tprismsAndMaterial = ContourPolygonToPrisms (polygons[i], currentHeight, curveAngle);\n\t\t\tif (prismsAndMaterial === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentPrisms = prismsAndMaterial[0];\n\t\t\tcurrentMaterial = prismsAndMaterial[1];\n\t\t\tmodel.AddMaterial (currentMaterial);\n\t\t\tfor (j = 0; j < currentPrisms.length; j++) {\n\t\t\t\tcurrentPrism = currentPrisms[j];\n\t\t\t\tcurrentPrism.SetPolygonsMaterialIndex (model.MaterialCount () - 1);\n\t\t\t\tmodel.AddBody (currentPrism);\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/textgenerator/textgenerator',[\"../../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateText\n\t* Description:\n\t*\tGenerates 3D model from the given text. It should get a font\n\t*\tspecification object created with facetype.js.\n\t* Parameters:\n\t*\ttext {string} the text\n\t*\tfontSpec {object} the font specification object generated with facetype.js\n\t*\tfontScale {number} the scale of the generated model\n\t*\tfontHeight {number} the height of the generated model\n\t*\tfontSegmentation {integer} the segmentation of font glyphs\n\t* Returns:\n\t*\t{Model} the result\n\t*/\n\tJSM.GenerateText = function (text, fontSpec, fontScale, fontHeight, fontSegmentation)\n\t{\n\t\tfunction CreatePathFromSpecification (commands, segmentation, offset, scale)\n\t\t{\n\t\t\tfunction Num (str)\n\t\t\t{\n\t\t\t\treturn parseFloat (str);\n\t\t\t}\n\t\t\n\t\t\tvar path = new JSM.Path2D ({\n\t\t\t\tsegmentation : segmentation,\n\t\t\t\toffset : offset,\n\t\t\t\tscale : scale\n\t\t\t});\n\t\t\t\n\t\t\tvar parts = commands.split (' ');\n\t\t\tvar index = 0;\n\t\t\tvar current;\n\t\t\twhile (index < parts.length) {\n\t\t\t\tcurrent = parts[index++];\n\t\t\t\tif (current.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (current == 'm') {\n\t\t\t\t\tpath.MoveTo (Num (parts[index + 0]), Num (parts[index + 1]));\n\t\t\t\t\tindex += 2;\n\t\t\t\t} else if (current == 'l') {\n\t\t\t\t\tpath.LineTo (Num (parts[index + 0]), Num (parts[index + 1]));\n\t\t\t\t\tindex += 2;\n\t\t\t\t} else if (current == 'b') {\n\t\t\t\t\tpath.CubicBezierTo (Num (parts[index + 0]), Num (parts[index + 1]), Num (parts[index + 2]), Num (parts[index + 3]), Num (parts[index + 4]), Num (parts[index + 5]));\n\t\t\t\t\tindex += 6;\n\t\t\t\t} else if (current == 'z') {\n\t\t\t\t\tpath.Close ();\n\t\t\t\t} else {\n\t\t\t\t\tJSM.Message ('Invalid path command found: ' + current);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n\t\tvar model = new JSM.Model ();\n\t\tvar offset = new JSM.Vector2D (0.0, 0.0);\n\t\tvar scale = new JSM.Coord2D (fontScale, fontScale);\n\t\tvar i, character, glyphs, path, bodies;\n\t\tfor (i = 0; i < text.length; i++) {\n\t\t\tcharacter = text[i];\n\t\t\tglyphs = fontSpec.glyphs[character];\n\t\t\tif (glyphs === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpath = CreatePathFromSpecification (glyphs.o, fontSegmentation, offset, scale);\n\t\t\tbodies = JSM.GeneratePrismsFromPath2D (path, fontHeight, true, 160 * JSM.DegRad);\n\t\t\tmodel.AddBodies (bodies);\n\t\t\toffset.x += glyphs.ha * scale.x;\n\t\t}\n\t\treturn model;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/threeviewer/threeconverter',[\"../../core/jsm\"],function(JSM){\n\tJSM.ConvertBodyToThreeMeshes = function (body, materials, conversionData)\n\t{\n\t\tvar theConversionData = {\n\t\t\ttextureLoadedCallback : null,\n\t\t\thasConvexPolygons : false\n\t\t};\n\n\t\tif (conversionData !== undefined && conversionData !== null) {\n\t\t\ttheConversionData.textureLoadedCallback = JSM.ValueOrDefault (conversionData.textureLoadedCallback, theConversionData.textureLoadedCallback);\n\t\t\ttheConversionData.hasConvexPolygons = JSM.ValueOrDefault (conversionData.hasConvexPolygons, theConversionData.hasConvexPolygons);\n\t\t}\n\t\t\n\t\tvar meshes = [];\n\t\tvar threeGeometry = null;\n\t\tvar threeMaterial = null;\n\n\t\tvar explodeData = {\n\t\t\thasConvexPolygons : theConversionData.hasConvexPolygons,\n\t\t\tonPointGeometryStart : function (material) {\n\t\t\t\t\tthreeMaterial = new JSM.THREE.PointsMaterial ({\n\t\t\t\t\t\tcolor : material.diffuse,\n\t\t\t\t\t\tsize: material.pointSize\n\t\t\t\t\t});\n\t\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t},\n\t\t\tonPointGeometryEnd : function () {\n\t\t\t\tvar points = new JSM.THREE.Points (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (points);\n\t\t\t},\n\t\t\tonPoint : function (vertex)\t{\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex.x, vertex.y, vertex.z));\n\t\t\t},\n\t\t\tonLineGeometryStart : function (material) {\n\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t\tthreeMaterial = new JSM.THREE.LineBasicMaterial ({\n\t\t\t\t\tcolor : material.diffuse\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLineGeometryEnd : function () {\n\t\t\t\tvar lines = new JSM.THREE.LineSegments (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (lines);\n\t\t\t},\n\t\t\tonLine : function (begVertex, endVertex) {\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (begVertex.x, begVertex.y, begVertex.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (endVertex.x, endVertex.y, endVertex.z));\n\t\t\t},\n\t\t\tonGeometryStart : function (material) {\n\t\t\t\tvar hasTexture = (material.texture !== null);\n\t\t\t\tvar hasOpacity = (material.opacity !== 1.0);\n\n\t\t\t\tvar diffuse = material.diffuse;\n\t\t\t\tvar specular = material.specular;\n\t\t\t\tvar shininess = material.shininess;\n\t\t\t\tif (shininess === 0.0) {\n\t\t\t\t\tspecular = 0x000000;\n\t\t\t\t\tshininess = 1;\n\t\t\t\t}\n\n\t\t\t\tthreeMaterial = new JSM.THREE.MeshPhongMaterial ({\n\t\t\t\t\tcolor : diffuse,\n\t\t\t\t\tspecular : specular,\n\t\t\t\t\tshininess : shininess\n\t\t\t\t});\n\n\t\t\t\tif (!material.singleSided) {\n\t\t\t\t\tthreeMaterial.side = JSM.THREE.DoubleSide;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hasOpacity) {\n\t\t\t\t\tthreeMaterial.opacity = material.opacity;\n\t\t\t\t\tthreeMaterial.transparent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hasTexture) {\n\t\t\t\t\tvar theMaterial = threeMaterial;\n\t\t\t\t\tvar textureName = material.texture;\n\t\t\t\t\tvar loader = new JSM.THREE.TextureLoader ();\n\t\t\t\t\tloader.load (textureName, function (texture) {\n\t\t\t\t\t\ttexture.image = JSM.ResizeImageToPowerOfTwoSides (texture.image);\n\t\t\t\t\t\ttexture.wrapS = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttheMaterial.map = texture;\n\t\t\t\t\t\ttheMaterial.needsUpdate = true;\n\t\t\t\t\t\tif (theConversionData.textureLoadedCallback !== null) {\n\t\t\t\t\t\t\ttheConversionData.textureLoadedCallback ();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthreeGeometry = new JSM.THREE.Geometry ();\n\t\t\t},\n\t\t\tonGeometryEnd : function () {\n\t\t\t\tthreeGeometry.computeFaceNormals ();\n\t\t\t\tvar mesh = new JSM.THREE.Mesh (threeGeometry, threeMaterial);\n\t\t\t\tmeshes.push (mesh);\n\t\t\t},\n\t\t\tonTriangle : function (vertex1, vertex2, vertex3, normal1, normal2, normal3, uv1, uv2, uv3) {\n\t\t\t\tvar lastVertexIndex = threeGeometry.vertices.length;\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex1.x, vertex1.y, vertex1.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex2.x, vertex2.y, vertex2.z));\n\t\t\t\tthreeGeometry.vertices.push (new JSM.THREE.Vector3 (vertex3.x, vertex3.y, vertex3.z));\n\t\t\t\tvar face = new JSM.THREE.Face3 (lastVertexIndex + 0, lastVertexIndex + 1, lastVertexIndex + 2);\n\t\t\t\tthreeGeometry.faces.push (face);\n\t\t\t\t\n\t\t\t\tif (normal1 !== null && normal2 !== null && normal3 !== null) {\n\t\t\t\t\tvar normalArray = [];\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal1.x, normal1.y, normal1.z));\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal2.x, normal2.y, normal2.z));\n\t\t\t\t\tnormalArray.push (new JSM.THREE.Vector3 (normal3.x, normal3.y, normal3.z));\n\t\t\t\t\tthreeGeometry.faces[threeGeometry.faces.length - 1].vertexNormals = normalArray;\n\t\t\t\t}\n\n\t\t\t\tif (uv1 !== null && uv2 !== null && uv3 !== null) {\n\t\t\t\t\tvar uvArray = [];\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv1.x, -uv1.y));\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv2.x, -uv2.y));\n\t\t\t\t\tuvArray.push (new JSM.THREE.Vector2 (uv3.x, -uv3.y));\n\t\t\t\t\tthreeGeometry.faceVertexUvs[0].push (uvArray);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tJSM.ExplodeBody (body, materials, explodeData);\n\t\treturn meshes;\n\t};\n\n\tJSM.ConvertModelToThreeMeshes = function (model, conversionData)\n\t{\n\t\tvar meshes = [];\n\t\tvar materials = model.GetMaterialSet ();\n\t\t\n\t\tvar i, j, body, currentMeshes;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentMeshes = JSM.ConvertBodyToThreeMeshes (body, materials, conversionData);\n\t\t\tfor (j = 0; j < currentMeshes.length; j++) {\n\t\t\t\tmeshes.push (currentMeshes[j]);\n\t\t\t}\n\t\t}\n\n\t\treturn meshes;\n\t};\n\n\tJSM.ConvertJSONDataToThreeMeshes = function (jsonData, textureLoadedCallback, asyncCallbacks)\n\t{\n\t\tfunction AddMesh (mesh, meshIndex, materials, resultMeshes)\n\t\t{\n\t\t\tfunction AddTriangles (currentTriangles, vertices, normals, uvs, materials, resultMeshes)\n\t\t\t{\n\t\t\t\tfunction GetTextureCoordinate (u, v, offset, scale, rotation)\n\t\t\t\t{\n\t\t\t\t\tvar result = new JSM.THREE.Vector2 (u, v);\n\t\t\t\t\tif (!JSM.IsZero (rotation)) {\n\t\t\t\t\t\tvar si = Math.sin (rotation * JSM.DegRad);\n\t\t\t\t\t\tvar co = Math.cos (rotation * JSM.DegRad);\n\t\t\t\t\t\tresult.x = co * u - si * v;\n\t\t\t\t\t\tresult.y = si * u + co * v;\n\t\t\t\t\t}\n\t\t\t\t\tresult.x = offset[0] + result.x * scale[0];\n\t\t\t\t\tresult.y = offset[1] + result.y * scale[1];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar materialIndex = currentTriangles.material;\n\t\t\t\tvar parameters = currentTriangles.parameters;\n\t\t\t\tvar materialData = materials[materialIndex];\n\t\t\t\t\n\t\t\t\tvar textureName = materialData.texture;\n\t\t\t\tvar textureOffset = materialData.offset;\n\t\t\t\tvar textureScale = materialData.scale;\n\t\t\t\tvar textureRotation = materialData.rotation;\n\t\t\t\t\n\t\t\t\tvar diffuseColor = new JSM.THREE.Color ();\n\t\t\t\tvar specularColor = new JSM.THREE.Color ();\n\t\t\t\tvar shininess = materialData.shininess || 0.0;\n\n\t\t\t\tdiffuseColor.setRGB (materialData.diffuse[0], materialData.diffuse[1], materialData.diffuse[2]);\n\t\t\t\tspecularColor.setRGB (materialData.specular[0], materialData.specular[1], materialData.specular[2]);\n\n\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\tdiffuseColor.setRGB (1.0, 1.0, 1.0);\n\t\t\t\t\tspecularColor.setRGB (1.0, 1.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\tif (textureOffset === undefined || textureOffset === null) {\n\t\t\t\t\t\ttextureOffset = [0.0, 0.0];\n\t\t\t\t\t}\n\t\t\t\t\tif (textureScale === undefined || textureScale === null) {\n\t\t\t\t\t\ttextureScale = [1.0, 1.0];\n\t\t\t\t\t}\n\t\t\t\t\tif (textureRotation === undefined || textureRotation === null) {\n\t\t\t\t\t\ttextureRotation = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shininess === 0.0) {\n\t\t\t\t\tspecularColor.setRGB (0.0, 0.0, 0.0);\n\t\t\t\t\tshininess = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar material = new JSM.THREE.MeshPhongMaterial ({\n\t\t\t\t\t\tcolor : diffuseColor.getHex (),\n\t\t\t\t\t\tspecular : specularColor.getHex (),\n\t\t\t\t\t\tshininess : shininess,\n\t\t\t\t\t\tside : JSM.THREE.DoubleSide\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (materialData.opacity !== 1.0) {\n\t\t\t\t\tmaterial.opacity = materialData.opacity;\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\tvar loader = new JSM.THREE.TextureLoader ();\n\t\t\t\t\tvar theMaterial = material;\n\t\t\t\t\tloader.load (textureName, function (texture) {\n\t\t\t\t\t\ttexture.image = JSM.ResizeImageToPowerOfTwoSides (texture.image);\n\t\t\t\t\t\ttexture.wrapS = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = JSM.THREE.RepeatWrapping;\n\t\t\t\t\t\ttheMaterial.map = texture;\n\t\t\t\t\t\ttheMaterial.needsUpdate = true;\n\t\t\t\t\t\tif (textureLoadedCallback !== undefined && textureLoadedCallback !== null) {\n\t\t\t\t\t\t\ttextureLoadedCallback ();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar geometry = new JSM.THREE.Geometry ();\n\n\t\t\t\tvar v1, v2, v3, n1, n2, n3, u1, u2, u3;\n\t\t\t\tvar lastVertex, lastFace, vertexNormals, textureUVs;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < parameters.length; j += 9) {\n\t\t\t\t\tv1 = 3 * parameters[j + 0];\n\t\t\t\t\tv2 = 3 * parameters[j + 1];\n\t\t\t\t\tv3 = 3 * parameters[j + 2];\n\t\t\t\t\tn1 = 3 * parameters[j + 3];\n\t\t\t\t\tn2 = 3 * parameters[j + 4];\n\t\t\t\t\tn3 = 3 * parameters[j + 5];\n\t\t\t\t\tu1 = 2 * parameters[j + 6];\n\t\t\t\t\tu2 = 2 * parameters[j + 7];\n\t\t\t\t\tu3 = 2 * parameters[j + 8];\n\t\t\t\t\t\n\t\t\t\t\tlastVertex = geometry.vertices.length;\n\t\t\t\t\tlastFace = geometry.faces.length;\n\t\t\t\t\t\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v1 + 0], vertices[v1 + 1], vertices[v1 + 2]));\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v2 + 0], vertices[v2 + 1], vertices[v2 + 2]));\n\t\t\t\t\tgeometry.vertices.push (new JSM.THREE.Vector3 (vertices[v3 + 0], vertices[v3 + 1], vertices[v3 + 2]));\n\t\t\t\t\tgeometry.faces.push (new JSM.THREE.Face3 (lastVertex + 0, lastVertex + 1, lastVertex + 2));\n\n\t\t\t\t\tvertexNormals = [];\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n1 + 0], normals[n1 + 1], normals[n1 + 2]));\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n2 + 0], normals[n2 + 1], normals[n2 + 2]));\n\t\t\t\t\tvertexNormals.push (new JSM.THREE.Vector3 (normals[n3 + 0], normals[n3 + 1], normals[n3 + 2]));\n\t\t\t\t\tgeometry.faces[lastFace].vertexNormals = vertexNormals;\n\n\t\t\t\t\tif (textureName !== undefined && textureName !== null) {\n\t\t\t\t\t\ttextureUVs = [];\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u1 + 0], uvs[u1 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u2 + 0], uvs[u2 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\ttextureUVs.push (GetTextureCoordinate (uvs[u3 + 0], uvs[u3 + 1], textureOffset, textureScale, textureRotation));\n\t\t\t\t\t\tgeometry.faceVertexUvs[0].push (textureUVs);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar mesh = new JSM.THREE.Mesh (geometry, material);\n\t\t\t\tmesh.originalJsonMaterialIndex = materialIndex;\n\t\t\t\tmesh.originalJsonMeshIndex = meshIndex;\n\t\t\t\tresultMeshes.push (mesh);\n\t\t\t}\n\n\t\t\tvar vertices = mesh.vertices;\n\t\t\tif (vertices === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar normals = mesh.normals;\n\t\t\tif (normals === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar uvs = mesh.uvs;\n\t\t\tif (uvs === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tvar triangles = mesh.triangles;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\tAddTriangles (triangles[i], vertices, normals, uvs, materials, resultMeshes);\n\t\t\t}\n\t\t}\n\n\t\tvar resultMeshes = [];\n\n\t\tvar materials = jsonData.materials;\n\t\tif (materials === undefined) {\n\t\t\treturn resultMeshes;\n\t\t}\n\t\t\n\t\tvar meshes = jsonData.meshes;\n\t\tif (meshes === undefined) {\n\t\t\treturn resultMeshes;\n\t\t}\n\t\t\n\t\tvar i = 0;\n\t\tJSM.AsyncRunTask (\n\t\t\tfunction () {\n\t\t\t\tAddMesh (meshes[i], i, materials, resultMeshes);\n\t\t\t\ti = i + 1;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tasyncCallbacks,\n\t\t\tmeshes.length, 0, resultMeshes\n\t\t);\n\n\t\treturn resultMeshes;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/extensions/threeviewer/threeviewer',[\"../../core/jsm\"],function(JSM){\n\tJSM.ThreeViewer = function ()\n\t{\n\t\tthis.canvas = null;\n\t\t\n\t\tthis.scene = null;\n\t\tthis.camera = null;\n\t\tthis.renderer = null;\n\t\tthis.ambientLight = null;\n\t\tthis.directionalLight = null;\n\t\tthis.runBeforeRender = null;\n\t\tthis.runAfterRender = null;\n\n\t\tthis.cameraMove = null;\n\t\tthis.navigation = null;\n\t\tthis.settings = null;\n\t\tthis.drawLoop = null;\n\t\tthis.enableDraw = null;\n\t};\n\n\tJSM.ThreeViewer.prototype.Start = function (canvas, settings)\n\t{\n\t\tif (!JSM.IsWebGLEnabled ()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitSettings (settings)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.InitThree (canvas)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitCamera (settings)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.InitLights ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.drawLoop = false;\n\t\tthis.enableDraw = true;\n\t\tthis.DrawIfNeeded ();\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitSettings = function (settings)\n\t{\n\t\tthis.settings = {\n\t\t\tcameraEyePosition : new JSM.Coord (1.0, 1.0, 1.0),\n\t\t\tcameraCenterPosition : new JSM.Coord (0.0, 0.0, 0.0),\n\t\t\tcameraUpVector : new JSM.Coord (0.0, 0.0, 1.0),\n\t\t\tlightAmbientColor : [0.5, 0.5, 0.5],\n\t\t\tlightDiffuseColor : [0.5, 0.5, 0.5]\n\t\t};\n\n\t\tif (settings !== undefined) {\n\t\t\tif (settings.cameraEyePosition !== undefined) { this.settings.cameraEyePosition = JSM.CoordFromArray (settings.cameraEyePosition); }\n\t\t\tif (settings.cameraCenterPosition !== undefined) { this.settings.cameraCenterPosition = JSM.CoordFromArray (settings.cameraCenterPosition); }\n\t\t\tif (settings.cameraUpVector !== undefined) { this.settings.cameraUpVector = JSM.CoordFromArray (settings.cameraUpVector); }\n\t\t\tif (settings.lightAmbientColor !== undefined) { this.settings.lightAmbientColor = settings.lightAmbientColor; }\n\t\t\tif (settings.lightDiffuseColor !== undefined) { this.settings.lightDiffuseColor = settings.lightDiffuseColor; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitThree = function (canvas)\n\t{\n\t\tthis.canvas = canvas;\n\t\tif (!this.canvas || !this.canvas.getContext) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.scene = new JSM.THREE.Scene();\n\t\tif (!this.scene) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar parameters = {\n\t\t\tcanvas : this.canvas,\n\t\t\tantialias : true\n\t\t};\n\t\tthis.renderer = new JSM.THREE.WebGLRenderer (parameters);\n\t\tif (!this.renderer) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.renderer.setClearColor (new JSM.THREE.Color (0xffffff));\n\t\tthis.renderer.setSize (this.canvas.width, this.canvas.height);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitCamera = function (settings)\n\t{\n\t\tthis.cameraMove = new JSM.Camera (\n\t\t\tJSM.CoordFromArray (settings.cameraEyePosition),\n\t\t\tJSM.CoordFromArray (settings.cameraCenterPosition),\n\t\t\tJSM.CoordFromArray (settings.cameraUpVector),\n\t\t\tsettings.fieldOfView,\n\t\t\tsettings.nearClippingPlane,\n\t\t\tsettings.farClippingPlane\n\t\t);\n\t\tif (!this.cameraMove) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.navigation = new JSM.Navigation ();\n\t\tif (!this.navigation.Init (this.canvas, this.cameraMove, this.DrawIfNeeded.bind (this), this.Resize.bind (this))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.camera = new JSM.THREE.PerspectiveCamera (this.cameraMove.fieldOfView, this.canvas.width / this.canvas.height, this.cameraMove.nearClippingPlane, this.cameraMove.farClippingPlane);\n\t\tif (!this.camera) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.scene.add (this.camera);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.InitLights = function ()\n\t{\n\t\tvar ambientColor = new JSM.THREE.Color ();\n\t\tvar diffuseColor = new JSM.THREE.Color ();\n\t\tambientColor.setRGB (this.settings.lightAmbientColor[0], this.settings.lightAmbientColor[1], this.settings.lightAmbientColor[2]);\n\t\tdiffuseColor.setRGB (this.settings.lightDiffuseColor[0], this.settings.lightDiffuseColor[1], this.settings.lightDiffuseColor[2]);\n\n\t\tthis.ambientLight = new JSM.THREE.AmbientLight (ambientColor.getHex ());\n\t\tif (!this.ambientLight) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.scene.add (this.ambientLight);\n\t\t\n\t\tthis.directionalLight = new JSM.THREE.DirectionalLight (diffuseColor.getHex ());\n\t\tif (!this.directionalLight) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar lightPosition = new JSM.THREE.Vector3 ().subVectors (this.cameraMove.eye, this.cameraMove.center);\n\t\tthis.directionalLight.position.set (lightPosition.x, lightPosition.y, lightPosition.z);\n\n\t\tthis.scene.add (this.directionalLight);\n\t\treturn true;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetRunBeforeRender = function (runBeforeRender)\n\t{\n\t\tthis.runBeforeRender = runBeforeRender;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetRunAfterRender = function (runAfterRender)\n\t{\n\t\tthis.runAfterRender = runAfterRender;\n\t};\n\n\tJSM.ThreeViewer.prototype.SetClearColor = function (color)\n\t{\n\t\tthis.renderer.setClearColor (new JSM.THREE.Color (color));\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AddMesh = function (mesh)\n\t{\n\t\tthis.scene.add (mesh);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AddMeshes = function (meshes)\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < meshes.length; i++) {\n\t\t\tthis.scene.add (meshes[i]);\n\t\t}\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.MeshCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.VisibleMeshCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsVisibleObject (current)) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.VertexCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tcount = count + current.geometry.vertices.length;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.FaceCount = function ()\n\t{\n\t\tvar count = 0;\n\t\t\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (current instanceof JSM.THREE.Mesh) {\n\t\t\t\tcount = count + current.geometry.faces.length;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn count;\n\t};\n\n\tJSM.ThreeViewer.prototype.GetMesh = function (index)\n\t{\n\t\tvar current = null;\n\t\tvar currIndex = 0;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < this.scene.children.length; i++) {\n\t\t\tcurrent = this.scene.children[i];\n\t\t\tif (this.IsRelevantObject (current)) {\n\t\t\t\tif (currIndex == index) {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\tcurrIndex = currIndex + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\n\tJSM.ThreeViewer.prototype.ShowMesh = function (mesh)\n\t{\n\t\tmesh.visible = true;\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.HideMesh = function (mesh)\n\t{\n\t\tmesh.visible = false;\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveMesh = function (mesh)\n\t{\n\t\tmesh.geometry.dispose ();\n\t\tthis.scene.remove (mesh);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveMeshes = function ()\n\t{\n\t\tvar current;\n\t\tvar i;\n\t\tfor (i = 0; i < this.scene.children.length; i++) {\n\t\t\tcurrent = this.scene.children[i];\n\t\t\tif (this.IsRelevantObject (current)) {\n\t\t\t\tcurrent.geometry.dispose ();\n\t\t\t\tthis.scene.remove (current);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.RemoveLastMesh = function ()\n\t{\n\t\tvar found = null;\n\t\t\n\t\tvar myThis = this;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (myThis.IsRelevantObject (current)) {\n\t\t\t\tfound = current;\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (found !== null) {\n\t\t\tthis.scene.remove (found);\n\t\t}\n\t\t\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.SetCamera = function (eye, center, up)\n\t{\n\t\tthis.navigation.SetCamera (eye, center, up);\n\t\tthis.navigation.SetOrbitCenter (center.Clone ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.Resize = function ()\n\t{\n\t\tthis.camera.aspect = this.canvas.width / this.canvas.height;\n\t\tthis.camera.updateProjectionMatrix ();\n\t\tthis.renderer.setSize (this.canvas.width, this.canvas.height);\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.FitInWindow = function ()\n\t{\n\t\tif (this.VisibleMeshCount () === 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.FitMeshesInWindow = function (meshes)\n\t{\n\t\tif (meshes.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar sphere = this.GetFilteredBoundingSphere (function (obj) {\n\t\t\treturn meshes.indexOf (obj) != -1;\n\t\t});\n\t\tthis.navigation.FitInWindow (sphere.GetCenter (), sphere.GetRadius ());\n\t\tthis.DrawIfNeeded ();\n\t};\n\n\tJSM.ThreeViewer.prototype.AdjustClippingPlanes = function (radiusLimit)\n\t{\n\t\tvar sphere = this.GetBoundingSphere ();\n\t\tif (sphere.GetRadius () < radiusLimit) {\n\t\t\tthis.camera.near = 0.1;\n\t\t\tthis.camera.far = 1000.0;\n\t\t} else {\n\t\t\tthis.camera.near = 10.0;\n\t\t\tthis.camera.far = 1000000.0;\n\t\t}\n\t\tthis.camera.updateProjectionMatrix ();\n\t\tthis.Draw ();\n\t};\n\n\tJSM.ThreeViewer.prototype.GetCenter = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredCenter (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetBoundingBox = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredBoundingBox (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetBoundingSphere = function ()\n\t{\n\t\tvar myThis = this;\n\t\treturn this.GetFilteredBoundingSphere (function (obj) {\n\t\t\treturn myThis.IsVisibleObject (obj);\n\t\t});\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredCenter = function (needToProcess)\n\t{\n\t\tvar boundingBox = this.GetFilteredBoundingBox (needToProcess);\n\t\treturn boundingBox.GetCenter ();\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredBoundingBox = function (needToProcess)\n\t{\n\t\tvar min = new JSM.Coord (JSM.Inf, JSM.Inf, JSM.Inf);\n\t\tvar max = new JSM.Coord (-JSM.Inf, -JSM.Inf, -JSM.Inf);\n\t\t\n\t\tvar geometry, coord;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (needToProcess (current)) {\n\t\t\t\tgeometry = current.geometry;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < geometry.vertices.length; j++) {\n\t\t\t\t\tcoord = geometry.vertices[j].clone ();\n\t\t\t\t\tcoord.add (current.position);\n\t\t\t\t\tmin.x = JSM.Minimum (min.x, coord.x);\n\t\t\t\t\tmin.y = JSM.Minimum (min.y, coord.y);\n\t\t\t\t\tmin.z = JSM.Minimum (min.z, coord.z);\n\t\t\t\t\tmax.x = JSM.Maximum (max.x, coord.x);\n\t\t\t\t\tmax.y = JSM.Maximum (max.y, coord.y);\n\t\t\t\t\tmax.z = JSM.Maximum (max.z, coord.z);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new JSM.Box (min, max);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetFilteredBoundingSphere = function (needToProcess)\n\t{\n\t\tvar center = this.GetFilteredCenter (needToProcess);\n\t\tvar radius = 0.0;\n\n\t\tvar geometry, coord, distance;\n\t\tthis.scene.traverse (function (current) {\n\t\t\tif (needToProcess (current)) {\n\t\t\t\tgeometry = current.geometry;\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < geometry.vertices.length; j++) {\n\t\t\t\t\tcoord = geometry.vertices[j].clone ();\n\t\t\t\t\tcoord.add (current.position);\n\t\t\t\t\tdistance = center.DistanceTo (new JSM.Coord (coord.x, coord.y, coord.z));\n\t\t\t\t\tif (JSM.IsGreater (distance, radius)) {\n\t\t\t\t\t\tradius = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar sphere = new JSM.Sphere (center, radius);\n\t\treturn sphere;\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderPosition = function (x, y)\n\t{\n\t\tvar mouseX = (x / this.canvas.width) * 2 - 1;\n\t\tvar mouseY = -(y / this.canvas.height) * 2 + 1;\n\n\t\tvar cameraPosition = this.camera.position;\n\t\tvar vector = new JSM.THREE.Vector3 (mouseX, mouseY, 0.5);\n\t\tvector.unproject (this.camera);\n\t\tvector.sub (cameraPosition);\n\t\tvector.normalize ();\n\n\t\tvar ray = new JSM.THREE.Raycaster (cameraPosition, vector);\n\t\treturn ray.intersectObjects (this.scene.children);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderMouse = function ()\n\t{\n\t\treturn this.GetObjectsUnderPosition (this.navigation.mouse.curr.x, this.navigation.mouse.curr.y);\n\t};\n\n\tJSM.ThreeViewer.prototype.GetObjectsUnderTouch = function ()\n\t{\n\t\treturn this.GetObjectsUnderPosition (this.navigation.touch.curr.x, this.navigation.touch.curr.y);\n\t};\n\n\tJSM.ThreeViewer.prototype.ProjectVector = function (x, y, z)\n\t{\n\t\tvar width = this.canvas.width;\n\t\tvar height = this.canvas.height;\n\t\tvar halfWidth = width / 2;\n\t\tvar halfHeight = height / 2;\n\n\t\tvar vector = new JSM.THREE.Vector3 (x, y, z);\n\t\tvector.project (this.camera);\n\t\tvector.x = (vector.x * halfWidth) + halfWidth;\n\t\tvector.y = -(vector.y * halfHeight) + halfHeight;\n\t\treturn vector;\n\t};\n\n\tJSM.ThreeViewer.prototype.EnableDraw = function (enable)\n\t{\n\t\tthis.enableDraw = enable;\n\t};\n\n\tJSM.ThreeViewer.prototype.Draw = function ()\n\t{\n\t\tif (!this.enableDraw) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.runBeforeRender !== null) {\n\t\t\tthis.runBeforeRender ();\n\t\t}\n\n\t\tthis.camera.position.set (this.cameraMove.eye.x, this.cameraMove.eye.y, this.cameraMove.eye.z);\n\t\tthis.camera.up.set (this.cameraMove.up.x, this.cameraMove.up.y, this.cameraMove.up.z);\n\t\tthis.camera.lookAt (new JSM.THREE.Vector3 (this.cameraMove.center.x, this.cameraMove.center.y, this.cameraMove.center.z));\n\n\t\tvar lightPosition = new JSM.THREE.Vector3 ().subVectors (this.cameraMove.eye, this.cameraMove.center);\n\t\tthis.directionalLight.position.set (lightPosition.x, lightPosition.y, lightPosition.z);\n\n\t\tthis.renderer.render (this.scene, this.camera);\n\t\t\n\t\tif (this.runAfterRender !== null) {\n\t\t\tthis.runAfterRender ();\n\t\t}\n\t\t\n\t\tif (this.drawLoop) {\n\t\t\trequestAnimationFrame (this.Draw.bind (this));\n\t\t}\n\t};\n\n\tJSM.ThreeViewer.prototype.DrawIfNeeded = function ()\n\t{\n\t\tif (!this.drawLoop) {\n\t\t\tthis.Draw ();\n\t\t}\n\t};\n\n\tJSM.ThreeViewer.prototype.StartDrawLoop = function ()\n\t{\n\t\tthis.drawLoop = true;\n\t\tthis.Draw ();\n\t};\n\n\tJSM.ThreeViewer.prototype.IsRelevantObject = function (threeObj)\n\t{\n\t\treturn (threeObj instanceof JSM.THREE.Mesh || threeObj instanceof JSM.THREE.LineSegments || threeObj instanceof JSM.THREE.Points);\n\t};\n\n\tJSM.ThreeViewer.prototype.IsVisibleObject = function (threeObj)\n\t{\n\t\treturn this.IsRelevantObject (threeObj) && threeObj.visible;\n\t};\n\n\treturn JSM;\n});\n\ndefine('skylark-jsmodeler/main',[\r\n\t\"skylark-langx/skylark\",\r\n\t\"./core/jsm\",\r\n\t\"./core/timer\",\r\n\t\"./core/algorithm\",\r\n\t\"./core/async\",\r\n\t\"./core/check\",\r\n\t\"./core/jsonloader\",\r\n\t\"./geometry/definitions\",\r\n\t\"./geometry/coord2d\",\r\n\t\"./geometry/coord\",\r\n\t\"./geometry/determinant\",\r\n\t\"./geometry/coordutils\",\r\n\t\"./geometry/matrix\",\r\n\t\"./geometry/coordsystem\",\r\n\t\"./geometry/sector\",\r\n\t\"./geometry/line\",\r\n\t\"./geometry/box\",\r\n\t\"./geometry/sphere\",\r\n\t\"./geometry/transformation\",\r\n\t\"./geometry/plane\",\r\n\t\"./geometry/projection\",\r\n\t\"./geometry/convexhull\",\r\n\t\"./geometry/polygon2d\",\r\n\t\"./geometry/polygon\",\r\n\t\"./geometry/cutpolygon\",\r\n\t\"./geometry/triangulation\",\r\n\t\"./geometry/octree\",\r\n\t\"./geometry/bsptree\",\r\n\t\"./geometry/curves\",\r\n\t\"./geometry/utilities\",\r\n\t\"./geometry/ray\",\r\n\t\"./geometry/path\",\r\n\t\"./modeler/color\",\r\n\t\"./modeler/material\",\r\n\t\"./modeler/materialset\",\r\n\t\"./modeler/body\",\r\n\t\"./modeler/model\",\r\n\t\"./modeler/adjacencyinfo\",\r\n\t\"./modeler/bodyutils\",\r\n\t\"./modeler/textureutils\",\r\n\t\"./modeler/cututils\",\r\n\t\"./modeler/generator\",\r\n\t\"./modeler/camera\",\r\n\t\"./modeler/explode\",\r\n\t\"./modeler/exporter\",\r\n\t\"./modeler/trianglebody\",\r\n\t\"./modeler/trianglemodel\",\r\n\t\"./modeler/converter\",\r\n\t\"./modeler/rayutils\",\r\n\t\"./import/binaryreader\",\r\n\t\"./import/importerutils\",\r\n\t\"./import/importer3ds\",\r\n\t\"./import/importerobj\",\r\n\t\"./import/importerstl\",\r\n\t\"./import/importeroff\",\r\n\t\"./import/importercommon\",\r\n\t\"./renderer/webglutils\",\r\n\t\"./renderer/renderlight\",\r\n\t\"./renderer/rendermaterial\",\r\n\t\"./renderer/rendermesh\",\r\n\t\"./renderer/renderbody\",\r\n\t\"./renderer/shaderprogram\",\r\n\t\"./renderer/renderer\",\r\n\t\"./renderer/pointcloudrenderer\",\r\n\t\"./renderer/renderconverter\",\r\n\t\"./viewer/mouse\",\r\n\t\"./viewer/touch\",\r\n\t\"./viewer/painter\",\r\n\t\"./viewer/drawing\",\r\n\t\"./viewer/navigation\",\r\n\t\"./viewer/softwareviewer\",\r\n\t\"./viewer/spriteviewer\",\r\n\t\"./viewer/viewer\",\r\n\t\"./viewer/pointcloudviewer\",\r\n\t\"./extras/solidgenerator\",\r\n\t\"./extras/extgenerator\",\r\n\t\"./extras/subdivision\",\r\n\t\"./extras/csg\",\r\n\t\"./extras/surfaces\",\r\n\t\"./extensions/svgtomodel/svgtomodel\",\r\n\t\"./extensions/textgenerator/textgenerator\",\r\n\t\"./extensions/threeviewer/threeconverter\",\r\n\t\"./extensions/threeviewer/threeviewer\"\r\n\r\n],function(skylark,jsm){\r\n\treturn skylark.attach(\"intg.jsmodeler\",jsm);\r\n});\ndefine('skylark-jsmodeler', ['skylark-jsmodeler/main'], function (main) { return main; });\n\n"]}