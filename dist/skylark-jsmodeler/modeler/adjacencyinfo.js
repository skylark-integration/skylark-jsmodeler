/**
 * skylark-jsmodeler - A version of jsmodeler that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-jsmodeler/
 * @license MIT
 */
define(["../core/jsm"],function(e){return e.VertInfo=function(){this.edges=[],this.pgons=[]},e.EdgeInfo=function(){this.vert1=-1,this.vert2=-1,this.pgon1=-1,this.pgon2=-1},e.PolyEdgeInfo=function(){this.index=-1,this.reverse=!1},e.PgonInfo=function(){this.verts=[],this.pedges=[]},e.AdjacencyInfo=function(e){this.verts=null,this.edges=null,this.pgons=null,this.Calculate(e)},e.AdjacencyInfo.prototype.Calculate=function(n){function t(n,t,o){function r(n,t,o,r,s){var g,d,i=new e.PolyEdgeInfo;for(g=0;g<n.edges.length;g++)(d=n.edges[g]).vert1===o&&d.vert2===r?(i.index=g,i.reverse=!1):d.vert1===r&&d.vert2===o&&(i.index=g,i.reverse=!0);if(-1===i.index){var f=new e.EdgeInfo;f.vert1=o,f.vert2=r,f.pgon1=s,f.pgon2=-1,n.edges.push(f),i.index=n.edges.length-1,i.reverse=!1}else{var p=n.edges[i.index];-1===p.pgon1?p.pgon1=s:p.pgon1!==s&&-1===p.pgon2&&(p.pgon2=s)}!function(e,n,t,o,r,s){function g(e,n,t){-1==e.edges.indexOf(t)&&e.edges.push(t),-1==e.pgons.indexOf(n)&&e.pgons.push(n)}s.verts.push(t),s.pedges.push(r),g(e.verts[t],n,r.index),g(e.verts[o],n,r.index)}(n,s,o,r,i,t)}var s,g=t.GetPolygon(o),d=new e.PgonInfo,i=g.VertexIndexCount();for(s=0;s<i;s++)r(n,d,g.GetVertexIndex(s),g.GetVertexIndex(s<i-1?s+1:0),o);n.pgons.push(d)}var o,r,s;for(this.verts=[],this.edges=[],this.pgons=[],o=0;o<n.VertexCount();o++)r=this,void 0,s=new e.VertInfo,r.verts.push(s);for(o=0;o<n.PolygonCount();o++)t(this,n,o)},e.AdjacencyInfo.prototype.IsContourVertex=function(e){var n,t;for(n=0;n<e.edges.length;n++)if(t=e.edges[n],this.IsContourEdge(this.edges[t]))return!0;return!1},e.AdjacencyInfo.prototype.IsContourEdge=function(e){return 1==this.GetEdgePolygonCount(e)},e.AdjacencyInfo.prototype.GetEdgePolygonCount=function(e){var n=0;return-1!=e.pgon1&&(n+=1),-1!=e.pgon2&&(n+=2),n},e.AdjacencyInfo.prototype.GetAnotherPgonOfEdge=function(e,n){return-1!=e.pgon1&&e.pgon1!=n?e.pgon1:-1!=e.pgon2&&e.pgon2!=n?e.pgon2:-1},e.AdjacencyInfo.prototype.GetPolyEdgeStartVertex=function(e){return e.reverse?this.edges[e.index].vert2:this.edges[e.index].vert1},e.AdjacencyInfo.prototype.GetPolyEdgeEndVertex=function(e){return e.reverse?this.edges[e.index].vert1:this.edges[e.index].vert2},e.CalculateBodyVertexToPolygon=function(e){var n,t,o,r=[];for(n=0;n<e.VertexCount();n++)r.push([]);for(n=0;n<e.PolygonCount();n++)for(o=e.GetPolygon(n),t=0;t<o.VertexIndexCount();t++)r[o.GetVertexIndex(t)].push(n);return r},e.IsSolidBody=function(n){var t,o,r=new e.AdjacencyInfo(n);if(0===r.edges.length)return!1;for(t=0;t<r.edges.length;t++)if(-1===(o=r.edges[t]).pgon1||-1===o.pgon2)return!1;return!0},e.CheckSolidBody=function(n){var t,o,r,s,g,d,i,f,p,u=new e.AdjacencyInfo(n);for(t=0;t<u.edges.length;t++){if(-1===(r=u.edges[t]).pgon1||-1===r.pgon2)return!1;for(d=u.pgons[r.pgon1],g=!1,o=0;o<d.pedges.length;o++)if((s=d.pedges[o]).index==t){f=s.reverse,g=!0;break}if(!g)return!1;for(i=u.pgons[r.pgon2],g=!1,o=0;o<i.pedges.length;o++)if((s=i.pedges[o]).index==t){p=s.reverse,g=!0;break}if(!g)return!1;if(f==p)return!1}return!0},e.TraversePgonsAlongEdges=function(e,n,t){function o(e,n,t){var o,r,s,g=n.pgons[e];for(o=0;o<g.pedges.length;o++)r=n.edges[g.pedges[o].index],-1!=(s=n.GetAnotherPgonOfEdge(r,e))&&t.push(s)}for(var r,s={},g=[e];g.length>0;)s[r=g.pop()]||(s[r]=!0,t(r)&&o(r,n,g))},e});
//# sourceMappingURL=../sourcemaps/modeler/adjacencyinfo.js.map
