{"version":3,"sources":["extras/extgenerator.js"],"names":["define","JSM","LegoDimensions","this","legoWidth","legoSmallHeight","legoLargeHeight","legoWallWidth","legoCylinderWidth","legoCylinderHeight","legoBottomSmallCylinderWidth","legoBottomLargeCylinderWidth","legoBottomLargeCylinderWallWidth","GenerateLegoBrick","rows","columns","isLarge","hasTopCylinders","hasBottomCylinders","segmentation","isCurved","OffsetBody","body","offset","i","vertex","VertexCount","GetVertex","position","CoordAdd","legoDimensions","normal","Vector","unitWidth","unitHeight","wallWidth","topCylinderWidth","topCylinderHeight","bottomSmallCylinderWidth","bottomLargeCylinderWidth","bottomLargeCylinderWallWidth","basePolygon","push","Coord","j","result","Body","walls","GeneratePrismShell","Merge","z","cylinderCenter","cylinder","bigger","columnWise","top","GeneratePrism","GenerateCylinder","GenerateCylinderShell","SetCubicTextureProjection","GenerateConvexHullBody","coords","current","index","newPolygon","convexHull","ConvexHull3D","oldToNewIndexTable","length","AddVertex","BodyVertex","AddPolygon","BodyPolygon","GenerateSuperShape","aLon","bLon","mLon","n1Lon","n2Lon","n3Lon","aLat","bLat","mLat","n1Lat","n2Lat","n3Lat","CartesianToSpherical","coord","radius","Math","sqrt","x","y","asin","atan2","CalculateSuperFormula","p","a","b","m","n1","n2","n3","abs1","abs","cos","abs2","sin","pow","CalculateSuperFormulaCoordinate","phi","theta","rPhi","rTheta","spherical","newCoord","GenerateSphere","SetPosition"],"mappings":"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","file":"../../extras/extgenerator.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: LegoDimensions\n\t* Description: Class that contains lego brick dimensions.\n\t*/\n\tJSM.LegoDimensions = function ()\n\t{\n\t\tthis.legoWidth = 0.78;\n\t\tthis.legoSmallHeight = 0.32;\n\t\tthis.legoLargeHeight = 0.96;\n\t\tthis.legoWallWidth = 0.16;\n\t\tthis.legoCylinderWidth = 0.5;\n\t\tthis.legoCylinderHeight = 0.17;\n\t\tthis.legoBottomSmallCylinderWidth = 0.3;\n\t\tthis.legoBottomLargeCylinderWidth = 0.6;\n\t\tthis.legoBottomLargeCylinderWallWidth = 0.1;\n\t};\n\n\t/**\n\t* Function: GenerateLegoBrick\n\t* Description: Generates a lego brick.\n\t* Parameters:\n\t*\trows {integer} the row count\n\t*\tcolumns {integer} the columns count\n\t*\tisLarge {boolean} the brick is large\n\t*\thasTopCylinders {boolean} the brick has top cylinders\n\t*\thasBottomCylinders {boolean} the brick has bottom cylinders\n\t*\tsegmentation {integer} the segmentation of cylinders\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLegoBrick = function (rows, columns, isLarge, hasTopCylinders, hasBottomCylinders, segmentation, isCurved)\n\t{\n\t\tfunction OffsetBody (body, offset)\n\t\t{\n\t\t\tvar i, vertex;\n\t\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\t\tvertex = body.GetVertex (i);\n\t\t\t\tvertex.position = JSM.CoordAdd (vertex.position, offset);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar legoDimensions = new JSM.LegoDimensions ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar unitWidth = legoDimensions.legoWidth;\n\t\tvar unitHeight = legoDimensions.legoLargeHeight;\n\t\tif (!isLarge) {\n\t\t\tunitHeight = legoDimensions.legoSmallHeight;\n\t\t}\n\t\tvar wallWidth = legoDimensions.legoWallWidth;\n\t\tvar topCylinderWidth = legoDimensions.legoCylinderWidth;\n\t\tvar topCylinderHeight = legoDimensions.legoCylinderHeight;\n\t\tvar bottomSmallCylinderWidth = legoDimensions.legoBottomSmallCylinderWidth;\n\t\tvar bottomLargeCylinderWidth = legoDimensions.legoBottomLargeCylinderWidth;\n\t\tvar bottomLargeCylinderWallWidth = legoDimensions.legoBottomLargeCylinderWallWidth;\n\n\t\tvar basePolygon = [];\n\t\tbasePolygon.push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, 0.0, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (unitWidth * rows, unitWidth * columns, 0.0));\n\t\tbasePolygon.push (new JSM.Coord (0.0, unitWidth * columns, 0.0));\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar walls = JSM.GeneratePrismShell (basePolygon, normal, unitHeight - wallWidth, wallWidth, true);\n\t\tresult.Merge (walls);\n\t\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbasePolygon[i].z = unitHeight - wallWidth;\n\t\t}\n\t\t\n\t\tvar top = JSM.GeneratePrism (basePolygon, normal, wallWidth, true, null);\n\t\tresult.Merge (top);\n\t\t\n\t\tvar cylinderCenter, cylinder;\n\t\tif (hasTopCylinders) {\n\t\t\tfor (i = 0; i < rows; i++) {\n\t\t\t\tfor (j = 0; j < columns; j++) {\n\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * i + unitWidth / 2.0, unitWidth * j + unitWidth / 2.0, unitHeight + topCylinderHeight / 2.0);\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (topCylinderWidth / 2.0, topCylinderHeight, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasBottomCylinders) {\n\t\t\tvar circle, bigger, columnWise;\n\t\t\tif ((rows === 1 && columns > 1) || (columns === 1 && rows > 1)) {\n\t\t\t\tbigger = columns;\n\t\t\t\tcolumnWise = true;\n\t\t\t\tif (rows > columns) {\n\t\t\t\t\tbigger = rows;\n\t\t\t\t\tcolumnWise = false;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < bigger - 1; i++) {\n\t\t\t\t\tif (columnWise) {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth / 2.0, unitWidth * (i + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth / 2.0, (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t}\n\t\t\t\t\tcylinder = JSM.GenerateCylinder (bottomSmallCylinderWidth / 2.0, unitHeight - wallWidth, segmentation, true, isCurved);\n\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t}\n\t\t\t} else if (rows > 1 && columns > 1) {\n\t\t\t\tfor (i = 0; i < rows - 1; i++) {\n\t\t\t\t\tfor (j = 0; j < columns - 1; j++) {\n\t\t\t\t\t\tcircle = [];\n\t\t\t\t\t\tcylinderCenter = new JSM.Coord (unitWidth * (i + 1), unitWidth * (j + 1), (unitHeight - wallWidth) / 2.0);\n\t\t\t\t\t\tcylinder = JSM.GenerateCylinderShell (bottomLargeCylinderWidth / 2.0, unitHeight - wallWidth, bottomLargeCylinderWallWidth, segmentation, true, isCurved);\n\t\t\t\t\t\tOffsetBody (cylinder, cylinderCenter);\n\t\t\t\t\t\tresult.Merge (cylinder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateConvexHullBody\n\t* Description: Generates a convex hull body from the given coordinates.\n\t* Parameters:\n\t*\tcoord {Coord[*]} the coordinates\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateConvexHullBody = function (coords)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar convexHull = JSM.ConvexHull3D (coords);\n\t\t\n\t\tvar oldToNewIndexTable = {};\n\t\tvar i, j, current, index;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tif (!(index in oldToNewIndexTable)) {\n\t\t\t\t\toldToNewIndexTable[index] = result.VertexCount ();\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coords[index]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar newPolygon;\n\t\tfor (i = 0; i < convexHull.length; i++) {\n\t\t\tcurrent = convexHull[i];\n\t\t\tnewPolygon = [];\n\t\t\tfor (j = 0; j < current.length; j++) {\n\t\t\t\tindex = current[j];\n\t\t\t\tnewPolygon.push (oldToNewIndexTable[index]);\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon (newPolygon));\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSuperShape\n\t* Description: Generates a supershape.\n\t* Parameters:\n\t*\tparameters {12 numbers} the supershape parameters\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSuperShape = function (\taLon, bLon, mLon, n1Lon, n2Lon, n3Lon,\n\t\t\t\t\t\t\t\t\t\taLat, bLat, mLat, n1Lat, n2Lat, n3Lat,\n\t\t\t\t\t\t\t\t\t\tsegmentation, isCurved)\n\t{\n\t\tfunction CartesianToSpherical (coord)\n\t\t{\n\t\t\tvar radius = Math.sqrt (coord.x * coord.x + coord.y * coord.y + coord.z * coord.z);\n\t\t\tvar phi = Math.asin (coord.z / radius);\n\t\t\tvar theta = Math.atan2 (coord.y, coord.x);\n\t\t\treturn [radius, phi, theta];\n\t\t}\n\n\t\tfunction CalculateSuperFormula (p, a, b, m, n1, n2, n3)\n\t\t{\n\t\t\tvar abs1 = Math.abs (Math.cos (m * p / 4.0) / a);\n\t\t\tvar abs2 = Math.abs (Math.sin (m * p / 4.0) / b);\n\t\t\treturn Math.pow (Math.pow (abs1, n2) + Math.pow (abs2, n3), -1.0 / n1);\n\t\t}\n\n\t\tfunction CalculateSuperFormulaCoordinate (phi, theta)\n\t\t{\n\t\t\tvar coord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tvar rPhi = CalculateSuperFormula (phi, aLat, bLat, mLat, n1Lat, n2Lat, n3Lat);\n\t\t\tvar rTheta = CalculateSuperFormula (theta, aLon, bLon, mLon, n1Lon, n2Lon, n3Lon);\n\t\t\tcoord.x = rTheta * Math.cos (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.y = rTheta * Math.sin (theta) * rPhi * Math.cos (phi);\n\t\t\tcoord.z = rPhi * Math.sin (phi);\n\t\t\treturn coord;\n\t\t}\n\n\t\tvar result = JSM.GenerateSphere (1.0, segmentation, isCurved);\n\n\t\tvar i, vertex, coord, spherical, newCoord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tcoord = vertex.position;\n\t\t\tspherical = CartesianToSpherical (coord);\n\t\t\tnewCoord = CalculateSuperFormulaCoordinate (spherical[1], spherical[2]);\n\t\t\tvertex.SetPosition (newCoord);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n"]}