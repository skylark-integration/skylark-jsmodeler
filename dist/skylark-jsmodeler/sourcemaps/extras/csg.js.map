{"version":3,"sources":["extras/csg.js"],"names":["define","JSM","BooleanOperation","operation","aBody","bBody","AddPolygonToBody","polygon","body","octree","reversed","AddBodyVertex","coord","AddVertex","BodyVertex","i","vertexIndex","bodyPolygon","BodyPolygon","VertexCount","GetVertex","AddVertexIndex","undefined","userData","SetMaterialIndex","material","AddPolygon","AddPolygonsToBody","polygons","length","ClipNodePolygonsWithTree","nodes","tree","frontPolygons","backPolygons","planarFrontPolygons","planarBackPolygons","SetPolygonsUserData","node","ClipPolygonWithBSPTree","aTree","BSPTree","bTree","AddBodyToBSPTree","aFrontPolygons","aBackPolygons","aPlanarFrontPolygons","aPlanarBackPolygons","GetNodes","bFrontPolygons","bBackPolygons","bPlanarFrontPolygons","result","Body","Octree","BoxUnion","GetBoundingBox","resultOctree"],"mappings":";;;;;;;AAAAA,QAAQ,eAAe,SAASC,GA0H/B,OA/GAA,EAAIC,iBAAmB,SAAUC,EAAWC,EAAOC,GAElD,SAASC,EAAkBC,EAASC,EAAMC,EAAQC,GAEjD,SAASC,EAAeC,EAAOH,GAY9B,OAAOD,EAAKK,UAAW,IAAIZ,EAAIa,WAAYF,IAG5C,IAEIG,EAAGC,EAFHC,EAAc,IAAIhB,EAAIiB,gBAG1B,GAAKR,EAMJ,IAAKK,EAAIR,EAAQY,cAAiB,EAAGJ,GAAK,EAAGA,IAC5CC,EAAcL,EAAeJ,EAAQa,UAAWL,IAChDE,EAAYI,eAAgBL,QAP7B,IAAKD,EAAI,EAAGA,EAAIR,EAAQY,cAAgBJ,IACvCC,EAAcL,EAAeJ,EAAQa,UAAWL,IAChDE,EAAYI,eAAgBL,QASLM,IAArBf,EAAQgB,UACXN,EAAYO,iBAAkBjB,EAAQgB,SAASE,UAEhDjB,EAAKkB,WAAYT,GAGlB,SAASU,EAAmBC,EAAUpB,EAAMC,EAAQC,GAEnD,IAAIK,EACJ,IAAKA,EAAI,EAAGA,EAAIa,EAASC,OAAQd,IAChCT,EAAkBsB,EAASb,GAAIP,EAAMC,EAAQC,GAI/C,SAASoB,EAA0BC,EAAOC,EAAMC,EAAeC,EAAcC,EAAqBC,GAEjG,SAASC,EAAqBT,EAAUL,GAEvC,IAAIR,EAAGR,EACP,IAAKQ,EAAI,EAAGA,EAAIa,EAASC,OAAQd,SAEPO,KADzBf,EAAUqB,EAASb,IACPQ,WACXhB,EAAQgB,SAAWA,GAKtB,IAAIR,EAAGuB,EACP,IAAKvB,EAAI,EAAGA,EAAIgB,EAAMF,OAAQd,IAC7BuB,EAAOP,EAAMhB,GACbd,EAAIsC,uBAAwBD,EAAK/B,QAASyB,EAAMC,EAAeC,EAAcC,EAAqBC,GAClGC,EAAqBJ,EAAeK,EAAKf,UACzCc,EAAqBH,EAAcI,EAAKf,UACxCc,EAAqBF,EAAqBG,EAAKf,UAC/Cc,EAAqBD,EAAoBE,EAAKf,UAIhD,IAAIiB,EAAQ,IAAIvC,EAAIwC,QAChBC,EAAQ,IAAIzC,EAAIwC,QACpBxC,EAAI0C,iBAAkBvC,EAAOoC,EAAO,KACpCvC,EAAI0C,iBAAkBtC,EAAOqC,EAAO,KAEpC,IAAIE,KACAC,KACAC,KACAC,KACJjB,EAA0BU,EAAMQ,WAAaN,EAAOE,EAAgBC,EAAeC,EAAsBC,GAEzG,IAAIE,KACAC,KACAC,KAEJrB,EAA0BY,EAAMM,WAAaR,EAAOS,EAAgBC,EAAeC,MAEnF,IAAIC,EAAS,IAAInD,EAAIoD,KACF,IAAIpD,EAAIqD,OAAQrD,EAAIsD,SAAUnD,EAAMoD,iBAAmBnD,EAAMmD,mBAkBhF,MAhBiB,SAAbrD,GACHwB,EAAmBiB,EAAgBQ,EAAQK,GAAc,GACzD9B,EAAmBmB,EAAsBM,EAAQK,GAAc,GAC/D9B,EAAmBoB,EAAqBK,EAAQK,GAAc,GAC9D9B,EAAmBsB,EAAgBG,EAAQK,GAAc,GACzD9B,EAAmBwB,EAAsBC,EAAQK,GAAc,IACxC,cAAbtD,GACVwB,EAAmBiB,EAAgBQ,EAAQK,GAAc,GACzD9B,EAAmBmB,EAAsBM,EAAQK,GAAc,GAC/D9B,EAAmBuB,EAAeE,EAAQK,GAAc,IACjC,gBAAbtD,IACVwB,EAAmBkB,EAAeO,EAAQK,GAAc,GACxD9B,EAAmBoB,EAAqBK,EAAQK,GAAc,GAC9D9B,EAAmBuB,EAAeE,EAAQK,GAAc,IAGlDL,GAGDnD","file":"../../extras/csg.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: BooleanOperation\n\t* Description: Makes a boolean operation on the given bodies.\n\t* Parameters:\n\t*\toperation {string} the operation ('Union', 'Difference', or 'Intersection')\n\t*\taBody {Body} the first body\n\t*\tbBody {Body} the second body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.BooleanOperation = function (operation, aBody, bBody)\n\t{\n\t\tfunction AddPolygonToBody (polygon, body, octree, reversed)\n\t\t{\n\t\t\tfunction AddBodyVertex (coord, octree)\n\t\t\t{\n\t\t\t\tvar merge = false;\n\t\t\t\tif (merge) {\n\t\t\t\t\tvar index = octree.FindCoord (coord);\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\tindex = body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\toctree.AddCoord (coord);\n\t\t\t\t\t}\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn body.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t}\n\n\t\t\tvar bodyPolygon = new JSM.BodyPolygon ([]);\n\n\t\t\tvar i, vertexIndex;\n\t\t\tif (!reversed) {\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = polygon.VertexCount () - 1; i >= 0; i--) {\n\t\t\t\t\tvertexIndex = AddBodyVertex (polygon.GetVertex (i), octree);\n\t\t\t\t\tbodyPolygon.AddVertexIndex (vertexIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (polygon.userData !== undefined) {\n\t\t\t\tbodyPolygon.SetMaterialIndex (polygon.userData.material);\n\t\t\t}\n\t\t\tbody.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tfunction AddPolygonsToBody (polygons, body, octree, reversed)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tAddPolygonToBody (polygons[i], body, octree, reversed);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ClipNodePolygonsWithTree (nodes, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t\t{\n\t\t\tfunction SetPolygonsUserData (polygons, userData)\n\t\t\t{\n\t\t\t\tvar i, polygon;\n\t\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\t\tpolygon = polygons[i];\n\t\t\t\t\tif (polygon.userData === undefined) {\n\t\t\t\t\t\tpolygon.userData = userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tvar i, node;\n\t\t\tfor (i = 0; i < nodes.length; i++) {\n\t\t\t\tnode = nodes[i];\n\t\t\t\tJSM.ClipPolygonWithBSPTree (node.polygon, tree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons);\n\t\t\t\tSetPolygonsUserData (frontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (backPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarFrontPolygons, node.userData);\n\t\t\t\tSetPolygonsUserData (planarBackPolygons, node.userData);\n\t\t\t}\n\t\t}\n\n\t\tvar aTree = new JSM.BSPTree ();\n\t\tvar bTree = new JSM.BSPTree ();\n\t\tJSM.AddBodyToBSPTree (aBody, aTree, 'a');\n\t\tJSM.AddBodyToBSPTree (bBody, bTree, 'b');\n\n\t\tvar aFrontPolygons = [];\n\t\tvar aBackPolygons = [];\n\t\tvar aPlanarFrontPolygons = [];\n\t\tvar aPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (aTree.GetNodes (), bTree, aFrontPolygons, aBackPolygons, aPlanarFrontPolygons, aPlanarBackPolygons);\n\n\t\tvar bFrontPolygons = [];\n\t\tvar bBackPolygons = [];\n\t\tvar bPlanarFrontPolygons = [];\n\t\tvar bPlanarBackPolygons = [];\n\t\tClipNodePolygonsWithTree (bTree.GetNodes (), aTree, bFrontPolygons, bBackPolygons, bPlanarFrontPolygons, bPlanarBackPolygons);\n\n\t\tvar result = new JSM.Body ();\n\t\tvar resultOctree = new JSM.Octree (JSM.BoxUnion (aBody.GetBoundingBox (), bBody.GetBoundingBox ()));\n\t\t\n\t\tif (operation == 'Union') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bPlanarFrontPolygons, result, resultOctree, false);\n\t\t} else if (operation == 'Difference') {\n\t\t\tAddPolygonsToBody (aFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarFrontPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, true);\n\t\t} else if (operation == 'Intersection') {\n\t\t\tAddPolygonsToBody (aBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (aPlanarBackPolygons, result, resultOctree, false);\n\t\t\tAddPolygonsToBody (bBackPolygons, result, resultOctree, false);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n"]}