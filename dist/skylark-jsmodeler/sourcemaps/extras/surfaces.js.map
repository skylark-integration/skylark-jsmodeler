{"version":3,"sources":["extras/surfaces.js"],"names":["define","JSM","GenerateSurface","xRange","yRange","xSegmentation","ySegmentation","useTriangles","isCurved","getPointCallback","userData","result","Body","xStart","yStart","xDiff","yDiff","xSegment","ySegment","i","j","coord","AddVertex","BodyVertex","AddVertices","current","next","top","ntop","polygon","BodyPolygon","SetCurveGroup","AddPolygon","AddPolygons","SurfaceControlPoints","n","m","this","points","push","Coord","prototype","GetNValue","GetMValue","GetControlPoint","InitPlanar","xSize","ySize","point","iStep","jStep","x","y","GenerateBezierSurface","surfaceControlPoints","uIndex","vIndex","u","v","tmp1","tmp2","scalar","BernsteinPolynomial","Clone","MultiplyScalar","CoordAdd"],"mappings":"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","file":"../../extras/surfaces.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateSurface\n\t* Description: Generates a parametric surface.\n\t* Parameters:\n\t*\txRange {number[2]} the from-to range on x axis\n\t*\tyRange {number[2]} the from-to range on y axis\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tuseTriangles {boolean} generate triangles instead of quadrangles\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tgetPointCallback {function} callback function which returns the point for a position\n\t*\tuserData {anything} user data which will be passed to getPointCallback\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSurface = function (xRange, yRange, xSegmentation, ySegmentation, useTriangles, isCurved, getPointCallback, userData)\n\t{\n\t\tfunction AddVertices (result, xStart, yStart, xSegment, ySegment)\n\t\t{\n\t\t\tvar i, j, u, v, coord;\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tu = xStart + j * xSegment;\n\t\t\t\t\tv = yStart + i * ySegment;\n\t\t\t\t\tcoord = getPointCallback (i, j, u, v, userData);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (result)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\tvar polygon;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (useTriangles) {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xRange[0];\n\t\tvar yStart = yRange[0];\n\t\tvar xDiff = xRange[1] - xRange[0];\n\t\tvar yDiff = yRange[1] - yRange[0];\n\t\tvar xSegment = xDiff / xSegmentation;\n\t\tvar ySegment = yDiff / ySegmentation;\n\t\t\n\t\tAddVertices (result, xStart, yStart, xSegment, ySegment);\n\t\tAddPolygons (result);\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: SurfaceControlPoints\n\t* Description: Represents control points for surface generation.\n\t* Parameters:\n\t*\tn {integer} the first dimension\n\t*\tm {integer} the second dimension\n\t*/\n\tJSM.SurfaceControlPoints = function (n, m)\n\t{\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\tthis.points = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tthis.points.push ([]);\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tthis.points[i].push (new JSM.Coord (0.0, 0.0, 0.0));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetNValue\n\t* Description: Returns the n value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetNValue = function ()\n\t{\n\t\treturn this.n;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetMValue\n\t* Description: Returns the m value.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetMValue = function ()\n\t{\n\t\treturn this.m;\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.GetControlPoint\n\t* Description: Returns a control point.\n\t* Parameters:\n\t*\ti {integer} the first dimension\n\t*\tj {integer} the second dimension\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.SurfaceControlPoints.prototype.GetControlPoint = function (i, j)\n\t{\n\t\treturn this.points[i][j];\n\t};\n\n\t/**\n\t* Function: SurfaceControlPoints.InitPlanar\n\t* Description: Inits planar control points.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\txSize {number} the y size\n\t*/\n\tJSM.SurfaceControlPoints.prototype.InitPlanar = function (xSize, ySize)\n\t{\n\t\tvar iStep = xSize / this.n;\n\t\tvar jStep = ySize / this.m;\n\n\t\tvar i, j, point;\n\t\tfor (i = 0; i <= this.n; i++) {\n\t\t\tfor (j = 0; j <= this.m; j++) {\n\t\t\t\tpoint = this.points[i][j];\n\t\t\t\tpoint.x = i * iStep;\n\t\t\t\tpoint.y = j * jStep;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateBezierSurface\n\t* Description: Generates a bezier surface base on the given control points.\n\t* Parameters:\n\t*\tsurfaceControlPoints {SurfaceControlPoints} the control points\n\t*\txSegmentation {integer} the segmentation along the x axis\n\t*\tySegmentation {integer} the segmentation along the y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateBezierSurface = function (surfaceControlPoints, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tfunction GetBezierSurfacePoint (uIndex, vIndex, u, v, surfaceControlPoints)\n\t\t{\n\t\t\tvar i, j, result, tmp1, tmp2, scalar;\n\t\t\tvar n = surfaceControlPoints.GetNValue ();\n\t\t\tvar m = surfaceControlPoints.GetMValue ();\n\t\t\t\n\t\t\tresult = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\tfor (i = 0; i <= n; i++) {\n\t\t\t\ttmp1 = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j <= m; j++) {\n\t\t\t\t\tscalar = JSM.BernsteinPolynomial (i, n, u) * JSM.BernsteinPolynomial (j, m, v);\n\t\t\t\t\ttmp2 = surfaceControlPoints.GetControlPoint (i, j).Clone ().MultiplyScalar (scalar);\n\t\t\t\t\ttmp1 = JSM.CoordAdd (tmp1, tmp2);\n\t\t\t\t}\n\t\t\t\tresult = JSM.CoordAdd (result, tmp1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar body = JSM.GenerateSurface ([0, 1], [0, 1], xSegmentation, ySegmentation, false, isCurved, GetBezierSurfacePoint, surfaceControlPoints);\n\t\treturn body;\n\t};\n\n\treturn JSM;\n});\n"]}