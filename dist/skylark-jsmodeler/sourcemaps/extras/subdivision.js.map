{"version":3,"sources":["extras/subdivision.js"],"names":["define","JSM","CatmullClarkSubdivisionOneIteration","body","result","Body","adjacencyInfo","AdjacencyInfo","pgonVertices","edgeVertices","i","vertCoord","verts","length","GetVertexPosition","AddVertex","BodyVertex","Clone","AddOriginalVertices","j","pgon","pgonCoord","pgons","Coord","CoordAdd","MultiplyScalar","push","AddPolygonVertices","edge","edgeCoord1","edgeCoord2","edgeCoord","pgonIndex","edges","vert1","vert2","IsContourEdge","MidCoord","pgon1","pgon2","AddEdgeVertices","MoveContourVertex","newVertCoord","x","y","z","MoveVertex","pgonAverage","edgeAverage","vertEdgeCount","vert","currentVertCoord","edgeCountForAverage","edgeMidCoords","IsContourVertex","Add","MoveOriginalVertices","edgeCount","currentEdge","nextEdge","centroid","currentEdgeVertex","originalVertex","nextEdgeVertex","polygon","oldPolygon","pedges","index","GetPolyEdgeStartVertex","BodyPolygon","GetPolygon","material","curved","AddPolygon","AddNewPolygons","CatmullClarkSubdivision","iterations"],"mappings":"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","file":"../../extras/subdivision.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CatmullClarkSubdivisionOneIteration\n\t* Description: Runs one iteration of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivisionOneIteration = function (body)\n\t{\n\t\tfunction AddOriginalVertices (body, result, adjacencyInfo)\n\t\t{\n\t\t\tvar i, vertCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvertCoord = body.GetVertexPosition (i);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertCoord.Clone ()));\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tvar i, j, pgon, vertCoord, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tpgonCoord = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tfor (j = 0; j < pgon.verts.length; j++) {\n\t\t\t\t\tvertCoord = body.GetVertexPosition (pgon.verts[j]);\n\t\t\t\t\tpgonCoord = JSM.CoordAdd (pgonCoord, vertCoord);\n\t\t\t\t}\n\n\t\t\t\tpgonCoord.MultiplyScalar (1.0 / pgon.verts.length);\n\t\t\t\tpgonVertices.push (result.AddVertex (new JSM.BodyVertex (pgonCoord)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar i, j, edge, edgeCoord1, edgeCoord2, edgeCoord, pgonIndex, pgonCoord;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord1 = body.GetVertexPosition (edge.vert1);\n\t\t\t\tedgeCoord2 = body.GetVertexPosition (edge.vert2);\n\t\t\t\tif (adjacencyInfo.IsContourEdge (edge)) {\n\t\t\t\t\tedgeCoord = JSM.MidCoord (edgeCoord1, edgeCoord2);\n\t\t\t\t} else {\n\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord1, edgeCoord2);\n\t\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t\tpgonIndex = (j === 0 ? edge.pgon1 : edge.pgon2);\n\t\t\t\t\t\tpgonCoord = result.GetVertexPosition (pgonVertices[pgonIndex]);\n\t\t\t\t\t\tedgeCoord = JSM.CoordAdd (edgeCoord, pgonCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeCoord.MultiplyScalar (1.0 / 4.0);\n\t\t\t\t}\n\t\t\t\tedgeVertices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord)));\n\t\t\t}\n\t\t}\n\n\t\tfunction MoveOriginalVertices (body, result, adjacencyInfo, pgonVertices)\n\t\t{\n\t\t\tfunction MoveContourVertex (newVertCoord, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = newVertCoord.x;\n\t\t\t\tvertCoord.y = newVertCoord.y;\n\t\t\t\tvertCoord.z = newVertCoord.z;\n\t\t\t}\t\t\n\t\t\t\n\t\t\tfunction MoveVertex (pgonAverage, edgeAverage, vertEdgeCount, vertCoord)\n\t\t\t{\n\t\t\t\tvertCoord.x = (pgonAverage.x + 2.0 * edgeAverage.x + (vertEdgeCount - 3) * vertCoord.x) / vertEdgeCount;\n\t\t\t\tvertCoord.y = (pgonAverage.y + 2.0 * edgeAverage.y + (vertEdgeCount - 3) * vertCoord.y) / vertEdgeCount;\n\t\t\t\tvertCoord.z = (pgonAverage.z + 2.0 * edgeAverage.z + (vertEdgeCount - 3) * vertCoord.z) / vertEdgeCount;\n\t\t\t}\n\t\t\n\t\t\tvar edgeMidCoords = [];\n\t\t\t\n\t\t\tvar edge, edgeCoord;\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (body.GetVertexPosition (edge.vert1), body.GetVertexPosition (edge.vert2));\n\t\t\t\tedgeMidCoords.push (edgeCoord);\n\t\t\t}\n\t\t\n\t\t\tvar vert, pgon, vertCoord, currentVertCoord;\n\t\t\tvar pgonAverage, edgeAverage, edgeCountForAverage;\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\tvert = adjacencyInfo.verts[i];\n\t\t\t\tvertCoord = result.GetVertexPosition (i);\n\t\t\t\tif (adjacencyInfo.IsContourVertex (vert)) {\n\t\t\t\t\tedgeCountForAverage = 0;\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tif (adjacencyInfo.IsContourEdge (adjacencyInfo.edges[edge])) {\n\t\t\t\t\t\t\tedgeCoord = edgeMidCoords [vert.edges[j]];\n\t\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.Add (vertCoord);\n\t\t\t\t\tedgeCountForAverage++;\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / edgeCountForAverage);\n\t\t\t\t\tMoveContourVertex (edgeAverage, vertCoord);\n\t\t\t\t} else {\n\t\t\t\t\tpgonAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\tedgeAverage = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < vert.pgons.length; j++) {\n\t\t\t\t\t\tpgon = vert.pgons[j];\n\t\t\t\t\t\tcurrentVertCoord = result.GetVertexPosition (pgonVertices[pgon]);\n\t\t\t\t\t\tpgonAverage.Add (currentVertCoord);\n\t\t\t\t\t}\n\t\t\t\t\tpgonAverage.MultiplyScalar (1.0 / vert.pgons.length);\n\n\t\t\t\t\tfor (j = 0; j < vert.edges.length; j++) {\n\t\t\t\t\t\tedge = vert.edges[j];\n\t\t\t\t\t\tedgeCoord = edgeMidCoords [edge];\n\t\t\t\t\t\tedgeAverage.Add (edgeCoord);\n\t\t\t\t\t}\n\t\t\t\t\tedgeAverage.MultiplyScalar (1.0 / vert.edges.length);\n\t\t\t\t\tMoveVertex (pgonAverage, edgeAverage, vert.edges.length, vertCoord);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices)\n\t\t{\n\t\t\tvar edgeCount, currentEdge, nextEdge;\n\t\t\tvar centroid, currentEdgeVertex, originalVertex, nextEdgeVertex;\n\t\t\tvar polygon, oldPolygon;\n\t\t\tvar i, j, pgon;\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tpgon = adjacencyInfo.pgons[i];\n\t\t\t\tedgeCount = pgon.verts.length;\n\t\t\t\tfor (j = 0; j < edgeCount; j++) {\n\t\t\t\t\tcurrentEdge = pgon.pedges[j];\n\t\t\t\t\tnextEdge = pgon.pedges[(j + 1) % edgeCount];\n\n\t\t\t\t\tcentroid = pgonVertices[i];\n\t\t\t\t\tcurrentEdgeVertex = edgeVertices[currentEdge.index];\n\t\t\t\t\toriginalVertex = adjacencyInfo.GetPolyEdgeStartVertex (nextEdge);\n\t\t\t\t\tnextEdgeVertex = edgeVertices[nextEdge.index];\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([centroid, currentEdgeVertex, originalVertex, nextEdgeVertex]);\n\t\t\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\t\t\tpolygon.material = oldPolygon.material;\n\t\t\t\t\tpolygon.curved = oldPolygon.curved;\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\n\t\tvar pgonVertices = [];\n\t\tvar edgeVertices = [];\n\n\t\tAddOriginalVertices (body, result, adjacencyInfo);\n\t\tAddPolygonVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddEdgeVertices (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\n\t\tMoveOriginalVertices (body, result, adjacencyInfo, pgonVertices);\n\t\tAddNewPolygons (body, result, adjacencyInfo, pgonVertices, edgeVertices);\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CatmullClarkSubdivision\n\t* Description: Runs multiple iterations of Catmull-Clark subdivision on a body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\titerations {integer} the iteration number\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CatmullClarkSubdivision = function (body, iterations)\n\t{\n\t\tvar result = body;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < iterations; i++) {\n\t\t\tresult = JSM.CatmullClarkSubdivisionOneIteration (result);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n"]}