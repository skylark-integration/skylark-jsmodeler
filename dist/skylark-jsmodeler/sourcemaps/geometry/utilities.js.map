{"version":3,"sources":["geometry/utilities.js"],"names":["define","JSM","GetGaussianCParameter","x","a","b","epsilon","Math","sqrt","pow","log","abs","GetGaussianValue","c","exp","GenerateCirclePoints","radius","segmentation","origo","i","coord","result","segments","theta","PI","step","CylindricalToCartesian","undefined","CoordAdd","push","GetRuledMesh","aCoords","bCoords","vertices","polygons","length","j","current","next","polygon","lineSegmentation","meshSegmentation","directions","lengths","CoordSub","DistanceTo","Clone","Offset"],"mappings":";;;;;;;AAAAA,QAAQ,eAAe,SAASC,GA4H/B,OA9GAA,EAAIC,sBAAwB,SAAUC,EAAGC,EAAGC,EAAGC,GAE9C,OAAOC,KAAKC,MAAQD,KAAKE,IAAKN,EAAIE,EAAG,IAAQ,EAAME,KAAKG,IAAKJ,EAAUC,KAAKI,IAAKP,OAclFH,EAAIW,iBAAmB,SAAUT,EAAGC,EAAGC,EAAGQ,GAEzC,OAAOT,EAAIG,KAAKO,KAAOP,KAAKE,IAAKN,EAAIE,EAAG,IAAQ,EAAME,KAAKE,IAAKI,EAAG,MAapEZ,EAAIc,qBAAuB,SAAUC,EAAQC,EAAcC,GAE1D,IAMIC,EAAGC,EANHC,KACAC,EAAWL,EAEXM,EAAQ,EAAMhB,KAAKiB,GACnBC,EAAO,EAAMlB,KAAKiB,GAAKF,EAG3B,IAAKH,EAAI,EAAGA,EAAIG,EAAUH,IACzBC,EAAQnB,EAAIyB,uBAAwBV,EAAQ,EAAKO,QACnCI,IAAVT,GAAiC,OAAVA,IAC1BE,EAAQnB,EAAI2B,SAAUR,EAAOF,IAE9BG,EAAOQ,KAAMT,GACbG,GAASE,EAGV,OAAOJ,GAgBRpB,EAAI6B,aAAe,SAAUC,EAASC,EAASf,EAAcgB,EAAUC,GAEtE,GAAIH,EAAQI,SAAWH,EAAQG,OAA/B,CAIA,IAKIhB,EAAGiB,EAMHX,EAAML,EASNiB,EAAcC,EAAYC,EApB1BC,EAAmBT,EAAQI,OAAS,EACpCM,EAAmBxB,EACnByB,KACAC,KAGJ,IAAKxB,EAAI,EAAGA,GAAKqB,EAAkBrB,IAClCuB,EAAWb,KAAM5B,EAAI2C,SAAUZ,EAAQb,GAAIY,EAAQZ,KACnDwB,EAAQd,KAAME,EAAQZ,GAAG0B,WAAYb,EAAQb,KAI9C,IAAKA,EAAI,EAAGA,GAAKqB,EAAkBrB,IAElC,IADAM,EAAOkB,EAAQxB,GAAKsB,EACfL,EAAI,EAAGA,GAAKK,EAAkBL,IAClChB,EAAQW,EAAQZ,GAAG2B,QAASC,OAAQL,EAAWvB,GAAIM,EAAOW,GAC1DH,EAASJ,KAAMT,GAKjB,IAAKD,EAAI,EAAGA,EAAIqB,EAAkBrB,IACjC,IAAKiB,EAAI,EAAGA,EAAIK,EAAkBL,IAGjCE,GAFAD,EAAUlB,GAAKsB,EAAmB,GAAKL,GAEtB,EADXC,EAAUI,EAAmB,EAEtB,EAObF,GALAF,EAAUlB,GAAKsB,EAAmB,GAAKL,EAEvCE,EAAOD,EAAUI,EAAmB,EAC7BH,EAAO,EAFRD,EAAU,GAKhBH,EAASL,KAAMU,KAKXtC","file":"../../geometry/utilities.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GetGaussianCParameter\n\t* Description:\n\t*\tCalculates the gaussian functions c parameter which can be used\n\t*\tfor the gaussian function to reach epsilon at a given value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tepsilon {number} the epsilon value\n\t* Returns:\n\t*\t{number} the c parameter of the function\n\t*/\n\tJSM.GetGaussianCParameter = function (x, a, b, epsilon)\n\t{\n\t\treturn Math.sqrt (-(Math.pow (x - b, 2.0) / (2.0 * Math.log (epsilon / Math.abs (a)))));\n\t};\n\n\t/**\n\t* Function: GetGaussianValue\n\t* Description: Calculates the gaussian functions value.\n\t* Parameters:\n\t*\tx {number} the value\n\t*\ta {number} the a parameter of the function\n\t*\tb {number} the b parameter of the function\n\t*\tc {number} the c parameter of the function\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.GetGaussianValue = function (x, a, b, c)\n\t{\n\t\treturn a * Math.exp (-(Math.pow (x - b, 2.0) / (2.0 * Math.pow (c, 2.0))));\n\t};\n\n\t/**\n\t* Function: GenerateCirclePoints\n\t* Description: Generates coordinates on circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {number} the segmentation of the circle\n\t*\torigo {Coord} the origo of the circle\n\t* Returns:\n\t*\t{Coord[*]} the result\n\t*/\n\tJSM.GenerateCirclePoints = function (radius, segmentation, origo)\n\t{\n\t\tvar result = [];\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i, coord;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcoord = JSM.CylindricalToCartesian (radius, 0.0, theta);\n\t\t\tif (origo !== undefined && origo !== null) {\n\t\t\t\tcoord = JSM.CoordAdd (coord, origo);\n\t\t\t}\n\t\t\tresult.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GetRuledMesh\n\t* Description:\n\t*\tGenerates ruled mesh coordinates and polygons between two coordinate array.\n\t*\tThe two arrays should have the same length. The result is a coordinate array\n\t*\tand a polygon array which contains indices for vertices.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tsegmentation {number} the segmentation of the mesh\n\t*\tvertices {Coord[*]} (out) the vertices of the mesh\n\t*\tpolygons {integer[*][4]} (out) the polygons of the mesh\n\t*/\n\tJSM.GetRuledMesh = function (aCoords, bCoords, segmentation, vertices, polygons)\n\t{\n\t\tif (aCoords.length !== bCoords.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lineSegmentation = aCoords.length - 1;\n\t\tvar meshSegmentation = segmentation;\n\t\tvar directions = [];\n\t\tvar lengths = [];\n\n\t\tvar i, j;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tdirections.push (JSM.CoordSub (bCoords[i], aCoords[i]));\n\t\t\tlengths.push (aCoords[i].DistanceTo (bCoords[i]));\n\t\t}\n\n\t\tvar step, coord;\n\t\tfor (i = 0; i <= lineSegmentation; i++) {\n\t\t\tstep = lengths[i] / meshSegmentation;\n\t\t\tfor (j = 0; j <= meshSegmentation; j++) {\n\t\t\t\tcoord = aCoords[i].Clone ().Offset (directions[i], step * j);\n\t\t\t\tvertices.push (coord);\n\t\t\t}\n\t\t}\n\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tfor (j = 0; j < meshSegmentation; j++) {\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + meshSegmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tcurrent = i * (meshSegmentation + 1) + j;\n\t\t\t\ttop = current + 1;\n\t\t\t\tnext = current + meshSegmentation + 1;\n\t\t\t\tntop = next + 1;\n\n\t\t\t\tpolygon = [current, next, ntop, top];\n\t\t\t\tpolygons.push (polygon);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n"]}