{"version":3,"sources":["geometry/polygon2d.js"],"names":["define","JSM","Complexity","Invalid","Convex","Concave","Complex","CoordPolygonPosition2D","OnVertex","OnEdge","Inside","Outside","SectorPolygonPosition2D","IntersectionOnePoint","IntersectionCoincident","IntersectionOnVertex","NoIntersection","Polygon2D","this","vertices","cache","Clear","prototype","AddVertex","x","y","AddVertexCoord","Coord2D","coord","push","ClearCache","GetVertex","index","RemoveVertex","splice","VertexCount","length","EnumerateVertices","from","to","callback","count","GetNextVertex","NextIndex","GetPrevVertex","PrevIndex","ShiftVertices","ShiftArray","ReverseVertices","reverse","GetVertexAngle","prev","curr","next","prevDir","CoordSub2D","nextDir","AngleTo","GetSignedArea","signedArea","result","i","current","GetArea","Math","abs","GetOrientation","orientation","Orientation","IsPositive","CounterClockwise","IsNegative","Clockwise","GetComplexity","complexity","IsConcaveVertex","GetVertexOrientation","undefined","vertexOrientations","CoordOrientation2D","IsConvexVertex","vertexOrientation","CoordPosition","IntersectionCount","beg","end","begYDist","endYDist","begBelow","begAbove","endBelow","endAbove","begOnLine","endOnLine","intersection","IsEqual","yMoveRatio","GetIntersection","IsLower","IsGreater","upwardEdge","edgeFrom","edgeTo","position","vertexCount","intersections","Sector2D","CoordSectorPosition2D","CoordInsideOfSector","CoordOnSectorEndCoord","SectorPosition","sector","begIndex","endIndex","edgeBegIndex","edgeEndIndex","edgeBeg","edgeEnd","currentSector","SectorSectorPosition2D","SectorsIntersectOnePoint","SectorsIntersectCoincident","SectorsIntersectEndPoint","IsDiagonal","fromVertex","toVertex","polygon","DiagonalIntersectsAnyEdges","midCoord","DiagonalInsideOfPolygon","ToArray","vertex","Clone","FromArray","GetBoundingBox","boundingBox","Box2D","Inf","min","Minimum","max","Maximum","ContourPolygon2D","contours","lastContour","AddContourVertex","contourIndex","AddContourVertexCoord","ContourVertexCount","AddContour","contour","GetLastContour","GetContourVertex","vertexIndex","GetContour","ContourCount","area","contourOrientation","j"],"mappings":";;;;;;;AAAAA,QAAQ,eAAe,SAASC,GAg9B/B,OAt8BAA,EAAIC,YACHC,QAAU,EACVC,OAAS,EACTC,QAAU,EACVC,QAAU,GAYXL,EAAIM,wBACHC,SAAW,EACXC,OAAS,EACTC,OAAS,EACTC,QAAU,GAYXV,EAAIW,yBACHC,qBAAuB,EACvBC,uBAAyB,EACzBC,qBAAuB,EACvBC,eAAiB,GAOlBf,EAAIgB,UAAY,WAEfC,KAAKC,SAAW,KAChBD,KAAKE,MAAQ,KACbF,KAAKG,SAUNpB,EAAIgB,UAAUK,UAAUC,UAAY,SAAUC,EAAGC,GAEhDP,KAAKQ,eAAgB,IAAIzB,EAAI0B,QAASH,EAAGC,KAS1CxB,EAAIgB,UAAUK,UAAUI,eAAiB,SAAUE,GAElDV,KAAKC,SAASU,KAAMD,GACpBV,KAAKY,cAWN7B,EAAIgB,UAAUK,UAAUS,UAAY,SAAUC,GAE7C,OAAOd,KAAKC,SAASa,IAStB/B,EAAIgB,UAAUK,UAAUW,aAAe,SAAUD,GAEhDd,KAAKC,SAASe,OAAQF,EAAO,IAS9B/B,EAAIgB,UAAUK,UAAUa,YAAc,WAErC,OAAOjB,KAAKC,SAASiB,QAatBnC,EAAIgB,UAAUK,UAAUe,kBAAoB,SAAUC,EAAMC,EAAIC,GAE/D,IAAIC,EAAQvB,KAAKC,SAASiB,OACtBJ,EAAQM,EAEZ,IADAE,EAAUR,GACHA,GAASO,GAEfC,EADAR,GAASA,EAAQ,GAAKS,IAaxBxC,EAAIgB,UAAUK,UAAUoB,cAAgB,SAAUV,GAEjD,OAAO/B,EAAI0C,UAAWX,EAAOd,KAAKC,SAASiB,SAW5CnC,EAAIgB,UAAUK,UAAUsB,cAAgB,SAAUZ,GAEjD,OAAO/B,EAAI4C,UAAWb,EAAOd,KAAKC,SAASiB,SAS5CnC,EAAIgB,UAAUK,UAAUwB,cAAgB,SAAUL,GAEjDxC,EAAI8C,WAAY7B,KAAKC,SAAUsB,GAC/BvB,KAAKY,cAON7B,EAAIgB,UAAUK,UAAU0B,gBAAkB,WAEzC9B,KAAKC,SAAS8B,UACd/B,KAAKY,cAWN7B,EAAIgB,UAAUK,UAAU4B,eAAiB,SAAUlB,GAElD,IAAImB,EAAOjC,KAAKC,SAASD,KAAK0B,cAAeZ,IACzCoB,EAAOlC,KAAKC,SAASa,GACrBqB,EAAOnC,KAAKC,SAASD,KAAKwB,cAAeV,IACzCsB,EAAUrD,EAAIsD,WAAYJ,EAAMC,GAChCI,EAAUvD,EAAIsD,WAAYF,EAAMD,GACpC,OAAOE,EAAQG,QAASD,IASzBvD,EAAIgB,UAAUK,UAAUoC,cAAgB,WAEvC,GAA8B,OAA1BxC,KAAKE,MAAMuC,WACd,OAAOzC,KAAKE,MAAMuC,WAGnB,IAAIlB,EAAQvB,KAAKC,SAASiB,OACtBwB,EAAS,EACb,GAAInB,GAAS,EAAG,CACf,IAAIoB,EAAGC,EAAST,EAChB,IAAKQ,EAAI,EAAGA,EAAIpB,EAAOoB,IACtBC,EAAU5C,KAAKC,SAAS0C,GACxBR,EAAOnC,KAAKC,UAAU0C,EAAI,GAAKpB,GAC/BmB,GAAUE,EAAQtC,EAAI6B,EAAK5B,EAAI4B,EAAK7B,EAAIsC,EAAQrC,EAEjDmC,GAAU,GAIX,OADA1C,KAAKE,MAAMuC,WAAaC,EACjBA,GASR3D,EAAIgB,UAAUK,UAAUyC,QAAU,WAEjC,IAAIJ,EAAazC,KAAKwC,gBACtB,OAAOM,KAAKC,IAAKN,IASlB1D,EAAIgB,UAAUK,UAAU4C,eAAiB,WAExC,GAA+B,OAA3BhD,KAAKE,MAAM+C,YACd,OAAOjD,KAAKE,MAAM+C,YAGnB,IAAIP,EAAS3D,EAAImE,YAAYjE,QAC7B,GAAIe,KAAKC,SAASiB,QAAU,EAAG,CAC9B,IAAIuB,EAAazC,KAAKwC,gBAClBzD,EAAIoE,WAAYV,GACnBC,EAAS3D,EAAImE,YAAYE,iBACfrE,EAAIsE,WAAYZ,KAC1BC,EAAS3D,EAAImE,YAAYI,WAK3B,OADAtD,KAAKE,MAAM+C,YAAcP,EAClBA,GAUR3D,EAAIgB,UAAUK,UAAUmD,cAAgB,WAEvC,GAA8B,OAA1BvD,KAAKE,MAAMsD,WACd,OAAOxD,KAAKE,MAAMsD,WAGnB,IAAIjC,EAAQvB,KAAKC,SAASiB,OAC1B,GAAIK,EAAQ,EACX,OAAOxC,EAAIC,WAAWC,QAGvB,IAIK0D,EAJDD,EAAS3D,EAAIC,WAAWC,QAE5B,GADuBe,KAAKgD,kBACJjE,EAAImE,YAAYjE,QAGvC,IAFAyD,EAAS3D,EAAIC,WAAWE,OAEnByD,EAAI,EAAGA,EAAIpB,EAAOoB,IACtB,GAAI3C,KAAKyD,gBAAiBd,GAAI,CAC7BD,EAAS3D,EAAIC,WAAWG,QACxB,MAMH,OADAa,KAAKE,MAAMsD,WAAad,EACjBA,GAWR3D,EAAIgB,UAAUK,UAAUsD,qBAAuB,SAAU5C,GAExD,QAA6C6C,IAAzC3D,KAAKE,MAAM0D,mBAAmB9C,GACjC,OAAOd,KAAKE,MAAM0D,mBAAmB9C,GAGtC,IAAImB,EAAOjC,KAAKC,SAASD,KAAK0B,cAAeZ,IACzCoB,EAAOlC,KAAKC,SAASa,GACrBqB,EAAOnC,KAAKC,SAASD,KAAKwB,cAAeV,IAEzC4B,EAAS3D,EAAI8E,mBAAoB5B,EAAMC,EAAMC,GAEjD,OADAnC,KAAKE,MAAM0D,mBAAmB9C,GAAS4B,EAChCA,GAWR3D,EAAIgB,UAAUK,UAAU0D,eAAiB,SAAUhD,GAElD,IAAImC,EAAcjD,KAAKgD,iBACnBe,EAAoB/D,KAAK0D,qBAAsB5C,GACnD,OAAIiD,GAAqBhF,EAAImE,YAAYjE,SAGlC8E,GAAqBd,GAW7BlE,EAAIgB,UAAUK,UAAUqD,gBAAkB,SAAU3C,GAEnD,IAAImC,EAAcjD,KAAKgD,iBACnBe,EAAoB/D,KAAK0D,qBAAsB5C,GACnD,OAAIiD,GAAqBhF,EAAImE,YAAYjE,SAGlC8E,GAAqBd,GAW7BlE,EAAIgB,UAAUK,UAAU4D,cAAgB,SAAUtD,GAEjD,SAASuD,EAAmBvD,EAAOwD,EAAKC,GAYvC,IAAIC,EAAWF,EAAI3D,EAAIG,EAAMH,EACzB8D,EAAWF,EAAI5D,EAAIG,EAAMH,EAEzB+D,EAAWvF,EAAIsE,WAAYe,GAC3BG,EAAWxF,EAAIoE,WAAYiB,GAC3BI,EAAWzF,EAAIsE,WAAYgB,GAC3BI,EAAW1F,EAAIoE,WAAYkB,GAC/B,GAAKC,GAAYE,GAAcD,GAAYE,EAC1C,OAAO,EAGR,IAAIC,GAAaJ,IAAaC,EAC1BI,GAAaH,IAAaC,EAC9B,GAAIC,GAAaC,EAChB,OAAO,EAGR,IAAIC,EA3BJ,SAA0BlE,EAAOwD,EAAKC,GAErC,IAAIzB,EAAS,IAAI3D,EAAI0B,QAASyD,EAAI5D,EAAGI,EAAMH,GAC3C,IAAKxB,EAAI8F,QAASX,EAAI3D,EAAGG,EAAMH,GAAI,CAClC,IAAIuE,EAAahC,KAAKC,KAAMmB,EAAI3D,EAAIG,EAAMH,IAAM4D,EAAI5D,EAAI2D,EAAI3D,IAC5DmC,EAAOpC,EAAI4D,EAAI5D,GAAK6D,EAAI7D,EAAI4D,EAAI5D,GAAKwE,EAEtC,OAAOpC,EAoBWqC,CAAiBrE,EAAOwD,EAAKC,GAChD,GAAIpF,EAAIiG,QAASJ,EAAatE,EAAGI,EAAMJ,GACtC,OAAO,EACD,GAAIvB,EAAIkG,UAAWL,EAAatE,EAAGI,EAAMJ,GAAI,CACnD,GAAIoE,GAAaC,EAAW,CAC3B,IAAIO,EAAanG,EAAIkG,UAAWd,EAAI5D,EAAG2D,EAAI3D,GAC3C,OAAImE,GAAaQ,GAAcP,IAAcO,EACrC,EAED,EAER,OAAO,EAER,OAAO,EAGR,IAEIvC,EAAGwC,EAAUC,EAAgBC,EAF7BC,EAActF,KAAKC,SAASiB,OAC5BqE,EAAgB,EAEpB,IAAK5C,EAAI,EAAGA,EAAI2C,EAAa3C,IAAK,CAKjC,GAJAwC,EAAWnF,KAAKC,SAAS0C,GACzByC,EAASpF,KAAKC,UAAU0C,EAAI,GAAK2C,IAEjCD,EADS,IAAItG,EAAIyG,SAAUL,EAAUC,GACnBpB,cAAetD,KACjB3B,EAAI0G,sBAAsBC,oBACzC,OAAO3G,EAAIM,uBAAuBE,OAC5B,GAAI8F,GAAYtG,EAAI0G,sBAAsBE,sBAChD,OAAO5G,EAAIM,uBAAuBC,SAEnCiG,GAAiBtB,EAAmBvD,EAAOyE,EAAUC,GAGtD,OAAIG,EAAgB,GAAM,EAClBxG,EAAIM,uBAAuBG,OAE5BT,EAAIM,uBAAuBI,SAenCV,EAAIgB,UAAUK,UAAUwF,eAAiB,SAAUC,EAAQC,EAAUC,GAEpE,IAMIpD,EAAGqD,EAAcC,EAAcC,EAASC,EACxCC,EAAef,EAPf3C,EAAS3D,EAAIW,wBAAwBI,eACrCwF,EAActF,KAAKC,SAASiB,OAChC,GAAIoE,EAAc,EACjB,OAAO5C,EAKR,IAAKC,EAAI,EAAGA,EAAI2C,EAAa3C,IAK5B,GAJAqD,EAAerD,EACfsD,GAAgBtD,EAAI,GAAK2C,EACzBY,EAAUlG,KAAKC,SAAS+F,GACxBG,EAAUnG,KAAKC,SAASgG,GACpBD,GAAgBF,GAAYG,GAAgBH,GAAYE,GAAgBD,GAAYE,GAAgBF,EAAxG,CAKA,GAFAK,EAAgB,IAAIrH,EAAIyG,SAAUU,EAASC,IAC3Cd,EAAWQ,EAAOD,eAAgBQ,KAClBrH,EAAIsH,uBAAuBC,yBAC1C,OAAOvH,EAAIW,wBAAwBC,qBAC7B,GAAI0F,GAAYtG,EAAIsH,uBAAuBE,2BACjD,OAAOxH,EAAIW,wBAAwBE,uBACzByF,GAAYtG,EAAIsH,uBAAuBG,2BACjD9D,EAAS3D,EAAIW,wBAAwBG,sBAIvC,OAAO6C,GAYR3D,EAAIgB,UAAUK,UAAUqG,WAAa,SAAUrF,EAAMC,GA0BpD,GAAID,GAAQC,EACX,OAAO,EAGR,GAAIrB,KAAK0B,cAAeN,IAASC,GAAMrB,KAAKwB,cAAeJ,IAASC,EACnE,OAAO,EAGR,IAAIqF,EAAa1G,KAAKC,SAASmB,GAC3BuF,EAAW3G,KAAKC,SAASoB,GAC7B,OAAIqF,EAAW7B,QAAS8B,MAlCxB,SAAqCC,EAASxF,EAAMC,GAEnD,IAAIqF,EAAaE,EAAQ/F,UAAWO,GAChCuF,EAAWC,EAAQ/F,UAAWQ,GAC9BwE,EAAS,IAAI9G,EAAIyG,SAAUkB,EAAYC,GAE3C,OADeC,EAAQhB,eAAgBC,EAAQzE,EAAMC,IACrCtC,EAAIW,wBAAwBI,eAgCzC+G,CAA4B7G,KAAMoB,EAAMC,MA1B5C,SAAkCuF,EAASxF,EAAMC,GAEhD,IAAIqF,EAAaE,EAAQ/F,UAAWO,GAChCuF,EAAWC,EAAQ/F,UAAWQ,GAC9ByF,EAAW,IAAI/H,EAAI0B,SACrBiG,EAAWpG,EAAIqG,EAASrG,GAAK,GAC7BoG,EAAWnG,EAAIoG,EAASpG,GAAK,GAG/B,OADeqG,EAAQ5C,cAAe8C,IACnB/H,EAAIM,uBAAuBG,OAqB1CuH,CAAyB/G,KAAMoB,EAAMC,KAa3CtC,EAAIgB,UAAUK,UAAU4G,QAAU,WAEjC,IACIrE,EAAGsE,EADHhH,KAEJ,IAAK0C,EAAI,EAAGA,EAAI3C,KAAKC,SAASiB,OAAQyB,IACrCsE,EAASjH,KAAKC,SAAS0C,GACvB1C,EAASU,KAAMsG,EAAOC,SAEvB,OAAOjH,GASRlB,EAAIgB,UAAUK,UAAU+G,UAAY,SAAUlH,GAG7C,IAAI0C,EAAGsE,EACP,IAFAjH,KAAKG,QAEAwC,EAAI,EAAGA,EAAI1C,EAASiB,OAAQyB,IAChCsE,EAAShH,EAAS0C,GAClB3C,KAAKK,UAAW4G,EAAO3G,EAAG2G,EAAO1G,IAUnCxB,EAAIgB,UAAUK,UAAUgH,eAAiB,WAExC,GAA+B,OAA3BpH,KAAKE,MAAMmH,YACd,OAAOrH,KAAKE,MAAMmH,YAGnB,IAKI1E,EAAGjC,EALHgC,EAAS,IAAI3D,EAAIuI,MACpB,IAAIvI,EAAI0B,QAAS1B,EAAIwI,IAAKxI,EAAIwI,KAC9B,IAAIxI,EAAI0B,SAAU1B,EAAIwI,KAAMxI,EAAIwI,MAIjC,IAAK5E,EAAI,EAAGA,EAAI3C,KAAKC,SAASiB,OAAQyB,IACrCjC,EAAQV,KAAKC,SAAS0C,GACtBD,EAAO8E,IAAIlH,EAAIvB,EAAI0I,QAAS/E,EAAO8E,IAAIlH,EAAGI,EAAMJ,GAChDoC,EAAO8E,IAAIjH,EAAIxB,EAAI0I,QAAS/E,EAAO8E,IAAIjH,EAAGG,EAAMH,GAChDmC,EAAOgF,IAAIpH,EAAIvB,EAAI4I,QAASjF,EAAOgF,IAAIpH,EAAGI,EAAMJ,GAChDoC,EAAOgF,IAAInH,EAAIxB,EAAI4I,QAASjF,EAAOgF,IAAInH,EAAGG,EAAMH,GAIjD,OADAP,KAAKE,MAAMmH,YAAc3E,EAClBA,GAOR3D,EAAIgB,UAAUK,UAAUD,MAAQ,WAE/BH,KAAKC,YACLD,KAAKY,cAON7B,EAAIgB,UAAUK,UAAUQ,WAAa,WAEpCZ,KAAKE,OACJuC,WAAa,KACbQ,YAAc,KACdW,sBACAJ,WAAa,KACb6D,YAAc,OAUhBtI,EAAIgB,UAAUK,UAAU8G,MAAQ,WAE/B,IACIvE,EAAGsE,EADHvE,EAAS,IAAI3D,EAAIgB,UAErB,IAAK4C,EAAI,EAAGA,EAAI3C,KAAKC,SAASiB,OAAQyB,IACrCsE,EAASjH,KAAKC,SAAS0C,GACvBD,EAAOlC,eAAgByG,EAAOC,SAE/B,OAAOxE,GAOR3D,EAAI6I,iBAAmB,WAEtB5H,KAAK6H,SAAW,KAChB7H,KAAKG,SAUNpB,EAAI6I,iBAAiBxH,UAAUC,UAAY,SAAUC,EAAGC,GAEvDP,KAAK8H,YAAYzH,UAAWC,EAAGC,IAShCxB,EAAI6I,iBAAiBxH,UAAUI,eAAiB,SAAUE,GAEzDV,KAAK8H,YAAYtH,eAAgBE,IAWlC3B,EAAI6I,iBAAiBxH,UAAU2H,iBAAmB,SAAUC,EAAc1H,EAAGC,GAE5E,OAAOP,KAAK6H,SAASG,GAAc3H,UAAWC,EAAGC,IAUlDxB,EAAI6I,iBAAiBxH,UAAU6H,sBAAwB,SAAUD,EAActH,GAE9E,OAAOV,KAAK6H,SAASG,GAAcxH,eAAgBE,IASpD3B,EAAI6I,iBAAiBxH,UAAUa,YAAc,WAE5C,IACI0B,EADA2C,EAAc,EAElB,IAAK3C,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IACrC2C,GAAetF,KAAK6H,SAASlF,GAAG1B,cAEjC,OAAOqE,GAORvG,EAAI6I,iBAAiBxH,UAAU0B,gBAAkB,WAEhD,IAAIa,EACJ,IAAKA,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IACrC3C,KAAK6H,SAASlF,GAAGb,mBAYnB/C,EAAI6I,iBAAiBxH,UAAU8H,mBAAqB,SAAUF,GAE7D,OAAOhI,KAAK6H,SAASG,GAAc/G,eAWpClC,EAAI6I,iBAAiBxH,UAAU+H,WAAa,SAAUC,GAGpDpI,KAAK8H,iBADUnE,IAAZyE,GAAqC,OAAZA,EACT,IAAIrJ,EAAIgB,UAERqI,EAEpBpI,KAAK6H,SAASlH,KAAMX,KAAK8H,cAS1B/I,EAAI6I,iBAAiBxH,UAAUiI,eAAiB,WAE/C,OAAOrI,KAAK8H,aAYb/I,EAAI6I,iBAAiBxH,UAAUkI,iBAAmB,SAAUN,EAAcO,GAEzE,OAAOvI,KAAK6H,SAASG,GAAcnH,UAAW0H,IAW/CxJ,EAAI6I,iBAAiBxH,UAAUoI,WAAa,SAAU1H,GAErD,OAAOd,KAAK6H,SAAS/G,IAStB/B,EAAI6I,iBAAiBxH,UAAUqI,aAAe,WAE7C,OAAOzI,KAAK6H,SAAS3G,QAStBnC,EAAI6I,iBAAiBxH,UAAUoC,cAAgB,WAE9C,IACIG,EADA+F,EAAO,EAEX,IAAK/F,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IACrC+F,GAAQ1I,KAAK6H,SAASlF,GAAGH,gBAE1B,OAAOkG,GASR3J,EAAI6I,iBAAiBxH,UAAUyC,QAAU,WAExC,IAAIJ,EAAazC,KAAKwC,gBACtB,OAAOM,KAAKC,IAAKN,IASlB1D,EAAI6I,iBAAiBxH,UAAU4C,eAAiB,WAE/C,GAAyB,OAArBhD,KAAK8H,YACR,OAAO/I,EAAImE,YAAYjE,QAExB,IAOI0D,EAAGgG,EAPH1F,EAAcjD,KAAK6H,SAAS,GAAG7E,iBACnC,GAA4B,GAAxBhD,KAAK6H,SAAS3G,OACjB,OAAO+B,EAER,GAAIA,GAAelE,EAAImE,YAAYjE,QAClC,OAAOF,EAAImE,YAAYjE,QAGxB,IAAK0D,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IAAK,CAE1C,IADAgG,EAAqB3I,KAAK6H,SAASlF,GAAGK,mBACZjE,EAAImE,YAAYjE,QACzC,OAAOF,EAAImE,YAAYjE,QAExB,GAAIgE,GAAe0F,EAClB,OAAO5J,EAAImE,YAAYjE,QAGzB,OAAOgE,GASRlE,EAAI6I,iBAAiBxH,UAAUmD,cAAgB,WAE9C,GAAyB,OAArBvD,KAAK8H,YACR,OAAO/I,EAAIC,WAAWC,QAEvB,GAA4B,GAAxBe,KAAK6H,SAAS3G,OACjB,OAAOlB,KAAK6H,SAAS,GAAGtE,gBAEzB,IAAIZ,EACJ,IAAKA,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IAErC,GADoB3C,KAAK6H,SAASlF,GAAGY,iBACZxE,EAAIC,WAAWC,QACvC,OAAOF,EAAIC,WAAWC,QAGxB,OAAOF,EAAIC,WAAWI,SAWvBL,EAAI6I,iBAAiBxH,UAAU4G,QAAU,WAExC,IACIrE,EAAGiG,EAAGR,EAASnB,EADfhH,KAEJ,IAAK0C,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IAAK,CAE1C,IADAyF,EAAUpI,KAAK6H,SAASlF,GACnBiG,EAAI,EAAGA,EAAIR,EAAQnH,cAAgB2H,IACvC3B,EAASmB,EAAQvH,UAAW+H,GAC5B3I,EAASU,KAAMsG,EAAOC,SAEnBvE,EAAI3C,KAAK6H,SAAS3G,OAAS,GAC9BjB,EAASU,KAAM,MAGjB,OAAOV,GAWRlB,EAAI6I,iBAAiBxH,UAAU+G,UAAY,SAAUlH,GAIpD,IAAI0C,EAAGsE,EACP,IAHAjH,KAAKG,QACLH,KAAKmI,aAEAxF,EAAI,EAAGA,EAAI1C,EAASiB,OAAQyB,IAEjB,QADfsE,EAAShH,EAAS0C,IAEjB3C,KAAKmI,aAELnI,KAAKK,UAAW4G,EAAO3G,EAAG2G,EAAO1G,IASpCxB,EAAI6I,iBAAiBxH,UAAUD,MAAQ,WAEtCH,KAAK6H,YACL7H,KAAK8H,YAAc,MASpB/I,EAAI6I,iBAAiBxH,UAAU8G,MAAQ,WAEtC,IACIvE,EAAGyF,EADH1F,EAAS,IAAI3D,EAAI6I,iBAErB,IAAKjF,EAAI,EAAGA,EAAI3C,KAAK6H,SAAS3G,OAAQyB,IACrCyF,EAAUpI,KAAK6H,SAASlF,GACxBD,EAAOyF,WAAYC,EAAQlB,SAE5B,OAAOxE,GAGD3D","file":"../../geometry/polygon2d.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Enum: Complexity\n\t* Description: Complexity of a polygon.\n\t* Values:\n\t*\t{Invalid} invalid polygon\n\t*\t{Convex} convex polygon\n\t*\t{Concave} concave polygon\n\t*\t{Complex} complex polygon (contains holes)\n\t*/\n\tJSM.Complexity = {\n\t\tInvalid : 0,\n\t\tConvex : 1,\n\t\tConcave : 2,\n\t\tComplex : 3\n\t};\n\n\t/**\n\t* Enum: CoordPolygonPosition2D\n\t* Description: Position of a coordinate and a polygon.\n\t* Values:\n\t*\t{OnVertex} coordinate lies on a vertex of the polygon\n\t*\t{OnEdge} coordinate lies on an edge of the polygon\n\t*\t{Inside} coordinate lies inside the polygon\n\t*\t{Outside} coordinate lies outside of the polygon\n\t*/\n\tJSM.CoordPolygonPosition2D = {\n\t\tOnVertex : 0,\n\t\tOnEdge : 1,\n\t\tInside : 2,\n\t\tOutside : 3\n\t};\n\n\t/**\n\t* Enum: SectorPolygonPosition2D\n\t* Description: Position of a sector and a polygon.\n\t* Values:\n\t*\t{IntersectionOnePoint} sector intersects polygon\n\t*\t{IntersectionCoincident} sector lies on an edge of the polygon\n\t*\t{IntersectionOnVertex} sector intersects polygon on a vertex\n\t*\t{NoIntersection} sector does not intersect polygon\n\t*/\n\tJSM.SectorPolygonPosition2D = {\n\t\tIntersectionOnePoint : 0,\n\t\tIntersectionCoincident : 1,\n\t\tIntersectionOnVertex : 2,\n\t\tNoIntersection : 3\n\t};\n\n\t/**\n\t* Class: Polygon2D\n\t* Description: Represents a 2D polygon.\n\t*/\n\tJSM.Polygon2D = function ()\n\t{\n\t\tthis.vertices = null;\n\t\tthis.cache = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertex\n\t* Description: Adds a vertex to the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.AddVertexCoord (new JSM.Coord2D (x, y));\n\t};\n\n\t/**\n\t* Function: Polygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the polygon.\n\t* Parameters:\n\t*\tcoord {Coord} the coordinate\n\t*/\n\tJSM.Polygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.vertices.push (coord);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertex\n\t* Description: Returns the vertex with the given index.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.Polygon2D.prototype.GetVertex = function (index)\n\t{\n\t\treturn this.vertices[index];\n\t};\n\n\t/**\n\t* Function: Polygon2D.RemoveVertex\n\t* Description: Removes a vertex from the polygon.\n\t* Parameters:\n\t*\tindex {integer} the index of the vertex\n\t*/\n\tJSM.Polygon2D.prototype.RemoveVertex = function (index)\n\t{\n\t\tthis.vertices.splice (index, 1);\n\t};\n\n\t/**\n\t* Function: Polygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.Polygon2D.prototype.VertexCount = function ()\n\t{\n\t\treturn this.vertices.length;\n\t};\n\n\t/**\n\t* Function: Polygon2D.EnumerateVertices\n\t* Description:\n\t*\tEnumerates the vertices of the polygon, and calls\n\t*\ta function for each vertex.\n\t* Parameters:\n\t*\tfrom {integer} the start vertex index\n\t*\tto {integer} the end vertex index\n\t*\tcallback {function} the callback function\n\t*/\n\tJSM.Polygon2D.prototype.EnumerateVertices = function (from, to, callback)\n\t{\n\t\tvar count = this.vertices.length;\n\t\tvar index = from;\n\t\tcallback (index);\n\t\twhile (index != to) {\n\t\t\tindex = (index + 1) % count;\n\t\t\tcallback (index);\n\t\t}\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetNextVertex\n\t* Description: Returns the vertex index after the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetNextVertex = function (index)\n\t{\n\t\treturn JSM.NextIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetPrevVertex\n\t* Description: Returns the vertex index before the given one.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetPrevVertex = function (index)\n\t{\n\t\treturn JSM.PrevIndex (index, this.vertices.length);\n\t};\n\n\t/**\n\t* Function: Polygon2D.ShiftVertices\n\t* Description: Shifts polygon vertices.\n\t* Parameters:\n\t*\tcount {integer} the number of shifts\n\t*/\n\tJSM.Polygon2D.prototype.ShiftVertices = function (count)\n\t{\n\t\tJSM.ShiftArray (this.vertices, count);\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.Polygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tthis.vertices.reverse ();\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexAngle\n\t* Description: Returns the angle of the given vertex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexAngle = function (index)\n\t{\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\tvar prevDir = JSM.CoordSub2D (prev, curr);\n\t\tvar nextDir = JSM.CoordSub2D (next, curr);\n\t\treturn prevDir.AngleTo (nextDir);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tif (this.cache.signedArea !== null) {\n\t\t\treturn this.cache.signedArea;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tvar result = 0.0;\n\t\tif (count >= 3) {\n\t\t\tvar i, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = this.vertices[i];\n\t\t\t\tnext = this.vertices[(i + 1) % count];\n\t\t\t\tresult += current.x * next.y - next.x * current.y;\n\t\t\t}\n\t\t\tresult *= 0.5;\n\t\t}\n\t\t\n\t\tthis.cache.signedArea = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.cache.orientation !== null) {\n\t\t\treturn this.cache.orientation;\n\t\t}\n\n\t\tvar result = JSM.Orientation.Invalid;\n\t\tif (this.vertices.length >= 3) {\n\t\t\tvar signedArea = this.GetSignedArea ();\n\t\t\tif (JSM.IsPositive (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.CounterClockwise;\n\t\t\t} else if (JSM.IsNegative (signedArea)) {\n\t\t\t\tresult = JSM.Orientation.Clockwise;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.orientation = result;\n\t\treturn result;\n\t};\n\n\n\t/**\n\t* Function: Polygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.cache.complexity !== null) {\n\t\t\treturn this.cache.complexity;\n\t\t}\n\t\t\n\t\tvar count = this.vertices.length;\n\t\tif (count < 3) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\t\n\t\tvar result = JSM.Complexity.Invalid;\n\t\tvar polygonOrientain = this.GetOrientation ();\n\t\tif (polygonOrientain != JSM.Orientation.Invalid) {\n\t\t\tresult = JSM.Complexity.Convex;\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (this.IsConcaveVertex (i)) {\n\t\t\t\t\tresult = JSM.Complexity.Concave;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cache.complexity = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.GetVertexOrientation\n\t* Description: Calculates the orientation of the given vertex of the polygon.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.Polygon2D.prototype.GetVertexOrientation = function (index)\n\t{\n\t\tif (this.cache.vertexOrientations[index] !== undefined) {\n\t\t\treturn this.cache.vertexOrientations[index];\n\t\t}\n\n\t\tvar prev = this.vertices[this.GetPrevVertex (index)];\n\t\tvar curr = this.vertices[index];\n\t\tvar next = this.vertices[this.GetNextVertex (index)];\n\t\t\n\t\tvar result = JSM.CoordOrientation2D (prev, curr, next);\n\t\tthis.cache.vertexOrientations[index] = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConvexVertex\n\t* Description: Returns if the given vertex is convex.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConvexVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation == orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsConcaveVertex\n\t* Description: Returns if the given vertex is concave.\n\t* Parameters:\n\t*\tindex {integer} the vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsConcaveVertex = function (index)\n\t{\n\t\tvar orientation = this.GetOrientation ();\n\t\tvar vertexOrientation = this.GetVertexOrientation (index);\n\t\tif (vertexOrientation == JSM.Orientation.Invalid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn vertexOrientation != orientation;\n\t};\n\n\t/**\n\t* Function: Polygon2D.CoordPosition\n\t* Description: Calculates the position of a coordinate and the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t* Returns:\n\t*\t{CoordPolygonPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.CoordPosition = function (coord)\n\t{\n\t\tfunction IntersectionCount (coord, beg, end)\n\t\t{\n\t\t\tfunction GetIntersection (coord, beg, end)\n\t\t\t{\n\t\t\t\tvar result = new JSM.Coord2D (beg.x, coord.y);\n\t\t\t\tif (!JSM.IsEqual (beg.y, coord.y)) {\n\t\t\t\t\tvar yMoveRatio = Math.abs ((beg.y - coord.y) / (end.y - beg.y));\n\t\t\t\t\tresult.x = beg.x + (end.x - beg.x) * yMoveRatio;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tvar begYDist = beg.y - coord.y;\n\t\t\tvar endYDist = end.y - coord.y;\n\t\t\t\n\t\t\tvar begBelow = JSM.IsNegative (begYDist);\n\t\t\tvar begAbove = JSM.IsPositive (begYDist);\n\t\t\tvar endBelow = JSM.IsNegative (endYDist);\n\t\t\tvar endAbove = JSM.IsPositive (endYDist);\n\t\t\tif ((begBelow && endBelow) || (begAbove && endAbove)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar begOnLine = !begBelow && !begAbove;\n\t\t\tvar endOnLine = !endBelow && !endAbove;\n\t\t\tif (begOnLine && endOnLine) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar intersection = GetIntersection (coord, beg, end);\n\t\t\tif (JSM.IsLower (intersection.x, coord.x)) {\n\t\t\t\treturn 0;\n\t\t\t} else if (JSM.IsGreater (intersection.x, coord.x)) {\n\t\t\t\tif (begOnLine || endOnLine) {\n\t\t\t\t\tvar upwardEdge = JSM.IsGreater (end.y, beg.y);\n\t\t\t\t\tif (begOnLine && upwardEdge || endOnLine && !upwardEdge) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tvar vertexCount = this.vertices.length;\n\t\tvar intersections = 0;\n\t\tvar i, edgeFrom, edgeTo, sector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeFrom = this.vertices[i];\n\t\t\tedgeTo = this.vertices[(i + 1) % vertexCount];\n\t\t\tsector = new JSM.Sector2D (edgeFrom, edgeTo);\n\t\t\tposition = sector.CoordPosition (coord);\n\t\t\tif (position == JSM.CoordSectorPosition2D.CoordInsideOfSector) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnEdge;\n\t\t\t} else if (position == JSM.CoordSectorPosition2D.CoordOnSectorEndCoord) {\n\t\t\t\treturn JSM.CoordPolygonPosition2D.OnVertex;\n\t\t\t}\n\t\t\tintersections += IntersectionCount (coord, edgeFrom, edgeTo);\n\t\t}\n\t\t\n\t\tif (intersections % 2 !== 0) {\n\t\t\treturn JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\treturn JSM.CoordPolygonPosition2D.Outside;\n\t};\n\n\t/**\n\t* Function: Polygon2D.SectorPosition\n\t* Description:\n\t*\tCalculates the position of a sector and the polygon. The given begin and end\n\t*\tvertex indices are omitted form intersection checking.\n\t* Parameters:\n\t*\tsector {Sector2D} the sector\n\t*\tbegIndex {integer} begin vertex index\n\t*\tendIndex {integer} end vertex index\n\t* Returns:\n\t*\t{CoordSectorPosition2D} the result\n\t*/\n\tJSM.Polygon2D.prototype.SectorPosition = function (sector, begIndex, endIndex)\n\t{\n\t\tvar result = JSM.SectorPolygonPosition2D.NoIntersection;\n\t\tvar vertexCount = this.vertices.length;\n\t\tif (vertexCount < 3) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tvar i, edgeBegIndex, edgeEndIndex, edgeBeg, edgeEnd;\n\t\tvar currentSector, position;\n\t\tfor (i = 0; i < vertexCount; i++) {\n\t\t\tedgeBegIndex = i;\n\t\t\tedgeEndIndex = (i + 1) % vertexCount;\n\t\t\tedgeBeg = this.vertices[edgeBegIndex];\n\t\t\tedgeEnd = this.vertices[edgeEndIndex];\n\t\t\tif (edgeBegIndex == begIndex || edgeEndIndex == begIndex || edgeBegIndex == endIndex || edgeEndIndex == endIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentSector = new JSM.Sector2D (edgeBeg, edgeEnd);\n\t\t\tposition = sector.SectorPosition (currentSector);\n\t\t\tif (position == JSM.SectorSectorPosition2D.SectorsIntersectOnePoint) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionOnePoint;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectCoincident) {\n\t\t\t\treturn JSM.SectorPolygonPosition2D.IntersectionCoincident;\n\t\t\t} else if (position == JSM.SectorSectorPosition2D.SectorsIntersectEndPoint) {\n\t\t\t\tresult = JSM.SectorPolygonPosition2D.IntersectionOnVertex;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.IsDiagonal\n\t* Description: Returns if the sector between two vertices is diagonal.\n\t* Parameters:\n\t*\tfrom {integer} begin vertex index\n\t*\tto {integer} end vertex index\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.Polygon2D.prototype.IsDiagonal = function (from, to)\n\t{\n\t\tfunction DiagonalIntersectsAnyEdges (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar sector = new JSM.Sector2D (fromVertex, toVertex);\n\t\t\tvar position = polygon.SectorPosition (sector, from, to);\n\t\t\tif (position != JSM.SectorPolygonPosition2D.NoIntersection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfunction DiagonalInsideOfPolygon (polygon, from, to)\n\t\t{\n\t\t\tvar fromVertex = polygon.GetVertex (from);\n\t\t\tvar toVertex = polygon.GetVertex (to);\n\t\t\tvar midCoord = new JSM.Coord2D (\n\t\t\t\t(fromVertex.x + toVertex.x) / 2.0,\n\t\t\t\t(fromVertex.y + toVertex.y) / 2.0\n\t\t\t);\n\t\t\tvar position = polygon.CoordPosition (midCoord);\n\t\t\treturn position == JSM.CoordPolygonPosition2D.Inside;\n\t\t}\n\t\t\n\t\tif (from == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.GetPrevVertex (from) == to || this.GetNextVertex (from) == to) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar fromVertex = this.vertices[from];\n\t\tvar toVertex = this.vertices[to];\n\t\tif (fromVertex.IsEqual (toVertex)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (DiagonalIntersectsAnyEdges (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!DiagonalInsideOfPolygon (this, from, to)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: Polygon2D.ToArray\n\t* Description: Creates an array of vertices from polygon.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.Polygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tvertices.push (vertex.Clone ());\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: Polygon2D.FromArray\n\t* Description: Creates the polygon from an array of vertices.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.Polygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t}\n\t};\n\n\t/**\n\t * Function: Polygon2D.GetBoundingBox\n\t * Description: Calculates the bounding box of the polygon.\n\t * Returns:\n\t *\t{Box2D} the result\n\t */\n\tJSM.Polygon2D.prototype.GetBoundingBox = function ()\n\t{\n\t\tif (this.cache.boundingBox !== null) {\n\t\t\treturn this.cache.boundingBox;\n\t\t}\n\n\t\tvar result = new JSM.Box2D (\n\t\t\tnew JSM.Coord2D (JSM.Inf, JSM.Inf),\n\t\t\tnew JSM.Coord2D (-JSM.Inf, -JSM.Inf)\n\t\t);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tcoord = this.vertices[i];\n\t\t\tresult.min.x = JSM.Minimum (result.min.x, coord.x);\n\t\t\tresult.min.y = JSM.Minimum (result.min.y, coord.y);\n\t\t\tresult.max.x = JSM.Maximum (result.max.x, coord.x);\n\t\t\tresult.max.y = JSM.Maximum (result.max.y, coord.y);\n\t\t}\n\n\t\tthis.cache.boundingBox = result;\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.Polygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.vertices = [];\n\t\tthis.ClearCache ();\n\t};\n\n\t/**\n\t* Function: Polygon2D.ClearCache\n\t* Description: Clears stored values from the polygon.\n\t*/\n\tJSM.Polygon2D.prototype.ClearCache = function ()\n\t{\n\t\tthis.cache = {\n\t\t\tsignedArea : null,\n\t\t\torientation : null,\n\t\t\tvertexOrientations : {},\n\t\t\tcomplexity : null,\n\t\t\tboundingBox : null\n\t\t};\n\t};\n\n\t/**\n\t* Function: Polygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{Polygon2D} a cloned instance\n\t*/\n\tJSM.Polygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < this.vertices.length; i++) {\n\t\t\tvertex = this.vertices[i];\n\t\t\tresult.AddVertexCoord (vertex.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t* Class: ContourPolygon2D\n\t* Description: Represents a 2D polygon with more contours.\n\t*/\n\tJSM.ContourPolygon2D = function ()\n\t{\n\t\tthis.contours = null;\n\t\tthis.Clear ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertex\n\t* Description: Adds a vertex to the last contour of the polygon.\n\t* Parameters:\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertex = function (x, y)\n\t{\n\t\tthis.lastContour.AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddVertexCoord\n\t* Description: Adds a vertex coordinate to the last contour of the polygon.\n\t* Parameters:\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddVertexCoord = function (coord)\n\t{\n\t\tthis.lastContour.AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertex\n\t* Description: Adds a vertex to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertex = function (contourIndex, x, y)\n\t{\n\t\treturn this.contours[contourIndex].AddVertex (x, y);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContourVertexCoord\n\t* Description: Adds a vertex coordinate to the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tcoord {Coord2D} the coordinate\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContourVertexCoord = function (contourIndex, coord)\n\t{\n\t\treturn this.contours[contourIndex].AddVertexCoord (coord);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.VertexCount\n\t* Description: Returns the vertex count of the polygon.\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.VertexCount = function ()\n\t{\n\t\tvar vertexCount = 0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tvertexCount += this.contours[i].VertexCount ();\n\t\t}\n\t\treturn vertexCount;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ReverseVertices\n\t* Description: Reverses the orientation of the vertices.\n\t*/\n\tJSM.ContourPolygon2D.prototype.ReverseVertices = function ()\n\t{\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tthis.contours[i].ReverseVertices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourVertexCount\n\t* Description: Returns the vertex count of the given contour of the polygon.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{integer} vertex count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourVertexCount = function (contourIndex)\n\t{\n\t\treturn this.contours[contourIndex].VertexCount ();\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.AddContour\n\t* Description:\n\t*\tAdds a contour to the polygon. If the given contour is null,\n\t*\tan empty contour is added to the polygon.\n\t* Parameters:\n\t*\tcontour {Polygon2D} the new contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.AddContour = function (contour)\n\t{\n\t\tif (contour === undefined || contour === null) {\n\t\t\tthis.lastContour = new JSM.Polygon2D ();\n\t\t} else {\n\t\t\tthis.lastContour = contour;\n\t\t}\n\t\tthis.contours.push (this.lastContour);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetLastContour\n\t* Description: Returns the last contour of the polygon.\n\t* Returns:\n\t*\t{Polygon2D} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetLastContour = function ()\n\t{\n\t\treturn this.lastContour;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContourVertex\n\t* Description: Returns the vertex of the given contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t*\tvertexIndex {integer} the index of the vertex\n\t* Returns:\n\t*\t{Coord2D} the vertex\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContourVertex = function (contourIndex, vertexIndex)\n\t{\n\t\treturn this.contours[contourIndex].GetVertex (vertexIndex);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetContour\n\t* Description: Returns the contour with the given index.\n\t* Parameters:\n\t*\tcontourIndex {integer} the index of the contour\n\t* Returns:\n\t*\t{Polygon2D} the contour\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetContour = function (index)\n\t{\n\t\treturn this.contours[index];\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ContourCount\n\t* Description: Returns the contour count of the polygon.\n\t* Returns:\n\t*\t{integer} contour count\n\t*/\n\tJSM.ContourPolygon2D.prototype.ContourCount = function ()\n\t{\n\t\treturn this.contours.length;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetSignedArea\n\t* Description: Calculates the signed area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetSignedArea = function ()\n\t{\n\t\tvar area = 0.0;\n\t\tvar i;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tarea += this.contours[i].GetSignedArea ();\n\t\t}\n\t\treturn area;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetArea\n\t* Description: Calculates the area of the polygon.\n\t* Returns:\n\t*\t{number} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetArea = function ()\n\t{\n\t\tvar signedArea = this.GetSignedArea ();\n\t\treturn Math.abs (signedArea);\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetOrientation\n\t* Description: Calculates the orientation of the polygon.\n\t* Returns:\n\t*\t{Orientation} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetOrientation = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar orientation = this.contours[0].GetOrientation ();\n\t\tif (this.contours.length == 1) {\n\t\t\treturn orientation;\n\t\t}\n\t\tif (orientation == JSM.Orientation.Invalid) {\n\t\t\treturn JSM.Orientation.Invalid;\n\t\t}\n\t\tvar i, contourOrientation;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourOrientation = this.contours[i].GetOrientation ();\n\t\t\tif (contourOrientation == JSM.Orientation.Invalid) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t\tif (orientation == contourOrientation) {\n\t\t\t\treturn JSM.Orientation.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn orientation;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.GetComplexity\n\t* Description: Calculates the complexity of the polygon.\n\t* Returns:\n\t*\t{Complexity} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.GetComplexity = function ()\n\t{\n\t\tif (this.lastContour === null) {\n\t\t\treturn JSM.Complexity.Invalid;\n\t\t}\n\t\tif (this.contours.length == 1) {\n\t\t\treturn this.contours[0].GetComplexity ();\n\t\t}\n\t\tvar i, contourComplexity;\n\t\tfor (i = 1; i < this.contours.length; i++) {\n\t\t\tcontourComplexity = this.contours[i].GetComplexity ();\n\t\t\tif (contourComplexity == JSM.Complexity.Invalid) {\n\t\t\t\treturn JSM.Complexity.Invalid;\n\t\t\t}\n\t\t}\n\t\treturn JSM.Complexity.Complex;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.ToArray\n\t* Description:\n\t*\tCreates an array of vertices from polygon. The result contains\n\t*\tnull values between contours.\n\t* Returns:\n\t*\t{Coord2D[*]} the result\n\t*/\n\tJSM.ContourPolygon2D.prototype.ToArray = function ()\n\t{\n\t\tvar vertices = [];\n\t\tvar i, j, contour, vertex;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\tvertices.push (vertex.Clone ());\n\t\t\t}\n\t\t\tif (i < this.contours.length - 1) {\n\t\t\t\tvertices.push (null);\n\t\t\t}\n\t\t}\n\t\treturn vertices;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.FromArray\n\t* Description:\n\t*\tCreates the polygon from an array of vertices. The input should contain\n\t*\tnull values between contours.\n\t* Parameters:\n\t*\tvertices {Coord2D[*]} the array of vertices\n\t*/\n\tJSM.ContourPolygon2D.prototype.FromArray = function (vertices)\n\t{\n\t\tthis.Clear ();\n\t\tthis.AddContour ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tif (vertex === null) {\n\t\t\t\tthis.AddContour ();\n\t\t\t} else {\n\t\t\t\tthis.AddVertex (vertex.x, vertex.y);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clear\n\t* Description: Makes the polygon empty.\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clear = function ()\n\t{\n\t\tthis.contours = [];\n\t\tthis.lastContour = null;\n\t};\n\n\t/**\n\t* Function: ContourPolygon2D.Clone\n\t* Description: Clones the polygon.\n\t* Returns:\n\t*\t{ContourPolygon2D} a cloned instance\n\t*/\n\tJSM.ContourPolygon2D.prototype.Clone = function ()\n\t{\n\t\tvar result = new JSM.ContourPolygon2D ();\n\t\tvar i, contour;\n\t\tfor (i = 0; i < this.contours.length; i++) {\n\t\t\tcontour = this.contours[i];\n\t\t\tresult.AddContour (contour.Clone ());\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n"]}