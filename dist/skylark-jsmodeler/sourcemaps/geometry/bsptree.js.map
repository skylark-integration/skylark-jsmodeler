{"version":3,"sources":["geometry/bsptree.js"],"names":["define","JSM","BSPTree","this","root","prototype","AddPolygon","polygon","userData","CreateNewNode","AddPolygonToNode","Traverse","nodeFound","TraverseNode","node","inside","outside","GetNodes","result","push","NodeCount","count","VertexCount","normal","GetNormal","plane","GetPlaneFromCoordAndDirection","GetVertex","undefined","backPolygons","frontPolygons","planePolygons","CutPolygonWithPlane","length","AddInsidePolygonsToNode","AddOutsidePolygonsToNode","VectorDot","polygons","i","parent","ClipPolygonWithBSPTree","bspTree","planarFrontPolygons","planarBackPolygons","CutPolygonWithNode","isPlanar","cutBackPolygons","cutFrontPolygons","cutPlanarPolygons","AddInsidePolygons","AddOutsidePolygons","CutPolygonsWithNode","AddPolygonsToArray","polygonArray","TraverseBSPTreeForEyePosition","eyePosition","coordPlanePosition","CoordPosition","CoordPlanePosition","CoordInFrontOfPlane","CoordAtBackOfPlane"],"mappings":"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","file":"../../geometry/bsptree.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Class: BSPTree\n\t* Description: Defines a BSP tree.\n\t*/\n\tJSM.BSPTree = function ()\n\t{\n\t\tthis.root = null;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygon\n\t* Description: Adds a polygon to the tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygon = function (polygon, userData)\n\t{\n\t\tif (this.root === null) {\n\t\t\tthis.root = this.CreateNewNode ();\n\t\t}\n\t\t\n\t\treturn this.AddPolygonToNode (this.root, polygon, userData);\n\t};\n\n\t/**\n\t* Function: BSPTree.Traverse\n\t* Description: Traverses the tree and calls a function on node found.\n\t* Parameters:\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.Traverse = function (nodeFound)\n\t{\n\t\tthis.TraverseNode (this.root, nodeFound);\n\t};\n\n\t/**\n\t* Function: BSPTree.TraverseNode\n\t* Description: Traverses a node and its children and calls a function on node found.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.BSPTree.prototype.TraverseNode = function (node, nodeFound)\n\t{\n\t\tif (node !== null) {\n\t\t\tnodeFound (node);\n\t\t\tthis.TraverseNode (node.inside, nodeFound);\n\t\t\tthis.TraverseNode (node.outside, nodeFound);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Returns the nodes as an array.\n\t* Returns:\n\t*\t{object[*]} the result\n\t*/\n\tJSM.BSPTree.prototype.GetNodes = function ()\n\t{\n\t\tvar result = [];\n\t\tthis.Traverse (function (node) {\n\t\t\tresult.push (node);\n\t\t});\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: BSPTree.GetNodes\n\t* Description: Count nodes.\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.BSPTree.prototype.NodeCount = function ()\n\t{\n\t\tvar count = 0;\n\t\tthis.Traverse (function () {\n\t\t\tcount = count + 1;\n\t\t});\n\t\treturn count;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddPolygonToNode\n\t* Description: Adds a polygon to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon} the polygon\n\t*\tuserData {anything} user data for polygon\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.BSPTree.prototype.AddPolygonToNode = function (node, polygon, userData)\n\t{\n\t\tif (polygon.VertexCount () < 3) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar normal;\n\t\tif (node.polygon === null) {\n\t\t\tnormal = polygon.GetNormal ();\n\t\t\tvar plane = JSM.GetPlaneFromCoordAndDirection (polygon.GetVertex (0), normal);\n\t\t\tnode.polygon = polygon;\n\t\t\tif (userData !== undefined) {\n\t\t\t\tnode.userData = userData;\n\t\t\t}\n\t\t\tnode.plane = plane;\n\t\t} else {\n\t\t\tvar backPolygons = [];\n\t\t\tvar frontPolygons = [];\n\t\t\tvar planePolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, frontPolygons, backPolygons, planePolygons);\n\t\t\tif (cutSucceeded) {\n\t\t\t\tif (backPolygons.length > 0) {\n\t\t\t\t\tthis.AddInsidePolygonsToNode (node, backPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (frontPolygons.length > 0) {\n\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, frontPolygons, userData);\n\t\t\t\t}\n\t\t\t\tif (planePolygons.length > 0) {\n\t\t\t\t\tnormal = polygon.GetNormal ();\n\t\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\t\tthis.AddInsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.AddOutsidePolygonsToNode (node, planePolygons, userData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: BSPTree.AddInsidePolygonsToNode\n\t* Description: Adds inside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddInsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.inside === null) {\n\t\t\tnode.inside = this.CreateNewNode ();\n\t\t\tnode.inside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.inside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.AddOutsidePolygonsToNode\n\t* Description: Adds outside polygons to a node.\n\t* Parameters:\n\t*\tnode {object} the node\n\t*\tpolygon {Polygon[*]} the polygons\n\t*\tuserData {anything} user data for polygons\n\t*/\n\tJSM.BSPTree.prototype.AddOutsidePolygonsToNode = function (node, polygons, userData)\n\t{\n\t\tif (node.outside === null) {\n\t\t\tnode.outside = this.CreateNewNode ();\n\t\t\tnode.outside.parent = node;\n\t\t}\n\t\tvar i;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tthis.AddPolygonToNode (node.outside, polygons[i], userData);\n\t\t}\n\t};\n\n\t/**\n\t* Function: BSPTree.CreateNewNode\n\t* Description: Creates a new node.\n\t* Returns:\n\t*\t{object} the result\n\t*/\n\tJSM.BSPTree.prototype.CreateNewNode = function ()\n\t{\n\t\tvar node = {\n\t\t\tpolygon : null,\n\t\t\tuserData : null,\n\t\t\tplane : null,\n\t\t\tparent : null,\n\t\t\tinside : null,\n\t\t\toutside : null\n\t\t};\n\t\treturn node;\n\t};\n\n\t/**\n\t* Function: ClipPolygonWithBSPTree\n\t* Description: Clips a polygon with a created BSP tree.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the tree\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the tree\n\t*\tplanarFrontPolygons {Polygon[*]} (out) polygons on the tree looks front\n\t*\tplanarBackPolygons {Polygon[*]} (out) polygons on the tree looks back\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.ClipPolygonWithBSPTree = function (polygon, bspTree, frontPolygons, backPolygons, planarFrontPolygons, planarBackPolygons)\n\t{\n\t\tfunction CutPolygonWithNode (polygon, node, isPlanar)\n\t\t{\n\t\t\tif (node === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar cutBackPolygons = [];\n\t\t\tvar cutFrontPolygons = [];\n\t\t\tvar cutPlanarPolygons = [];\n\t\t\tvar cutSucceeded = JSM.CutPolygonWithPlane (polygon, node.plane, cutFrontPolygons, cutBackPolygons, cutPlanarPolygons);\n\t\t\tif (!cutSucceeded) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cutBackPolygons.length > 0) {\n\t\t\t\tAddInsidePolygons (node, cutBackPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutFrontPolygons.length > 0) {\n\t\t\t\tAddOutsidePolygons (node, cutFrontPolygons, isPlanar);\n\t\t\t}\n\t\t\tif (cutPlanarPolygons.length > 0) {\n\t\t\t\tvar normal = polygon.GetNormal ();\n\t\t\t\tif (JSM.VectorDot (normal, node.plane.GetNormal ()) > 0) {\n\t\t\t\t\tAddInsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t} else {\n\t\t\t\t\tAddOutsidePolygons (node, cutPlanarPolygons, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction CutPolygonsWithNode (polygons, node, isPlanar)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tCutPolygonWithNode (polygons[i], node, isPlanar);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygonsToArray (polygons, polygonArray)\n\t\t{\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tpolygonArray.push (polygons[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction AddInsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.inside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.inside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarBackPolygons : backPolygons);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddOutsidePolygons (node, polygons, isPlanar)\n\t\t{\n\t\t\tif (node.outside !== null) {\n\t\t\t\tCutPolygonsWithNode (polygons, node.outside, isPlanar);\n\t\t\t} else {\n\t\t\t\tAddPolygonsToArray (polygons, isPlanar ? planarFrontPolygons : frontPolygons);\n\t\t\t}\n\t\t}\n\n\t\tCutPolygonWithNode (polygon, bspTree.root, false);\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraverseBSPTreeForEyePosition\n\t* Description: Traverses a BSP tree for a given eye position.\n\t* Parameters:\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\teyePosition {Coord} the eye position\n\t*\tnodeFound {function} the callback function\n\t*/\n\tJSM.TraverseBSPTreeForEyePosition = function (bspTree, eyePosition, nodeFound)\n\t{\n\t\tfunction TraverseNode (node)\n\t\t{\n\t\t\tif (node !== null) {\n\t\t\t\tvar coordPlanePosition = node.plane.CoordPosition (eyePosition);\n\t\t\t\tif (coordPlanePosition == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t} else if (coordPlanePosition == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tnodeFound (node);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t} else {\n\t\t\t\t\tTraverseNode (node.outside);\n\t\t\t\t\tTraverseNode (node.inside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTraverseNode (bspTree.root);\n\t};\n\n\treturn JSM;\n});\n"]}