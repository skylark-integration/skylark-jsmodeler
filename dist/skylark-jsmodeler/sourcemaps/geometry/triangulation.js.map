{"version":3,"sources":["geometry/triangulation.js"],"names":["define","JSM","ConvertContourPolygonToPolygon2D","inputPolygon","vertexMap","AddResultVertex","resultPolygon","vertex","originalContour","originalVertex","AddVertexCoord","undefined","push","AddContour","holeIndex","conversionData","entryPoint","IsEntryPoint","resultVertex","holeVertex","SegmentIntersectsPolygon","polygon","segmentBeg","segmentEnd","sector","Sector2D","position","SectorPosition","SectorPolygonPosition2D","IntersectionOnePoint","IntersectionCoincident","i","ContourCount","addedHoles","GetContour","IsExistingEntryPosition","coord","entryPositions","length","IsEqual","resultVertexIndex","holeVertexIndex","holePolygon","VertexCount","GetVertex","Clone","beg","end","GetEntryPoint","mainContourBeg","mainEntryVertex","ShiftVertices","mainEntryContourIndex","mainEntryVertexIndex","ShiftArray","contourBeg","contourEnd","GetPrevVertex","EnumerateVertices","index","AddHole","contourCount","mainContour","Polygon2D","holeQueue","holeTryouts","shift","TriangulateConvexPolygon","result","TriangulateConcavePolygon2D","FindSplitDiagonal","j","count","IsDiagonal","SplitPolygon","polygonData","diagonal","AddVertex","resultData","map","resultData1","resultData2","polygonStack","inputMap","GetInitialVertexMap","vertexCount","pop","TriangulatePolygon2D","complexity","GetComplexity","Complexity","Invalid","Convex","TriangulatePolygon","polygon2D","ToPolygon2D"],"mappings":"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","file":"../../geometry/triangulation.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\tJSM.ConvertContourPolygonToPolygon2D = function (inputPolygon, vertexMap)\n\t{\n\t\tfunction AddResultVertex (resultPolygon, vertex, vertexMap, originalContour, originalVertex)\n\t\t{\n\t\t\tresultPolygon.AddVertexCoord (vertex);\n\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\tvertexMap.push ([originalContour, originalVertex]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)\n\t\t{\n\t\t\tfunction GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData)\n\t\t\t{\n\t\t\t\tfunction IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)\n\t\t\t\t{\n\t\t\t\t\tfunction SegmentIntersectsPolygon (polygon, segmentBeg, segmentEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sector = new JSM.Sector2D (segmentBeg, segmentEnd);\n\t\t\t\t\t\tvar position = polygon.SectorPosition (sector, -1, -1);\n\t\t\t\t\t\tif (position == JSM.SectorPolygonPosition2D.IntersectionOnePoint || position == JSM.SectorPolygonPosition2D.IntersectionCoincident) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SegmentIntersectsPolygon (resultPolygon, resultVertex, holeVertex)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar i, hole;\n\t\t\t\t\tfor (i = 1; i < inputPolygon.ContourCount (); i++) {\n\t\t\t\t\t\tif (conversionData.addedHoles[i] !== undefined) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thole = inputPolygon.GetContour (i);\n\t\t\t\t\t\tif (SegmentIntersectsPolygon (hole, resultVertex, holeVertex)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction IsExistingEntryPosition (coord, conversionData)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = 0; i < conversionData.entryPositions.length; i++) {\n\t\t\t\t\t\tif (coord.IsEqual (conversionData.entryPositions[i])) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar resultVertexIndex, holeVertexIndex, resultVertex, holeVertex;\n\t\t\t\tfor (resultVertexIndex = 0; resultVertexIndex < resultPolygon.VertexCount (); resultVertexIndex++) {\n\t\t\t\t\tfor (holeVertexIndex = 0; holeVertexIndex < holePolygon.VertexCount (); holeVertexIndex++) {\n\t\t\t\t\t\tresultVertex = resultPolygon.GetVertex (resultVertexIndex);\n\t\t\t\t\t\tholeVertex = holePolygon.GetVertex (holeVertexIndex);\n\t\t\t\t\t\tif (IsEntryPoint (inputPolygon, resultPolygon, resultVertex, holeVertex, conversionData)) {\n\t\t\t\t\t\t\tif (IsExistingEntryPosition (resultVertex, conversionData) || IsExistingEntryPosition (holeVertex, conversionData)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconversionData.entryPositions.push (resultVertex.Clone ());\n\t\t\t\t\t\t\tconversionData.entryPositions.push (holeVertex.Clone ());\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tbeg : resultVertexIndex,\n\t\t\t\t\t\t\t\tend : holeVertexIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tfunction AddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap)\n\t\t\t{\n\t\t\t\tvar holePolygon = inputPolygon.GetContour (holeIndex);\n\t\t\t\tvar mainContourBeg = entryPoint.beg;\n\t\t\t\tvar mainEntryVertex = resultPolygon.GetVertex (mainContourBeg).Clone ();\n\t\t\t\tresultPolygon.ShiftVertices (mainContourBeg + 1);\n\n\t\t\t\tvar mainEntryContourIndex = 0;\n\t\t\t\tvar mainEntryVertexIndex = 0;\n\t\t\t\tif (vertexMap !== undefined && vertexMap !== null) {\n\t\t\t\t\tmainEntryContourIndex = vertexMap[mainContourBeg][0];\n\t\t\t\t\tmainEntryVertexIndex = vertexMap[mainContourBeg][1];\n\t\t\t\t\tJSM.ShiftArray (vertexMap, mainContourBeg + 1);\n\t\t\t\t}\n\n\t\t\t\tvar contourBeg = entryPoint.end;\n\t\t\t\tvar contourEnd = holePolygon.GetPrevVertex (contourBeg);\n\t\t\t\tholePolygon.EnumerateVertices (contourBeg, contourEnd, function (index) {\n\t\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (index).Clone (), vertexMap, holeIndex, index);\n\t\t\t\t});\n\t\t\t\tAddResultVertex (resultPolygon, holePolygon.GetVertex (contourBeg).Clone (), vertexMap, holeIndex, contourBeg);\n\t\t\t\tAddResultVertex (resultPolygon, mainEntryVertex, vertexMap, mainEntryContourIndex, mainEntryVertexIndex);\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPoint = GetEntryPoint (inputPolygon, resultPolygon, holeIndex, conversionData);\n\t\t\tif (entryPoint === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAddHole (resultPolygon, inputPolygon, holeIndex, entryPoint, vertexMap);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tvar contourCount = inputPolygon.ContourCount ();\n\t\tvar mainContour = inputPolygon.GetContour (0);\n\t\tvar resultPolygon = new JSM.Polygon2D ();\n\t\tvar i, vertex;\n\t\tfor (i = 0; i < mainContour.VertexCount (); i++) {\n\t\t\tvertex = mainContour.GetVertex (i);\n\t\t\tAddResultVertex (resultPolygon, vertex.Clone (), vertexMap, 0, i);\n\t\t}\n\t\tif (contourCount == 1) {\n\t\t\treturn resultPolygon;\n\t\t}\n\t\t\n\t\tvar holeQueue = [];\n\t\tvar holeIndex;\n\t\tfor (holeIndex = 1; holeIndex < contourCount; holeIndex++) {\n\t\t\tholeQueue.push (holeIndex);\n\t\t}\n\t\t\n\t\tvar conversionData = {\n\t\t\taddedHoles : {},\n\t\t\tholeTryouts : {},\n\t\t\tentryPositions : []\n\t\t};\n\t\t\n\t\twhile (holeQueue.length > 0) {\n\t\t\tholeIndex = holeQueue.shift ();\n\t\t\tif (AddContour (inputPolygon, resultPolygon, holeIndex, vertexMap, conversionData)) {\n\t\t\t\tconversionData.addedHoles[holeIndex] = true;\n\t\t\t} else {\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] === undefined) {\n\t\t\t\t\tconversionData.holeTryouts[holeIndex] = 0;\n\t\t\t\t}\n\t\t\t\tconversionData.holeTryouts[holeIndex] += 1;\n\t\t\t\tif (conversionData.holeTryouts[holeIndex] > 10) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tholeQueue.push (holeIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn resultPolygon;\n\t};\n\n\tJSM.TriangulateConvexPolygon = function (polygon)\n\t{\n\t\tvar result = [];\n\t\tvar i;\n\t\tfor (i = 1; i < polygon.VertexCount () - 1; i++) {\n\t\t\tresult.push ([0, i, i + 1]);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulateConcavePolygon2D = function (inputPolygon)\n\t{\n\t\tfunction GetInitialVertexMap (count)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tresult[i] = i;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tfunction FindSplitDiagonal (polygon)\n\t\t{\n\t\t\tvar count = polygon.VertexCount ();\n\t\t\tvar i, j;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (polygon.IsDiagonal (i, j)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tbeg : i,\n\t\t\t\t\t\t\tend : j\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction SplitPolygon (polygonData, diagonal)\n\t\t{\n\t\t\tfunction AddVertex (polygonData, resultData, index)\n\t\t\t{\n\t\t\t\tresultData.polygon.AddVertexCoord (polygonData.polygon.GetVertex (index));\n\t\t\t\tresultData.map.push (polygonData.map[index]);\n\t\t\t}\n\t\t\t\n\t\t\tvar resultData1 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\t\t\tvar resultData2 = {\n\t\t\t\tpolygon : new JSM.Polygon2D (),\n\t\t\t\tmap : []\n\t\t\t};\n\n\t\t\tvar beg, end;\n\t\t\t\n\t\t\tbeg = diagonal.beg;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.end);\n\t\t\tAddVertex (polygonData, resultData1, diagonal.end);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData1, index);\n\t\t\t});\n\n\t\t\tbeg = diagonal.end;\n\t\t\tend = polygonData.polygon.GetPrevVertex (diagonal.beg);\n\t\t\tAddVertex (polygonData, resultData2, diagonal.beg);\n\t\t\tpolygonData.polygon.EnumerateVertices (beg, end, function (index) {\n\t\t\t\tAddVertex (polygonData, resultData2, index);\n\t\t\t});\n\t\t\t\n\t\t\treturn {\n\t\t\t\tresultData1 : resultData1,\n\t\t\t\tresultData2 : resultData2\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar polygonStack = [];\n\t\tvar count = inputPolygon.VertexCount ();\n\t\tvar inputMap = GetInitialVertexMap (count);\n\t\tpolygonStack.push ({\n\t\t\tpolygon : inputPolygon,\n\t\t\tmap : inputMap\n\t\t});\n\t\t\n\t\tvar result = [];\n\t\tvar polygonData, vertexCount, diagonal, resultData;\n\t\twhile (polygonStack.length > 0) {\n\t\t\tpolygonData = polygonStack.pop ();\n\t\t\tvertexCount = polygonData.polygon.VertexCount ();\n\t\t\tif (vertexCount < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\tresult.push (polygonData.map);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdiagonal = FindSplitDiagonal (polygonData.polygon);\n\t\t\tif (diagonal === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresultData = SplitPolygon (polygonData, diagonal);\n\t\t\tpolygonStack.push (resultData.resultData1);\n\t\t\tpolygonStack.push (resultData.resultData2);\n\t\t}\n\t\treturn result;\n\t};\n\n\tJSM.TriangulatePolygon2D = function (polygon)\n\t{\n\t\tif (polygon === null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar vertexCount = polygon.VertexCount ();\n\t\tif (vertexCount < 3) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (vertexCount == 3) {\n\t\t\treturn [[0, 1, 2]];\n\t\t}\n\t\t\n\t\tvar complexity = polygon.GetComplexity ();\n\t\tif (complexity === JSM.Complexity.Invalid) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (complexity == JSM.Complexity.Convex) {\n\t\t\treturn JSM.TriangulateConvexPolygon (polygon);\n\t\t}\n\t\t\n\t\treturn JSM.TriangulateConcavePolygon2D (polygon);\n\t};\n\n\t/**\n\t* Function: TriangulatePolygon\n\t* Description:\n\t*\tTriangulates a polygon. The result defines triangles as an\n\t*\tarray of arrays with three original vertex indices.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t* Returns:\n\t*\t{integer[3][*]} the result\n\t*/\n\tJSM.TriangulatePolygon = function (polygon)\n\t{\n\t\tvar polygon2D = polygon.ToPolygon2D ();\n\t\treturn JSM.TriangulatePolygon2D (polygon2D);\n\t};\n\n\treturn JSM;\n});\n"]}