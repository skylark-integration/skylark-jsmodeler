{"version":3,"sources":["geometry/cutpolygon.js"],"names":["define","JSM","CutVertexType","Left","Right","Cut","PolygonCutter","geometryInterface","this","Reset","prototype","polygon","aSidePolygons","bSidePolygons","cutPolygons","allVertexType","CalculateOriginalPolygonData","cloned","Clone","push","CalculateCutPolygonData","CalculateEntryVertices","CalculateCuttedPolygons","originalPolygon","originalPolygonVertexTypes","cutPolygon","cutPolygonVertexTypes","cutPolygonVertexDistances","cutVertexIndices","entryVertices","entryVertexTypes","i","vertex","type","aSideFound","bSideFound","VertexCount","GetVertex","getVertexSide","IsIntersectionVertex","originalType","length","prevType","AddCutVertexToPolygon","polygonCutter","AddVertexCoord","AddIntersectionVertex","originalIndex","prevIndex","GetPrevVertex","prevVertex","currVertex","intersection","getIntersectionVertex","AddOriginalVertex","vertexCount","PrevIndex","nextType","NextIndex","createPolygon","lastVertex","getVertexDistances","BubbleSort","a","b","aDist","bDist","IsLower","j","SwapArrayValues","GetEntryVertexType","currIndex","nextIndex","prevSideType","nextSideType","currVertexDistance","prevVertexDistance","nextVertexDistance","IsLowerOrEqual","IsGreaterOrEqual","vertexIndex","vertexType","AddOneSideCuttedPolygons","reversed","AddEntryPairToArray","entryPairs","fromIndex","toIndex","GetNextVertex","currVertexIndex","nextVertex","index","RemoveEntryPairFromArray","AddCutPolygon","currEntryVertex","startVertexIndex","currPolygon","polygonSide","IsEqual","FindPairIndex","startIndex","pairIndex","CreateEntryPairsArray","CutPolygon2DWithLine","line","leftPolygons","rightPolygons","Polygon2D","position","CoordPosition","CoordLinePosition2D","CoordAtLineLeft","CoordAtLineRight","edgeLine","Line2D","CoordSub2D","Coord2D","LinePosition","LineLinePosition2D","LinesIntersectsOnePoint","origo","refLineStart","start","refLineDir","direction","Rotate","Math","PI","refLine","distances","CoordSignedDistance","CutPolygonWithPlane","plane","frontPolygons","backPolygons","Polygon","CoordPlanePosition","CoordInFrontOfPlane","CoordAtBackOfPlane","Line","CoordSub","Coord","LinePlanePosition","LineIntersectsPlane","polygonNormal","GetNormal","planeNormal","Vector","c","refPlaneNormal","VectorCross","refPlaneOrigin","refPlane","GetPlaneFromCoordAndDirection","SegmentPolygon2D","xSegments","ySegments","CutPolygonsOneDirection","inputPolygons","resultPolygons","segmentCount","segmentSize","startCoordinate","segmentDir","cutDir","CutPolygon","left","right","newPolygonsToProcess","polygonsToProcess","startCoord","Offset","boundingBox","GetBoundingBox","xSegmentSize","max","x","min","ySegmentSize","y","originalPolygons","bottomLeft","topLeft","xCuttedPolygons","yCuttedPolygons","Vector2D"],"mappings":"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","file":"../../geometry/cutpolygon.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\tJSM.CutVertexType = {\n\t\tLeft : 1,\n\t\tRight : 2,\n\t\tCut : 3\n\t};\n\n\tJSM.PolygonCutter = function (geometryInterface)\n\t{\n\t\tthis.geometryInterface = geometryInterface;\n\t\tthis.Reset ();\n\t};\n\n\tJSM.PolygonCutter.prototype.Cut = function (polygon, aSidePolygons, bSidePolygons, cutPolygons)\n\t{\n\t\tthis.Reset ();\n\t\t\n\t\tvar allVertexType = this.CalculateOriginalPolygonData (polygon);\n\t\tif (allVertexType !== null) {\n\t\t\tvar cloned = polygon.Clone ();\n\t\t\tif (allVertexType == JSM.CutVertexType.Left) {\n\t\t\t\taSidePolygons.push (cloned);\n\t\t\t} else if (allVertexType == JSM.CutVertexType.Right) {\n\t\t\t\tbSidePolygons.push (cloned);\n\t\t\t} else {\n\t\t\t\tcutPolygons.push (cloned);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCutPolygonData ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateEntryVertices ()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.CalculateCuttedPolygons (aSidePolygons, bSidePolygons)) {\n\t\t\treturn false;\n\t\t}\t\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.Reset = function ()\n\t{\n\t\tthis.originalPolygon = null;\n\t\tthis.originalPolygonVertexTypes = null;\n\t\tthis.cutPolygon = null;\n\t\tthis.cutPolygonVertexTypes = null;\n\t\tthis.cutPolygonVertexDistances = null;\n\t\tthis.cutVertexIndices = null;\n\t\tthis.entryVertices = null;\n\t\tthis.entryVertexTypes = null;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateOriginalPolygonData = function (polygon)\n\t{\n\t\tthis.originalPolygon = polygon;\n\t\tthis.originalPolygonVertexTypes = [];\n\t\tvar aSideFound = false;\n\t\tvar bSideFound = false;\n\t\t\n\t\tvar i, vertex, type;\n\t\tfor (i = 0; i < this.originalPolygon.VertexCount (); i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\ttype = this.geometryInterface.getVertexSide (vertex);\n\t\t\tif (type == JSM.CutVertexType.Left) {\n\t\t\t\taSideFound = true;\n\t\t\t} else if (type == JSM.CutVertexType.Right) {\n\t\t\t\tbSideFound = true;\n\t\t\t}\n\t\t\tthis.originalPolygonVertexTypes.push (type);\n\t\t}\n\t\t\n\t\tif (aSideFound && bSideFound) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (aSideFound) {\n\t\t\treturn JSM.CutVertexType.Left;\n\t\t} else if (bSideFound) {\n\t\t\treturn JSM.CutVertexType.Right;\n\t\t}\n\t\t\n\t\treturn JSM.CutVertexType.Cut;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCutPolygonData = function ()\n\t{\n\t\tfunction IsIntersectionVertex (cutPolygonVertexTypes, originalType)\n\t\t{\n\t\t\tif (cutPolygonVertexTypes.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar prevType = cutPolygonVertexTypes[cutPolygonVertexTypes.length - 1];\n\t\t\tif (prevType == JSM.CutVertexType.Cut || originalType == JSM.CutVertexType.Cut) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn prevType != originalType;\n\t\t}\n\t\t\n\t\tfunction AddCutVertexToPolygon (polygonCutter, vertex, type)\n\t\t{\n\t\t\tpolygonCutter.cutPolygon.AddVertexCoord (vertex);\n\t\t\tpolygonCutter.cutPolygonVertexTypes.push (type);\n\t\t\tif (type == JSM.CutVertexType.Cut) {\n\t\t\t\tpolygonCutter.cutVertexIndices.push (polygonCutter.cutPolygonVertexTypes.length - 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddIntersectionVertex (polygonCutter, originalIndex)\n\t\t{\n\t\t\tvar prevIndex = polygonCutter.originalPolygon.GetPrevVertex (originalIndex);\n\t\t\tvar prevVertex = polygonCutter.originalPolygon.GetVertex (prevIndex);\n\t\t\tvar currVertex = polygonCutter.originalPolygon.GetVertex (originalIndex);\n\t\t\tvar intersection = polygonCutter.geometryInterface.getIntersectionVertex (prevVertex, currVertex);\n\t\t\tif (intersection === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tAddCutVertexToPolygon (polygonCutter, intersection, JSM.CutVertexType.Cut);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction AddOriginalVertex (polygonCutter, originalIndex, originalType)\n\t\t{\n\t\t\tvar vertex = polygonCutter.originalPolygon.GetVertex (originalIndex).Clone ();\n\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\n\t\t\tvar vertexCount = polygonCutter.originalPolygon.VertexCount ();\n\t\t\tvar prevType = polygonCutter.originalPolygonVertexTypes[JSM.PrevIndex (originalIndex, vertexCount)];\n\t\t\tvar nextType = polygonCutter.originalPolygonVertexTypes[JSM.NextIndex (originalIndex, vertexCount)];\n\t\t\tif (originalType == JSM.CutVertexType.Cut && prevType == nextType) {\n\t\t\t\tAddCutVertexToPolygon (polygonCutter, vertex, originalType);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction SortCutVertices (cutPolygon, cutVertexIndices, cutPolygonVertexDistances)\n\t\t{\n\t\t\tif (cutVertexIndices.length < 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tJSM.BubbleSort (cutVertexIndices,\n\t\t\t\tfunction (a, b) {\n\t\t\t\t\tvar aDist = cutPolygonVertexDistances[a];\n\t\t\t\t\tvar bDist = cutPolygonVertexDistances[b];\n\t\t\t\t\treturn JSM.IsLower (aDist, bDist);\n\t\t\t\t},\n\t\t\t\tfunction (i, j) {\n\t\t\t\t\tJSM.SwapArrayValues (cutVertexIndices, i, j);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\treturn true;\n\t\t}\t\n\n\t\tthis.cutPolygon = this.geometryInterface.createPolygon ();\n\t\tthis.cutPolygonVertexTypes = [];\n\t\tthis.cutVertexIndices = [];\n\t\t\n\t\tvar vertexCount = this.originalPolygon.VertexCount ();\n\t\tvar i, lastVertex, originalIndex, originalType;\n\t\tfor (i = 0; i <= vertexCount; i++) {\n\t\t\tlastVertex = (i === vertexCount);\n\t\t\toriginalIndex = i;\n\t\t\tif (lastVertex) {\n\t\t\t\toriginalIndex = 0;\n\t\t\t}\n\t\t\t\n\t\t\toriginalType = this.originalPolygonVertexTypes[originalIndex];\n\t\t\tif (IsIntersectionVertex (this.cutPolygonVertexTypes, originalType)) {\n\t\t\t\tAddIntersectionVertex (this, originalIndex);\n\t\t\t}\n\t\t\t\n\t\t\tif (!lastVertex) {\n\t\t\t\tAddOriginalVertex (this, originalIndex, originalType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cutPolygonVertexDistances = this.geometryInterface.getVertexDistances (this.cutPolygon);\n\t\tif (!SortCutVertices (this.cutPolygon, this.cutVertexIndices, this.cutPolygonVertexDistances)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateEntryVertices = function ()\n\t{\n\t\tfunction GetEntryVertexType (cutPolygonVertexTypes, cutPolygonVertexDistances, currIndex)\n\t\t{\n\t\t\tvar currSideType = cutPolygonVertexTypes[currIndex];\n\t\t\tif (currSideType != JSM.CutVertexType.Cut) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tvar prevIndex = JSM.PrevIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar nextIndex = JSM.NextIndex (currIndex, cutPolygonVertexTypes.length);\n\t\t\tvar prevSideType = cutPolygonVertexTypes[prevIndex];\n\t\t\tvar nextSideType = cutPolygonVertexTypes[nextIndex];\n\n\t\t\tvar currVertexDistance = cutPolygonVertexDistances[currIndex];\n\t\t\tvar prevVertexDistance = cutPolygonVertexDistances[prevIndex];\n\t\t\tvar nextVertexDistance = cutPolygonVertexDistances[nextIndex];\n\t\t\t\n\t\t\tif (prevSideType == JSM.CutVertexType.Right) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Left) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Cut) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, nextVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (prevSideType == JSM.CutVertexType.Cut) {\n\t\t\t\tif (nextSideType == JSM.CutVertexType.Left) {\n\t\t\t\t\tif (JSM.IsLowerOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (nextSideType == JSM.CutVertexType.Right) {\n\t\t\t\t\tif (JSM.IsGreaterOrEqual (currVertexDistance, prevVertexDistance)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\n\t\tthis.entryVertices = [];\n\t\tthis.entryVertexTypes = [];\n\t\tvar i, vertexIndex, vertexType;\n\t\tfor (i = 0; i < this.cutVertexIndices.length; i++) {\n\t\t\tvertexIndex = this.cutVertexIndices[i];\n\t\t\tvertexType = GetEntryVertexType (this.cutPolygonVertexTypes, this.cutPolygonVertexDistances, vertexIndex);\n\t\t\tif (vertexType !== 0) {\n\t\t\t\tthis.entryVertices.push (vertexIndex);\n\t\t\t\tthis.entryVertexTypes.push (vertexType);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.entryVertices.length === 0 || this.entryVertices.length % 2 !== 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tJSM.PolygonCutter.prototype.CalculateCuttedPolygons = function (aSidePolygons, bSidePolygons)\n\t{\n\t\tfunction AddOneSideCuttedPolygons (polygonCutter, aSidePolygons, bSidePolygons, reversed)\n\t\t{\n\t\t\tfunction AddEntryPairToArray (entryPairs, entryVertices, fromIndex, toIndex)\n\t\t\t{\n\t\t\t\tentryPairs[entryVertices[fromIndex]] = entryVertices[toIndex];\n\t\t\t\tentryPairs[entryVertices[toIndex]] = entryVertices[fromIndex];\n\t\t\t}\n\n\t\t\tfunction RemoveEntryPairFromArray (entryPairs, index)\n\t\t\t{\n\t\t\t\tentryPairs[entryPairs[index]] = -1;\n\t\t\t\tentryPairs[index] = -1;\n\t\t\t}\n\n\t\t\tfunction CreateEntryPairsArray (cutPolygon, entryVertices, entryVertexTypes)\n\t\t\t{\n\t\t\t\tfunction FindPairIndex (entryPairs, entryVertices, entryVertexTypes, startIndex)\n\t\t\t\t{\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor (i = startIndex + 1; i < entryVertices.length; i++) {\n\t\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entryVertexTypes[startIndex] != entryVertexTypes[i]) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tvar entryPairs = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < cutPolygon.VertexCount (); i++) {\n\t\t\t\t\tentryPairs.push (-1);\n\t\t\t\t}\n\n\t\t\t\tvar pairIndex;\n\t\t\t\tfor (i = 0; i < entryVertices.length; i++) {\n\t\t\t\t\tif (entryPairs[entryVertices[i]] != -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpairIndex = FindPairIndex (entryPairs, entryVertices, entryVertexTypes, i);\n\t\t\t\t\tif (pairIndex == -1) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tAddEntryPairToArray (entryPairs, entryVertices, i, pairIndex);\n\t\t\t\t}\n\t\t\t\treturn entryPairs;\n\t\t\t}\n\t\t\t\n\t\t\tfunction GetNextVertex (currVertexIndex, cutPolygon, entryPairs)\n\t\t\t{\n\t\t\t\tif (entryPairs[currVertexIndex] != -1) {\n\t\t\t\t\tvar nextVertex = entryPairs[currVertexIndex];\n\t\t\t\t\tRemoveEntryPairFromArray (entryPairs, currVertexIndex);\n\t\t\t\t\treturn nextVertex;\n\t\t\t\t} else {\n\t\t\t\t\treturn JSM.NextIndex (currVertexIndex, cutPolygon.VertexCount ());\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tfunction AddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons)\n\t\t\t{\n\t\t\t\tfunction AddVertexIfNotDuplicated (polygon, vertex)\n\t\t\t\t{\n\t\t\t\t\tvar vertexCount = polygon.VertexCount ();\n\t\t\t\t\tif (vertexCount > 0 && polygon.GetVertex (vertexCount - 1).IsEqual (vertex)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpolygon.AddVertexCoord (vertex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar startVertexIndex = polygonCutter.entryVertices[currEntryVertex];\n\t\t\t\tif (entryPairs[startVertexIndex] !== -1) {\n\t\t\t\t\tvar currPolygon = polygonCutter.geometryInterface.createPolygon ();\n\t\t\t\t\tcurrPolygon.AddVertexCoord (polygonCutter.cutPolygon.GetVertex (startVertexIndex).Clone ());\n\t\t\t\t\tvar currVertexIndex = GetNextVertex (startVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\tvar polygonSide = null;\n\t\t\t\t\twhile (currVertexIndex != startVertexIndex) {\n\t\t\t\t\t\tif (polygonSide === null) {\n\t\t\t\t\t\t\tif (polygonCutter.cutPolygonVertexTypes[currVertexIndex] !== JSM.CutVertexType.Cut) {\n\t\t\t\t\t\t\t\tpolygonSide = polygonCutter.cutPolygonVertexTypes[currVertexIndex];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAddVertexIfNotDuplicated (currPolygon, polygonCutter.cutPolygon.GetVertex (currVertexIndex).Clone ());\n\t\t\t\t\t\tcurrVertexIndex = GetNextVertex (currVertexIndex, polygonCutter.cutPolygon, entryPairs);\n\t\t\t\t\t}\n\t\t\t\t\tif (currPolygon.VertexCount () > 2) {\n\t\t\t\t\t\tif (polygonSide == JSM.CutVertexType.Left) {\n\t\t\t\t\t\t\taSidePolygons.push (currPolygon);\n\t\t\t\t\t\t} else if (polygonSide == JSM.CutVertexType.Right) {\n\t\t\t\t\t\t\tbSidePolygons.push (currPolygon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar entryPairs = CreateEntryPairsArray (polygonCutter.cutPolygon, polygonCutter.entryVertices, polygonCutter.entryVertexTypes);\n\t\t\tif (entryPairs === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currEntryVertex = reversed ? polygonCutter.entryVertices.length - 1 : 0;\n\t\t\twhile (currEntryVertex >= 0 && currEntryVertex < polygonCutter.entryVertices.length) {\n\t\t\t\tAddCutPolygon (polygonCutter, entryPairs, currEntryVertex, aSidePolygons, bSidePolygons);\n\t\t\t\tcurrEntryVertex = reversed ? currEntryVertex - 1 : currEntryVertex + 1;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, false)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!AddOneSideCuttedPolygons (this, aSidePolygons, bSidePolygons, true)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CutPolygon2DWithLine\n\t* Description:\n\t*\tCuts a polygon with a line. The result array contains cutted\n\t*\tpolygons grouped by their position to the line.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\tline {Line2D} the line\n\t*\tleftPolygons {Polygon2D[*]} (out) polygons on the left of the line\n\t*\trightPolygons {Polygon2D[*]} (out) polygons on the right of the line\n\t*\tcutPolygons {Polygon2D[*]} (out) polygons on the line\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygon2DWithLine = function (polygon, line, leftPolygons, rightPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon2D ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = line.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordLinePosition2D.CoordAtLineLeft) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordLinePosition2D.CoordAtLineRight) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar edgeLine = new JSM.Line2D (currVertex, JSM.CoordSub2D (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar lineLinePosition = line.LinePosition (edgeLine, intersection);\n\t\t\t\tif (lineLinePosition != JSM.LineLinePosition2D.LinesIntersectsOnePoint) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar origo = new JSM.Coord2D (0.0, 0.0);\n\t\t\t\tvar refLineStart = line.start.Clone ();\n\t\t\t\tvar refLineDir = line.direction.Clone ().Rotate (-Math.PI / 2.0, origo);\n\t\t\t\tvar refLine = new JSM.Line2D (refLineStart, refLineDir);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refLine.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, leftPolygons, rightPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: CutPolygonWithPlane\n\t* Description:\n\t*\tCuts a polygon with a plane. The result array contains cutted\n\t*\tpolygons grouped by their position to the plane.\n\t* Parameters:\n\t*\tpolygon {Polygon} the polygon\n\t*\tplane {Plane} the plane\n\t*\tfrontPolygons {Polygon[*]} (out) polygons in front of the plane\n\t*\tbackPolygons {Polygon[*]} (out) polygons at the back of the plane\n\t*\tcutPolygons {Polygon[*]} (out) polygons on the plane\n\t* Returns:\n\t*\t{boolean} success\n\t*/\n\tJSM.CutPolygonWithPlane = function (polygon, plane, frontPolygons, backPolygons, cutPolygons)\n\t{\n\t\tvar geometryInterface = {\n\t\t\tcreatePolygon : function () {\n\t\t\t\treturn new JSM.Polygon ();\n\t\t\t},\n\t\t\tgetVertexSide : function (vertex) {\n\t\t\t\tvar position = plane.CoordPosition (vertex);\n\t\t\t\tvar type = JSM.CutVertexType.Cut;\n\t\t\t\tif (position == JSM.CoordPlanePosition.CoordInFrontOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Left;\n\t\t\t\t} else if (position == JSM.CoordPlanePosition.CoordAtBackOfPlane) {\n\t\t\t\t\ttype = JSM.CutVertexType.Right;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tgetIntersectionVertex : function (prevVertex, currVertex) {\n\t\t\t\tvar line = new JSM.Line (currVertex, JSM.CoordSub (currVertex, prevVertex));\n\t\t\t\tvar intersection = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\t\tvar linePlanePosition = plane.LinePosition (line, intersection);\n\t\t\t\tif (linePlanePosition != JSM.LinePlanePosition.LineIntersectsPlane) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn intersection;\n\t\t\t},\n\t\t\tgetVertexDistances : function (polygon) {\n\t\t\t\tvar polygonNormal = polygon.GetNormal ();\n\t\t\t\tvar planeNormal = new JSM.Vector (plane.a, plane.b, plane.c);\n\t\t\t\tvar refPlaneNormal = JSM.VectorCross (planeNormal, polygonNormal);\n\t\t\t\tvar refPlaneOrigin = polygon.GetVertex (0);\n\t\t\t\tvar refPlane = JSM.GetPlaneFromCoordAndDirection (refPlaneOrigin, refPlaneNormal);\n\t\t\t\tvar i, vertex;\n\t\t\t\tvar distances = [];\n\t\t\t\tfor (i = 0; i < polygon.VertexCount (); i++) {\n\t\t\t\t\tvertex = polygon.GetVertex (i);\n\t\t\t\t\tdistances.push (refPlane.CoordSignedDistance (vertex));\n\t\t\t\t}\n\t\t\t\treturn distances;\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar cutter = new JSM.PolygonCutter (geometryInterface);\n\t\treturn cutter.Cut (polygon, frontPolygons, backPolygons, cutPolygons);\n\t};\n\n\t/**\n\t* Function: SegmentPolygon2D\n\t* Description: Segments up a polygon along x and y axis.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the polygon\n\t*\txSegments {integer} x segment number\n\t*\tySegments {integer} y segment number\n\t* Returns:\n\t*\t{Polygon[*]} result polygons\n\t*/\n\tJSM.SegmentPolygon2D = function (polygon, xSegments, ySegments)\n\t{\n\t\tfunction CutPolygonsOneDirection (inputPolygons, resultPolygons, segmentCount, segmentSize, startCoordinate, segmentDir, cutDir)\n\t\t{\n\t\t\tfunction CutPolygon (polygon, line, leftPolygons, rightPolygons)\n\t\t\t{\n\t\t\t\tvar left = [];\n\t\t\t\tvar right = [];\n\t\t\t\tvar cut = [];\n\t\t\t\tif (!JSM.CutPolygon2DWithLine (polygon, line, left, right, cut)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < left.length; i++) {\n\t\t\t\t\tleftPolygons.push (left[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < right.length; i++) {\n\t\t\t\t\trightPolygons.push (right[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar polygonsToProcess = inputPolygons;\n\t\t\tvar startCoord = startCoordinate.Clone ();\n\t\t\tvar i, j, line, newPolygonsToProcess;\n\t\t\tfor (i = 1; i < segmentCount; i++) {\n\t\t\t\tstartCoord.Offset (segmentDir, segmentSize);\n\t\t\t\tline = new JSM.Line2D (startCoord, cutDir);\n\t\t\t\tnewPolygonsToProcess = [];\n\t\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\t\tCutPolygon (polygonsToProcess[j], line, resultPolygons, newPolygonsToProcess);\n\t\t\t\t}\n\t\t\t\tpolygonsToProcess = newPolygonsToProcess;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygonsToProcess.length; j++) {\n\t\t\t\tresultPolygons.push (polygonsToProcess[j]);\n\t\t\t}\n\t\t}\n\n\t\tvar boundingBox = polygon.GetBoundingBox ();\n\t\tvar xSize = boundingBox.max.x - boundingBox.min.x;\n\t\tvar ySize = boundingBox.max.y - boundingBox.min.y;\n\t\tvar xSegmentSize = xSize / xSegments;\n\t\tvar ySegmentSize = ySize / ySegments;\n\n\t\tvar originalPolygons = [polygon];\n\t\tvar bottomLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.min.y);\n\t\tvar topLeft = new JSM.Coord2D (boundingBox.min.x, boundingBox.max.y);\n\n\t\tvar xCuttedPolygons = [];\n\t\tvar yCuttedPolygons = [];\n\t\tCutPolygonsOneDirection (originalPolygons, xCuttedPolygons, xSegments, xSegmentSize, bottomLeft, new JSM.Vector2D (1.0, 0.0), new JSM.Vector2D (0.0, 1.0));\n\t\tCutPolygonsOneDirection (xCuttedPolygons, yCuttedPolygons, ySegments, ySegmentSize, topLeft, new JSM.Vector2D (0.0, -1.0), new JSM.Vector2D (1.0, 0.0));\n\t\treturn yCuttedPolygons;\n\t};\n\n\treturn JSM;\n});\n"]}