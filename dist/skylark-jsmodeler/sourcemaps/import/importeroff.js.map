{"version":3,"sources":["import/importeroff.js"],"names":["define","JSM","ReadOffFile","stringBuffer","callbacks","ProcessLine","line","readState","length","x","y","z","lineParts","split","offHeaderFound","infoFound","readVertices","vertexCount","parseFloat","undefined","onVertex","readFaces","faceCount","parseInt","i","vertex","vertices","push","onFace","OnFace","lines","trim","ProcessFile","ConvertOffToJsonData","triangleModel","TriangleModel","index","AddBody","TriangleBody","currentBody","GetBody","AddVertex","v0","v1","v2","count","AddTriangle","Finalize","ConvertTriangleModelToJsonData"],"mappings":";;;;;;;AAAAA,QAAQ,eAAe,SAASC,GA8H/B,OA7HAA,EAAIC,YAAc,SAAUC,EAAcC,GAgBzC,SAASC,EAAaC,EAAMC,GAE3B,GAAoB,IAAhBD,EAAKE,QAIM,KAAXF,EAAK,GAAT,CAIA,IAxBkBG,EAAGC,EAAGC,EAwBpBC,EAAYN,EAAKO,MAAO,OAC5B,GAAyB,IAArBD,EAAUJ,QAAmC,KAAnBI,EAAU,GAAG,GAI3C,GAAKL,EAAUO,eAOf,GAAKP,EAAUQ,UASf,GAAIR,EAAUS,aAAeT,EAAUU,YACd,GAApBL,EAAUJ,SA9CGC,EA+CNS,WAAYN,EAAU,IA/CbF,EA+CkBQ,WAAYN,EAAU,IA/CrCD,EA+C0CO,WAAYN,EAAU,SA7C7DO,IAAvBf,EAAUgB,UAAiD,OAAvBhB,EAAUgB,UACjDhB,EAAUgB,SAAUX,EAAGC,EAAGC,GA6CzBJ,EAAUS,cAAgB,QAK5B,GAAIT,EAAUc,UAAYd,EAAUe,UAApC,CACC,IAAIL,EAAcM,SAAUX,EAAU,IACtC,GAAIA,EAAUJ,QAAUS,EAAc,EAAG,CACxC,IACIO,EAAGC,EADHC,KAEJ,IAAKF,EAAI,EAAGA,EAAIP,EAAc,EAAGO,IAChCC,EAASF,SAAUX,EAAUY,IAC7BE,EAASC,KAAMF,IArDnB,SAAiBC,QAESP,IAArBf,EAAUwB,QAA6C,OAArBxB,EAAUwB,QAC/CxB,EAAUwB,OAAQF,GAoDjBG,CAAQH,GACRnB,EAAUc,WAAa,aA1BA,GAApBT,EAAUJ,SACbD,EAAUU,YAAcM,SAAUX,EAAU,IAC5CL,EAAUe,UAAYC,SAAUX,EAAU,IAC1CL,EAAUQ,WAAY,QAVC,GAApBH,EAAUJ,QAA+B,OAAhBI,EAAU,KACtCL,EAAUO,gBAAiB,SAyDZK,IAAdf,GAAyC,OAAdA,IAC9BA,MApBD,SAAsBD,GAErB,IAUIqB,EAVAjB,GACHO,gBAAiB,EACjBC,WAAY,EACZE,YAAc,EACdK,UAAY,EACZN,aAAe,EACfK,UAAY,GAGTS,EAAQ3B,EAAaU,MAAO,MAEhC,IAAKW,EAAI,EAAGA,EAAIM,EAAMtB,OAAQgB,IAE7BnB,EADOyB,EAAMN,GAAGO,OACGxB,GAQrByB,CAAa7B,IAGdF,EAAIgC,qBAAuB,SAAU9B,GAEpC,IAAI+B,EAAgB,IAAIjC,EAAIkC,cACxBC,EAAQF,EAAcG,QAAS,IAAIpC,EAAIqC,aAAc,YACrDC,EAAcL,EAAcM,QAASJ,GAqBzC,OAnBAnC,EAAIC,YAAaC,GAChBiB,SAAW,SAAUX,EAAGC,EAAGC,GAC1B4B,EAAYE,UAAWhC,EAAGC,EAAGC,IAE9BiB,OAAS,SAAUF,GAClB,IAAIF,EAAGkB,EAAIC,EAAIC,EACXC,EAAQnB,EAASlB,OACrB,IAAKgB,EAAI,EAAGA,EAAIqB,EAAQ,EAAGrB,IAC1BkB,EAAKhB,EAAS,GACdiB,EAAKjB,EAASF,EAAI,GAClBoB,EAAKlB,EAASF,EAAI,GAClBe,EAAYO,YAAaJ,EAAIC,EAAIC,MAKpCV,EAAca,WAEC9C,EAAI+C,+BAAgCd,IAI7CjC","file":"../../import/importeroff.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\tJSM.ReadOffFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnVertex (x, y, z)\n\t\t{\n\t\t\tif (callbacks.onVertex !== undefined && callbacks.onVertex !== null) {\n\t\t\t\tcallbacks.onVertex (x, y, z);\n\t\t\t}\n\t\t}\n\n\t\tfunction OnFace (vertices)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (vertices);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (line, readState)\n\t\t{\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (line[0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0 || lineParts[0][0] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!readState.offHeaderFound) {\n\t\t\t\tif (lineParts.length == 1 && lineParts[0] == 'OFF') {\n\t\t\t\t\treadState.offHeaderFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (!readState.infoFound) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\treadState.vertexCount = parseInt (lineParts[0]);\n\t\t\t\t\treadState.faceCount = parseInt (lineParts[1]);\n\t\t\t\t\treadState.infoFound = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readVertices < readState.vertexCount) {\n\t\t\t\tif (lineParts.length == 3) {\n\t\t\t\t\tOnVertex (parseFloat (lineParts[0]), parseFloat (lineParts[1]), parseFloat (lineParts[2]));\n\t\t\t\t\treadState.readVertices += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (readState.readFaces < readState.faceCount) {\n\t\t\t\tvar vertexCount = parseInt (lineParts[0]);\n\t\t\t\tif (lineParts.length >= vertexCount + 1) {\n\t\t\t\t\tvar vertices = [];\n\t\t\t\t\tvar i, vertex;\n\t\t\t\t\tfor (i = 1; i < vertexCount + 1; i++) {\n\t\t\t\t\t\tvertex = parseInt (lineParts[i]);\n\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t}\n\t\t\t\t\tOnFace (vertices);\n\t\t\t\t\treadState.readFaces += 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction ProcessFile (stringBuffer)\n\t\t{\n\t\t\tvar readState = {\n\t\t\t\toffHeaderFound : false,\n\t\t\t\tinfoFound : false,\n\t\t\t\tvertexCount : 0,\n\t\t\t\tfaceCount : 0,\n\t\t\t\treadVertices : 0,\n\t\t\t\treadFaces : 0\n\t\t\t};\n\t\t\t\n\t\t\tvar lines = stringBuffer.split ('\\n');\n\t\t\tvar i, line;\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tline = lines[i].trim ();\n\t\t\t\tProcessLine (line, readState);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tProcessFile (stringBuffer);\n\t};\n\n\tJSM.ConvertOffToJsonData = function (stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\t\t\n\t\tJSM.ReadOffFile (stringBuffer, {\n\t\t\tonVertex : function (x, y, z) {\n\t\t\t\tcurrentBody.AddVertex (x, y, z);\n\t\t\t},\n\t\t\tonFace : function (vertices) {\n\t\t\t\tvar i, v0, v1, v2;\n\t\t\t\tvar count = vertices.length;\n\t\t\t\tfor (i = 0; i < count - 2; i++) {\n\t\t\t\t\tv0 = vertices[0];\n\t\t\t\t\tv1 = vertices[i + 1];\n\t\t\t\t\tv2 = vertices[i + 2];\n\t\t\t\t\tcurrentBody.AddTriangle (v0, v1, v2);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n"]}