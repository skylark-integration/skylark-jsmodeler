{"version":3,"sources":["import/importerstl.js"],"names":["define","JSM","ReadBinaryStlFile","arrayBuffer","callbacks","OnFace","v0","v1","v2","normal","undefined","onFace","ReadVector","reader","i","result","ReadFloat32","BinaryReader","Skip","triangleCount","ReadUnsignedInteger32","ReadAsciiStlFile","stringBuffer","ProcessLine","lines","lineIndex","GetLine","trim","line","length","lineParts","split","parseFloat","vertices","nextLineIndex","currentLineIndex","currentLine","vertex","push","GetVertices","IsBinaryStlFile","byteLength","ConvertStlToJsonData","triangleModel","TriangleModel","index","AddBody","TriangleBody","currentBody","GetBody","v0Index","AddVertex","v1Index","v2Index","triangleNormal","Vector","Normalize","normalIndex","AddNormal","x","y","z","AddTriangle","Finalize","ConvertTriangleModelToJsonData"],"mappings":"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","file":"../../import/importerstl.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\tJSM.ReadBinaryStlFile = function (arrayBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadVector (reader)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tresult[i] = reader.ReadFloat32 ();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tvar i, v0, v1, v2, normal;\n\t\tfor (i = 0; i < triangleCount; i++) {\n\t\t\tnormal = ReadVector (reader);\n\t\t\tv0 = ReadVector (reader);\n\t\t\tv1 = ReadVector (reader);\n\t\t\tv2 = ReadVector (reader);\n\t\t\treader.Skip (2);\n\t\t\tOnFace (v0, v1, v2, normal);\n\t\t}\n\t};\n\n\tJSM.ReadAsciiStlFile = function (stringBuffer, callbacks)\n\t{\n\t\tfunction OnFace (v0, v1, v2, normal)\n\t\t{\n\t\t\tif (callbacks.onFace !== undefined && callbacks.onFace !== null) {\n\t\t\t\tcallbacks.onFace (v0, v1, v2, normal);\n\t\t\t}\n\t\t}\n\n\t\tfunction ProcessLine (lines, lineIndex)\n\t\t{\n\t\t\tfunction GetLine (lines, lineIndex)\n\t\t\t{\n\t\t\t\treturn lines[lineIndex].trim ();\n\t\t\t}\n\t\t\n\t\t\tfunction GetVertices (lines, lineIndex, vertices)\n\t\t\t{\n\t\t\t\tvar currentLineIndex, currentLine, lineParts, vertex;\n\t\t\t\tfor (currentLineIndex = lineIndex; currentLineIndex < lines.length && vertices.length < 3; currentLineIndex++) {\n\t\t\t\t\tcurrentLine = GetLine (lines, currentLineIndex);\n\t\t\t\t\tif (currentLine.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlineParts = currentLine.split (/\\s+/);\n\t\t\t\t\tif (lineParts.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (lineParts[0] == 'vertex') {\n\t\t\t\t\t\tif (lineParts.length < 4) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvertex = [parseFloat (lineParts[1]), parseFloat (lineParts[2]), parseFloat (lineParts[3])];\n\t\t\t\t\t\t\tvertices.push (vertex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn currentLineIndex + 1;\n\t\t\t}\n\t\t\n\t\t\tvar line = GetLine (lines, lineIndex);\n\t\t\tif (line.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar lineParts = line.split (/\\s+/);\n\t\t\tif (lineParts.length === 0) {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t}\n\n\t\t\tif (lineParts[0] == 'solid') {\n\t\t\t\treturn lineIndex + 1;\n\t\t\t} else if (lineParts[0] == 'facet' && lineParts[1] == 'normal') {\n\t\t\t\tif (lineParts.length < 5) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar normal = [parseFloat (lineParts[2]), parseFloat (lineParts[3]), parseFloat (lineParts[4])];\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar nextLineIndex = GetVertices (lines, lineIndex + 1, vertices);\n\t\t\t\tif (vertices.length != 3) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tOnFace (vertices[0], vertices[1], vertices[2], normal);\n\t\t\t\treturn nextLineIndex;\n\t\t\t}\n\n\t\t\treturn lineIndex + 1;\n\t\t}\n\t\t\n\t\tif (callbacks === undefined || callbacks === null) {\n\t\t\tcallbacks = {};\n\t\t}\n\n\t\tvar lineIndex = 0;\n\t\tvar lines = stringBuffer.split ('\\n');\n\t\twhile (lineIndex < lines.length && lineIndex != -1) {\n\t\t\tlineIndex = ProcessLine (lines, lineIndex);\n\t\t}\n\t};\n\n\tJSM.IsBinaryStlFile = function (arrayBuffer)\n\t{\n\t\tvar byteLength = arrayBuffer.byteLength;\n\t\tif (byteLength < 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar reader = new JSM.BinaryReader (arrayBuffer, true);\n\t\treader.Skip (80);\n\t\t\n\t\tvar triangleCount = reader.ReadUnsignedInteger32 ();\n\t\tif (byteLength != triangleCount * 50 + 84) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t};\n\n\tJSM.ConvertStlToJsonData = function (arrayBuffer, stringBuffer)\n\t{\n\t\tvar triangleModel = new JSM.TriangleModel ();\n\t\tvar index = triangleModel.AddBody (new JSM.TriangleBody ('Default'));\n\t\tvar currentBody = triangleModel.GetBody (index);\n\n\t\tif (arrayBuffer !== null) {\n\t\t\tJSM.ReadBinaryStlFile (arrayBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (stringBuffer !== null) {\n\t\t\tJSM.ReadAsciiStlFile (stringBuffer, {\n\t\t\t\tonFace : function (v0, v1, v2, normal) {\n\t\t\t\t\tvar v0Index = currentBody.AddVertex (v0[0], v0[1], v0[2]);\n\t\t\t\t\tvar v1Index = currentBody.AddVertex (v1[0], v1[1], v1[2]);\n\t\t\t\t\tvar v2Index = currentBody.AddVertex (v2[0], v2[1], v2[2]);\n\t\t\t\t\tvar triangleNormal = new JSM.Vector (normal[0], normal[1], normal[2]).Normalize ();\n\t\t\t\t\tvar normalIndex = currentBody.AddNormal (triangleNormal.x, triangleNormal.y, triangleNormal.z);\n\t\t\t\t\tcurrentBody.AddTriangle (v0Index, v1Index, v2Index, normalIndex, normalIndex, normalIndex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\ttriangleModel.Finalize ();\n\t\t\n\t\tvar jsonData = JSM.ConvertTriangleModelToJsonData (triangleModel);\n\t\treturn jsonData;\n\t};\n\n\treturn JSM;\n});\n"]}