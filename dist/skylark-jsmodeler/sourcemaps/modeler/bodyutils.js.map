{"version":3,"sources":["modeler/bodyutils.js"],"names":["define","JSM","AddVertexToBody","body","x","y","z","AddVertex","BodyVertex","Coord","AddPointToBody","vertex","AddPoint","BodyPoint","AddLineToBody","beg","end","AddLine","BodyLine","AddPolygonToBody","vertices","AddPolygon","BodyPolygon","CheckBody","i","j","point","line","polygon","vertexCount","VertexCount","PointCount","GetPoint","GetVertexIndex","LineCount","GetLine","GetBegVertexIndex","GetEndVertexIndex","PolygonCount","GetPolygon","VertexIndexCount","CalculateBodyPolygonNormal","index","currentIndex","nextIndex","current","next","count","normal","Vector","GetVertexPosition","Normalize","CalculateBodyPolygonNormals","result","push","CalculateBodyVertexNormals","k","average","neighbourPolygons","polygonNormals","vertexToPolygon","HasCurveGroup","CalculateBodyVertexToPolygon","length","GetCurveGroup","CoordAdd","MultiplyScalar","CalculatePolygonCurveGroups","curveAngle","prev","curveGroups","GetPrevVertex","GetVertexAngle","firstGroup","lastGroup","CalculatePolygonCentroid","MakeBodyInsideOut","ReverseVertexIndices","SoftMoveBodyVertex","radius","direction","distance","currentDistance","newDistance","referenceCoord","Clone","a","c","GetGaussianCParameter","DistanceTo","GetVertex","position","IsGreater","GetGaussianValue","Offset","GenerateWireBody","Body","edge","adjacencyInfo","AdjacencyInfo","edges","vert1","vert2","TriangulateWithCentroids","centroidCoord","centroidIndex","oldPolygon","oldVertexCount","curr","oldPolygonCount","InheritAttributes","RemovePolygon","TriangulatePolygons","coord","triangleIndices","triangle","bodyTriangle","Polygon","TriangulatePolygon","GenerateRandomMaterials","materials","seeded","GetRandomInt","seed","undefined","SeededRandomInt","RandomInt","color","material","AddMaterial","Material","ambient","diffuse","SetMaterialIndex","AddBodyToBSPTree","bspTree","id","ConvertBodyPolygonToPolygon","userData","GetMaterialIndex","originalPolygon"],"mappings":"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","file":"../../modeler/bodyutils.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: AddVertexToBody\n\t* Description: Adds a vertex to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tx {number} the x coordinate of the vertex\n\t*\ty {number} the y coordinate of the vertex\n\t*\tz {number} the z coordinate of the vertex\n\t*/\n\tJSM.AddVertexToBody = function (body, x, y, z)\n\t{\n\t\treturn body.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t};\n\n\t/**\n\t* Function: AddPointToBody\n\t* Description: Adds a point to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertex {integer} the vertex index stored in the body\n\t*/\n\tJSM.AddPointToBody = function (body, vertex)\n\t{\n\t\treturn body.AddPoint (new JSM.BodyPoint (vertex));\n\t};\n\n\t/**\n\t* Function: AddLineToBody\n\t* Description: Adds a line to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbeg {integer} begin vertex index stored in the body\n\t*\tend {integer} end vertex index stored in the body\n\t*/\n\tJSM.AddLineToBody = function (body, beg, end)\n\t{\n\t\treturn body.AddLine (new JSM.BodyLine (beg, end));\n\t};\n\n\t/**\n\t* Function: AddPolygonToBody\n\t* Description: Adds a polygon to an existing body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tvertices {integer[*]} array of vertex indices stored in the body\n\t*/\n\tJSM.AddPolygonToBody = function (body, vertices)\n\t{\n\t\treturn body.AddPolygon (new JSM.BodyPolygon (vertices));\n\t};\n\n\t/**\n\t* Function: CheckBody\n\t* Description:\n\t*\tChecks if the body is correct. It means that every polygon has at least three\n\t*\tvertices, and every point, line and polygon vertex index is valid.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckBody = function (body)\n\t{\n\t\tvar vertexCount = body.VertexCount ();\n\t\tvar i, j, point, line, polygon;\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tpoint = body.GetPoint (i);\n\t\t\tif (point.GetVertexIndex () < 0 || point.GetVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tline = body.GetLine (i);\n\t\t\tif (line.GetBegVertexIndex () < 0 || line.GetBegVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (line.GetEndVertexIndex () < 0 || line.GetEndVertexIndex () >= vertexCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tif (polygon.VertexIndexCount () < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tif (polygon.GetVertexIndex (j) < 0 || polygon.GetVertexIndex (j) >= vertexCount) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormal\n\t* Description: Calculates a normal vector for a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Vector} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormal = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 0.0);\n\t\tif (count >= 3) {\n\t\t\tvar i, currentIndex, nextIndex, current, next;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrentIndex = i;\n\t\t\t\tnextIndex = (i + 1) % count;\n\t\t\n\t\t\t\tcurrent = body.GetVertexPosition (polygon.GetVertexIndex (currentIndex));\n\t\t\t\tnext = body.GetVertexPosition (polygon.GetVertexIndex (nextIndex));\n\t\t\n\t\t\t\tnormal.x += (current.y - next.y) * (current.z + next.z);\n\t\t\t\tnormal.y += (current.z - next.z) * (current.x + next.x);\n\t\t\t\tnormal.z += (current.x - next.x) * (current.y + next.y);\n\t\t\t}\n\t\t}\n\n\t\tnormal.Normalize ();\n\t\treturn normal;\n\t};\n\n\t/**\n\t* Function: CalculateBodyPolygonNormals\n\t* Description: Calculates polygon normal vectors for all polygons stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*]} the result\n\t*/\n\tJSM.CalculateBodyPolygonNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tresult.push (JSM.CalculateBodyPolygonNormal (body, i));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexNormals\n\t* Description:\n\t*\tCalculates vertex normal vectors for all vertices stored in the body.\n\t*\tThe result is an array of array with vertex normal vectors.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{Vector[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexNormals = function (body)\n\t{\n\t\tvar result = [];\n\t\tvar polygonNormals = JSM.CalculateBodyPolygonNormals (body);\n\t\tvar vertexToPolygon = null;\n\t\t\n\t\tvar i, j, k, polygon, normal;\n\t\tvar average, count, neighbourPolygons, neighbourPolygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tresult[i] = [];\n\n\t\t\tif (polygon.HasCurveGroup ()) {\n\t\t\t\tif (vertexToPolygon === null) {\n\t\t\t\t\tvertexToPolygon = JSM.CalculateBodyVertexToPolygon (body);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\taverage = new JSM.Vector (0.0, 0.0, 0.0);\n\t\t\t\t\tcount = 0;\n\t\t\t\t\t\n\t\t\t\t\tneighbourPolygons = vertexToPolygon[polygon.GetVertexIndex (j)];\n\t\t\t\t\tfor (k = 0; k < neighbourPolygons.length; k++) {\n\t\t\t\t\t\tneighbourPolygon = body.GetPolygon (neighbourPolygons[k]);\n\t\t\t\t\t\tif (neighbourPolygon.GetCurveGroup () === polygon.GetCurveGroup ()) {\n\t\t\t\t\t\t\taverage = JSM.CoordAdd (average, polygonNormals[neighbourPolygons[k]]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\taverage.MultiplyScalar (1.0 / count);\n\t\t\t\t\taverage.Normalize ();\n\t\t\t\t\tresult[i].push (average);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnormal = polygonNormals[i];\n\t\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\t\tresult[i].push (new JSM.Vector (normal.x, normal.y, normal.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: CalculatePolygonCurveGroups\n\t* Description: Calculates the curve groups for a given polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon|Polygon2D} the polygon\n\t*\tcurveAngle {number} the curve angle\n\t* Returns:\n\t*\t{integer[*]} the curve groups\n\t*/\n\tJSM.CalculatePolygonCurveGroups = function (polygon, curveAngle)\n\t{\n\t\tvar curveGroups = [];\n\t\tvar count = polygon.VertexCount ();\n\n\t\tvar i, prev;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurveGroups.push (0);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprev = curveGroups[polygon.GetPrevVertex (i)];\n\t\t\tif (polygon.GetVertexAngle (i) > curveAngle) {\n\t\t\t\tcurveGroups[i] = prev;\n\t\t\t} else {\n\t\t\t\tcurveGroups[i] = prev + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar firstGroup = curveGroups[0];\n\t\tvar lastGroup = curveGroups[count - 1];\n\t\tif (firstGroup === 0 && firstGroup != lastGroup) {\n\t\t\tfor (i = 0; curveGroups[i] == firstGroup; i++) {\n\t\t\t\tcurveGroups[i] = lastGroup;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curveGroups;\n\t};\n\n\n\t/**\n\t* Function: CalculatePolygonCentroid\n\t* Description: Calculates the centroid of a polygon stored in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the polygon index\n\t* Returns:\n\t*\t{Coord} the result\n\t*/\n\tJSM.CalculatePolygonCentroid = function (body, index)\n\t{\n\t\tvar polygon = body.GetPolygon (index);\n\t\tvar count = polygon.VertexIndexCount ();\n\t\t\n\t\tvar result = new JSM.Coord (0.0, 0.0, 0.0);\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult = JSM.CoordAdd (result, body.GetVertexPosition (polygon.GetVertexIndex (i)));\n\t\t}\n\t\t\n\t\tresult.MultiplyScalar (1.0 / count);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: MakeBodyInsideOut\n\t* Description: Reverses all polygons orientation in the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.MakeBodyInsideOut = function (body)\n\t{\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tpolygon.ReverseVertexIndices ();\n\t\t}\n\t};\n\n\t/**\n\t* Function: SoftMoveBodyVertex\n\t* Description: Moves a vertex and its nearby vertices depending on gaussian function.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tindex {integer} the vertex index to move\n\t*\tradius {number} the radius of the movement\n\t*\tdirection {Vector} the direction of the movement\n\t*\tdistance {number} the distance of the movement\n\t*/\n\tJSM.SoftMoveBodyVertex = function (body, index, radius, direction, distance)\n\t{\n\t\tvar referenceCoord = body.GetVertexPosition (index).Clone ();\n\n\t\tvar eps = 0.00001;\n\t\tvar a = distance;\n\t\tvar b = 0.0;\n\t\tvar c = JSM.GetGaussianCParameter (radius, a, b, eps);\n\n\t\tvar i, currentDistance, newDistance;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tcurrentDistance = referenceCoord.DistanceTo (body.GetVertex (i).position);\n\t\t\tif (JSM.IsGreater (currentDistance, radius)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewDistance = JSM.GetGaussianValue (currentDistance, distance, b, c);\n\t\t\tbody.GetVertexPosition (i).Offset (direction, newDistance);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateWireBody\n\t* Description: Generates a body which contains only the lines from the given body.\n\t* Parameters:\n\t*\tbody {Body} the original body\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateWireBody = function (body)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.AddVertex (body.GetVertex (i).Clone ());\n\t\t}\n\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tJSM.AddLineToBody (result, edge.vert1, edge.vert2);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: TriangulateWithCentroids\n\t* Description:\n\t*\tTriangulates all polygons of the body by connecting all polygon\n\t*\tvertices with the centroid vertex of the polygon.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulateWithCentroids = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, centroidCoord, centroidIndex, oldPolygon, oldVertexCount, polygon, curr, next;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tcentroidCoord = JSM.CalculatePolygonCentroid (body, i);\n\t\t\tcentroidIndex = body.AddVertex (new JSM.BodyVertex (centroidCoord));\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\toldVertexCount = oldPolygon.VertexIndexCount ();\n\t\t\tfor (j = 0; j < oldVertexCount; j++) {\n\t\t\t\tcurr = oldPolygon.GetVertexIndex (j);\n\t\t\t\tnext = oldPolygon.GetVertexIndex (j < oldVertexCount - 1 ? j + 1 : 0);\n\t\t\t\tpolygon = new JSM.BodyPolygon ([curr, next, centroidIndex]);\n\t\t\t\tpolygon.InheritAttributes (oldPolygon);\n\t\t\t\tbody.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: TriangulatePolygons\n\t* Description: Triangulates all polygons of the body.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.TriangulatePolygons = function (body)\n\t{\n\t\tvar oldPolygonCount = body.PolygonCount ();\n\t\tvar i, j, oldPolygon, polygon, coord, triangleIndices, triangle, bodyTriangle;\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\toldPolygon = body.GetPolygon (i);\n\t\t\tpolygon = new JSM.Polygon ();\n\t\t\tfor (j = 0; j < oldPolygon.VertexIndexCount (); j++) {\n\t\t\t\tcoord = body.GetVertexPosition (oldPolygon.GetVertexIndex (j));\n\t\t\t\tpolygon.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\ttriangleIndices = JSM.TriangulatePolygon (polygon);\n\t\t\tif (triangleIndices !== null) {\n\t\t\t\tfor (j = 0; j < triangleIndices.length; j++) {\n\t\t\t\t\ttriangle = triangleIndices[j];\n\t\t\t\t\tbodyTriangle = new JSM.BodyPolygon ([\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[0]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[1]),\n\t\t\t\t\t\toldPolygon.GetVertexIndex (triangle[2])\n\t\t\t\t\t]);\n\t\t\t\t\tbodyTriangle.InheritAttributes (oldPolygon);\n\t\t\t\t\tbody.AddPolygon (bodyTriangle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldPolygonCount; i++) {\n\t\t\tbody.RemovePolygon (0);\n\t\t}\n\t};\n\n\t/**\n\t* Function: GenerateRandomMaterials\n\t* Description: Generates random materials for a body. A seed number can be specified.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tmaterials {MaterialSet} the materials\n\t*\tseeded {boolean} seeded random generation\n\t*/\n\tJSM.GenerateRandomMaterials = function (body, materials, seeded)\n\t{\n\t\tfunction GetRandomInt (seeded, seed)\n\t\t{\n\t\t\tvar minColor = 0;\n\t\t\tvar maxColor = 16777215;\n\t\t\tvar color = 0;\n\t\t\tif (seeded !== undefined && seeded) {\n\t\t\t\tcolor = JSM.SeededRandomInt (minColor, maxColor, seed + 1);\n\t\t\t} else {\n\t\t\t\tcolor = JSM.RandomInt (minColor, maxColor);\n\t\t\t}\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tvar i, color, material;\n\t\tvar seed = 0;\n\t\tfor (i = 0; i < body.LineCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetLine (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PointCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPoint (i).SetMaterialIndex (material);\n\t\t}\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tcolor = GetRandomInt (seeded, seed++);\n\t\t\tmaterial = materials.AddMaterial (new JSM.Material ({ambient : color, diffuse : color}));\n\t\t\tbody.GetPolygon (i).SetMaterialIndex (material);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AddBodyToBSPTree\n\t* Description: Adds a body to a BSP tree.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tbspTree {BSPTree} the BSP tree\n\t*\tid {anything} the id for added polygons\n\t*/\n\tJSM.AddBodyToBSPTree = function (body, bspTree, id)\n\t{\n\t\tfunction ConvertBodyPolygonToPolygon (body, index, userData)\n\t\t{\n\t\t\tvar polygon = body.GetPolygon (index);\n\t\t\tuserData.material = polygon.GetMaterialIndex ();\n\t\t\tvar result = new JSM.Polygon ();\n\t\t\tvar i, coord;\n\t\t\tfor (i = 0; i < polygon.VertexIndexCount (); i++) {\n\t\t\t\tcoord = body.GetVertexPosition (polygon.GetVertexIndex (i));\n\t\t\t\tresult.AddVertex (coord.x, coord.y, coord.z);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar i, polygon, userData;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tuserData = {\n\t\t\t\tid : id,\n\t\t\t\toriginalPolygon : i,\n\t\t\t\tmaterial : -1\n\t\t\t};\n\t\t\tpolygon = ConvertBodyPolygonToPolygon (body, i, userData);\n\t\t\tbspTree.AddPolygon (polygon, userData);\n\t\t}\n\t};\n\n\treturn JSM;\n});\n"]}