{"version":3,"sources":["modeler/rayutils.js"],"names":["define","JSM","RayTriangleIntersection","ray","v0","v1","v2","rayOrigin","GetOrigin","rayDirection","GetDirection","edgeDir1","CoordSub","edgeDir2","pVector","VectorCross","determinant","VectorDot","IsZero","IsPositive","invDeterminant","tVector","u","IsLower","IsGreater","qVector","v","distance","IsLengthReached","scaledDirection","Clone","MultiplyScalar","position","CoordAdd","RayBoxIntersection","min","max","i","rayOriginVec","rayDirectionVec","CoordToArray","minB","maxB","quadrant","candidatePlane","originInBox","maxT","whichPlane","IsNegative","xCoord","intersectionCoord","CoordFromArray","DistanceTo","RayOctreeIntersection","octree","intersection","minIntersection","foundIntersection","calcMinIntersection","undefined","TraverseOctreeNodes","node","box","triangles","length","triangle","currentIntersection","userData","RayTriangleBodyIntersection","body","TriangleCount","GetTriangle","GetVertex","triangleIndex","RayTriangleModelIntersection","model","BodyCount","GetBody","bodyIndex","RayTriangleModelIntersectionWithOctree","hasIntersection","ConvertTriangleBodyToOctree"],"mappings":"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","file":"../../modeler/rayutils.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: RayTriangleIntersection\n\t* Description: Calculates intersection between a ray and a triangle.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tv0, v1, v2 {Coord} the vertices of the triangle\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayTriangleIntersection = function (ray, v0, v1, v2)\n\t{\n\t\tvar rayOrigin = ray.GetOrigin ();\n\t\tvar rayDirection = ray.GetDirection ();\n\n\t\tvar edgeDir1 = JSM.CoordSub (v1, v0);\n\t\tvar edgeDir2 = JSM.CoordSub (v2, v0);\n\t\tvar pVector = JSM.VectorCross (rayDirection, edgeDir2);\n\n\t\tvar determinant = JSM.VectorDot (edgeDir1, pVector);\n\t\tif (JSM.IsZero (determinant)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar isFrontFacing = JSM.IsPositive (determinant);\n\t\tif (!isFrontFacing) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar invDeterminant = 1.0 / determinant;\n\n\t\tvar tVector = JSM.CoordSub (rayOrigin, v0);\n\t\tvar u = JSM.VectorDot (tVector, pVector) * invDeterminant;\n\t\tif (JSM.IsLower (u, 0.0) || JSM.IsGreater (u, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar qVector = JSM.VectorCross (tVector, edgeDir1);\n\t\tvar v = JSM.VectorDot (rayDirection, qVector) * invDeterminant;\n\t\tif (JSM.IsLower (v, 0.0) || JSM.IsGreater (u + v, 1.0)) {\n\t\t\treturn null;\n\t\t}\n\t \n\t\tvar distance = JSM.VectorDot (edgeDir2, qVector) * invDeterminant;\n\t\tif (!JSM.IsPositive (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar scaledDirection = rayDirection.Clone ().MultiplyScalar (distance);\n\t\tvar intersection = {\n\t\t\tposition : JSM.CoordAdd (rayOrigin, scaledDirection),\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayBoxIntersection\n\t* Description: Calculates intersection between a ray and a box.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmin, max {Coord} the minimum and maximum points of the box\n\t* Returns:\n\t*\t{object} the result data (position, distance) if intersection found, null otherwise\n\t*/\n\tJSM.RayBoxIntersection = function (ray, min, max)\n\t{\n\t\tvar rayOriginVec = ray.GetOrigin ();\n\t\tvar rayDirectionVec = ray.GetDirection ();\n\n\t\tvar rayOrigin = JSM.CoordToArray (rayOriginVec);\n\t\tvar rayDirection = JSM.CoordToArray (rayDirectionVec);\n\t\tvar minB = JSM.CoordToArray (min);\n\t\tvar maxB = JSM.CoordToArray (max);\n\t\tvar quadrant = [0, 0, 0];\n\t\tvar candidatePlane = [0.0, 0.0, 0.0];\n\n\t\tvar originInBox = true;\n\t\tvar i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (JSM.IsLower (rayOrigin[i], minB[i])) {\n\t\t\t\tquadrant[i] = -1; // left\n\t\t\t\tcandidatePlane[i] = minB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else if (JSM.IsGreater (rayOrigin[i], maxB[i])) {\n\t\t\t\tquadrant[i] = 1; // right\n\t\t\t\tcandidatePlane[i] = maxB[i];\n\t\t\t\toriginInBox = false;\n\t\t\t} else {\n\t\t\t\tquadrant[i] = 0; // middle\n\t\t\t}\n\t\t}\n\n\t\tvar intersection = null;\n\t\tif (originInBox) {\n\t\t\tintersection = {\n\t\t\t\tposition : rayOriginVec,\n\t\t\t\tdistance : 0.0\n\t\t\t};\n\t\t\treturn intersection;\n\t\t}\n\n\t\tvar maxT = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (quadrant[i] !== 0 && !JSM.IsZero (rayDirection[i])) {\n\t\t\t\tmaxT[i] = (candidatePlane[i] - rayOrigin[i]) / rayDirection[i];\n\t\t\t} else {\n\t\t\t\tmaxT[i] = -1.0;\n\t\t\t}\n\t\t}\n\n\t\tvar whichPlane = 0;\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (JSM.IsLower (maxT[whichPlane], maxT[i])) {\n\t\t\t\twhichPlane = i;\n\t\t\t}\n\t\t}\n\n\t\tif (JSM.IsNegative (maxT[whichPlane])) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar xCoord = [0.0, 0.0, 0.0];\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (whichPlane != i) {\n\t\t\t\txCoord[i] = rayOrigin[i] + maxT[whichPlane] * rayDirection[i];\n\t\t\t\tif (JSM.IsLower (xCoord[i], minB[i]) || JSM.IsGreater (xCoord[i], maxB[i])) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txCoord[i] = candidatePlane[i];\n\t\t\t}\n\t\t}\n\n\t\tvar intersectionCoord = JSM.CoordFromArray (xCoord);\n\t\tvar distance = rayOriginVec.DistanceTo (intersectionCoord);\n\t\tif (ray.IsLengthReached (distance)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tintersection = {\n\t\t\tposition : intersectionCoord,\n\t\t\tdistance : distance\n\t\t};\n\t\treturn intersection;\n\t};\n\n\t/**\n\t* Function: RayOctreeIntersection\n\t* Description: Calculates the nearest intersection between a ray and an octree.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\toctree {Octree} the octree\n\t*\tintersection {object} the result data (position, distance, userData)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayOctreeIntersection = function (ray, octree, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\n\t\tJSM.TraverseOctreeNodes (octree, function (node) {\n\t\t\tif (!calcMinIntersection && foundIntersection) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!JSM.RayBoxIntersection (ray, node.box.min, node.box.max)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < node.triangles.length; i++) {\n\t\t\t\tvar triangle = node.triangles[i];\n\t\t\t\tvar v0 = triangle.v0;\n\t\t\t\tvar v1 = triangle.v1;\n\t\t\t\tvar v2 = triangle.v2;\n\t\t\t\tvar currentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\t\tif (currentIntersection !== null) {\n\t\t\t\t\tfoundIntersection = true;\n\t\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\t\tminIntersection.userData = triangle.userData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\t\n\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.userData = minIntersection.userData;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleBodyIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle body.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tbody {TriangleBody} the triangle body\n\t*\tintersection {object} the result data (position, distance, triangleIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleBodyIntersection = function (ray, body, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\t\n\t\tvar i, triangle, v0, v1, v2, currentIntersection;\n\t\tfor (i = 0; i < body.TriangleCount (); i++) {\n\t\t\ttriangle = body.GetTriangle (i);\n\t\t\tv0 = body.GetVertex (triangle.v0);\n\t\t\tv1 = body.GetVertex (triangle.v1);\n\t\t\tv2 = body.GetVertex (triangle.v2);\n\t\t\tcurrentIntersection = JSM.RayTriangleIntersection (ray, v0, v1, v2);\n\t\t\tif (currentIntersection !== null) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.triangleIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t}\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersection\n\t* Description: Calculates the nearest intersection between a ray and a triangle model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersection = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (JSM.RayTriangleBodyIntersection (ray, body, currentIntersection)) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\t/**\n\t* Function: RayTriangleModelIntersectionWithOctree\n\t* Description:\n\t*\tCalculates the nearest intersection between a ray and a triangle model.\n\t*\tCaches the octrees for all bodies in the model.\n\t* Parameters:\n\t*\tray {Ray} the ray\n\t*\tmodel {TriangleModel} the triangle model\n\t*\tintersection {object} the result data (position, distance, triangleIndex, bodyIndex)\n\t* Returns:\n\t*\t{boolean} true if found intersection, false otherwise\n\t*/\n\tJSM.RayTriangleModelIntersectionWithOctree = function (ray, model, intersection)\n\t{\n\t\tvar minIntersection = null;\n\t\tvar foundIntersection = false;\n\t\tvar calcMinIntersection = (intersection !== null && intersection !== undefined);\n\t\tvar i, body, hasIntersection, currentIntersection;\n\t\tfor (i = 0; i < model.BodyCount (); i++) {\n\t\t\tbody = model.GetBody (i);\n\t\t\thasIntersection = false;\n\t\t\tcurrentIntersection = calcMinIntersection ? {} : null;\n\t\t\tif (body.TriangleCount () > 20) {\n\t\t\t\tif (body.octree === undefined) {\n\t\t\t\t\tbody.octree = JSM.ConvertTriangleBodyToOctree (body);\n\t\t\t\t}\n\t\t\t\thasIntersection = JSM.RayOctreeIntersection (ray, body.octree, currentIntersection);\n\t\t\t} else {\n\t\t\t\thasIntersection = JSM.RayTriangleBodyIntersection (ray, body, currentIntersection);\n\t\t\t}\n\t\t\t\n\t\t\tif (hasIntersection) {\n\t\t\t\tfoundIntersection = true;\n\t\t\t\tif (!calcMinIntersection) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (minIntersection === null || currentIntersection.distance < minIntersection.distance) {\n\t\t\t\t\tminIntersection = currentIntersection;\n\t\t\t\t\tif (currentIntersection.userData !== undefined) {\n\t\t\t\t\t\tminIntersection.triangleIndex = currentIntersection.userData.triangleIndex;\n\t\t\t\t\t}\n\t\t\t\t\tminIntersection.bodyIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (calcMinIntersection && minIntersection !== null) {\n\t\t\tintersection.position = minIntersection.position;\n\t\t\tintersection.distance = minIntersection.distance;\n\t\t\tintersection.triangleIndex = minIntersection.triangleIndex;\n\t\t\tintersection.bodyIndex = minIntersection.bodyIndex;\n\t\t}\t\n\t\treturn foundIntersection;\n\t};\n\n\treturn JSM;\n});\n"]}