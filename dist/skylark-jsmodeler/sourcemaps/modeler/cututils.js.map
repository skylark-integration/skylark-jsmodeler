{"version":3,"sources":["modeler/cututils.js"],"names":["define","JSM","CutBodyByPlane","body","plane","CutBodyPolygonByPlane","polygon","indexTable","AddOriginalVertex","index","vertex","rawResult","rawIndexTable","push","Coord","x","y","z","AddIntersectionVertex","from","to","direction","CoordSub","Normalize","line","Line","intersection","LineIntersection","i","position","hasIndexTable","undefined","count","length","result","front","needCut","CoordPosition","CoordPlanePosition","CoordAtBackOfPlane","currentVertex","currentIndex","lastVertex","lastIndex","IsEqual","GetInsertedVertexIndex","originalVertexCount","VertexCount","GetVertexPosition","AddVertex","BodyVertex","j","polygon3D","vertexPosition","cuttedPolygon","Body","cuttedPolygons","cuttedIndexTables","remainsVertex","originalOldToNewIndex","PolygonCount","GetPolygon","VertexIndexCount","GetVertexIndex","newPolygon","newPolygonVertices","BodyPolygon","InheritAttributes","AddPolygon"],"mappings":";;;;;;;AAAAA,QAAQ,eAAe,SAASC,GAwM/B,OA9LAA,EAAIC,eAAiB,SAAUC,EAAMC,GAEpC,SAASC,EAAuBC,EAASF,EAAOG,GAE/C,SAASC,EAAmBC,EAAOC,EAAQC,EAAWC,GAErDD,EAAUE,KAAM,IAAIZ,EAAIa,MAAOJ,EAAOK,EAAGL,EAAOM,EAAGN,EAAOO,IAC1DL,EAAcC,KAAMJ,GAGrB,SAASS,EAAuBC,EAAMC,EAAIT,EAAWC,GAEpD,IAAIS,EAAYpB,EAAIqB,SAAUhB,EAAQc,GAAKd,EAAQa,IAAOI,YACtDC,EAAO,IAAIvB,EAAIwB,KAAMnB,EAAQa,GAAOE,GACpCK,EAAetB,EAAMuB,iBAAkBH,GAC3Cb,EAAUE,KAAM,IAAIZ,EAAIa,MAAOY,EAAaX,EAAGW,EAAaV,EAAGU,EAAaT,IAC5EL,EAAcC,MAAO,GAGtB,IAMIe,EAAGC,EAAUnB,EANboB,OAAgCC,IAAfxB,GAA2C,OAAfA,EAC7CyB,EAAQ1B,EAAQ2B,OAChBC,KACAC,KAEAC,GAAU,EAEd,IAAKR,EAAI,EAAGA,EAAII,EAAOJ,IACtBlB,EAASJ,EAAQsB,GACjBC,EAAWzB,EAAMiC,cAAe3B,GAChCyB,EAAMtB,KAAMgB,IAAa5B,EAAIqC,mBAAmBC,oBAC5CX,EAAI,GAAKO,EAAMP,EAAI,KAAOO,EAAMP,KACnCQ,GAAU,GAIZ,IAAKA,EAAS,CACb,IAAiB,IAAbD,EAAM,GACT,OAAOD,EAGR,IAAKN,EAAI,EAAGA,EAAII,EAAOJ,IACtBlB,EAASJ,EAAQsB,GACjBM,EAAOrB,KAAM,IAAIZ,EAAIa,MAAOJ,EAAOK,EAAGL,EAAOM,EAAGN,EAAOO,IACnDa,GACHvB,EAAWM,KAAMe,GAGnB,OAAOM,EAGR,IAGIf,EAAMC,EAqBNoB,EACAC,EACAC,EACAC,EA3BAhC,KACAC,KAGJ,IAAKgB,EAAI,EAAGA,EAAII,EAAOJ,IACtBT,EAAOS,EAAI,EACXR,EAAKQ,EACK,IAANA,IACHT,EAAOa,EAAQ,GAGhBtB,EAASJ,EAAQc,GACbe,EAAMf,IACJe,EAAMhB,IACVD,EAAuBC,EAAMC,EAAIT,EAAWC,GAE7CJ,EAAmBY,EAAIV,EAAQC,EAAWC,IAEtCuB,EAAMhB,IACTD,EAAuBC,EAAMC,EAAIT,EAAWC,GAS/C,IAAKgB,EAAI,EAAGA,EAAIjB,EAAUsB,OAAQL,IACjCY,EAAgB7B,EAAUiB,GAC1Bc,EAAaR,EAAOA,EAAOD,OAAS,GAC1B,IAANL,GAAYc,EAAWE,QAASJ,GAO/BV,IAEHa,EAAY/B,EAAcgB,EAAI,IACR,KAFtBa,EAAe7B,EAAcgB,IAG5BrB,EAAWA,EAAW0B,OAAS,GAAKQ,GACX,IAAfE,IACVpC,EAAWA,EAAW0B,OAAS,GAAKU,KAZtCT,EAAOrB,KAAM,IAAIZ,EAAIa,MAAO0B,EAAczB,EAAGyB,EAAcxB,EAAGwB,EAAcvB,IACxEa,IACHW,EAAe7B,EAAcgB,GAC7BrB,EAAWM,KAAM4B,KAepB,OAAOP,EAGR,SAASW,EAAwBX,EAAQxB,EAAQoC,GAEhD,IAEIlB,EAFAnB,GAAS,EAGb,IAAKmB,EAAIkB,EAAqBlB,EAAIM,EAAOa,cAAgBnB,IACxD,GAAIlB,EAAOkC,QAASV,EAAOc,kBAAmBpB,IAAK,CAClDnB,EAAQmB,EACR,MAQF,OAJe,IAAXnB,IACHA,EAAQyB,EAAOe,UAAW,IAAIhD,EAAIiD,WAAY,IAAIjD,EAAIa,MAAOJ,EAAOK,EAAGL,EAAOM,EAAGN,EAAOO,MAGlFR,EAGR,IAQImB,EAAGuB,EAAG7C,EAAS8C,EAAWC,EAC1BC,EAAe/C,EAsBfG,EA/BAwB,EAAS,IAAIjC,EAAIsD,KAEjBC,KACAC,KAEAC,KACAC,KAIJ,IAAK/B,EAAI,EAAGA,EAAIzB,EAAKyD,eAAiBhC,IAAK,CAI1C,IAHAtB,EAAUH,EAAK0D,WAAYjC,GAE3BwB,KACKD,EAAI,EAAGA,EAAI7C,EAAQwD,mBAAqBX,IAC5CE,EAAiBlD,EAAK6C,kBAAmB1C,EAAQyD,eAAgBZ,IACjEC,EAAUvC,KAAM,IAAIZ,EAAIa,MAAOuC,EAAetC,EAAGsC,EAAerC,EAAGqC,EAAepC,IAKnF,IADAqC,EAAgBjD,EAAuB+C,EAAWhD,EADlDG,MAEK4C,EAAI,EAAGA,EAAI5C,EAAW0B,OAAQkB,KACX,IAAnB5C,EAAW4C,KACdO,EAAcpD,EAAQyD,eAAgBxD,EAAW4C,MAAO,GAI1DK,EAAe3C,KAAMyC,GACrBG,EAAkB5C,KAAMN,GAIzB,IAAKqB,EAAI,EAAGA,EAAIzB,EAAK4C,cAAgBnB,IAChC8B,EAAc9B,KACjBlB,EAASP,EAAK6C,kBAAmBpB,GACjC+B,EAAsB/B,GAAKM,EAAOe,UAAW,IAAIhD,EAAIiD,WAAY,IAAIjD,EAAIa,MAAOJ,EAAOK,EAAGL,EAAOM,EAAGN,EAAOO,MAI7G,IAEI+C,EAAYC,EAFZnB,EAAsBZ,EAAOa,cAGjC,IAAKnB,EAAI,EAAGA,EAAIzB,EAAKyD,eAAiBhC,IAIrC,GAHAtB,EAAUH,EAAK0D,WAAYjC,GAC3B0B,EAAgBE,EAAe5B,GAEL,KAD1BrB,EAAakD,EAAkB7B,IAChBK,OAAf,CAKA,IADAgC,KACKd,EAAI,EAAGA,EAAI5C,EAAW0B,OAAQkB,KACX,IAAnB5C,EAAW4C,GACdc,EAAmBpD,KAAM8C,EAAsBrD,EAAQyD,eAAgBxD,EAAW4C,OAElFzC,EAAS4C,EAAcH,GACvBc,EAAmBpD,KAAMgC,EAAwBX,EAAQxB,EAAQoC,MAInEkB,EAAa,IAAI/D,EAAIiE,YAAaD,IACvBE,kBAAmB7D,GAC9B4B,EAAOkC,WAAYJ,GAGpB,OAAO9B,GAGDjC","file":"../../modeler/cututils.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: CutBodyByPlane\n\t* Description: Cuts a body by a plane.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*\tplane {Plane} the plane\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.CutBodyByPlane = function (body, plane)\n\t{\n\t\tfunction CutBodyPolygonByPlane (polygon, plane, indexTable)\n\t\t{\n\t\t\tfunction AddOriginalVertex (index, vertex, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\trawResult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\trawIndexTable.push (index);\n\t\t\t}\n\n\t\t\tfunction AddIntersectionVertex (from, to, rawResult, rawIndexTable)\n\t\t\t{\n\t\t\t\tvar direction = JSM.CoordSub (polygon[to], polygon[from]).Normalize ();\n\t\t\t\tvar line = new JSM.Line (polygon[from], direction);\n\t\t\t\tvar intersection = plane.LineIntersection (line);\n\t\t\t\trawResult.push (new JSM.Coord (intersection.x, intersection.y, intersection.z));\n\t\t\t\trawIndexTable.push (-1);\n\t\t\t}\n\n\t\t\tvar hasIndexTable = (indexTable !== undefined && indexTable !== null);\n\t\t\tvar count = polygon.length;\n\t\t\tvar result = [];\n\t\t\tvar front = [];\n\t\t\t\n\t\t\tvar needCut = false;\n\t\t\tvar i, position, vertex;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tvertex = polygon[i];\n\t\t\t\tposition = plane.CoordPosition (vertex);\n\t\t\t\tfront.push (position !== JSM.CoordPlanePosition.CoordAtBackOfPlane);\n\t\t\t\tif (i > 0 && front[i - 1] !== front[i]) {\n\t\t\t\t\tneedCut = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!needCut) {\n\t\t\t\tif (front[0] === false) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\tvertex = polygon[i];\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, vertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tindexTable.push (i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tvar rawResult = [];\n\t\t\tvar rawIndexTable = [];\n\n\t\t\tvar from, to;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfrom = i - 1;\n\t\t\t\tto = i;\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tfrom = count - 1;\n\t\t\t\t}\n\n\t\t\t\tvertex = polygon[to];\n\t\t\t\tif (front[to]) {\n\t\t\t\t\tif (!front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t\tAddOriginalVertex (to, vertex, rawResult, rawIndexTable);\n\t\t\t\t} else {\n\t\t\t\t\tif (front[from]) {\n\t\t\t\t\t\tAddIntersectionVertex (from, to, rawResult, rawIndexTable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar currentVertex;\n\t\t\tvar currentIndex;\n\t\t\tvar lastVertex;\n\t\t\tvar lastIndex;\n\t\t\tfor (i = 0; i < rawResult.length; i++) {\n\t\t\t\tcurrentVertex = rawResult[i];\n\t\t\t\tlastVertex = result[result.length - 1];\n\t\t\t\tif (i === 0 || !lastVertex.IsEqual (currentVertex)) {\n\t\t\t\t\tresult.push (new JSM.Coord (currentVertex.x, currentVertex.y, currentVertex.z));\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tindexTable.push (currentIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasIndexTable) {\n\t\t\t\t\t\tcurrentIndex = rawIndexTable[i];\n\t\t\t\t\t\tlastIndex = rawIndexTable[i - 1];\n\t\t\t\t\t\tif (currentIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = currentIndex;\n\t\t\t\t\t\t} else if (lastIndex !== -1) {\n\t\t\t\t\t\t\tindexTable[indexTable.length - 1] = lastIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction GetInsertedVertexIndex (result, vertex, originalVertexCount)\n\t\t{\n\t\t\tvar index = -1;\n\t\t\n\t\t\tvar i;\n\t\t\tfor (i = originalVertexCount; i < result.VertexCount (); i++) {\n\t\t\t\tif (vertex.IsEqual (result.GetVertexPosition (i))) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (index === -1) {\n\t\t\t\tindex = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t\t\n\t\t\treturn index;\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar cuttedPolygons = [];\n\t\tvar cuttedIndexTables = [];\n\t\t\n\t\tvar remainsVertex = [];\n\t\tvar originalOldToNewIndex = [];\n\t\t\n\t\tvar i, j, polygon, polygon3D, vertexPosition;\n\t\tvar cuttedPolygon, indexTable;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\t\n\t\t\tpolygon3D = [];\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tvertexPosition = body.GetVertexPosition (polygon.GetVertexIndex (j));\n\t\t\t\tpolygon3D.push (new JSM.Coord (vertexPosition.x, vertexPosition.y, vertexPosition.z));\n\t\t\t}\n\t\t\t\n\t\t\tindexTable = [];\n\t\t\tcuttedPolygon = CutBodyPolygonByPlane (polygon3D, plane, indexTable);\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tremainsVertex[polygon.GetVertexIndex (indexTable[j])] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcuttedPolygons.push (cuttedPolygon);\n\t\t\tcuttedIndexTables.push (indexTable);\n\t\t}\n\n\t\tvar vertex;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tif (remainsVertex[i]) {\n\t\t\t\tvertex = body.GetVertexPosition (i);\n\t\t\t\toriginalOldToNewIndex[i] = result.AddVertex (new JSM.BodyVertex (new JSM.Coord (vertex.x, vertex.y, vertex.z)));\n\t\t\t}\n\t\t}\n\n\t\tvar originalVertexCount = result.VertexCount ();\n\n\t\tvar newPolygon, newPolygonVertices;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tcuttedPolygon = cuttedPolygons[i];\n\t\t\tindexTable = cuttedIndexTables[i];\n\t\t\tif (indexTable.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnewPolygonVertices = [];\n\t\t\tfor (j = 0; j < indexTable.length; j++) {\n\t\t\t\tif (indexTable[j] !== -1) {\n\t\t\t\t\tnewPolygonVertices.push (originalOldToNewIndex[polygon.GetVertexIndex (indexTable[j])]);\n\t\t\t\t} else {\n\t\t\t\t\tvertex = cuttedPolygon[j];\n\t\t\t\t\tnewPolygonVertices.push (GetInsertedVertexIndex (result, vertex, originalVertexCount));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnewPolygon = new JSM.BodyPolygon (newPolygonVertices);\n\t\t\tnewPolygon.InheritAttributes (polygon);\n\t\t\tresult.AddPolygon (newPolygon);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n"]}