{"version":3,"sources":["modeler/generator.js"],"names":["define","JSM","GenerateRectangle","xSize","ySize","result","Body","x","y","AddVertex","BodyVertex","Coord","AddPolygon","BodyPolygon","SetCubicTextureProjection","GenerateCuboid","zSize","z","GenerateCuboidSides","sides","GenerateSegmentedRectangle","xSegmentation","ySegmentation","xStart","yStart","xSegment","ySegment","i","j","coord","AddVertices","current","next","top","ntop","AddPolygons","GenerateSegmentedCuboid","segmentation","GetLevelOffset","level","offset","GetLevelSideVertices","vertices","push","zCoord","zSegment","zStart","prevSideVertices","levelSideVertices","currSideVertices","GenerateCircle","radius","segments","step","Math","PI","circlePoints","GenerateCirclePoints","length","topPolygon","AddVertexIndex","SetCylindricalTextureProjection","GenerateSphere","isCurved","phi","circle","topIndex","SphericalToCartesian","theta","polygon","bottomIndex","SetCurveGroup","GenerateTriangulatedSphere","iterations","iteration","oldVertexCoord","oldBody","adjacencyInfo","currentEdge","edgeVertexIndices","currentPgon","polygonVertexIndices","edgeCoord","currentPolyEdge","c","sqrt","AddVertexToBody","AddPolygonToBody","GenerateIcosahedron","scale","GetVertexPosition","Length","VertexCount","GetVertex","position","MultiplyScalar","AdjacencyInfo","verts","edges","MidCoord","vert1","vert2","SetLength","pgons","pedges","GetPolyEdgeStartVertex","index","PolygonCount","GetPolygon","GenerateCylinder","height","withTopAndBottom","CylindricalToCartesian","bottomPolygon","GeneratePie","angle","GenerateCone","topRadius","bottomRadius","topDegenerated","IsZero","bottomDegenerated","avgRadius","GeneratePrismGeometry","bottomVertices","topVertices","bodyPolygon","count","Clone","GeneratePrismFromPolygon","curveAngle","vertex","undefined","curveGroups","CalculatePolygonCurveGroups","origo","firtVertex","firstDirection","CoordSub","Normalize","e3","Vector","e2","VectorCross","e1","GeneratePrism","basePolygon","direction","Polygon","FromArray","Offset","GeneratePrismWithHole","contourOffsets","contourPolygon","ContourPolygon","contour","vertex1","vertex2","ContourCount","GetContour","vertexCount","AddContours","vertexMap","contourPolygon2D","ToContourPolygon2D","simplePolygon","ConvertContourPolygonToPolygon2D","triangle","mapValue","topTriangle","bottomTriangle","triangles","TriangulatePolygon2D","AddTopBottomPolygons","GeneratePrismsFromPath2D","path","GetPrismPolygon","bodies","polygons","GetPolygons","GeneratePrismShell","width","offseted","curr","innerBasePolygon","OffsetPolygonContour","GenerateCylinderShell","normal","bottom","cartesian","PolarToCartesian","GenerateLineShell","basePolyLine","withStartAndEnd","prev","prevDir","nextDir","angles","AngleTo","CoordOrientation","Orientation","Clockwise","distance","innerCoord","offsetDirection","innerBasePolyLine","sin","Rotate","GenerateTorus","outerRadius","innerRadius","outerSegmentation","innerSegmentation","coord2D","rotated","axisDir","GeneratePolyTorus","GenerateRuledFromSectors","aSector","bSector","lineSegmentation","meshSegmentation","aCoords","GetSectorSegmentation","bCoords","GetRuledMesh","GenerateGrid","xSector","Sector","ySector","GenerateSquareGrid","size","GenerateRuledFromSectorsWithHeight","newVertex","newpolygonVertexIndices","topVertexCount","GenerateRuledFromCoords","GenerateRevolved","polyLine","axis","curveMode","circular","IsEqual","end","beg","curveModeFlag","axisNormalDir","axisLine","Line","ProjectCoord","DistanceTo","projectedToBaseLine","xDirection","GenerateTube","basePolygons","contourCount","GenerateFunctionSurface","function3D","intervalMin","intervalMax","GenerateFunctionSurfaceSolid","bottomZ"],"mappings":"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","file":"../../modeler/generator.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\t/**\n\t* Function: GenerateRectangle\n\t* Description: Generates a rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRectangle = function (xSize, ySize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, 0.0)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboid\n\t* Description: Generates a cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboid = function (xSize, ySize, zSize)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1]));\n\t\tresult.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7]));\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCuboidSides\n\t* Description:\n\t*\tGenerates the specified sides of a cuboid. The last parameter is\n\t*\ta boolean array which defines sides visibility.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsides {boolean[]} sides visibility\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCuboidSides = function (xSize, ySize, zSize, sides)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar x = xSize / 2.0;\n\t\tvar y = ySize / 2.0;\n\t\tvar z = zSize / 2.0;\n\t\t\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, -y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, -z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (x, y, z)));\n\t\tresult.AddVertex (new JSM.BodyVertex (new JSM.Coord (-x, y, z)));\n\n\t\tif (sides[0]) { result.AddPolygon (new JSM.BodyPolygon ([0, 1, 2, 3])); }\n\t\tif (sides[1]) { result.AddPolygon (new JSM.BodyPolygon ([1, 5, 6, 2])); }\n\t\tif (sides[2]) { result.AddPolygon (new JSM.BodyPolygon ([5, 4, 7, 6])); }\n\t\tif (sides[3]) { result.AddPolygon (new JSM.BodyPolygon ([4, 0, 3, 7])); }\n\t\tif (sides[4]) { result.AddPolygon (new JSM.BodyPolygon ([0, 4, 5, 1])); }\n\t\tif (sides[5]) { result.AddPolygon (new JSM.BodyPolygon ([3, 2, 6, 7])); }\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (-x, -y, -z), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedRectangle\n\t* Description:\tGenerates a segmented rectangle.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\txSegmentation {integer} segmentation along x side\n\t*\tySegmentation {integer} segmentation along y side\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedRectangle = function (xSize, ySize, xSegmentation, ySegmentation)\n\t{\n\t\tfunction AddVertices ()\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tfor (i = 0; i <= ySegmentation; i++) {\n\t\t\t\tfor (j = 0; j <= xSegmentation; j++) {\n\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, 0.0);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons ()\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tfor (j = 0; j < ySegmentation; j++) {\n\t\t\t\tfor (i = 0; i < xSegmentation; i++) {\n\t\t\t\t\tcurrent = j * (xSegmentation + 1) + i;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current + xSegmentation + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar xSegment = xSize / xSegmentation;\n\t\tvar ySegment = ySize / ySegmentation;\n\t\t\n\t\tAddVertices ();\n\t\tAddPolygons ();\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSegmentedCuboid\n\t* Description:\tGenerates a segmented cuboid.\n\t* Parameters:\n\t*\txSize {number} x size\n\t*\tySize {number} y size\n\t*\tzSize {number} z size\n\t*\tsegmentation {integer} segmentation of the sides\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSegmentedCuboid = function (xSize, ySize, zSize, segmentation)\n\t{\n\t\tfunction GetLevelOffset (level)\n\t\t{\n\t\t\tvar offset = 0;\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\toffset = (segmentation + 1) * (segmentation + 1) + (level - 1) * (segmentation * 4);\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction GetLevelSideVertices (level)\n\t\t{\n\t\t\tvar i;\n\t\t\t\n\t\t\tvar vertices = [];\n\t\t\tvar offset = GetLevelOffset (level);\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + (i + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (segmentation + 1) * segmentation + i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + i * (segmentation + 1));\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + i);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < segmentation; i++) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation; i >= 0; i--) {\n\t\t\t\t\tvertices.push (offset + (3 * segmentation) + i - 1);\n\t\t\t\t}\n\t\t\t\tfor (i = segmentation - 1; i > 0; i--) {\n\t\t\t\t\tvertices.push (offset + segmentation + 2 * i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn vertices;\n\t\t}\n\n\t\tfunction AddVertices (level)\n\t\t{\n\t\t\tvar i, j, coord;\n\n\t\t\tvar zCoord = level * zSegment;\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (level > 0 && level < segmentation) {\n\t\t\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\t\t\tif (i === 0 || i === segmentation || j === 0 || j === segmentation) {\n\t\t\t\t\t\t\tcoord = new JSM.Coord (j * xSegment - xStart, i * ySegment - yStart, zCoord - zStart);\n\t\t\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (coord));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddPolygons (level)\n\t\t{\n\t\t\tvar i, j;\n\t\t\tvar current, next, top, ntop;\n\t\t\t\n\t\t\tif (level === 0 || level === segmentation) {\n\t\t\t\tvar offset = GetLevelOffset (level);\n\t\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\t\t\tcurrent = offset + i * (segmentation + 1) + j;\n\t\t\t\t\t\tnext = current + 1;\n\t\t\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\t\t\tntop = top + 1;\n\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, top, ntop, next]));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (level > 0 && level <= segmentation) {\n\t\t\t\tvar prevSideVertices = levelSideVertices [level - 1];\n\t\t\t\tvar currSideVertices = levelSideVertices [level];\n\t\t\t\tfor (i = 0; i < segmentation * 4; i++) {\n\t\t\t\t\tcurrent = prevSideVertices[i];\n\t\t\t\t\ttop = currSideVertices[i];\n\t\t\t\t\tif (i < segmentation * 4 - 1) {\n\t\t\t\t\t\tnext = prevSideVertices[i + 1];\n\t\t\t\t\t\tntop = currSideVertices[i + 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = prevSideVertices[0];\n\t\t\t\t\t\tntop = currSideVertices[0];\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, ntop, top]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\n\t\tvar xStart = xSize / 2.0;\n\t\tvar yStart = ySize / 2.0;\n\t\tvar zStart = zSize / 2.0;\n\t\t\n\t\tvar xSegment = xSize / segmentation;\n\t\tvar ySegment = ySize / segmentation;\n\t\tvar zSegment = zSize / segmentation;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddVertices (i);\n\t\t}\n\t\t\n\t\tvar levelSideVertices = [];\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tlevelSideVertices.push (GetLevelSideVertices (i));\n\t\t}\n\n\t\tfor (i = 0; i <= segmentation; i++) {\n\t\t\tAddPolygons (i);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCircle\n\t* Description:\tGenerates a circle.\n\t* Parameters:\n\t*\tradius {number} the radius of the circle\n\t*\tsegmentation {integer} the segmentation of the circle\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCircle = function (radius, segmentation)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar circlePoints = JSM.GenerateCirclePoints (radius, segmentation);\n\t\tvar i;\n\t\tfor (i = 0; i < circlePoints.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (circlePoints[i]));\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\ttopPolygon.AddVertexIndex (i);\n\t\t}\n\t\tresult.AddPolygon (topPolygon);\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateSphere\n\t* Description: Generates a sphere.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\tsegmentation {integer} the segmentation of the sphere\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSphere = function (radius, segmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar segments = segmentation;\n\t\tvar circle = segments * 2;\n\n\t\tvar topIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, 0.0, 0.0)));\n\t\tvar step = Math.PI / segments;\n\t\tvar theta = step;\n\t\t\n\t\tvar i, j, phi;\n\t\tfor (i = 1; i < segments; i++) {\n\t\t\tphi = 0;\n\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (radius, theta, phi)));\n\t\t\t\tphi += step;\n\t\t\t}\n\t\t\ttheta += step;\n\t\t}\n\t\tvar bottomIndex = result.AddVertex (new JSM.BodyVertex (JSM.SphericalToCartesian (-radius, 0.0, 0.0)));\n\n\t\tvar offset, current, next, top, ntop, polygon;\n\t\tfor (i = 1; i <= segments; i++) {\n\t\t\tif (i === 1) {\n\t\t\t\toffset = 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, topIndex]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i < segments) {\n\t\t\t\toffset = (i - 1) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\ttop = current - circle;\n\t\t\t\t\tntop = top + 1;\n\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t\tntop = offset - circle;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t} else if (i === segments) {\n\t\t\t\toffset = (i - 2) * circle + 1;\n\t\t\t\tfor (j = 0; j < circle; j++) {\n\t\t\t\t\tcurrent = offset + j;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tif (j === circle - 1) {\n\t\t\t\t\t\tnext = offset;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpolygon = new JSM.BodyPolygon ([current, bottomIndex, next]);\n\t\t\t\t\tif (isCurved) {\n\t\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTriangulatedSphere\n\t* Description: Generates a sphere from triangles.\n\t* Parameters:\n\t*\tradius {number} the radius of the sphere\n\t*\titerations {integer} the iteration number\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTriangulatedSphere = function (radius, iterations, isCurved)\n\t{\n\t\tfunction GenerateIcosahedron () {\n\t\t\tvar result = new JSM.Body ();\n\n\t\t\tvar a = 1.0;\n\t\t\tvar b = 0.0;\n\t\t\tvar c = (1.0 + Math.sqrt (5.0)) / 2.0;\n\n\t\t\tJSM.AddVertexToBody (result, +b, +a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, +a, -c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, +c);\n\t\t\tJSM.AddVertexToBody (result, +b, -a, -c);\n\n\t\t\tJSM.AddVertexToBody (result, +a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, +a, -c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, +c, +b);\n\t\t\tJSM.AddVertexToBody (result, -a, -c, +b);\n\n\t\t\tJSM.AddVertexToBody (result, +c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, +a);\n\t\t\tJSM.AddVertexToBody (result, +c, +b, -a);\n\t\t\tJSM.AddVertexToBody (result, -c, +b, -a);\n\n\t\t\tJSM.AddPolygonToBody (result, [0, 2, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 4, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 6, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 8, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [0, 9, 2]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 3, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 4, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 6, 4]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 10, 3]);\n\t\t\tJSM.AddPolygonToBody (result, [1, 11, 6]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 5, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 7, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [2, 9, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 5, 7]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 7, 11]);\n\t\t\tJSM.AddPolygonToBody (result, [3, 10, 5]);\n\t\t\tJSM.AddPolygonToBody (result, [4, 8, 10]);\n\t\t\tJSM.AddPolygonToBody (result, [6, 11, 9]);\n\t\t\tJSM.AddPolygonToBody (result, [5, 10, 8]);\n\t\t\tJSM.AddPolygonToBody (result, [7, 9, 11]);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tvar result = GenerateIcosahedron ();\n\t\t\n\t\tvar currentRadius = result.GetVertexPosition (0).Length ();\n\t\tvar scale = radius / currentRadius;\n\n\t\tvar i, j, vertex;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tvertex = result.GetVertex (i);\n\t\t\tvertex.position.MultiplyScalar (scale);\n\t\t}\n\t\t\n\t\tvar iteration, oldVertexCoord, oldBody, adjacencyInfo;\n\t\tvar currentEdge, edgeVertexIndices;\n\t\tvar currentPgon, polygonVertexIndices;\n\t\tvar edgeCoord, currentPolyEdge;\n\t\tfor (iteration = 0; iteration < iterations; iteration++) {\n\t\t\toldBody = result;\n\t\t\t\n\t\t\tresult = new JSM.Body ();\n\t\t\tadjacencyInfo = new JSM.AdjacencyInfo (oldBody);\n\t\t\tfor (i = 0; i < adjacencyInfo.verts.length; i++) {\n\t\t\t\toldVertexCoord = oldBody.GetVertexPosition (i);\n\t\t\t\tJSM.AddVertexToBody (result, oldVertexCoord.x, oldVertexCoord.y, oldVertexCoord.z);\n\t\t\t}\n\t\t\t\n\t\t\tedgeVertexIndices = [];\n\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\tcurrentEdge = adjacencyInfo.edges[i];\n\t\t\t\tedgeCoord = JSM.MidCoord (oldBody.GetVertexPosition (currentEdge.vert1), oldBody.GetVertexPosition (currentEdge.vert2));\n\t\t\t\tedgeVertexIndices.push (result.AddVertex (new JSM.BodyVertex (edgeCoord.SetLength (radius))));\n\t\t\t}\n\n\t\t\tfor (i = 0; i < adjacencyInfo.pgons.length; i++) {\n\t\t\t\tcurrentPgon = adjacencyInfo.pgons[i];\n\t\t\t\tpolygonVertexIndices = [];\n\t\t\t\tfor (j = 0; j < currentPgon.pedges.length; j++) {\n\t\t\t\t\tcurrentPolyEdge = currentPgon.pedges[j];\n\t\t\t\t\tpolygonVertexIndices.push (adjacencyInfo.GetPolyEdgeStartVertex (currentPolyEdge));\n\t\t\t\t\tpolygonVertexIndices.push (edgeVertexIndices[currentPolyEdge.index]);\n\t\t\t\t}\n\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[0], polygonVertexIndices[1], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[2], polygonVertexIndices[3]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[3], polygonVertexIndices[4], polygonVertexIndices[5]]);\n\t\t\t\tJSM.AddPolygonToBody (result, [polygonVertexIndices[1], polygonVertexIndices[3], polygonVertexIndices[5]]);\n\t\t\t}\n\t\t}\n\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < result.PolygonCount (); i++) {\n\t\t\t\tresult.GetPolygon (i).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinder\n\t* Description: Generates a cylinder.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinder = function (radius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePie\n\t* Description: Generates a pie.\n\t* Parameters:\n\t*\tradius {number} the radius of the pie\n\t*\theight {number} the height of the pie\n\t*\tangle {number} the angle of the pie\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePie = function (radius, height, angle, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar theta = angle;\n\t\tvar step = angle / (segments - 1);\n\t\t\n\t\tvar i;\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, height / 2.0, theta)));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (radius, -height / 2.0, theta)));\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i <= segments; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === segments) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tif (isCurved && i > 0 && i < segments) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i <= segments; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i));\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), radius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCone\n\t* Description: Generates a cone.\n\t* Parameters:\n\t*\ttopRadius {number} the top radius of the cone\n\t*\tbottomRadius {number} the bottom radius of the cone\n\t*\theight {number} the height of the cone\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCone = function (topRadius, bottomRadius, height, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar segments = segmentation;\n\n\t\tvar topDegenerated = (JSM.IsZero (topRadius));\n\t\tvar bottomDegenerated = (JSM.IsZero (bottomRadius));\n\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / segments;\n\n\t\tif (topDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, height / 2.0, 0.0)));\n\t\t}\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (!topDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (topRadius, height / 2.0, theta)));\n\t\t\t}\n\t\t\tif (!bottomDegenerated) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (bottomRadius, -height / 2.0, theta)));\n\t\t\t}\n\t\t\ttheta -= step;\n\t\t}\n\t\tif (bottomDegenerated) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (JSM.CylindricalToCartesian (0.0, -height / 2.0, 0.0)));\n\t\t}\n\n\t\tvar current, next, polygon;\n\t\tfor (i = 0; i < segments; i++) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tcurrent = i + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 1;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([0, next, current]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\tcurrent = i;\n\t\t\t\tnext = current + 1;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, segments]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t} else {\n\t\t\t\tcurrent = 2 * i;\n\t\t\t\tnext = current + 2;\n\t\t\t\tif (i === segments - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t}\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tvar topPolygon, bottomPolygon;\n\t\tif (withTopAndBottom) {\n\t\t\tif (topDegenerated) {\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\tbottomPolygon.AddVertexIndex (i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t} else if (bottomDegenerated) {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (segments - i - 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t} else {\n\t\t\t\ttopPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\t\ttopPolygon.AddVertexIndex (2 * (segments - i - 1));\n\t\t\t\t\tbottomPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topPolygon);\n\t\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t\t}\n\t\t}\n\n\t\tvar avgRadius = (topRadius + bottomRadius) / 2.0;\n\t\tresult.SetCylindricalTextureProjection (new JSM.Coord (0.0, 0.0, -(height / 2.0)), avgRadius, new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismGeometry\n\t* Description: Generates a prism defined by bottom and top vertices polygon.\n\t* Parameters:\n\t*\tbottomVertices {Coord[*]} bottom vertices\n\t*\ttopVertices {Coord[*]} top vertices\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismGeometry = function (bottomVertices, topVertices, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = bottomVertices.length;\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (bottomVertices[i].Clone ()));\n\t\t\tresult.AddVertex (new JSM.BodyVertex (topVertices[i].Clone ()));\n\t\t}\n\n\t\tvar current, next, bodyPolygon;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurrent = 2 * i;\n\t\t\tnext = current + 2;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (2 * i + 1);\n\t\t\t\tbottomPolygon.AddVertexIndex (2 * (count - i - 1));\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismFromPolygon\n\t* Description: Generates a prism defined by a polygon.\n\t* Parameters:\n\t*\tpolygon {Polygon2D} the base polygon\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismFromPolygon = function (polygon, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i, vertex;\n\t\tvar count = polygon.VertexCount ();\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tvertex = polygon.GetVertex (i);\n\t\t\tbottomVertices.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\ttopVertices.push (new JSM.Coord (vertex.x, vertex.y, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = bottomVertices[0].Clone ();\n\t\tvar firtVertex = bottomVertices[1].Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrism\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The base polygon is an array\n\t*\tof coordinates which will be offseted in the given direction.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrism = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.FromArray (basePolygon);\n\t\tvar count = polygon.VertexCount ();\n\n\n\t\tvar bottomVertices = [];\n\t\tvar topVertices = [];\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tbottomVertices.push (polygon.GetVertex (i).Clone ());\n\t\t\ttopVertices.push (polygon.GetVertex (i).Clone ().Offset (direction, height));\n\t\t}\n\n\t\tvar result = JSM.GeneratePrismGeometry (bottomVertices, topVertices, withTopAndBottom);\n\t\t\n\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\tvar curveGroups = JSM.CalculatePolygonCurveGroups (polygon, curveAngle);\n\t\t\tvar bodyPolygon;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tbodyPolygon = result.GetPolygon (i);\n\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar origo = polygon.GetVertex (0).Clone ();\n\t\tvar firtVertex = polygon.GetVertex (1).Clone ();\n\t\tvar firstDirection = JSM.CoordSub (firtVertex, origo).Normalize ();\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismWithHole\n\t* Description:\n\t*\tGenerates a prism defined by a polygon. The polygon can contain null\n\t*\tvalues which defines the end of the current contour. The holes have\n\t*\tto be in reversed orientation than the main contour.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon which can contain null values\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveAngle {number} if not null, defines the curve angle of the prism\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismWithHole = function (basePolygon, direction, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction AddVertices (contourPolygon, direction, height, result)\n\t\t{\n\t\t\tvar i, j, contour, vertex1, vertex2;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex1 = contour.GetVertex (j).Clone ();\n\t\t\t\t\tvertex2 = contour.GetVertex (j).Clone ().Offset (direction, height);\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex1));\n\t\t\t\t\tresult.AddVertex (new JSM.BodyVertex (vertex2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction AddContours (contourPolygon, contourOffsets, curveAngle, result)\n\t\t{\n\t\t\tvar offset = 0;\n\n\t\t\tvar i, j, contour, vertexCount, current, next, bodyPolygon, curveGroups;\n\t\t\tfor (i = 0; i < contourPolygon.ContourCount (); i++) {\n\t\t\t\tcontour = contourPolygon.GetContour (i);\n\t\t\t\tcurveGroups = null;\n\t\t\t\tif (curveAngle !== undefined && curveAngle !== null) {\n\t\t\t\t\tcurveGroups = JSM.CalculatePolygonCurveGroups (contour, curveAngle);\n\t\t\t\t}\t\t\n\t\t\t\tvertexCount = contour.VertexCount ();\n\t\t\t\tcontourOffsets.push (offset);\n\t\t\t\tfor (j = 0; j < vertexCount; j++) {\n\t\t\t\t\tcurrent = 2 * offset + 2 * j;\n\t\t\t\t\tnext = current + 2;\n\t\t\t\t\tif (j == vertexCount - 1) {\n\t\t\t\t\t\tnext = 2 *  offset;\n\t\t\t\t\t}\n\t\t\t\t\tbodyPolygon = new JSM.BodyPolygon ([current, next, next + 1, current + 1]);\n\t\t\t\t\tif (curveGroups !== null) {\n\t\t\t\t\t\tbodyPolygon.SetCurveGroup (curveGroups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tresult.AddPolygon (bodyPolygon);\n\t\t\t\t}\n\t\t\t\toffset += vertexCount;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction AddTopBottomPolygons (contourPolygon, contourOffsets)\n\t\t{\n\t\t\tvar vertexMap = [];\n\t\t\tvar contourPolygon2D = contourPolygon.ToContourPolygon2D ();\n\t\t\tvar simplePolygon = JSM.ConvertContourPolygonToPolygon2D (contourPolygon2D, vertexMap);\n\t\t\tif (simplePolygon === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar triangles = JSM.TriangulatePolygon2D (simplePolygon);\n\t\t\tif (triangles === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar i, j, triangle, mapValue;\n\t\t\tvar topTriangle, bottomTriangle;\n\t\t\tfor (i = 0; i < triangles.length; i++) {\n\t\t\t\ttriangle = triangles[i];\n\t\t\t\ttopTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tbottomTriangle = new JSM.BodyPolygon ([]);\n\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\tmapValue = vertexMap[triangle[j]];\n\t\t\t\t\ttopTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1] + 1);\n\t\t\t\t\tmapValue = vertexMap[triangle[2 - j]];\n\t\t\t\t\tbottomTriangle.AddVertexIndex (2 * contourOffsets[mapValue[0]] + 2 * mapValue[1]);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (topTriangle);\n\t\t\t\tresult.AddPolygon (bottomTriangle);\n\t\t\t}\n\t\t}\n\n\t\tvar result = new JSM.Body ();\n\t\tvar contourOffsets = [];\n\t\tvar contourPolygon = new JSM.ContourPolygon ();\n\t\tcontourPolygon.FromArray (basePolygon);\n\t\tAddVertices (contourPolygon, direction, height, result);\n\t\tAddContours (contourPolygon, contourOffsets, curveAngle, result);\n\n\t\tif (withTopAndBottom) {\n\t\t\tAddTopBottomPolygons (contourPolygon, contourOffsets);\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePrismsFromPath2D\n\t* Description: Generates a prism from the given path.\n\t* Parameters:\n\t*\tpath {Path2D} the path\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body[*]} the result\n\t*/\n\tJSM.GeneratePrismsFromPath2D = function (path, height, withTopAndBottom, curveAngle)\n\t{\n\t\tfunction GetPrismPolygon (polygon)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar i, j, contour, vertex;\n\t\t\tfor (i = 0; i < polygon.ContourCount (); i++) {\n\t\t\t\tcontour = polygon.GetContour (i);\n\t\t\t\tfor (j = 0; j < contour.VertexCount (); j++) {\n\t\t\t\t\tvertex = contour.GetVertex (j);\n\t\t\t\t\tresult.push (new JSM.Coord (vertex.x, vertex.y, 0.0));\n\t\t\t\t}\n\t\t\t\tif (i < polygon.ContourCount () - 1) {\n\t\t\t\t\tresult.push (null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar bodies = [];\n\t\tvar polygons = path.GetPolygons ();\n\t\tvar direction = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar i, polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygon = polygons[i];\n\t\t\tif (polygon.ContourCount () === 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrism (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t} else if (polygon.ContourCount () > 1) {\n\t\t\t\tbodies.push (JSM.GeneratePrismWithHole (GetPrismPolygon (polygon), direction, height, withTopAndBottom, curveAngle));\n\t\t\t}\n\t\t}\n\t\treturn bodies;\n\t};\n\n\t/**\n\t* Function: GeneratePrismShell\n\t* Description: Generates a prism with the given width of sides.\n\t* Parameters:\n\t*\tbasePolygon {Coord[*]} the base polygon\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the prism\n\t*\twidth {number} the width of the prism sides\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePrismShell = function (basePolygon, direction, height, width, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolygon.length;\n\n\t\tvar i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygon[i]));\n\t\t}\n\n\t\tvar polygon = new JSM.Polygon ();\n\t\tpolygon.vertices = basePolygon;\n\t\tvar offsetedPolygon = JSM.OffsetPolygonContour (polygon, width);\n\t\tvar innerBasePolygon = offsetedPolygon.vertices;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolygon[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolygon[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar curr, next, top, ntop;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tif (i === count - 1) {\n\t\t\t\tnext = 0;\n\t\t\t\tntop = 2 * count;\n\t\t\t}\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t\tntop = count;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolygon[1], basePolygon[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolygon[0].x, basePolygon[0].y, basePolygon[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateCylinderShell\n\t* Description: Generates a cylinder with the given width of sides.\n\t* Parameters:\n\t*\tradius {number} the radius of the cylinder\n\t*\theight {number} the height of the cylinder\n\t*\twidth {number} the width of the cylinder sides\n\t*\tsegmentation {integer} the segmentation of the top and bottom polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateCylinderShell = function (radius, height, width, segmentation, withTopAndBottom, isCurved)\n\t{\n\t\tfunction GenerateCircle (radius, segmentation, bottom)\n\t\t{\n\t\t\tvar result = [];\n\t\t\tvar step = 2.0 * Math.PI / segmentation;\n\t\t\tvar theta, cartesian;\n\t\t\tvar i = 0;\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttheta = i * step;\n\t\t\t\tcartesian = JSM.PolarToCartesian (radius, theta);\n\t\t\t\tresult.push (new JSM.Coord (cartesian.x, cartesian.y, bottom));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0.0, 0.0, 1.0);\n\t\tvar circle = GenerateCircle (radius, segmentation, -height / 2.0);\n\t\tvar result = JSM.GeneratePrismShell (circle, normal, height, width, withTopAndBottom);\n\t\t\n\t\tvar i;\n\t\tif (isCurved) {\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\tresult.GetPolygon (2 * i).SetCurveGroup (0);\n\t\t\t\tresult.GetPolygon (2 * i + 1).SetCurveGroup (0);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateLineShell\n\t* Description: Generates a polyline with width and height.\n\t* Parameters:\n\t*\tbasePolyLine {Coord[*]} the base polyline\n\t*\tdirection {Vector} the vector of the offset\n\t*\theight {number} the height of the shell\n\t*\twidth {number} the width of the shell\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateLineShell = function (basePolyLine, direction, height, width, withStartAndEnd, withTopAndBottom)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar count = basePolyLine.length;\n\n\t\tvar angles = [];\n\t\t\n\t\tvar i, prev, curr, next;\n\t\tvar prevDir, nextDir, angle;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (i === 0 || i === count - 1) {\n\t\t\t\tangle = Math.PI / 2.0;\n\t\t\t} else {\n\t\t\t\tprev = i - 1;\n\t\t\t\tcurr = i;\n\t\t\t\tnext = i + 1;\n\n\t\t\t\tnextDir = JSM.CoordSub (basePolyLine[next], basePolyLine[curr]);\n\t\t\t\tprevDir = JSM.CoordSub (basePolyLine[prev], basePolyLine[curr]);\n\t\t\t\tangle = nextDir.AngleTo (prevDir) / 2.0;\n\t\t\t\tif (JSM.CoordOrientation (basePolyLine[prev], basePolyLine[curr], basePolyLine[next], direction) == JSM.Orientation.Clockwise) {\n\t\t\t\t\tangle = Math.PI - angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tangles.push (angle);\n\t\t}\n\n\t\tvar normal = new JSM.Vector (0, 0, 1);\n\t\tvar innerBasePolyLine = [];\n\t\tvar distance, innerCoord, offsetDirection;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcurr = i;\n\t\t\tif (i === count - 1) {\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr - 1], basePolyLine[curr]);\n\t\t\t} else {\n\t\t\t\tnext = (i + 1) % count;\n\t\t\t\toffsetDirection = JSM.CoordSub (basePolyLine[curr], basePolyLine[next]);\n\t\t\t}\n\n\t\t\tangle = angles[curr];\n\t\t\tdistance = width / Math.sin (angle);\n\t\t\tinnerCoord = basePolyLine[curr].Clone ();\n\t\t\tinnerCoord.Offset (offsetDirection, distance);\n\t\t\tinnerCoord.Rotate (normal, -(Math.PI - angle), basePolyLine[curr]);\n\t\t\tinnerBasePolyLine.push (innerCoord);\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolyLine[i]));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (innerBasePolyLine[i]));\n\t\t}\n\n\t\tvar offseted;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = basePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toffseted = innerBasePolyLine[i].Clone ().Offset (direction, height);\n\t\t\tresult.AddVertex (new JSM.BodyVertex (offseted));\n\t\t}\n\n\t\tvar top, ntop;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tcurr = i;\n\t\t\tnext = curr + 1;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = top + 1;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + count, top + count, ntop + count, next + count]));\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tcurr = 0;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\n\t\t\tcurr = count - 1;\n\t\t\tnext = curr + count;\n\t\t\ttop = curr + 2 * count;\n\t\t\tntop = curr + 3 * count;\n\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, next, ntop, top]));\n\t\t}\n\n\t\tif (withTopAndBottom) {\n\t\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\t\tcurr = i;\n\t\t\t\tnext = curr + 1;\n\t\t\t\ttop = i + count;\n\t\t\t\tntop = top + 1;\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr, top, ntop, next]));\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([curr + 2 * count, next + 2 * count, ntop + 2 * count, top + 2 * count]));\n\t\t\t}\n\t\t}\n\n\t\tvar firstDirection = JSM.CoordSub (basePolyLine[1], basePolyLine[0]).Normalize ();\n\t\tvar origo = new JSM.Coord (basePolyLine[0].x, basePolyLine[0].y, basePolyLine[0].z);\n\t\tvar e3 = direction.Clone ().Normalize ();\n\t\tvar e2 = JSM.VectorCross (e3, firstDirection);\n\t\tvar e1 = JSM.VectorCross (e2, e3);\n\n\t\tresult.SetCubicTextureProjection (origo, e1, e2, e3);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTorus\n\t* Description: Generates a torus.\n\t* Parameters:\n\t*\touterRadius {number} the outer radius of the torus\n\t*\tinnerRadius {number} the inner radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tinnerSegmentation {integer} the inner segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTorus = function (outerRadius, innerRadius, outerSegmentation, innerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar theta = 0.0;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = JSM.PolarToCartesian (innerRadius, theta);\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta += step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GeneratePolyTorus\n\t* Description: Generates a torus with a polygon cross section.\n\t* Parameters:\n\t*\tbasePolygon {Coord2D[*]} the cross section polygon of the torus\n\t*\touterRadius {number} the outer radius of the torus\n\t*\touterSegmentation {integer} the outer segmentation of the torus\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GeneratePolyTorus = function (basePolygon, outerRadius, outerSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\t\n\t\tvar innerSegmentation = basePolygon.length;\n\t\tvar theta = 2.0 * Math.PI;\n\t\tvar step = 2.0 * Math.PI / innerSegmentation;\n\t\t\n\t\tvar circle = [];\n\t\t\n\t\tvar i, coord2D, coord;\n\t\tfor (i = 0; i < innerSegmentation; i++) {\n\t\t\tcoord2D = basePolygon[i];\n\t\t\tcoord = new JSM.Coord (coord2D.x + outerRadius, 0.0, coord2D.y);\n\t\t\tcircle.push (coord);\n\t\t\ttheta -= step;\n\t\t}\n\n\t\tvar axisDir = new JSM.Coord (0.0, 0.0, 1.0);\n\t\tvar origo = new JSM.Coord (0.0, 0.0, 0.0);\n\t\t\n\t\tstep = (2.0 * Math.PI) / outerSegmentation;\n\t\tvar j, rotated;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\trotated = circle[j].Clone ().Rotate (axisDir, i * step, origo);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar polygon, current, top, next, ntop;\n\t\tfor (i = 0; i < outerSegmentation; i++) {\n\t\t\tpolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (j = 0; j < innerSegmentation; j++) {\n\t\t\t\tcurrent = i * innerSegmentation + j;\n\t\t\t\tnext = current + innerSegmentation;\n\t\t\t\ttop = current + 1;\n\t\t\t\tntop = next + 1;\n\t\t\t\t\n\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\ttop = (i * innerSegmentation);\n\t\t\t\t\tntop = (i + 1) * innerSegmentation;\n\t\t\t\t}\n\n\t\t\t\tif (i === outerSegmentation - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t\tntop = j + 1;\n\t\t\t\t\tif (j === innerSegmentation - 1) {\n\t\t\t\t\t\tntop = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (isCurved) {\n\t\t\t\t\tpolygon.SetCurveGroup (j);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectors\n\t* Description: Generates a ruled surface between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectors = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateGrid\n\t* Description: Generates a planar grid.\n\t* Parameters:\n\t*\txSize {number} the x size\n\t*\tySize {number} the y size\n\t*\txSegmentation {integer} the segmentation along x axis\n\t*\tySegmentation {integer} the segmentation along y axis\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateGrid = function (xSize, ySize, xSegmentation, ySegmentation, isCurved)\n\t{\n\t\tvar xSector = new JSM.Sector (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (xSize, 0.0, 0.0));\n\t\tvar ySector = new JSM.Sector (new JSM.Coord (0.0, ySize, 0.0), new JSM.Coord (xSize, ySize, 0.0));\n\t\treturn JSM.GenerateRuledFromSectors (xSector, ySector, xSegmentation, ySegmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateSquareGrid\n\t* Description: Generates a planar square grid.\n\t* Parameters:\n\t*\tsize {number} the size\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateSquareGrid = function (size, segmentation, isCurved)\n\t{\n\t\treturn JSM.GenerateGrid (size, size, segmentation, segmentation, isCurved);\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromSectorsWithHeight\n\t* Description: Generates a ruled surface with height between two sectors.\n\t* Parameters:\n\t*\taSector {Sector} the first sector\n\t*\tbSector {Sector} the second sector\n\t*\tlineSegmentation {integer} the segmentation along sectors\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\theight {height} the height\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromSectorsWithHeight = function (aSector, bSector, lineSegmentation, meshSegmentation, isCurved, height)\n\t{\n\t\tvar result = new JSM.Body ();\n\n\t\tvar aCoords = JSM.GetSectorSegmentation (aSector, lineSegmentation);\n\t\tvar bCoords = JSM.GetSectorSegmentation (bSector, lineSegmentation);\n\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon, polygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (polygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\t\t\n\t\tvar topVertexCount = result.VertexCount ();\n\n\t\tvar newVertex, vertex;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tvertex = vertices[i];\n\t\t\tnewVertex = new JSM.Coord (vertex.x, vertex.y, vertex.z);\n\t\t\tnewVertex.z -= height;\n\t\t\tresult.AddVertex (new JSM.BodyVertex (newVertex));\n\t\t}\n\n\t\tvar j, newpolygonVertexIndices;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tpolygonVertexIndices = polygons[i];\n\t\t\tnewpolygonVertexIndices = [];\n\t\t\tfor (j = polygonVertexIndices.length - 1; j >= 0; j--) {\n\t\t\t\tnewpolygonVertexIndices.push (polygonVertexIndices[j] + topVertexCount);\n\t\t\t}\n\t\t\tpolygon = new JSM.BodyPolygon (newpolygonVertexIndices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tvar current, next, top, ntop;\n\t\t\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < meshSegmentation; i++) {\n\t\t\tcurrent = i + (lineSegmentation * (meshSegmentation + 1)) + topVertexCount;\n\t\t\tnext = current + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = i * (meshSegmentation + 1) + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, top, ntop, next]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tfor (i = 0; i < lineSegmentation; i++) {\n\t\t\tcurrent = (i + 1) * meshSegmentation + i + topVertexCount;\n\t\t\tnext = current + meshSegmentation + 1;\n\t\t\ttop = current - topVertexCount;\n\t\t\tntop = top + meshSegmentation + 1;\n\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRuledFromCoords\n\t* Description:\n\t*\tGenerates a ruled surface between two coordinate arrays.\n\t*\tThe two arrays should have the same length.\n\t* Parameters:\n\t*\taCoords {Coord[*]} the first coordinate array\n\t*\tbCoords {Coord[*]} the second coordinate array\n\t*\tmeshSegmentation {integer} the segmentation along surface\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRuledFromCoords = function (aCoords, bCoords, meshSegmentation, isCurved)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar vertices = [];\n\t\tvar polygons = [];\n\n\t\tJSM.GetRuledMesh (aCoords, bCoords, meshSegmentation, vertices, polygons);\n\n\t\tvar i;\n\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\tresult.AddVertex (new JSM.BodyVertex (vertices[i]));\n\t\t}\n\n\t\tvar polygon;\n\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\tvertices = polygons[i];\n\t\t\tpolygon = new JSM.BodyPolygon (vertices);\n\t\t\tif (isCurved) {\n\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t}\n\t\t\tresult.AddPolygon (polygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateRevolved\n\t* Description:\n\t*\tGenerates a revolved surface by rotating a polyline around a given axis.\n\t*\tIf the angle is 360 degree, it can generate top and bottom polygons.\n\t* Parameters:\n\t*\tpolyLine {Coord[*]} the polyline\n\t*\taxis {Sector} the axis\n\t*\tangle {number} the angle\n\t*\tsegmentation {integer} the segmentation\n\t*\twithTopAndBottom {boolean} generate top and bottom polygons\n\t*\tcurveMode {string} 'None', 'CurveSegments', or 'CurveAll'\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateRevolved = function (polyLine, axis, angle, segmentation, withTopAndBottom, curveMode)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar circular = JSM.IsEqual (angle, 2.0 * Math.PI);\n\n\t\tvar count = polyLine.length;\n\t\tvar step = angle / segmentation;\n\t\tvar axisDir = JSM.CoordSub (axis.end, axis.beg);\n\t\t\n\t\tvar i, j, rotated;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tfor (j = 0; j <= segmentation; j++) {\n\t\t\t\tif (circular && j === segmentation) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trotated = polyLine[i].Clone ().Rotate (axisDir, j * step, axis.beg);\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (rotated));\n\t\t\t}\n\t\t}\n\n\t\tvar curveModeFlag = 0;\n\t\tif (curveMode == 'CurveSegments') {\n\t\t\tcurveModeFlag = 1;\n\t\t} else if (curveMode == 'CurveAll') {\n\t\t\tcurveModeFlag = 2;\n\t\t}\n\t\t\n\t\tvar current, top, next, ntop, polygon;\n\t\tfor (i = 0; i < count - 1; i++) {\n\t\t\tfor (j = 0; j < segmentation; j++) {\n\t\t\t\tcurrent = i * (segmentation + 1) + j;\n\t\t\t\ttop = current + segmentation + 1;\n\t\t\t\tnext = current + 1;\n\t\t\t\tntop = top + 1;\n\n\t\t\t\tif (circular) {\n\t\t\t\t\tcurrent = i * segmentation + j;\n\t\t\t\t\ttop = current + segmentation;\n\t\t\t\t\tnext = current + 1;\n\t\t\t\t\tntop = top + 1;\n\t\t\t\t\tif (j === segmentation - 1) {\n\t\t\t\t\t\tnext = i * segmentation;\n\t\t\t\t\t\tntop = (i + 1) * segmentation;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon = new JSM.BodyPolygon ([current, next, ntop, top]);\n\t\t\t\tif (curveModeFlag == 1) {\n\t\t\t\t\tpolygon.SetCurveGroup (i);\n\t\t\t\t} else if (curveModeFlag == 2) {\n\t\t\t\t\tpolygon.SetCurveGroup (0);\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (polygon);\n\t\t\t}\n\t\t}\n\n\t\tif (circular && withTopAndBottom) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < segmentation; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (segmentation * (count - 1) + i);\n\t\t\t\tbottomPolygon.AddVertexIndex (segmentation - i - 1);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tvar axisNormalDir = axisDir.Clone ().Normalize ();\n\t\tvar axisLine = new JSM.Line (axis.beg, axisNormalDir);\n\t\tvar avgRadius = 0.0;\n\t\tvar projected;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprojected = axisLine.ProjectCoord (polyLine[i]);\n\t\t\tavgRadius = avgRadius + projected.DistanceTo (polyLine[i]);\n\t\t}\n\t\tavgRadius = avgRadius / count;\n\t\t\n\t\tvar origo = new JSM.Coord (axis.beg.x, axis.beg.y, axis.beg.z);\n\t\tvar baseLine = new JSM.Line (origo, axisDir);\n\t\tvar projectedToBaseLine = baseLine.ProjectCoord (polyLine[0]);\n\t\tvar xDirection = JSM.CoordSub (polyLine[0], projectedToBaseLine).Normalize ();\n\t\t\n\t\tresult.SetCylindricalTextureProjection (origo, avgRadius, xDirection, axisNormalDir);\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateTube\n\t* Description:\n\t*\tGenerates a tube from a given array of polygons. All of the\n\t*\tpolygons should have same number of vertices.\n\t* Parameters:\n\t*\tbasePolygons {Coord[*][*]} the array of polygons\n\t*\twithStartAndEnd {boolean} generate start and end polygons\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateTube = function (basePolygons, withStartAndEnd)\n\t{\n\t\tvar result = new JSM.Body ();\n\t\tvar contourCount = basePolygons.length;\n\t\tvar count = basePolygons[0].length;\n\n\t\tvar i, j;\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tfor (i = 0; i < contourCount; i++) {\n\t\t\t\tresult.AddVertex (new JSM.BodyVertex (basePolygons[i][j]));\n\t\t\t}\n\t\t}\n\n\t\tvar current, next;\n\t\tfor (j = 0; j < contourCount - 1; j++) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurrent = j + contourCount * i;\n\t\t\t\tnext = current + contourCount;\n\t\t\t\tif (i === count - 1) {\n\t\t\t\t\tnext = j;\n\t\t\t\t}\n\t\t\t\tresult.AddPolygon (new JSM.BodyPolygon ([current, next, next + 1, current + 1]));\n\t\t\t}\n\t\t}\n\n\t\tif (withStartAndEnd) {\n\t\t\tvar topPolygon = new JSM.BodyPolygon ([]);\n\t\t\tvar bottomPolygon = new JSM.BodyPolygon ([]);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ttopPolygon.AddVertexIndex (contourCount * i + contourCount - 1);\n\t\t\t}\n\t\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\t\tbottomPolygon.AddVertexIndex (contourCount * i);\n\t\t\t}\n\t\t\tresult.AddPolygon (topPolygon);\n\t\t\tresult.AddPolygon (bottomPolygon);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurface\n\t* Description: Generates the surface of a given function.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurface = function (function3D, intervalMin, intervalMax, segmentation, isCurved)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMin.y, 0.0), new JSM.Coord (intervalMax.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMin.x, intervalMax.y, 0.0), new JSM.Coord (intervalMax.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectors (aSector, bSector, segmentation, segmentation, isCurved);\n\n\t\tvar i, coord;\n\t\tfor (i = 0; i < result.VertexCount (); i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: GenerateFunctionSurfaceSolid\n\t* Description: Generates the surface of a given function with a solid body.\n\t* Parameters:\n\t*\tfunction3D {function} the callback function for get surface point\n\t*\tintervalMin {Coord2D} the minimum of the interval\n\t*\tintervalMax {Coord2D} the maximum of the interval\n\t*\tsegmentation {integer} the segmentation\n\t*\tisCurved {boolean} create smooth surfaces\n\t*\tbottomZ {number} the bottom z coordinate of the solid\n\t* Returns:\n\t*\t{Body} the result\n\t*/\n\tJSM.GenerateFunctionSurfaceSolid = function (function3D, intervalMin, intervalMax, segmentation, isCurved, bottomZ)\n\t{\n\t\tvar aSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMin.y, 0.0), new JSM.Coord (intervalMin.x, intervalMin.y, 0.0));\n\t\tvar bSector = new JSM.Sector (new JSM.Coord (intervalMax.x, intervalMax.y, 0.0), new JSM.Coord (intervalMin.x, intervalMax.y, 0.0));\n\t\tvar result = JSM.GenerateRuledFromSectorsWithHeight (aSector, bSector, segmentation, segmentation, isCurved, bottomZ);\n\n\t\tvar i, coord;\n\t\tvar topVertexCount = (segmentation + 1) * (segmentation + 1);\n\t\tfor (i = 0; i < topVertexCount; i++) {\n\t\t\tcoord = result.GetVertexPosition (i);\n\t\t\tcoord.z = function3D (coord.x, coord.y);\n\t\t}\n\n\t\tresult.SetCubicTextureProjection (new JSM.Coord (0.0, 0.0, 0.0), new JSM.Coord (1.0, 0.0, 0.0), new JSM.Coord (0.0, 1.0, 0.0), new JSM.Coord (0.0, 0.0, 1.0));\n\t\treturn result;\n\t};\n\n\treturn JSM;\n});\n"]}