{"version":3,"sources":["modeler/adjacencyinfo.js"],"names":["define","JSM","VertInfo","this","edges","pgons","EdgeInfo","vert1","vert2","pgon1","pgon2","PolyEdgeInfo","index","reverse","PgonInfo","verts","pedges","AdjacencyInfo","body","Calculate","prototype","AddPolygon","adjacencyInfo","polygonIndex","AddEdge","pgonInfo","fromVertexIndex","toVertexIndex","i","edge","pedge","length","newEdge","push","currEdge","ConnectPgonAndEdgeToVert","vert","pgonIndex","edgeIndex","indexOf","ConnectEdge","polygon","GetPolygon","pgon","count","VertexIndexCount","GetVertexIndex","VertexCount","PolygonCount","IsContourVertex","IsContourEdge","GetEdgePolygonCount","pgonCount","GetAnotherPgonOfEdge","GetPolyEdgeStartVertex","polyEdge","GetPolyEdgeEndVertex","CalculateBodyVertexToPolygon","j","result","IsSolidBody","CheckSolidBody","found","pgon1Reverse","pgon2Reverse","TraversePgonsAlongEdges","onPgonFound","AddNeighboursToStack","pgonStack","anotherPgon","currentPgonIndex","pgonIsProcessed","pop"],"mappings":"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","file":"../../modeler/adjacencyinfo.js","sourcesContent":["define([\"../core/jsm\"],function(JSM){\n\n\t/**\n\t* Class: VertInfo\n\t* Description:\n\t*\tContains adjacency information for a body vertex. Contains arrays\n\t*\twith indices of connected edge and polygon info.\n\t*/\n\tJSM.VertInfo = function ()\n\t{\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\n\t};\n\n\t/**\n\t* Class: EdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body edge. Contains indices\n\t*\tof connected vertex and polygon info.\n\t*/\n\tJSM.EdgeInfo = function ()\n\t{\n\t\tthis.vert1 = -1;\n\t\tthis.vert2 = -1;\n\t\tthis.pgon1 = -1;\n\t\tthis.pgon2 = -1;\n\t};\n\n\t/**\n\t* Class: PolyEdgeInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon edge. Contains an index\n\t*\tof an existing edge, and a flag which defines its direction.\n\t*/\n\tJSM.PolyEdgeInfo = function ()\n\t{\n\t\tthis.index = -1;\n\t\tthis.reverse = false;\n\t};\n\n\t/**\n\t* Class: PgonInfo\n\t* Description:\n\t*\tContains adjacency information for a body polygon. Contains arrays\n\t*\twith indices of connected vertex and poly edge info.\n\t*/\n\tJSM.PgonInfo = function ()\n\t{\n\t\tthis.verts = [];\n\t\tthis.pedges = [];\n\t};\n\n\t/**\n\t* Class: AdjacencyInfo\n\t* Description:\n\t*\tContains adjacency information for a body. Contains arrays\n\t*\twith vertex, edge and polygon info.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo = function (body)\n\t{\n\t\tthis.verts = null;\n\t\tthis.edges = null;\n\t\tthis.pgons = null;\n\t\tthis.Calculate (body);\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.Reset\n\t* Description: Calculates the adjacency information for a body.\n\t* Returns:\n\t*\tbody {Body} the body\n\t*/\n\tJSM.AdjacencyInfo.prototype.Calculate = function (body)\n\t{\n\t\tfunction AddVertex (adjacencyInfo)\n\t\t{\n\t\t\tvar vert = new JSM.VertInfo ();\n\t\t\tadjacencyInfo.verts.push (vert);\n\t\t}\n\t\t\n\t\tfunction AddPolygon (adjacencyInfo, body, polygonIndex)\n\t\t{\n\t\t\tfunction AddEdge (adjacencyInfo, pgonInfo, fromVertexIndex, toVertexIndex, polygonIndex)\n\t\t\t{\n\t\t\t\tfunction ConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo)\n\t\t\t\t{\n\t\t\t\t\tfunction ConnectPgonAndEdgeToVert (vert, pgonIndex, edgeIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (vert.edges.indexOf (edgeIndex) == -1) {\n\t\t\t\t\t\t\tvert.edges.push (edgeIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vert.pgons.indexOf (pgonIndex) == -1) {\n\t\t\t\t\t\t\tvert.pgons.push (pgonIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpgonInfo.verts.push (fromVertexIndex);\n\t\t\t\t\tpgonInfo.pedges.push (pedge);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[fromVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t\tConnectPgonAndEdgeToVert (adjacencyInfo.verts[toVertexIndex], polygonIndex, pedge.index);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar pedge = new JSM.PolyEdgeInfo ();\n\t\t\t\n\t\t\t\tvar i, edge;\n\t\t\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\t\t\tif (edge.vert1 === fromVertexIndex && edge.vert2 === toVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t\t} else if (edge.vert1 === toVertexIndex && edge.vert2 === fromVertexIndex) {\n\t\t\t\t\t\tpedge.index = i;\n\t\t\t\t\t\tpedge.reverse = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pedge.index === -1) {\n\t\t\t\t\tvar newEdge = new JSM.EdgeInfo ();\n\t\t\t\t\tnewEdge.vert1 = fromVertexIndex;\n\t\t\t\t\tnewEdge.vert2 = toVertexIndex;\n\t\t\t\t\tnewEdge.pgon1 = polygonIndex;\n\t\t\t\t\tnewEdge.pgon2 = -1;\n\t\t\t\t\tadjacencyInfo.edges.push (newEdge);\n\t\t\t\t\t\n\t\t\t\t\tpedge.index = adjacencyInfo.edges.length - 1;\n\t\t\t\t\tpedge.reverse = false;\n\t\t\t\t} else {\n\t\t\t\t\tvar currEdge = adjacencyInfo.edges[pedge.index];\n\t\t\t\t\tif (currEdge.pgon1 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon1 = polygonIndex;\n\t\t\t\t\t} else if (currEdge.pgon1 !== polygonIndex && currEdge.pgon2 === -1) {\n\t\t\t\t\t\tcurrEdge.pgon2 = polygonIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tConnectEdge (adjacencyInfo, polygonIndex, fromVertexIndex, toVertexIndex, pedge, pgonInfo);\n\t\t\t}\n\n\t\t\tvar polygon = body.GetPolygon (polygonIndex);\n\t\t\tvar pgon = new JSM.PgonInfo ();\n\t\t\t\n\t\t\tvar i, curr, next;\n\t\t\tvar count = polygon.VertexIndexCount ();\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcurr = polygon.GetVertexIndex (i);\n\t\t\t\tnext = polygon.GetVertexIndex (i < count - 1 ? i + 1 : 0);\n\t\t\t\tAddEdge (adjacencyInfo, pgon, curr, next, polygonIndex);\n\t\t\t}\n\t\t\tadjacencyInfo.pgons.push (pgon);\n\t\t}\n\n\t\tthis.verts = [];\n\t\tthis.edges = [];\n\t\tthis.pgons = [];\t\n\t\t\n\t\tvar i;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tAddVertex (this);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tAddPolygon (this, body, i);\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourVertex\n\t* Description: Returns if the vertex has contour edge.\n\t* Parameters:\n\t*\tvert {VertInfo} the vertex info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourVertex = function (vert)\n\t{\n\t\tvar i, edge;\n\t\tfor (i = 0; i < vert.edges.length; i++) {\n\t\t\tedge = vert.edges[i];\n\t\t\tif (this.IsContourEdge (this.edges[edge])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.IsContourEdge\n\t* Description: Returns if the edge has only one polygon neighbour.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.IsContourEdge = function (edge)\n\t{\n\t\tvar pgonCount = this.GetEdgePolygonCount (edge);\n\t\treturn pgonCount == 1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetEdgePolygonCount\n\t* Description: Returns the neighbour polygon count of the edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetEdgePolygonCount = function (edge)\n\t{\n\t\tvar pgonCount = 0;\n\t\tif (edge.pgon1 != -1) {\n\t\t\tpgonCount += 1;\n\t\t}\n\t\tif (edge.pgon2 != -1) {\n\t\t\tpgonCount += 2;\n\t\t}\n\t\treturn pgonCount;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetAnotherPgonOfEdge\n\t* Description: Returns the polygon index which is next to the given polygon along an edge.\n\t* Parameters:\n\t*\tedge {EdgeInfo} the edge info\n\t*\tcurrentPgon {integer} the polygon index\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetAnotherPgonOfEdge = function (edge, pgon)\n\t{\n\t\tif (edge.pgon1 != -1 && edge.pgon1 != pgon) {\n\t\t\treturn edge.pgon1;\n\t\t} else if (edge.pgon2 != -1 && edge.pgon2 != pgon) {\n\t\t\treturn edge.pgon2;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeStartVertex\n\t* Description: Returns the start vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeStartVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t}\n\t};\n\n\t/**\n\t* Function: AdjacencyInfo.GetPolyEdgeEndVertex\n\t* Description: Returns the end vertex index of a polygon edge.\n\t* Parameters:\n\t*\tpolyEdge {PolyEdgeInfo} the polygon edge info\n\t* Returns:\n\t*\t{integer} the result\n\t*/\n\tJSM.AdjacencyInfo.prototype.GetPolyEdgeEndVertex = function (polyEdge)\n\t{\n\t\tif (!polyEdge.reverse) {\n\t\t\treturn this.edges[polyEdge.index].vert2;\n\t\t} else {\n\t\t\treturn this.edges[polyEdge.index].vert1;\n\t\t}\n\t};\n\n\t/**\n\t* Function: CalculateBodyVertexToPolygon\n\t* Description:\n\t*\tCalculates an array which contains array of the connected polygon\n\t*\tindices for all vertex indices in the body. The result is an\n\t*\tarray of array of polygon indices.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{integer[*][*]} the result\n\t*/\n\tJSM.CalculateBodyVertexToPolygon = function (body)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tvar i, j;\n\t\tfor (i = 0; i < body.VertexCount (); i++) {\n\t\t\tresult.push ([]);\n\t\t}\n\t\t\n\t\tvar polygon;\n\t\tfor (i = 0; i < body.PolygonCount (); i++) {\n\t\t\tpolygon = body.GetPolygon (i);\n\t\t\tfor (j = 0; j < polygon.VertexIndexCount (); j++) {\n\t\t\t\tresult[polygon.GetVertexIndex (j)].push (i);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\t/**\n\t* Function: IsSolidBody\n\t* Description:\n\t*\tReturns if a given body is solid. It means that every\n\t*\tedges of the body has two polygon neighbours.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.IsSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tif (adjacencyInfo.edges.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar i, edge;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: CheckSolidBody\n\t* Description:\n\t*\tReturns if a given body solid body is correct. It means that every\n\t*\tedges of the body has two polygon neighbours, and there are no edge\n\t*\tin the body which appears twice with the same direction.\n\t* Parameters:\n\t*\tbody {Body} the body\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.CheckSolidBody = function (body)\n\t{\n\t\tvar adjacencyInfo = new JSM.AdjacencyInfo (body);\n\t\tvar i, j, edge, pedge, found, pgon1, pgon2, pgon1Reverse, pgon2Reverse;\n\t\tfor (i = 0; i < adjacencyInfo.edges.length; i++) {\n\t\t\tedge = adjacencyInfo.edges[i];\n\t\t\tif (edge.pgon1 === -1 || edge.pgon2 === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon1 = adjacencyInfo.pgons[edge.pgon1];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon1.pedges.length; j++) {\n\t\t\t\tpedge = pgon1.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon1Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpgon2 = adjacencyInfo.pgons[edge.pgon2];\n\t\t\tfound = false;\n\t\t\tfor (j = 0; j < pgon2.pedges.length; j++) {\n\t\t\t\tpedge = pgon2.pedges[j];\n\t\t\t\tif (pedge.index == i) {\n\t\t\t\t\tpgon2Reverse = pedge.reverse;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (pgon1Reverse == pgon2Reverse) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t* Function: TraversePgonsAlongEdges\n\t* Description:\n\t*\tTraverses polygons along edges. The given callback function called on every\n\t*\tfound polygon. The return value of the callback means if the traverse should\n\t*\tcontinue along the edges of the current polygon.\n\t* Parameters:\n\t*\tpgonIndex {integer} the polygon index to start from\n\t*\tadjacencyInfo {AdjacencyInfo} the adjacency info\n\t*\tonPgonFound {function} the callback\n\t* Returns:\n\t*\t{boolean} the result\n\t*/\n\tJSM.TraversePgonsAlongEdges = function (pgonIndex, adjacencyInfo, onPgonFound)\n\t{\n\t\tfunction AddNeighboursToStack (pgonIndex, adjacencyInfo, pgonStack)\n\t\t{\n\t\t\tvar pgon = adjacencyInfo.pgons[pgonIndex];\n\t\t\tvar i, edge, anotherPgon;\n\t\t\tfor (i = 0; i < pgon.pedges.length; i++) {\n\t\t\t\tedge = adjacencyInfo.edges[pgon.pedges[i].index];\n\t\t\t\tanotherPgon = adjacencyInfo.GetAnotherPgonOfEdge (edge, pgonIndex);\n\t\t\t\tif (anotherPgon != -1) {\n\t\t\t\t\tpgonStack.push (anotherPgon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar pgonIsProcessed = {};\n\t\tvar pgonStack = [pgonIndex];\n\t\tvar currentPgonIndex;\n\t\twhile (pgonStack.length > 0) {\n\t\t\tcurrentPgonIndex = pgonStack.pop ();\n\t\t\tif (pgonIsProcessed[currentPgonIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpgonIsProcessed[currentPgonIndex] = true;\n\t\t\tif (onPgonFound (currentPgonIndex)) {\n\t\t\t\tAddNeighboursToStack (currentPgonIndex, adjacencyInfo, pgonStack);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn JSM;\n});\n"]}